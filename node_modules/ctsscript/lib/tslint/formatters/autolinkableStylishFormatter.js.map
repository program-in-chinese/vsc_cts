{"version":3,"sources":["formatters/autolinkableStylishFormatter.ts"],"names":[],"mappings":"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","file":"autolinkableStylishFormatter.js","sourcesContent":["import * as Lint from \"tslint\";\r\nimport * as colors from \"colors\";\r\nimport { sep } from \"path\";\r\nfunction groupBy<T>(array: ReadonlyArray<T> | undefined, getGroupId: (elem: T, index: number) => number | string): T[][] {\r\n    if (!array) {\r\n        return [];\r\n    }\r\n\r\n    const groupIdToGroup: { [index: string]: T[] } = {};\r\n    let result: T[][] | undefined; // Compacted array for return value\r\n    for (let index = 0; index < array.length; index++) {\r\n        const value = array[index];\r\n        const key = getGroupId(value, index);\r\n        if (groupIdToGroup[key]) {\r\n            groupIdToGroup[key].push(value);\r\n        }\r\n        else {\r\n            const newGroup = [value];\r\n            groupIdToGroup[key] = newGroup;\r\n            if (!result) {\r\n                result = [newGroup];\r\n            }\r\n            else {\r\n                result.push(newGroup);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result || [];\r\n}\r\n\r\nfunction max<T>(array: ReadonlyArray<T> | undefined, selector: (elem: T) => number): number {\r\n    if (!array) {\r\n        return 0;\r\n    }\r\n\r\n    let max = 0;\r\n    for (const item of array) {\r\n        const scalar = selector(item);\r\n        if (scalar > max) {\r\n            max = scalar;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n\r\nfunction getLink(failure: Lint.RuleFailure, color: boolean): string {\r\n    const lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\r\n    const sev = failure.getRuleSeverity().toUpperCase();\r\n    let path = failure.getFileName();\r\n    // Most autolinks only become clickable if they contain a slash in some way; so we make a top level file into a relative path here\r\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"\\\\\") === -1) {\r\n        path = `.${sep}${path}`;\r\n    }\r\n    return `${color ? (sev === \"WARNING\" ? colors.blue(sev) : colors.red(sev)) : sev}: ${path}:${lineAndCharacter.line + 1}:${lineAndCharacter.character + 1}`;\r\n}\r\n\r\nfunction getLinkMaxSize(failures: Lint.RuleFailure[]): number {\r\n    return max(failures, f => getLink(f, /*color*/ false).length);\r\n}\r\n\r\nfunction getNameMaxSize(failures: Lint.RuleFailure[]): number {\r\n    return max(failures, f => f.getRuleName().length);\r\n}\r\n\r\nfunction pad(str: string, visiblelen: number, len: number) {\r\n    if (visiblelen >= len) return str;\r\n    const count = len - visiblelen;\r\n    for (let i = 0; i < count; i++) {\r\n        str += \" \";\r\n    }\r\n    return str;\r\n}\r\n\r\nexport class Formatter extends Lint.Formatters.AbstractFormatter {\r\n    public static metadata: Lint.IFormatterMetadata = {\r\n        formatterName: \"autolinkableStylish\",\r\n        description: \"Human-readable formatter which creates stylish messages with autolinkable filepaths.\",\r\n        descriptionDetails: Lint.Utils.dedent`\r\n            Colorized output grouped by file, with autolinkable filepaths containing line and column information\r\n        `,\r\n        sample: Lint.Utils.dedent`\r\n        src/myFile.ts\r\n        ERROR: src/myFile.ts:1:14 semicolon Missing semicolon`,\r\n        consumer: \"human\"\r\n    };\r\n    public format(failures: Lint.RuleFailure[]): string {\r\n        return groupBy(failures, f => f.getFileName()).map(group => {\r\n            const currentFile = group[0].getFileName();\r\n            const linkMaxSize = getLinkMaxSize(group);\r\n            const nameMaxSize = getNameMaxSize(group);\r\n            return `\r\n${currentFile}\r\n${group.map(f => `${pad(getLink(f, /*color*/ true), getLink(f, /*color*/ false).length, linkMaxSize)} ${colors.grey(pad(f.getRuleName(), f.getRuleName().length, nameMaxSize))} ${colors.yellow(f.getFailure())}`).join(\"\\n\")}`;\r\n        }).join(\"\\n\");\r\n    }\r\n}"]}