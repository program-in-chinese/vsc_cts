{"version":3,"sources":["rules/nextLineRule.ts"],"names":[],"mappings":"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","file":"nextLineRule.js","sourcesContent":["import * as Lint from \"tslint/lib\";\r\nimport * as ts from \"typescript\";\r\n\r\nconst OPTION_CATCH = \"check-catch\";\r\nconst OPTION_ELSE = \"check-else\";\r\n\r\nexport class Rule extends Lint.Rules.AbstractRule {\r\n    public static CATCH_FAILURE_STRING = \"'catch' should not be on the same line as the preceeding block's curly brace\";\r\n    public static ELSE_FAILURE_STRING = \"'else' should not be on the same line as the preceeding block's curly brace\";\r\n\r\n    public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {\r\n        const options = this.getOptions().ruleArguments;\r\n        const checkCatch = options.indexOf(OPTION_CATCH) !== -1;\r\n        const checkElse = options.indexOf(OPTION_ELSE) !== -1;\r\n        return this.applyWithFunction(sourceFile, ctx => walk(ctx, checkCatch, checkElse));\r\n    }\r\n}\r\n\r\nfunction walk(ctx: Lint.WalkContext<void>, checkCatch: boolean, checkElse: boolean): void {\r\n    const { sourceFile } = ctx;\r\n    ts.forEachChild(sourceFile, function recur(node) {\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.IfStatement:\r\n                checkIf(node as ts.IfStatement);\r\n                break;\r\n            case ts.SyntaxKind.TryStatement:\r\n                checkTry(node as ts.TryStatement);\r\n                break;\r\n        }\r\n        ts.forEachChild(node, recur);\r\n    });\r\n\r\n    function checkIf(node: ts.IfStatement): void {\r\n        const { thenStatement, elseStatement } = node;\r\n        if (!elseStatement) {\r\n            return;\r\n        }\r\n\r\n        // find the else keyword\r\n        const elseKeyword = getFirstChildOfKind(node, ts.SyntaxKind.ElseKeyword);\r\n        if (checkElse && !!elseKeyword) {\r\n            const thenStatementEndLoc = sourceFile.getLineAndCharacterOfPosition(thenStatement.getEnd());\r\n            const elseKeywordLoc = sourceFile.getLineAndCharacterOfPosition(elseKeyword.getStart(sourceFile));\r\n            if (thenStatementEndLoc.line === elseKeywordLoc.line) {\r\n                ctx.addFailureAtNode(elseKeyword, Rule.ELSE_FAILURE_STRING);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkTry({ tryBlock, catchClause }: ts.TryStatement): void {\r\n        if (!checkCatch || !catchClause) {\r\n            return;\r\n        }\r\n\r\n        const tryClosingBrace = tryBlock.getLastToken(sourceFile);\r\n        const catchKeyword = catchClause.getFirstToken(sourceFile);\r\n        const tryClosingBraceLoc = sourceFile.getLineAndCharacterOfPosition(tryClosingBrace.getEnd());\r\n        const catchKeywordLoc = sourceFile.getLineAndCharacterOfPosition(catchKeyword.getStart(sourceFile));\r\n        if (tryClosingBraceLoc.line === catchKeywordLoc.line) {\r\n            ctx.addFailureAtNode(catchKeyword, Rule.CATCH_FAILURE_STRING);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getFirstChildOfKind(node: ts.Node, kind: ts.SyntaxKind) {\r\n    return node.getChildren().filter((child) => child.kind === kind)[0];\r\n}\r\n"]}