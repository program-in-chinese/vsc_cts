{"version":3,"sources":["rules/typeOperatorSpacingRule.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,iCAAmC;AACnC,+BAAiC;AAEjC;IAA0B,wBAAuB;IAAjD;;IAMA,CAAC;IAHU,oBAAK,GAAZ,UAAa,UAAyB;QAClC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IACpD,CAAC;IAJa,mBAAc,GAAG,+DAA+D,CAAC;IAKnG,WAAC;CAND,AAMC,CANyB,IAAI,CAAC,KAAK,CAAC,YAAY,GAMhD;AANY,oBAAI;AAQjB,cAAc,GAA2B;IAC7B,IAAA,2BAAU,CAAS;IAC3B,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACnC,eAAe,IAAa;QACxB,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACxF,KAAK,CAAE,IAAuC,CAAC,KAAK,CAAC,CAAC;QAC1D,CAAC;QACD,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACjC,CAAC;IAED,eAAe,KAAiC;QAC5C,IAAI,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,gBAAgB;QACtD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,WAAW,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,aAAa,KAAK,WAAW,CAAC,GAAG,IAAI,WAAW,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;gBACjF,IAAM,kBAAkB,GAAG,UAAU,CAAC,6BAA6B,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gBACtF,IAAM,mBAAmB,GAAG,UAAU,CAAC,6BAA6B,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;gBACtF,EAAE,CAAC,CAAC,kBAAkB,CAAC,IAAI,KAAK,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;oBACvD,GAAG,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;gBAC3D,CAAC;YACL,CAAC;YACD,aAAa,GAAG,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC;QACxC,CAAC;IACL,CAAC;AACL,CAAC","file":"typeOperatorSpacingRule.js","sourcesContent":["import * as Lint from \"tslint/lib\";\r\nimport * as ts from \"typescript\";\r\n\r\nexport class Rule extends Lint.Rules.AbstractRule {\r\n    public static FAILURE_STRING = \"The '|' and '&' operators must be surrounded by single spaces\";\r\n\r\n    public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {\r\n        return this.applyWithFunction(sourceFile, walk);\r\n    }\r\n}\r\n\r\nfunction walk(ctx: Lint.WalkContext<void>): void {\r\n    const { sourceFile } = ctx;\r\n    ts.forEachChild(sourceFile, recur);\r\n    function recur(node: ts.Node): void {\r\n        if (node.kind === ts.SyntaxKind.UnionType || node.kind === ts.SyntaxKind.IntersectionType) {\r\n            check((node as ts.UnionOrIntersectionTypeNode).types);\r\n        }\r\n        ts.forEachChild(node, recur);\r\n    }\r\n\r\n    function check(types: ReadonlyArray<ts.TypeNode>): void {\r\n        let expectedStart = types[0].end + 2; // space, | or &\r\n        for (let i = 1; i < types.length; i++) {\r\n            const currentType = types[i];\r\n            if (expectedStart !== currentType.pos || currentType.getLeadingTriviaWidth() !== 1) {\r\n                const previousTypeEndPos = sourceFile.getLineAndCharacterOfPosition(types[i - 1].end);\r\n                const currentTypeStartPos = sourceFile.getLineAndCharacterOfPosition(currentType.pos);\r\n                if (previousTypeEndPos.line === currentTypeStartPos.line) {\r\n                    ctx.addFailureAtNode(currentType, Rule.FAILURE_STRING);\r\n                }\r\n            }\r\n            expectedStart = currentType.end + 2;\r\n        }\r\n    }\r\n}\r\n"]}