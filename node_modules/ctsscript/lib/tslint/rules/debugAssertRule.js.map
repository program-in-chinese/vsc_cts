{"version":3,"sources":["rules/debugAssertRule.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,iCAAmC;AACnC,+BAAiC;AAEjC;IAA0B,wBAAuB;IAAjD;;IAIA,CAAC;IAHU,oBAAK,GAAZ,UAAa,UAAyB;QAClC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,UAAA,GAAG,IAAI,OAAA,IAAI,CAAC,GAAG,CAAC,EAAT,CAAS,CAAC,CAAC;IAChE,CAAC;IACL,WAAC;AAAD,CAJA,AAIC,CAJyB,IAAI,CAAC,KAAK,CAAC,YAAY,GAIhD;AAJY,oBAAI;AAMjB,cAAc,GAA2B;IACrC,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,UAAU,EAAE,eAAe,IAAI;QAC/C,EAAE,CAAC,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,SAAS,CAAC,IAAI,CAAC,CAAC;QACpB,CAAC;QACD,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,mBAAmB,IAAuB;QACtC,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/D,MAAM,CAAC;QACX,CAAC;QAED,IAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAClC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC/B,GAAG,CAAC,gBAAgB,CAAC,OAAO,EAAE,+DAA+D,CAAC,CAAC;QACnG,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC;QACX,CAAC;QAED,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACnC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACjE,GAAG,CAAC,gBAAgB,CAAC,OAAO,EAAE,gFAAgF,CAAC,CAAC;QACpH,CAAC;IACL,CAAC;IAED,uBAAuB,IAAa;QAChC,MAAM,CAAC,EAAE,CAAC,0BAA0B,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAClH,CAAC;IAED,gBAAgB,IAAa,EAAE,IAAY;QACvC,MAAM,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;IACvD,CAAC;AACL,CAAC","file":"debugAssertRule.js","sourcesContent":["import * as Lint from \"tslint/lib\";\r\nimport * as ts from \"typescript\";\r\n\r\nexport class Rule extends Lint.Rules.AbstractRule {\r\n    public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {\r\n        return this.applyWithFunction(sourceFile, ctx => walk(ctx));\r\n    }\r\n}\r\n\r\nfunction walk(ctx: Lint.WalkContext<void>): void {\r\n    ts.forEachChild(ctx.sourceFile, function recur(node) {\r\n        if (ts.isCallExpression(node)) {\r\n            checkCall(node);\r\n        }\r\n        ts.forEachChild(node, recur);\r\n    });\r\n\r\n    function checkCall(node: ts.CallExpression) {\r\n        if (!isDebugAssert(node.expression) || node.arguments.length < 2) {\r\n            return;\r\n        }\r\n\r\n        const message = node.arguments[1];\r\n        if (!ts.isStringLiteral(message)) {\r\n            ctx.addFailureAtNode(message, \"Second argument to 'Debug.assert' should be a string literal.\");\r\n        }\r\n\r\n        if (node.arguments.length < 3) {\r\n            return;\r\n        }\r\n\r\n        const message2 = node.arguments[2];\r\n        if (!ts.isStringLiteral(message2) && !ts.isArrowFunction(message2)) {\r\n            ctx.addFailureAtNode(message, \"Third argument to 'Debug.assert' should be a string literal or arrow function.\");\r\n        }\r\n    }\r\n\r\n    function isDebugAssert(expr: ts.Node): boolean {\r\n        return ts.isPropertyAccessExpression(expr) && isName(expr.expression, \"Debug\") && isName(expr.name, \"assert\");\r\n    }\r\n\r\n    function isName(expr: ts.Node, text: string): boolean {\r\n        return ts.isIdentifier(expr) && expr.text === text;\r\n    }\r\n}\r\n"]}