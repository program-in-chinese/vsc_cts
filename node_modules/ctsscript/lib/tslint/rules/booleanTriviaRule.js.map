{"version":3,"sources":["rules/booleanTriviaRule.ts"],"names":[],"mappings":"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","file":"booleanTriviaRule.js","sourcesContent":["import * as Lint from \"tslint/lib\";\r\nimport * as ts from \"typescript\";\r\n\r\nexport class Rule extends Lint.Rules.AbstractRule {\r\n    public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {\r\n        return this.applyWithFunction(sourceFile, ctx => walk(ctx));\r\n    }\r\n}\r\n\r\nfunction walk(ctx: Lint.WalkContext<void>): void {\r\n    const { sourceFile } = ctx;\r\n    ts.forEachChild(sourceFile, function recur(node: ts.Node): void {\r\n        if (node.kind === ts.SyntaxKind.CallExpression) {\r\n            checkCall(node as ts.CallExpression);\r\n        }\r\n        ts.forEachChild(node, recur);\r\n    });\r\n\r\n    function checkCall(node: ts.CallExpression): void {\r\n        if (!shouldIgnoreCalledExpression(node.expression)) {\r\n            for (const arg of node.arguments) {\r\n                checkArg(arg);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Skip certain function/method names whose parameter names are not informative. */\r\n    function shouldIgnoreCalledExpression(expression: ts.Expression): boolean {\r\n        if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\r\n            const methodName = (expression as ts.PropertyAccessExpression).name.text as string;\r\n            if (methodName.indexOf(\"set\") === 0) {\r\n                return true;\r\n            }\r\n            switch (methodName) {\r\n                case \"apply\":\r\n                case \"assert\":\r\n                case \"assertEqual\":\r\n                case \"call\":\r\n                case \"equal\":\r\n                case \"fail\":\r\n                case \"isTrue\":\r\n                case \"output\":\r\n                case \"stringify\":\r\n                    return true;\r\n            }\r\n        }\r\n        else if (expression.kind === ts.SyntaxKind.Identifier) {\r\n            const functionName = (expression as ts.Identifier).text as string;\r\n            if (functionName.indexOf(\"set\") === 0) {\r\n                return true;\r\n            }\r\n            switch (functionName) {\r\n                case \"assert\":\r\n                case \"contains\":\r\n                case \"createAnonymousType\":\r\n                case \"createImportSpecifier\":\r\n                case \"createProperty\":\r\n                case \"createSignature\":\r\n                case \"resolveName\":\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function checkArg(arg: ts.Expression): void {\r\n        if (!isTrivia(arg)) {\r\n            return;\r\n        }\r\n\r\n        const ranges = ts.getTrailingCommentRanges(sourceFile.text, arg.pos) || ts.getLeadingCommentRanges(sourceFile.text, arg.pos);\r\n        if (ranges === undefined || ranges.length !== 1 || ranges[0].kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\r\n            ctx.addFailureAtNode(arg, \"Tag argument with parameter name\");\r\n            return;\r\n        }\r\n\r\n        const range = ranges[0];\r\n        const argStart = arg.getStart(sourceFile);\r\n        if (range.end + 1 !== argStart && sourceFile.text.slice(range.end, argStart).indexOf(\"\\n\") === -1) {\r\n            ctx.addFailureAtNode(arg, \"There should be 1 space between an argument and its comment.\");\r\n        }\r\n    }\r\n\r\n    function isTrivia(arg: ts.Expression): boolean {\r\n        switch (arg.kind) {\r\n            case ts.SyntaxKind.TrueKeyword:\r\n            case ts.SyntaxKind.FalseKeyword:\r\n            case ts.SyntaxKind.NullKeyword:\r\n                return true;\r\n            case ts.SyntaxKind.Identifier:\r\n                return (arg as ts.Identifier).originalKeywordKind === ts.SyntaxKind.UndefinedKeyword;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n}\r\n"]}