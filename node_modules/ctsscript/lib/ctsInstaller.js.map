{"version":3,"sources":["../../compiler/types.ts","../../compiler/performance.ts","../../compiler/core.ts","../../compiler/sys.ts","../../compiler/diagnosticInformationMap.generated.ts","../../compiler/utilities.ts","../../compiler/scanner.ts","../../compiler/parser.ts","../../compiler/commandLineParser.ts","../../services/jsTyping.ts","../shared.ts","../../compiler/moduleNameResolver.ts","typingsInstaller.ts","nodeTypingsInstaller.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,IAAU,EAAE,CA6gKX;AA7gKD,WAAU,EAAE;IAiDR,IAAkB,UAqrBjB;IArrBD,WAAkB,UAAU;QAExB,iDAAO,CAAA;QAEP,+DAAc,CAAA;QAEd,iFAAuB,CAAA;QAEvB,+EAAsB,CAAA;QAEtB,6DAAa,CAAA;QAEb,mEAAgB,CAAA;QAGhB,6DAAa,CAAA;QAGb,2EAAoB,CAAA;QAGpB,+DAAc,CAAA;QAEd,6DAAa,CAAA;QAEb,kDAAO,CAAA;QACP,8EAAqB,CAAA;QAErB,oFAAwB,CAAA;QAExB,8FAA6B,CAAA;QAG7B,4DAAY,CAAA;QAEZ,gEAAc,CAAA;QAEd,4DAAY,CAAA;QAGZ,gEAAc,CAAA;QAEd,kEAAe,CAAA;QAEf,gEAAc,CAAA;QAEd,kEAAe,CAAA;QAEf,oEAAgB,CAAA;QAEhB,sEAAiB,CAAA;QAEjB,oDAAQ,CAAA;QAER,gEAAc,CAAA;QAEd,gEAAc,CAAA;QAEd,wDAAU,CAAA;QAEV,8DAAa,CAAA;QAEb,wEAAkB,CAAA;QAElB,oEAAgB,CAAA;QAEhB,0EAAmB,CAAA;QAEnB,gFAAsB,CAAA;QAEtB,sEAAiB,CAAA;QAEjB,gFAAsB,CAAA;QAEtB,kFAAuB,CAAA;QAEvB,4FAA4B,CAAA;QAE5B,gFAAsB,CAAA;QAEtB,sDAAS,CAAA;QAET,wDAAU,CAAA;QAEV,8DAAa,CAAA;QAEb,8EAAqB,CAAA;QAErB,wDAAU,CAAA;QAEV,4DAAY,CAAA;QAEZ,8DAAa,CAAA;QAEb,kEAAe,CAAA;QAEf,8EAAqB,CAAA;QAErB,0FAA2B,CAAA;QAE3B,gHAAsC,CAAA;QAEtC,gEAAc,CAAA;QAEd,oDAAQ,CAAA;QAER,wDAAU,CAAA;QAEV,oEAAgB,CAAA;QAEhB,wDAAU,CAAA;QAEV,kFAAuB,CAAA;QAEvB,0DAAW,CAAA;QAEX,8DAAa,CAAA;QAEb,wDAAU,CAAA;QAEV,kDAAO,CAAA;QAGP,0DAAW,CAAA;QAEX,kEAAe,CAAA;QAEf,oEAAgB,CAAA;QAEhB,0EAAmB,CAAA;QAEnB,0FAA2B,CAAA;QAE3B,oEAAgB,CAAA;QAEhB,wEAAkB,CAAA;QAElB,0FAA2B,CAAA;QAE3B,sGAAiC,CAAA;QAEjC,4HAA4C,CAAA;QAE5C,4EAAoB,CAAA;QAEpB,gEAAc,CAAA;QAEd,oEAAgB,CAAA;QAGhB,wDAAU,CAAA;QAGV,4DAAY,CAAA;QAEZ,0DAAW,CAAA;QAEX,4DAAY,CAAA;QAEZ,4DAAY,CAAA;QAEZ,4DAAY,CAAA;QAEZ,kEAAe,CAAA;QAEf,kEAAe,CAAA;QAEf,gEAAc,CAAA;QAEd,8DAAa,CAAA;QAEb,sDAAS,CAAA;QAET,0DAAW,CAAA;QAEX,0DAAW,CAAA;QAEX,8DAAa,CAAA;QAEb,gEAAc,CAAA;QAEd,4DAAY,CAAA;QAEZ,gEAAc,CAAA;QAEd,wDAAU,CAAA;QAEV,kEAAe,CAAA;QAEf,sDAAS,CAAA;QAET,8DAAa,CAAA;QAEb,sDAAS,CAAA;QAET,sEAAiB,CAAA;QAEjB,wDAAU,CAAA;QAEV,0DAAW,CAAA;QAEX,8DAAa,CAAA;QAEb,4DAAY,CAAA;QAEZ,8DAAa,CAAA;QAEb,0DAAW,CAAA;QAEX,6DAAY,CAAA;QAEZ,2DAAW,CAAA;QAEX,yDAAU,CAAA;QAEV,+DAAa,CAAA;QAEb,yDAAU,CAAA;QAEV,2DAAW,CAAA;QAEX,6DAAY,CAAA;QAEZ,2DAAW,CAAA;QAGX,uEAAiB,CAAA;QAEjB,qEAAgB,CAAA;QAEhB,yDAAU,CAAA;QAEV,iEAAc,CAAA;QAEd,iEAAc,CAAA;QAEd,qEAAgB,CAAA;QAEhB,+DAAa,CAAA;QAEb,+DAAa,CAAA;QAEb,6DAAY,CAAA;QAGZ,mEAAe,CAAA;QAEf,uDAAS,CAAA;QAET,yDAAU,CAAA;QAEV,6DAAY,CAAA;QAEZ,6DAAY,CAAA;QAEZ,iEAAc,CAAA;QAEd,yEAAkB,CAAA;QAElB,iEAAc,CAAA;QAEd,yDAAU,CAAA;QAEV,uDAAS,CAAA;QAET,6DAAY,CAAA;QAEZ,+DAAa,CAAA;QAEb,qEAAgB,CAAA;QAEhB,6DAAY,CAAA;QAEZ,mEAAe,CAAA;QAEf,iEAAc,CAAA;QAEd,+DAAa,CAAA;QAEb,+DAAa,CAAA;QAEb,yDAAU,CAAA;QAEV,+DAAa,CAAA;QAEb,+DAAa,CAAA;QAEb,2DAAW,CAAA;QAEX,qEAAgB,CAAA;QAEhB,2DAAW,CAAA;QAEX,+DAAa,CAAA;QAEb,uDAAS,CAAA;QAMT,+DAAa,CAAA;QAEb,6EAAoB,CAAA;QAGpB,+DAAa,CAAA;QAEb,uDAAS,CAAA;QAET,uDAAS,CAAA;QAGT,uEAAiB,CAAA;QAEjB,2EAAmB,CAAA;QAEnB,mEAAe,CAAA;QAEf,uEAAiB,CAAA;QAEjB,2DAAW,CAAA;QAEX,2DAAW,CAAA;QAEX,2DAAW,CAAA;QAEX,+DAAa,CAAA;QAEb,yEAAkB,CAAA;QAElB,iEAAc,CAAA;QAGd,+DAAa,CAAA;QAEb,+DAAa,CAAA;QAEb,6DAAY,CAAA;QAEZ,mEAAe,CAAA;QAEf,uDAAS,CAAA;QAET,2DAAW,CAAA;QAEX,uDAAS,CAAA;QAET,uDAAS,CAAA;QAET,uDAAS,CAAA;QAET,qEAAgB,CAAA;QAEhB,uEAAiB,CAAA;QAEjB,qDAAQ,CAAA;QAER,6DAAY,CAAA;QAEZ,uEAAiB,CAAA;QAEjB,yDAAU,CAAA;QAEV,2DAAW,CAAA;QAGX,6EAAoB,CAAA;QAGpB,2EAAmB,CAAA;QAEnB,iEAAc,CAAA;QAGd,iFAAsB,CAAA;QAEtB,mFAAuB,CAAA;QAEvB,qFAAwB,CAAA;QAExB,mFAAuB,CAAA;QAEvB,iEAAc,CAAA;QAEd,+DAAa,CAAA;QAEb,qFAAwB,CAAA;QAExB,mFAAuB,CAAA;QAEvB,mFAAuB,CAAA;QAEvB,yEAAkB,CAAA;QAElB,+DAAa,CAAA;QAEb,qEAAgB,CAAA;QAEhB,qEAAgB,CAAA;QAEhB,iEAAc,CAAA;QAEd,mEAAe,CAAA;QAEf,+EAAqB,CAAA;QAErB,iFAAsB,CAAA;QAEtB,qEAAgB,CAAA;QAEhB,+EAAqB,CAAA;QAErB,yEAAkB,CAAA;QAElB,mEAAe,CAAA;QAEf,+DAAa,CAAA;QAEb,mEAAe,CAAA;QAEf,uEAAiB,CAAA;QAEjB,2FAA2B,CAAA;QAE3B,6DAAY,CAAA;QAEZ,uEAAiB,CAAA;QAEjB,6DAAY,CAAA;QAIZ,6DAAY,CAAA;QAEZ,+EAAqB,CAAA;QAGrB,+CAAK,CAAA;QAEL,uEAAiB,CAAA;QAEjB,iEAAc,CAAA;QAEd,2EAAmB,CAAA;QAEnB,2DAAW,CAAA;QAEX,2DAAW,CAAA;QAEX,iEAAc,CAAA;QAEd,6DAAY,CAAA;QAEZ,iEAAc,CAAA;QAEd,iEAAc,CAAA;QAEd,uEAAiB,CAAA;QAEjB,iEAAc,CAAA;QAEd,mEAAe,CAAA;QAEf,+DAAa,CAAA;QAEb,mEAAe,CAAA;QAEf,qEAAgB,CAAA;QAEhB,iEAAc,CAAA;QAEd,6DAAY,CAAA;QAEZ,uEAAiB,CAAA;QAEjB,2EAAmB,CAAA;QAEnB,mFAAuB,CAAA;QAEvB,2EAAmB,CAAA;QAEnB,qEAAgB,CAAA;QAEhB,6EAAoB,CAAA;QAEpB,6EAAoB,CAAA;QAEpB,mEAAe,CAAA;QAEf,uEAAiB,CAAA;QAEjB,2DAAW,CAAA;QAEX,uDAAS,CAAA;QAET,yFAA0B,CAAA;QAE1B,mFAAuB,CAAA;QAEvB,uEAAiB,CAAA;QAEjB,6DAAY,CAAA;QAEZ,mEAAe,CAAA;QAEf,6DAAY,CAAA;QAEZ,mEAAe,CAAA;QAEf,qEAAgB,CAAA;QAEhB,uEAAiB,CAAA;QAEjB,6DAAY,CAAA;QAEZ,mEAAe,CAAA;QAEf,yEAAkB,CAAA;QAIlB,mFAAuB,CAAA;QAIvB,yDAAU,CAAA;QAEV,+EAAqB,CAAA;QAErB,uEAAiB,CAAA;QAEjB,uEAAiB,CAAA;QAEjB,6DAAY,CAAA;QAEZ,+DAAa,CAAA;QAEb,yEAAkB,CAAA;QAElB,+DAAa,CAAA;QAIb,yDAAU,CAAA;QAEV,+DAAa,CAAA;QAEb,iEAAc,CAAA;QAEd,2DAAW,CAAA;QAIX,yEAAkB,CAAA;QAElB,2FAA2B,CAAA;QAE3B,qEAAgB,CAAA;QAIhB,yDAAU,CAAA;QAGV,yDAAU,CAAA;QAEV,iDAAM,CAAA;QAIN,2EAAmB,CAAA;QAGnB,6DAAY,CAAA;QAGZ,qEAAgB,CAAA;QAEhB,uEAAiB,CAAA;QAEjB,6EAAoB,CAAA;QAEpB,uEAAiB,CAAA;QAEjB,uEAAiB,CAAA;QAEjB,uEAAiB,CAAA;QAEjB,6DAAY,CAAA;QAEZ,qDAAQ,CAAA;QAER,qEAAgB,CAAA;QAEhB,+DAAa,CAAA;QAEb,uEAAiB,CAAA;QAEjB,iEAAc,CAAA;QAEd,6DAAY,CAAA;QAEZ,qEAAgB,CAAA;QAEhB,mEAAe,CAAA;QAEf,qEAAgB,CAAA;QAEhB,qEAAgB,CAAA;QAEhB,6GAAM,CAAA;QACN,6GAAM,CAAA;QACN,yEAAG,CAAA;QACH,yEAAG,CAAA;QACH,iGAAK,CAAA;QAGL,yDAAU,CAAA;QAGV,2EAAmB,CAAA;QAEnB,yFAA0B,CAAA;QAE1B,2EAAmB,CAAA;QAEnB,iFAAsB,CAAA;QAEtB,iFAAsB,CAAA;QAItB,+CAAK,CAAA;QAGL,kEAA6B,CAAA;QAE7B,gEAAiC,CAAA;QAEjC,kFAAyC,CAAA;QAEzC,gFAAyC,CAAA;QAEzC,sEAAgC,CAAA;QAEhC,qEAA8B,CAAA;QAE9B,4DAA2B,CAAA;QAE3B,2DAAuB,CAAA;QAEvB,mFAA2C,CAAA;QAE3C,iFAAqC,CAAA;QAErC,+DAA6B,CAAA;QAE7B,6DAA0B,CAAA;QAE1B,oEAAiC,CAAA;QAEjC,kEAAkC,CAAA;QAElC,uDAAoB,CAAA;QAEpB,uDAAuB,CAAA;QAEvB,mEAA0C,CAAA;QAE1C,iEAAsC,CAAA;QAEtC,qEAAkC,CAAA;QAElC,oEAAgD,CAAA;QAEhD,wEAAkD,CAAA;QAElD,sEAAgC,CAAA;QAEhC,0EAAmC,CAAA;QAEnC,wEAAqC,CAAA;QAErC,uDAAyB,CAAA;QAEzB,iEAAoC,CAAA;QAEpC,+DAAgC,CAAA;QAEhC,uEAA4B,CAAA;QAE5B,qEAAmC,CAAA;IACvC,CAAC,EArrBiB,UAAU,GAAV,aAAU,KAAV,aAAU,QAqrB3B;IAED,IAAkB,SA4CjB;IA5CD,WAAkB,SAAS;QACvB,yCAAQ,CAAA;QACR,uCAAY,CAAA;QACZ,2CAAc,CAAA;QACd,+DAAwB,CAAA;QACxB,uDAAoB,CAAA;QACpB,oDAAkB,CAAA;QAClB,4DAAsB,CAAA;QACtB,0DAAqB,CAAA;QACrB,qEAA0B,CAAA;QAC1B,qEAA0B,CAAA;QAC1B,uEAA2B,CAAA;QAC3B,sEAA2B,CAAA;QAC3B,sEAA2B,CAAA;QAC3B,4DAAsB,CAAA;QACtB,oEAA0B,CAAA;QAC1B,6DAAsB,CAAA;QACtB,qEAA0B,CAAA;QAC1B,iEAAwB,CAAA;QACxB,gGAAuC,CAAA;QACvC,kFAAgC,CAAA;QAWhC,gGAAuC,CAAA;QACvC,iDAAe,CAAA;QACf,uFAAc,CAAA;QACd,uDAAyB,CAAA;QAEzB,+EAA8D,CAAA;QAC9D,oFAAqE,CAAA;QAGrE,6DAAkG,CAAA;QAGlG,uEAA+C,CAAA;IACnD,CAAC,EA5CiB,SAAS,GAAT,YAAS,KAAT,YAAS,QA4C1B;IAED,IAAkB,aAsBjB;IAtBD,WAAkB,aAAa;QAC3B,iDAAQ,CAAA;QACR,qDAAe,CAAA;QACf,uDAAgB,CAAA;QAChB,qDAAe,CAAA;QACf,uDAAgB,CAAA;QAChB,4DAAkB,CAAA;QAClB,sDAAe,CAAA;QACf,0DAAiB,CAAA;QACjB,2DAAiB,CAAA;QACjB,qDAAc,CAAA;QACd,yDAAgB,CAAA;QAChB,sDAAe,CAAA;QACf,iFAA0B,CAAA;QAE1B,oFAAoD,CAAA;QAEpD,4FAA4D,CAAA;QAC5D,sGAAoD,CAAA;QAEpD,gFAAyF,CAAA;QACzF,qEAAgC,CAAA;IACpC,CAAC,EAtBiB,aAAa,GAAb,gBAAa,KAAb,gBAAa,QAsB9B;IAED,IAAkB,QAQjB;IARD,WAAkB,QAAQ;QACtB,uCAAQ,CAAA;QAER,yEAA8B,CAAA;QAE9B,6EAAgC,CAAA;QAEhC,+DAAkE,CAAA;IACtE,CAAC,EARiB,QAAQ,GAAR,WAAQ,KAAR,WAAQ,QAQzB;IAGD,IAAkB,wBAIjB;IAJD,WAAkB,wBAAwB;QACtC,iFAAa,CAAA;QACb,2EAAU,CAAA;QACV,iGAAqB,CAAA;IACzB,CAAC,EAJiB,wBAAwB,GAAxB,2BAAwB,KAAxB,2BAAwB,QAIzC;IAyGD,IAAkB,uBAMjB;IAND,WAAkB,uBAAuB;QACrC,qEAAI,CAAA;QACJ,qEAAI,CAAA;QACJ,qEAAI,CAAA;QACJ,yEAAM,CAAA;QACN,qEAAI,CAAA;IACR,CAAC,EANiB,uBAAuB,GAAvB,0BAAuB,KAAvB,0BAAuB,QAMxC;IAyzBD,IAAkB,mBAQjB;IARD,WAAkB,mBAAmB;QACjC,6DAAQ,CAAA;QACR,yEAAmB,CAAA;QACnB,+DAAc,CAAA;QACd,6EAAqB,CAAA;QACrB,oFAAwB,CAAA;QACxB,kFAAuB,CAAA;QACvB,kGAAyD,CAAA;IAC7D,CAAC,EARiB,mBAAmB,GAAnB,sBAAmB,KAAnB,sBAAmB,QAQpC;IA4wBD,IAAkB,SAgBjB;IAhBD,WAAkB,SAAS;QACvB,uDAAoB,CAAA;QACpB,2CAAc,CAAA;QACd,uDAAoB,CAAA;QACpB,mDAAkB,CAAA;QAClB,sDAAmB,CAAA;QACnB,4DAAsB,CAAA;QACtB,8DAAuB,CAAA;QACvB,2DAAqB,CAAA;QACrB,6DAAsB,CAAA;QACtB,uDAAmB,CAAA;QACnB,gDAAgB,CAAA;QAChB,wDAAoB,CAAA;QACpB,4DAAsB,CAAA;QACtB,4CAA+B,CAAA;QAC/B,oDAA0C,CAAA;IAC9C,CAAC,EAhBiB,SAAS,GAAT,YAAS,KAAT,YAAS,QAgB1B;IAyND;QAAA;QAA0C,CAAC;QAAD,iCAAC;IAAD,CAA1C,AAA2C,IAAA;IAA9B,6BAA0B,6BAAI,CAAA;IAkF3C,IAAkB,iBAIjB;IAJD,WAAkB,iBAAiB;QAC/B,uDAAO,CAAA;QACP,uEAAoB,CAAA;QACpB,qEAAmB,CAAA;IACvB,CAAC,EAJiB,iBAAiB,GAAjB,oBAAiB,KAAjB,oBAAiB,QAIlC;IAsCD,IAAY,UAWX;IAXD,WAAY,UAAU;QAIlB,iDAAW,CAAA;QAGX,qGAAqC,CAAA;QAGrC,yGAAuC,CAAA;IAC3C,CAAC,EAXW,UAAU,GAAV,aAAU,KAAV,aAAU,QAWrB;IA4MD,IAAY,gBAsBX;IAtBD,WAAY,gBAAgB;QACxB,uDAAQ,CAAA;QAER,uEAAqB,CAAA;QACrB,6FAAgC,CAAA;QAChC,0GAAsC,CAAA;QACtC,0FAA8B,CAAA;QAC9B,2FAA8B,CAAA;QAC9B,qHAA2C,CAAA;QAG3C,kGAAkC,CAAA;QAClC,0HAA8C,CAAA;QAC9C,kGAAkC,CAAA;QAClC,6GAAuC,CAAA;QACvC,iFAAyB,CAAA;QAEzB,2EAA2J,CAAA;QAG3J,2FAA6B,CAAA;QAC7B,2EAAqB,CAAA;IACzB,CAAC,EAtBW,gBAAgB,GAAhB,mBAAgB,KAAhB,mBAAgB,QAsB3B;IA8CD,IAAkB,eAkBjB;IAlBD,WAAkB,eAAe;QAC7B,qDAAQ,CAAA;QACR,2FAAgC,CAAA;QAChC,+EAA0B,CAAA;QAC1B,qEAAqB,CAAA;QACrB,8FAAiC,CAAA;QACjC,0FAA+B,CAAA;QAC/B,wGAAsC,CAAA;QACtC,yEAAsB,CAAA;QACtB,yFAA8B,CAAA;QAC9B,qFAA4B,CAAA;QAC5B,sEAAqB,CAAA;QACrB,0FAA+B,CAAA;QAC/B,wEAAsB,CAAA;QACtB,mHAA2C,CAAA;QAC3C,uEAAqB,CAAA;QACrB,qHAA4C,CAAA;IAEhD,CAAC,EAlBiB,eAAe,GAAf,kBAAe,KAAf,kBAAe,QAkBhC;IAED,IAAkB,iBAajB;IAbD,WAAkB,iBAAiB;QAC/B,yDAAiB,CAAA;QAMjB,6GAA2C,CAAA;QAK3C,+FAAoC,CAAA;IACxC,CAAC,EAbiB,iBAAiB,GAAjB,oBAAiB,KAAjB,oBAAiB,QAalC;IAGD,IAAkB,mBAIjB;IAJD,WAAkB,mBAAmB;QACjC,yEAAU,CAAA;QACV,+EAAa,CAAA;QACb,+EAAa,CAAA;IACjB,CAAC,EAJiB,mBAAmB,GAAnB,sBAAmB,KAAnB,sBAAmB,QAIpC;IAGD,IAAkB,mBAGjB;IAHD,WAAkB,mBAAmB;QACjC,2FAAmB,CAAA;QACnB,iEAAM,CAAA;IACV,CAAC,EAHiB,mBAAmB,GAAnB,sBAAmB,KAAnB,sBAAmB,QAGpC;IAED,IAAkB,iBAGjB;IAHD,WAAkB,iBAAiB;QAC/B,yDAAI,CAAA;QACJ,qEAAU,CAAA;IACd,CAAC,EAHiB,iBAAiB,GAAjB,oBAAiB,KAAjB,oBAAiB,QAGlC;IAqCD,IAAY,8BAiBX;IAjBD,WAAY,8BAA8B;QACtC,yFAAO,CAAA;QAEP,+IAAkC,CAAA;QAIlC,yHAAuB,CAAA;QACvB,uGAAc,CAAA;QACd,uGAAc,CAAA;QACd,iGAAW,CAAA;QACX,qGAAa,CAAA;QACb,mGAAY,CAAA;QACZ,yFAAO,CAAA;QACP,qHAAqB,CAAA;QAErB,gGAAU,CAAA;IACd,CAAC,EAjBW,8BAA8B,GAA9B,iCAA8B,KAA9B,iCAA8B,QAiBzC;IAsED,IAAkB,WA+EjB;IA/ED,WAAkB,WAAW;QACzB,6CAAQ,CAAA;QACR,iFAA+B,CAAA;QAC/B,2EAA4B,CAAA;QAC5B,qDAAiB,CAAA;QACjB,yDAAmB,CAAA;QACnB,sDAAiB,CAAA;QACjB,gDAAc,CAAA;QACd,wDAAkB,CAAA;QAClB,yDAAkB,CAAA;QAClB,6DAAoB,CAAA;QACpB,6DAAoB,CAAA;QACpB,sEAAyB,CAAA;QACzB,8DAAqB,CAAA;QACrB,kEAAuB,CAAA;QACvB,oDAAgB,CAAA;QAChB,+DAAqB,CAAA;QACrB,+DAAqB,CAAA;QACrB,+DAAqB,CAAA;QACrB,4DAAmB,CAAA;QACnB,oEAAuB,CAAA;QACvB,4DAAmB,CAAA;QACnB,iEAAqB,CAAA;QACrB,qDAAe,CAAA;QACf,6DAAmB,CAAA;QACnB,+DAAoB,CAAA;QACpB,4DAAkB,CAAA;QAClB,8DAAmB,CAAA;QAEnB,+CAA8B,CAAA;QAC9B,qDAAuD,CAAA;QACvD,oDAAqH,CAAA;QACrH,kDAAsG,CAAA;QACtG,0DAAgD,CAAA;QAChD,oDAAsC,CAAA;QACtC,yDAAoC,CAAA;QAIpC,sGAAgE,CAAA;QAIhE,gGAAmC,CAAA;QAEnC,4EAAyB,CAAA;QACzB,qEAAuB,CAAA;QACvB,8EAAiC,CAAA;QACjC,0EAAoD,CAAA;QACpD,oEAA2D,CAAA;QAC3D,4EAA+C,CAAA;QAC/C,gFAAmE,CAAA;QACnE,4EAA+C,CAAA;QAC/C,gFAA6E,CAAA;QAC7E,mFAA2B,CAAA;QAC3B,qEAAgC,CAAA;QAChC,+EAA0C,CAAA;QAC1C,+EAA0C,CAAA;QAC1C,oFAA6C,CAAA;QAC7C,4EAAwB,CAAA;QACxB,qEAAqB,CAAA;QAErB,mEAA0F,CAAA;QAE1F,mEAAsD,CAAA;QAEtD,4DAAkC,CAAA;QAClC,4DAA4D,CAAA;QAE5D,6DAAgD,CAAA;QAEhD,6EAAwC,CAAA;QAExC,gEAA0C,CAAA;QAK1C,kEAA4E,CAAA;IAChF,CAAC,EA/EiB,WAAW,GAAX,cAAW,KAAX,cAAW,QA+E5B;IAiDD,IAAkB,QAGjB;IAHD,WAAkB,QAAQ;QACtB,6CAAO,CAAA;QACP,6CAAO,CAAA;IACX,CAAC,EAHiB,QAAQ,GAAR,WAAQ,KAAR,WAAQ,QAGzB;IAGD,IAAkB,UAYjB;IAZD,WAAkB,UAAU;QACxB,2DAAqB,CAAA;QACrB,qEAA0B,CAAA;QAC1B,iEAAwB,CAAA;QACxB,mDAAiB,CAAA;QACjB,kDAAgB,CAAA;QAChB,sEAA0B,CAAA;QAC1B,gEAAuB,CAAA;QACvB,uEAA0B,CAAA;QAC1B,mEAAwB,CAAA;QACxB,iEAAuB,CAAA;QACvB,qDAA+C,CAAA;IACnD,CAAC,EAZiB,UAAU,GAAV,aAAU,KAAV,aAAU,QAY3B;IAQD,IAAkB,kBAiBjB;IAjBD,WAAkB,kBAAkB;QAChC,qCAAe,CAAA;QACf,mDAA6B,CAAA;QAC7B,mCAAa,CAAA;QACb,uCAAiB,CAAA;QACjB,6CAAuB,CAAA;QACvB,yCAAmB,CAAA;QACnB,2CAAqB,CAAA;QACrB,qCAAe,CAAA;QACf,yCAAmB,CAAA;QACnB,uDAAiC,CAAA;QACjC,uCAAiB,CAAA;QACjB,6CAAuB,CAAA;QACvB,6CAAuB,CAAA;QACvB,iDAA2B,CAAA;QAC3B,8CAAwB,CAAA;QACxB,yCAAmB,CAAA;IACvB,CAAC,EAjBiB,kBAAkB,GAAlB,qBAAkB,KAAlB,qBAAkB,QAiBnC;IAgDD,IAAkB,cA2CjB;IA3CD,WAAkB,cAAc;QAE5B,iEAAwB,CAAA;QAExB,iEAAwB,CAAA;QAExB,iEAAwB,CAAA;QAExB,2EAA6B,CAAA;QAE7B,uEAA0B,CAAA;QAE1B,mEAAwB,CAAA;QAExB,0EAA2B,CAAA;QAE3B,sFAAiC,CAAA;QAEjC,oGAAwC,CAAA;QAExC,8EAA6B,CAAA;QAE7B,mFAA+B,CAAA;QAE/B,uGAAyC,CAAA;QAEzC,mHAA+C,CAAA;QAE/C,oGAAuC,CAAA;QAEvC,gGAAqC,CAAA;QAErC,8GAA4C,CAAA;QAE5C,6FAAmC,CAAA;QAEnC,2FAAkC,CAAA;QAElC,mFAA8B,CAAA;QAE9B,2GAA0C,CAAA;QAE1C,wGAAwC,CAAA;IAC5C,CAAC,EA3CiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QA2C/B;IAwBD,IAAkB,SAgEjB;IAhED,WAAkB,SAAS;QACvB,uCAAY,CAAA;QACZ,6CAAe,CAAA;QACf,6CAAe,CAAA;QACf,+CAAgB,CAAA;QAChB,0CAAa,CAAA;QACb,4DAAsB,CAAA;QACtB,4DAAsB,CAAA;QACtB,+DAAuB,CAAA;QACvB,yDAAoB,CAAA;QACpB,mDAAiB,CAAA;QACjB,4CAAc,CAAA;QACd,sDAAmB,CAAA;QACnB,4CAAc,CAAA;QACd,8CAAe,CAAA;QACf,+DAAuB,CAAA;QACvB,iDAAgB,CAAA;QAChB,+CAAe,CAAA;QACf,8DAAsB,CAAA;QACtB,gDAAe,CAAA;QACf,gEAAuB,CAAA;QAEvB,+DAAsB,CAAA;QAEtB,+EAA8B,CAAA;QAE9B,iFAA+B,CAAA;QAE/B,qFAAiC,CAAA;QACjC,gEAAsB,CAAA;QAEtB,kEAAuB,CAAA;QACvB,4DAAoB,CAAA;QAGpB,oDAA2B,CAAA;QAC3B,iDAAwD,CAAA;QACxD,4CAAyB,CAAA;QACzB,4EAAqD,CAAA;QAErD,kEAA0F,CAAA;QAC1F,8DAA2D,CAAA;QAE3D,0DAAwH,CAAA;QAExH,sDAAyG,CAAA;QACzG,0DAA2C,CAAA;QAC3C,sDAA0C,CAAA;QAC1C,yDAAsC,CAAA;QACtC,mDAA6B,CAAA;QAC7B,4EAA0C,CAAA;QAC1C,kEAA8C,CAAA;QAC9C,uFAAiF,CAAA;QACjF,8DAA4C,CAAA;QAI5C,4DAA2I,CAAA;QAC3I,oEAAuD,CAAA;QAEvD,uEAA+D,CAAA;QAE/D,wEAAyF,CAAA;QACzF,4FAAuE,CAAA;IAC3E,CAAC,EAhEiB,SAAS,GAAT,YAAS,KAAT,YAAS,QAgE1B;IA+CD,IAAkB,WAYjB;IAZD,WAAkB,WAAW;QACzB,+CAAc,CAAA;QACd,uDAAkB,CAAA;QAClB,uDAAkB,CAAA;QAClB,+CAAc,CAAA;QACd,wDAAkB,CAAA;QAClB,kDAAe,CAAA;QACf,8DAAqB,CAAA;QACrB,iEAAsB,CAAA;QACtB,iEAAsB,CAAA;QACtB,2HAAmD,CAAA;QACnD,qEAAoC,CAAA;IACxC,CAAC,EAZiB,WAAW,GAAX,cAAW,KAAX,cAAW,QAY5B;IAgDD,IAAkB,QAMjB;IAND,WAAkB,QAAQ;QACtB,iDAAa,CAAA;QACb,iDAAa,CAAA;QACb,yDAAiB,CAAA;QACjB,iDAAa,CAAA;QACb,qDAAe,CAAA;IACnB,CAAC,EANiB,QAAQ,GAAR,WAAQ,KAAR,WAAQ,QAMzB;IAiID,IAAkB,aAGjB;IAHD,WAAkB,aAAa;QAC3B,iDAAI,CAAA;QACJ,2DAAS,CAAA;IACb,CAAC,EAHiB,aAAa,GAAb,gBAAa,KAAb,gBAAa,QAG9B;IAkCD,IAAkB,SAGjB;IAHD,WAAkB,SAAS;QACvB,6CAAM,CAAA;QACN,6CAAM,CAAA;IACV,CAAC,EAHiB,SAAS,GAAT,YAAS,KAAT,YAAS,QAG1B;IAaD,IAAkB,iBAKjB;IALD,WAAkB,iBAAiB;QAC/B,2EAAsB,CAAA;QACtB,mFAA0B,CAAA;QAC1B,qEAAmB,CAAA;QACnB,qEAAmB,CAAA;IACvB,CAAC,EALiB,iBAAiB,GAAjB,oBAAiB,KAAjB,oBAAiB,QAKlC;IAWD,IAAkB,cAIjB;IAJD,WAAkB,cAAc;QAC5B,yEAAwB,CAAA;QACxB,6DAAkB,CAAA;QAClB,+DAAmB,CAAA;IACvB,CAAC,EAJiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QAI/B;IAWD,IAAkB,OAIjB;IAJD,WAAkB,OAAO;QACrB,uCAAS,CAAA;QACT,uCAAS,CAAA;QACT,sCAAS,CAAA;IACb,CAAC,EAJiB,OAAO,GAAP,UAAO,KAAP,UAAO,QAIxB;IAaD,IAAkB,6BAYjB;IAZD,WAAkB,6BAA6B;QAC3C,iFAAI,CAAA;QAEJ,uGAAe,CAAA;QAEf,mGAAa,CAAA;QAEb,2GAAiB,CAAA;QAEjB,iGAAY,CAAA;QAEZ,yFAAQ,CAAA;IACZ,CAAC,EAZiB,6BAA6B,GAA7B,gCAA6B,KAA7B,gCAA6B,QAY9C;IAsCD,IAAY,kBAIX;IAJD,WAAY,kBAAkB;QAC1B,iEAAO,CAAA;QACP,6DAAK,CAAA;QACL,iEAAO,CAAA;IACX,CAAC,EAJW,kBAAkB,GAAlB,qBAAkB,KAAlB,qBAAkB,QAI7B;IAED,IAAY,oBAGX;IAHD,WAAY,oBAAoB;QAC5B,qEAAW,CAAA;QACX,mEAAU,CAAA;IACd,CAAC,EAHW,oBAAoB,GAApB,uBAAoB,KAApB,uBAAoB,QAG/B;IAgID,IAAY,UAQX;IARD,WAAY,UAAU;QAClB,2CAAQ,CAAA;QACR,mDAAY,CAAA;QACZ,yCAAO,CAAA;QACP,yCAAO,CAAA;QACP,+CAAU,CAAA;QACV,+CAAU,CAAA;QACV,+CAAU,CAAA;IACd,CAAC,EARW,UAAU,GAAV,aAAU,KAAV,aAAU,QAQrB;IAED,IAAkB,OAKjB;IALD,WAAkB,OAAO;QACrB,qCAAQ,CAAA;QACR,6CAAY,CAAA;QACZ,uCAAS,CAAA;QACT,mDAAe,CAAA;IACnB,CAAC,EALiB,OAAO,GAAP,UAAO,KAAP,UAAO,QAKxB;IAED,IAAkB,WAGjB;IAHD,WAAkB,WAAW;QACzB,iFAA0B,CAAA;QAC1B,qDAAY,CAAA;IAChB,CAAC,EAHiB,WAAW,GAAX,cAAW,KAAX,cAAW,QAG5B;IAWD,IAAkB,UAUjB;IAVD,WAAkB,UAAU;QACxB,iDAAW,CAAA;QACX,uCAAM,CAAA;QACN,yCAAO,CAAA;QACP,uCAAM,CAAA;QACN,yCAAO,CAAA;QACP,yCAAO,CAAA;QACP,2CAAQ,CAAA;QACR,mDAAY,CAAA;QACZ,2CAAQ,CAAA;IACZ,CAAC,EAViB,UAAU,GAAV,aAAU,KAAV,aAAU,QAU3B;IAED,IAAkB,YAQjB;IARD,WAAkB,YAAY;QAC1B,6CAAO,CAAA;QACP,6CAAO,CAAA;QACP,mDAAU,CAAA;QACV,mDAAU,CAAA;QACV,mDAAU,CAAA;QACV,mDAAU,CAAA;QACV,mDAAe,CAAA;IACnB,CAAC,EARiB,YAAY,GAAZ,eAAY,KAAZ,eAAY,QAQ7B;IAED,IAAkB,eAGjB;IAHD,WAAkB,eAAe;QAC7B,6DAAQ,CAAA;QACR,mDAAG,CAAA;IACP,CAAC,EAHiB,eAAe,GAAf,kBAAe,KAAf,kBAAe,QAGhC;IAGD,IAAkB,eAGjB;IAHD,WAAkB,eAAe;QAC7B,yDAAM,CAAA;QACN,yDAAM,CAAA;IACV,CAAC,EAHiB,eAAe,GAAf,kBAAe,KAAf,kBAAe,QAGhC;IAcD,IAAkB,mBAGjB;IAHD,WAAkB,mBAAmB;QACjC,6DAAQ,CAAA;QACR,uEAAkB,CAAA;IACtB,CAAC,EAHiB,mBAAmB,GAAnB,sBAAmB,KAAnB,sBAAmB,QAGpC;IAkED,IAAkB,cAsIjB;IAtID,WAAkB,cAAc;QAC5B,qEAAiB,CAAA;QACjB,+EAAwB,CAAA;QAExB,4DAAe,CAAA;QACf,wEAAqB,CAAA;QACrB,wEAAsB,CAAA;QACtB,kFAA2B,CAAA;QAC3B,6DAAiB,CAAA;QAGjB,sDAAc,CAAA;QACd,6EAAyB,CAAA;QACzB,0DAAe,CAAA;QACf,0DAAe,CAAA;QACf,4DAAgB,CAAA;QAChB,4DAAgB,CAAA;QAChB,4EAAwB,CAAA;QACxB,0EAAuB,CAAA;QACvB,wEAAsB,CAAA;QACtB,oEAAoB,CAAA;QACpB,8EAAyB,CAAA;QACzB,gEAAkB,CAAA;QAClB,gEAAkB,CAAA;QAClB,0EAAuB,CAAA;QACvB,kFAA2B,CAAA;QAC3B,+EAAyB,CAAA;QACzB,gFAA0B,CAAA;QAC1B,wDAAc,CAAA;QAEd,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QAER,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QACT,gDAAS,CAAA;QAET,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QACR,+CAAQ,CAAA;QAER,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QACR,8CAAQ,CAAA;QAER,8DAAgB,CAAA;QAChB,4DAAe,CAAA;QACf,gDAAS,CAAA;QACT,8DAAgB,CAAA;QAChB,4DAAe,CAAA;QACf,mDAAU,CAAA;QACV,sDAAY,CAAA;QACZ,iEAAiB,CAAA;QACjB,oEAAmB,CAAA;QACnB,gEAAiB,CAAA;QACjB,sDAAY,CAAA;QACZ,sDAAY,CAAA;QACZ,kDAAU,CAAA;QACV,kEAAkB,CAAA;QAClB,wDAAa,CAAA;QACb,kEAAkB,CAAA;QAClB,kEAAkB,CAAA;QAClB,oDAAW,CAAA;QACX,4DAAe,CAAA;QACf,sDAAY,CAAA;QACZ,+DAAgB,CAAA;QAChB,kEAAkB,CAAA;QAClB,8DAAgB,CAAA;QAChB,0DAAc,CAAA;QACd,oDAAW,CAAA;QACX,4DAAe,CAAA;QACf,8DAAgB,CAAA;QAChB,kEAAkB,CAAA;QAClB,sDAAY,CAAA;QACZ,uDAAY,CAAA;QAEZ,6DAAgB,CAAA;QAChB,4DAAe,CAAA;QACf,yEAAsB,CAAA;QACtB,iDAAU,CAAA;QACV,kEAAkB,CAAA;IACtB,CAAC,EAtIiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QAsI/B;IAkED,IAAkB,SAUjB;IAVD,WAAkB,SAAS;QACvB,uBAAU,CAAA;QACV,yBAAY,CAAA;QACZ,yBAAY,CAAA;QACZ,2BAAc,CAAA;QACd,0BAAa,CAAA;QACb,4BAAe,CAAA;QACf,uBAAU,CAAA;QACV,yBAAY,CAAA;QACZ,2BAAc,CAAA;IAClB,CAAC,EAViB,SAAS,GAAT,YAAS,KAAT,YAAS,QAU1B;IA0DD,IAAkB,cA4EjB;IA5ED,WAAkB,cAAc;QAC5B,mDAAQ,CAAA;QAIR,+DAAmB,CAAA;QACnB,+EAA2B,CAAA;QAC3B,iEAAoB,CAAA;QACpB,uEAAuB,CAAA;QACvB,wEAAuB,CAAA;QACvB,wEAAuB,CAAA;QACvB,wDAAe,CAAA;QACf,yEAAuB,CAAA;QACvB,+DAAkB,CAAA;QAClB,+EAA0B,CAAA;QAC1B,4FAAiC,CAAA;QACjC,4GAAyC,CAAA;QAIzC,kFAA4B,CAAA;QAC5B,oGAAqC,CAAA;QACrC,qFAA6B,CAAA;QAC7B,qGAAqC,CAAA;QACrC,iIAAmD,CAAA;QACnD,8GAAyC,CAAA;QACzC,wHAA8C,CAAA;QAC9C,4EAAwB,CAAA;QACxB,yFAA8B,CAAA;QAC9B,wEAA6B,CAAA;QAC7B,qFAAyC,CAAA;QACzC,yGAAsC,CAAA;QACtC,qGAAoC,CAAA;QACpC,6FAAgC,CAAA;QAChC,4EAAuB,CAAA;QACvB,8HAAgD,CAAA;QAChD,4FAA+B,CAAA;QAK/B,mFAA0B,CAAA;QAI1B,2EAAkD,CAAA;QAClD,6DAAuB,CAAA;QACvB,mEAA6B,CAAA;QAC7B,oEAA6B,CAAA;QAC7B,oEAA6B,CAAA;QAC7B,qEAAsC,CAAA;QACtC,2EAA+C,CAAA;QAC/C,wGAAyF,CAAA;QAKzF,2EAA2F,CAAA;QAC3F,6FAA4R,CAAA;QAC5R,mFAAqT,CAAA;QACrT,yFAA4P,CAAA;QAC5P,mGAAiQ,CAAA;QACjQ,6EAAqP,CAAA;QACrP,+EAA4K,CAAA;QAC5K,oEAAkC,CAAA;QAClC,6FAA2J,CAAA;QAC3J,iHAA+D,CAAA;QAC/D,iHAA4F,CAAA;QAC5F,qFAAgC,CAAA;QAChC,yFAAuD,CAAA;QACvD,+FAAoD,CAAA;QAIpD,kGAAmH,CAAA;QACnH,gGAAwF,CAAA;IAC5F,CAAC,EA5EiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QA4E/B;IA2BD,IAAkB,SA8BjB;IA9BD,WAAkB,SAAS;QACvB,qDAAmB,CAAA;QACnB,iEAAyB,CAAA;QACzB,6DAAuB,CAAA;QACvB,yDAAqB,CAAA;QACrB,sEAA2B,CAAA;QAC3B,wEAA4B,CAAA;QAC5B,wDAAsD,CAAA;QACtD,sEAA2B,CAAA;QAC3B,mFAAiC,CAAA;QACjC,qFAAkC,CAAA;QAClC,qEAAwE,CAAA;QACxE,qEAA0B,CAAA;QAC1B,wEAA4B,CAAA;QAC5B,wDAAmD,CAAA;QACnD,oEAA0B,CAAA;QAC1B,wDAAoB,CAAA;QACpB,wDAAoB,CAAA;QACpB,uDAAmB,CAAA;QACnB,6DAAsB,CAAA;QACtB,qDAAkB,CAAA;QAClB,gEAAuB,CAAA;QACvB,wEAA2B,CAAA;QAC3B,kFAAgC,CAAA;QAChC,mEAAwB,CAAA;QACxB,2DAAoB,CAAA;QACpB,yFAAmC,CAAA;QACnC,uDAAkB,CAAA;QAClB,sEAAyB,CAAA;QACX,oFAAgC,CAAA;IAClD,CAAC,EA9BiB,SAAS,GAAT,YAAS,KAAT,YAAS,QA8B1B;IAcD,IAAkB,mBAuCjB;IAvCD,WAAkB,mBAAmB;QACjC,mEAAgB,CAAA;QAChB,iEAAe,CAAA;QACf,6DAAa,CAAA;QACb,qEAAiB,CAAA;QACjB,sEAAiB,CAAA;QACjB,gEAAc,CAAA;QACd,oEAAgB,CAAA;QAChB,yEAAkB,CAAA;QAClB,mEAAe,CAAA;QACf,+DAAa,CAAA;QACb,oEAAgB,CAAA;QAChB,kEAAe,CAAA;QACf,oFAAwB,CAAA;QACxB,oFAAwB,CAAA;QACxB,+EAAqB,CAAA;QACrB,6EAAoB,CAAA;QAEpB,6FAA4B,CAAA;QAC5B,0EAAkB,CAAA;QAElB,mFAAyB,CAAA;QACzB,sFAAyB,CAAA;QAGzB,iFAAsB,CAAA;QAGtB,6FAAgC,CAAA;QAGhC,oGAA+C,CAAA;QAG/C,qGAA6D,CAAA;QAG7D,oFAA8B,CAAA;IAElC,CAAC,EAvCiB,mBAAmB,GAAnB,sBAAmB,KAAnB,sBAAmB,QAuCpC;IAED,IAAkB,QAMjB;IAND,WAAkB,QAAQ;QACtB,mDAAU,CAAA;QACV,mDAAU,CAAA;QACV,2DAAc,CAAA;QACd,qEAAmB,CAAA;QACnB,qDAAW,CAAA;IACf,CAAC,EANiB,QAAQ,GAAR,WAAQ,KAAR,WAAQ,QAMzB;AAsRL,CAAC,EA7gKS,EAAE,KAAF,EAAE,QA6gKX;AAED,WAAU,EAAE;IAGR,IAAkB,IAGjB;IAHD,WAAkB,IAAI;QAClB,uEAAQ,CAAA;QACR,uEAAQ,CAAA;IACZ,CAAC,EAHiB,IAAI,GAAJ,OAAI,KAAJ,OAAI,QAGrB;IAED,IAAkB,IAGjB;IAHD,WAAkB,IAAI;QAClB,+CAAM,CAAA;QACN,uEAAQ,CAAA;IACZ,CAAC,EAHiB,IAAI,GAAJ,OAAI,KAAJ,OAAI,QAGrB;IAED,IAAkB,IAIjB;IAJD,WAAkB,IAAI;QAClB,uEAAQ,CAAA;QACR,uEAAQ,CAAA;QACR,uEAAQ,CAAA;IACZ,CAAC,EAJiB,IAAI,GAAJ,OAAI,KAAJ,OAAI,QAIrB;IAED,IAAkB,IAYjB;IAZD,WAAkB,IAAI;QAClB,+CAAM,CAAA;QACN,+BAAQ,CAAA;QACR,6BAAO,CAAA;QACP,6BAAO,CAAA;QACP,2BAAM,CAAA;QACN,+BAAQ,CAAA;QACR,6BAAO,CAAA;QACP,2BAAM,CAAA;QACN,6BAAO,CAAA;QACP,+CAAM,CAAA;QACN,gCAAS,CAAA;IACb,CAAC,EAZiB,IAAI,GAAJ,OAAI,KAAJ,OAAI,QAYrB;IAkDD,IAAkB,IASjB;IATD,WAAkB,IAAI;QAClB,mCAAK,CAAA;QACL,+CAAM,CAAA;QACN,+CAAW,CAAA;QACX,2DAAY,CAAA;QACZ,uEAAa,CAAA;QACb,wEAAa,CAAA;QACb,wEAAa,CAAA;QACb,wEAAa,CAAA;IACjB,CAAC,EATiB,IAAI,GAAJ,OAAI,KAAJ,OAAI,QASrB;AAkDL,CAAC,EA5IS,EAAE,KAAF,EAAE,QA4IX;AC1pKD,IAAU,EAAE,CAIX;AAJD,WAAU,EAAE;IAGK,YAAS,GAAG,OAAO,WAAW,KAAK,WAAW,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,cAAM,OAAA,WAAW,CAAC,GAAG,EAAE,EAAjB,CAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,cAAM,OAAA,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,EAAb,CAAa,CAAC;AACzJ,CAAC,EAJS,EAAE,KAAF,EAAE,QAIX;AAID,WAAU,EAAE;IAAC,IAAA,WAAW,CAqFvB;IArFY,WAAA,WAAW;QAGpB,IAAM,aAAa,GAAG,OAAO,eAAe,KAAK,UAAU,IAAI,eAAe,CAAC,QAAQ,KAAK,IAAI;YACxF,CAAC,CAAC,eAAe;YACjB,CAAC,CAAC,UAAC,SAAiB,IAAO,CAAC,CAAC;QAErC,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,MAAmB,CAAC;QACxB,IAAI,KAAkB,CAAC;QACvB,IAAI,QAAqB,CAAC;QAO1B,cAAqB,QAAgB;YACjC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACV,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAA,SAAS,EAAE,CAAC,CAAC;gBACjC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACtD,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC5B,CAAC;QACL,CAAC;QANe,gBAAI,OAMnB,CAAA;QAWD,iBAAwB,WAAmB,EAAE,aAAsB,EAAE,WAAoB;YACrF,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACV,IAAM,GAAG,GAAG,WAAW,IAAI,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,GAAA,SAAS,EAAE,CAAC;gBACjE,IAAM,KAAK,GAAG,aAAa,IAAI,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,aAAa,CAAC;gBACzE,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;YAChF,CAAC;QACL,CAAC;QANe,mBAAO,UAMtB,CAAA;QAOD,kBAAyB,QAAgB;YACrC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QAFe,oBAAQ,WAEvB,CAAA;QAOD,qBAA4B,WAAmB;YAC3C,MAAM,CAAC,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACtD,CAAC;QAFe,uBAAW,cAE1B,CAAA;QAOD,wBAA+B,EAAmD;YAC9E,QAAQ,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,GAAG;gBAC1B,EAAE,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACrB,CAAC,CAAC,CAAC;QACP,CAAC;QAJe,0BAAc,iBAI7B,CAAA;QAGD;YACI,MAAM,GAAG,GAAA,SAAS,EAAU,CAAC;YAC7B,KAAK,GAAG,GAAA,SAAS,EAAU,CAAC;YAC5B,QAAQ,GAAG,GAAA,SAAS,EAAU,CAAC;YAC/B,OAAO,GAAG,IAAI,CAAC;YACf,aAAa,GAAG,GAAA,SAAS,EAAE,CAAC;QAChC,CAAC;QANe,kBAAM,SAMrB,CAAA;QAGD;YACI,OAAO,GAAG,KAAK,CAAC;QACpB,CAAC;QAFe,mBAAO,UAEtB,CAAA;IACL,CAAC,EArFY,WAAW,GAAX,cAAW,KAAX,cAAW,QAqFvB;AAAD,CAAC,EArFS,EAAE,KAAF,EAAE,QAqFX;AC3FD,IAAU,EAAE,CAMX;AAND,WAAU,EAAE;IAGK,oBAAiB,GAAG,KAAK,CAAC;IAE1B,UAAO,GAAM,GAAA,iBAAiB,OAAI,CAAC;AACpD,CAAC,EANS,EAAE,KAAF,EAAE,QAMX;AAED,WAAU,EAAE;IACR,sCAA6C,UAAkB;QAI3D,MAAM,CAAC,GAAA,cAAc,CAAC,UAAU,CAAC,IAAI,GAAA,gBAAgB,CAAC,UAAU,CAAC,CAAC;IACtE,CAAC;IALe,+BAA4B,+BAK3C,CAAA;AACL,CAAC,EAPS,EAAE,KAAF,EAAE,QAOX;AAGD,WAAU,EAAE;IAGK,WAAQ,GAA8C,OAAO,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAa,SAAS,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAEvN,yBAAsB,GAAG,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IAGvF;QACI,IAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAe,IAAI,CAAC,CAAC;QAK9C,GAAG,CAAC,EAAE,GAAG,SAAS,CAAC;QACnB,OAAO,GAAG,CAAC,EAAE,CAAC;QAEd,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAGD;QACI,MAAM,CAAC,IAAI,MAAM,EAAK,CAAC;IAC3B,CAAC;IAFe,YAAS,YAExB,CAAA;IAGD;QACI,MAAM,CAAC,IAAI,MAAM,EAAgC,CAAC;IACtD,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,2BAAkC,OAA+B;QAC7D,IAAM,MAAM,GAAG,SAAS,EAAyB,CAAC;QAClD,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACV,GAAG,CAAC,CAAiB,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;gBAAvB,IAAM,MAAM,gBAAA;gBACb,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;aAC1C;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IARe,oBAAiB,oBAQhC,CAAA;IAED,+BAAyC,QAAqB;QAC1D,IAAM,GAAG,GAAW,IAAI,MAAM,EAAK,CAAC;QAIpC,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC;YACzB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBACrC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;YAChC,CAAC;QACL,CAAC;QAED,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAZe,wBAAqB,wBAYpC,CAAA;IAMD,IAAM,MAAM,GAAG,OAAO,GAAG,KAAK,WAAW,IAAI,SAAS,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;IAG1F;QAEI;YAKI,qBAAY,IAAgB,EAAE,QAA8C;gBAFpE,UAAK,GAAG,CAAC,CAAC;gBAGd,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;gBACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;gBACzB,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClC,CAAC;YAEM,0BAAI,GAAX;gBACI,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;gBACzB,EAAE,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;oBAC3B,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;gBAC9E,CAAC;gBACD,MAAM,CAAC,EAAE,KAAK,EAAE,SAAkB,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;YACrD,CAAC;YACL,kBAAC;QAAD,CAnBA,AAmBC,IAAA;QAED,MAAM;YAAC;gBACK,SAAI,GAAG,sBAAsB,EAAK,CAAC;gBACpC,SAAI,GAAG,CAAC,CAAC;YAkDpB,CAAC;YAhDG,qBAAG,GAAH,UAAI,GAAW;gBACX,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC1B,CAAC;YAED,qBAAG,GAAH,UAAI,GAAW,EAAE,KAAQ;gBACrB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACjB,IAAI,CAAC,IAAI,EAAE,CAAC;gBAChB,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gBACvB,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YAED,qBAAG,GAAH,UAAI,GAAW;gBAEX,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC;YAC5B,CAAC;YAED,wBAAM,GAAN,UAAO,GAAW;gBACd,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAChB,IAAI,CAAC,IAAI,EAAE,CAAC;oBACZ,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACtB,MAAM,CAAC,IAAI,CAAC;gBAChB,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YAED,uBAAK,GAAL;gBACI,IAAI,CAAC,IAAI,GAAG,sBAAsB,EAAK,CAAC;gBACxC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;YAClB,CAAC;YAED,sBAAI,GAAJ;gBACI,MAAM,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,UAAC,KAAK,EAAE,GAAG,IAAK,OAAA,GAAG,EAAH,CAAG,CAAC,CAAC;YAC3D,CAAC;YAED,wBAAM,GAAN;gBACI,MAAM,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,UAAC,IAAI,EAAE,GAAG,IAAK,OAAA,IAAI,CAAC,GAAG,CAAC,EAAT,CAAS,CAAC,CAAC;YAChE,CAAC;YAED,yBAAO,GAAP;gBACI,MAAM,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,UAAC,IAAI,EAAE,GAAG,IAAK,OAAA,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAgB,EAA/B,CAA+B,CAAC,CAAC;YACtF,CAAC;YAED,yBAAO,GAAP,UAAQ,MAAuC;gBAC3C,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC1B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;gBAChC,CAAC;YACL,CAAC;YACL,cAAC;QAAD,CApDO,AAoDN,IAAC;IACN,CAAC;IAED,gBAAuB,QAAgB,EAAE,QAAgB,EAAE,oBAA8C;QACrG,IAAM,oBAAoB,GAAG,gBAAgB,CAAC,QAAQ,CAAC;YACnD,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC;YACzB,CAAC,CAAC,yBAAyB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACpD,MAAM,CAAO,oBAAoB,CAAC,oBAAoB,CAAC,CAAC;IAC5D,CAAC;IALe,SAAM,SAKrB,CAAA;IAED,IAAkB,UAIjB;IAJD,WAAkB,UAAU;QACxB,oDAAgB,CAAA;QAChB,iDAAe,CAAA;QACf,yDAAe,CAAA;IACnB,CAAC,EAJiB,UAAU,GAAV,aAAU,KAAV,aAAU,QAI3B;IAED,gBAAuB,KAAyB;QAC5C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACpC,CAAC;IAFe,SAAM,SAErB,CAAA;IAOD,iBAA8B,KAAmC,EAAE,QAAsD;QACrH,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACrC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACT,MAAM,CAAC,MAAM,CAAC;gBAClB,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAVe,UAAO,UAUtB,CAAA;IAGD,sBAAmC,KAAmC,EAAE,QAAsD;QAC1H,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;gBACvB,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,eAAY,eAQ3B,CAAA;IAUD,sBAA6B,IAAU,EAAE,QAA6C;QAClF,OAAO,IAAI,EAAE,CAAC;YACV,IAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;YAC9B,EAAE,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC;gBACpB,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACd,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAZe,eAAY,eAY3B,CAAA;IAED,iBAAiC,MAAwB,EAAE,MAAwB,EAAE,QAA0C;QAC3H,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC;QAC9C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACnD,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAPe,UAAO,UAOtB,CAAA;IAED,kBAA4B,IAA2B,EAAE,MAAwB;QAC7E,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC;QAC5C,IAAM,GAAG,GAAG,SAAS,EAAK,CAAC;QAC3B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YACnC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAChC,CAAC;QACD,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAPe,WAAQ,WAOvB,CAAA;IAOD,eAAyB,KAAuB,EAAE,QAAgD;QAC9F,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzB,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;YACL,CAAC;QACL,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAVe,QAAK,QAUpB,CAAA;IAKD,cAAwB,KAAuB,EAAE,SAAiD;QAC9F,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,OAAI,OAQnB,CAAA;IAED,kBAA4B,KAAuB,EAAE,SAAiD;QAClG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,WAAQ,WAQvB,CAAA;IAGD,mBAA6B,KAAuB,EAAE,SAAiD;QACnG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC,CAAC,CAAC;YACb,CAAC;QACL,CAAC;QACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACd,CAAC;IAPe,YAAS,YAOxB,CAAA;IAMD,iBAA8B,KAAuB,EAAE,QAAsD;QACzG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IARe,UAAO,UAQtB,CAAA;IAED,kBAA4B,KAAuB,EAAE,KAAQ;QACzD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAY,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;gBAAhB,IAAM,CAAC,cAAA;gBACR,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;oBACd,MAAM,CAAC,IAAI,CAAC;gBAChB,CAAC;aACJ;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IATe,WAAQ,WASvB,CAAA;IAED,iBAA2B,KAAuB,EAAE,KAAQ;QACxD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;oBACrB,MAAM,CAAC,CAAC,CAAC;gBACb,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACd,CAAC;IATe,UAAO,UAStB,CAAA;IAED,4BAAmC,IAAY,EAAE,SAAgC,EAAE,KAAc;QAC7F,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5C,EAAE,CAAC,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAC,CAAC,CAAC;YACb,CAAC;QACL,CAAC;QACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACd,CAAC;IAPe,qBAAkB,qBAOjC,CAAA;IAED,oBAA8B,KAAuB,EAAE,SAAuC;QAC1F,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACnB,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClB,KAAK,EAAE,CAAC;gBACZ,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAXe,aAAU,aAWzB,CAAA;IAUD,gBAA0B,KAAU,EAAE,CAAoB;QACtD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;YACzB,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAAE,CAAC,EAAE,CAAC;YACnC,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBACV,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACjC,CAAC,EAAE,CAAC;gBACJ,OAAO,CAAC,GAAG,GAAG,EAAE,CAAC;oBACb,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACV,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACtB,CAAC;oBACD,CAAC,EAAE,CAAC;gBACR,CAAC;gBACD,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAnBe,SAAM,SAmBrB,CAAA;IAED,sBAAgC,KAAU,EAAE,CAA2C;QACnF,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;gBACxB,KAAK,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC3B,QAAQ,EAAE,CAAC;YACf,CAAC;QACL,CAAC;QACD,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,CAAC;IATe,eAAY,eAS3B,CAAA;IAED,eAAsB,KAAW;QAC7B,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACrB,CAAC;IAFe,QAAK,QAEpB,CAAA;IAED,aAA0B,KAAuB,EAAE,CAAyB;QACxE,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,EAAE,CAAC;YACZ,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAChC,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IATe,MAAG,MASlB,CAAA;IAKD,iBAA2B,KAAU,EAAE,CAAyB;QAC5D,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACT,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAChC,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtB,IAAM,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;oBAC1B,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;wBAClB,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;wBAC3B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,IAAI,KAAK,CAAC;IAC3B,CAAC;IAlBe,UAAO,UAkBtB,CAAA;IAOD,iBAA2B,KAA0C;QACjE,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,EAAE,CAAC;YACZ,GAAG,CAAC,CAAY,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;gBAAhB,IAAM,CAAC,cAAA;gBACR,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACJ,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACb,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBACxB,CAAC;oBACD,IAAI,CAAC,CAAC;wBACF,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,CAAC;gBACL,CAAC;aACJ;QACL,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAjBe,UAAO,UAiBtB,CAAA;IAQD,iBAA8B,KAAmC,EAAE,KAA4D;QAC3H,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,EAAE,CAAC;YACZ,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC7B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACJ,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACb,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBACxB,CAAC;oBACD,IAAI,CAAC,CAAC;wBACF,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAjBe,UAAO,UAiBtB,CAAA;IAED,qBAAkC,IAAiB,EAAE,KAAoC;QACrF,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,OAAO,IAAI,EAAE,CAAC;YACJ,IAAA,gBAA6B,EAA3B,gBAAK,EAAE,cAAI,CAAiB;YACpC,EAAE,CAAC,CAAC,IAAI,CAAC;gBAAC,KAAK,CAAC;YAChB,IAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;YACzB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACf,MAAM,CAAC,IAAI,OAAX,MAAM,EAAS,GAAG,EAAE;gBACxB,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACrB,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAhBe,cAAW,cAgB1B,CAAA;IAWD,qBAA+B,KAAU,EAAE,KAAmC;QAC1E,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAM,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC9B,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBAC/C,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACV,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC/B,CAAC;oBACD,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAClB,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;oBAC7B,CAAC;oBACD,IAAI,CAAC,CAAC;wBACF,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,IAAI,KAAK,CAAC;IAC3B,CAAC;IApBe,cAAW,cAoB1B,CAAA;IAED,oBAAiC,KAAmC,EAAE,KAAyC;QAC3G,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAM,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC9B,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;oBACvB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACxB,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAZe,aAAU,aAYzB,CAAA;IAED,wBAAqC,IAAiB,EAAE,KAA8B;QAClF,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,OAAO,IAAI,EAAE,CAAC;YACJ,IAAA,gBAA6B,EAA3B,gBAAK,EAAE,cAAI,CAAiB;YACpC,EAAE,CAAC,CAAC,IAAI,CAAC;gBAAC,KAAK,CAAC;YAChB,IAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;YACzB,EAAE,CAAC,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC;gBACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAXe,iBAAc,iBAW7B,CAAA;IAMD,cAAwB,KAAuB,EAAE,CAA+B;QAC5E,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC/C,CAAC;YACL,CAAC;YACD,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAChC,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAXe,OAAI,OAWnB,CAAA;IASD,iBAAiC,KAAuB,EAAE,KAA6B,EAAE,KAA4D;QACjJ,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,EAAE,CAAC;YACZ,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;YACzB,IAAI,WAAW,SAAG,CAAC;YACnB,IAAI,GAAG,SAAG,CAAC;YACX,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,IAAI,GAAG,GAAG,CAAC,CAAC;YACZ,OAAO,KAAK,GAAG,GAAG,EAAE,CAAC;gBACjB,OAAO,GAAG,GAAG,GAAG,EAAE,CAAC;oBACf,IAAM,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;oBACzB,GAAG,GAAG,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;oBACxB,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;wBACZ,WAAW,GAAG,GAAG,CAAC;oBACtB,CAAC;oBACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,CAAC;wBAC3B,KAAK,CAAC;oBACV,CAAC;oBAED,GAAG,EAAE,CAAC;gBACV,CAAC;gBAED,EAAE,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC;oBACd,IAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;oBAClE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACJ,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,CAAC;oBAED,KAAK,GAAG,GAAG,CAAC;gBAChB,CAAC;gBAED,WAAW,GAAG,GAAG,CAAC;gBAClB,GAAG,EAAE,CAAC;YACV,CAAC;QACL,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAtCe,UAAO,UAsCtB,CAAA;IAED,oBAAiC,GAAmB,EAAE,CAAyC;QAC3F,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAED,IAAM,MAAM,GAAG,SAAS,EAAK,CAAC;QAC9B,GAAG,CAAC,OAAO,CAAC,UAAC,KAAK,EAAE,GAAG;YACb,IAAA,kBAAkC,EAAjC,cAAM,EAAE,gBAAQ,CAAkB;YACzC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAXe,aAAU,aAWzB,CAAA;IAED,cAAwB,KAAuB,EAAE,SAAiC;QAC9E,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACZ,GAAG,CAAC,CAAY,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;oBAAhB,IAAM,CAAC,cAAA;oBACR,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACf,MAAM,CAAC,IAAI,CAAC;oBAChB,CAAC;iBACJ;YACL,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YAC5B,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAde,OAAI,OAcnB,CAAA;IAID,qBAA+B,MAAW,EAAE,MAAW;QACnD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAAC,MAAM,CAAC,MAAM,CAAC;QACjC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAAC,MAAM,CAAC,MAAM,CAAC;QACjC,MAAM,CAAK,MAAM,QAAK,MAAM,EAAE;IAClC,CAAC;IAJe,cAAW,cAI1B,CAAA;IAGD,qBAA+B,KAAuB,EAAE,QAAkC;QACtF,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,EAAE,CAAC;YACZ,IAAI,EAAE,GAAG,CAAC,CAAe,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;gBAAnB,IAAM,IAAI,cAAA;gBACjB,GAAG,CAAC,CAAc,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM;oBAAnB,IAAM,GAAG,eAAA;oBACV,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC;wBAChD,QAAQ,CAAC,IAAI,CAAC;oBAClB,CAAC;iBACJ;gBACD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACrB;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAde,cAAW,cAc1B,CAAA;IAED,wBAAkC,MAAwB,EAAE,MAAwB,EAAE,OAAiC;QACnH,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC;QAC7B,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,IAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAjBe,iBAAc,iBAiB7B,CAAA;IAED,uCAA8C,UAA2B,EAAE,UAA2B;QAClG,MAAM,CAAC,CAAC,UAAU;YACd,CAAC,UAAU,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,CAAC;YACzC,CAAC,UAAU,CAAC,gBAAgB,KAAK,UAAU,CAAC,gBAAgB,CAAC;YAC7D,CAAC,UAAU,CAAC,SAAS,KAAK,UAAU,CAAC,SAAS,CAAC;YAC/C,CAAC,UAAU,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,CAAC;YACzC,CAAC,UAAU,CAAC,KAAK,KAAK,UAAU,CAAC,KAAK,CAAC;YACvC,CAAC,UAAU,CAAC,GAAG,KAAK,UAAU,CAAC,GAAG,CAAC;YACnC,CAAC,UAAU,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,CAAC;YAC3C,CAAC,UAAU,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,CAAC;YAC3C,CAAC,UAAU,CAAC,cAAc,KAAK,UAAU,CAAC,cAAc,CAAC;YACzD,CAAC,UAAU,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,CAAC;YAC3C,CAAC,UAAU,CAAC,oBAAoB,KAAK,UAAU,CAAC,oBAAoB,CAAC;YACrE,CAAC,cAAc,CAAC,UAAU,CAAC,GAAG,EAAE,UAAU,CAAC,GAAG,CAAC;YAC/C,CAAC,cAAc,CAAC,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,SAAS,CAAC;YAC3D,CAAC,cAAc,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAU,CAAC,QAAQ,CAAC;YACzD,CAAC,kBAAkB,CAAC,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;IAChE,CAAC;IAjBe,gCAA6B,gCAiB5C,CAAA;IAOD,iBAA2B,KAAU;QACjC,IAAI,MAAW,CAAC;QAChB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACnB,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;oBACf,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACV,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC/B,CAAC;oBACD,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACJ,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,IAAI,KAAK,CAAC;IAC3B,CAAC;IAhBe,UAAO,UAgBtB,CAAA;IAOD,4BAAsC,MAAuB,EAAE,MAAuB,EAAE,QAAqC,EAAE,OAAW,EAAE,OAAW;QAA/D,yBAAA,EAAA,wBAAqC;QAAE,wBAAA,EAAA,WAAW;QAAE,wBAAA,EAAA,WAAW;QACnJ,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,MAAM,CAAC;QACpF,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,KAAK,EAAE,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE,CAAC;YAC/C,KAAK,EAAE,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE,CAAC;gBAC/C,MAAM,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjD,SAA0B,KAAK,CAAC,KAAK,CAAC;oBACtC,QAAyB,QAAQ,CAAC,KAAK,CAAC;oBACxC,QAA6B,QAAQ,CAAC,KAAK,CAAC;gBAChD,CAAC;YACL,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;QACjC,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAde,qBAAkB,qBAcjC,CAAA;IAED,aAAmE,KAAuB,EAAE,IAAO;QAC/F,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,GAAG,CAAC,CAAY,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;YAAhB,IAAM,CAAC,cAAA;YAER,MAAM,IAAI,CAAC,CAAC,IAAI,CAAW,CAAC;SAC/B;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAPe,MAAG,MAOlB,CAAA;IAUD,gBAA0B,EAAmB,EAAE,KAAoB;QAC/D,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QACnC,EAAE,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC;YAAC,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC;QACrC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACf,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IALe,SAAM,SAKrB,CAAA;IAMD,kBAAkB,KAAyB,EAAE,MAAc;QACvD,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;IACvD,CAAC;IAYD,kBAA4B,EAAmB,EAAE,IAAkC,EAAE,KAAc,EAAE,GAAY;QAC7G,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QACvD,EAAE,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACpD,KAAK,GAAG,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACxD,GAAG,GAAG,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAC5D,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClD,IAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAZe,WAAQ,WAYvB,CAAA;IAKD,sBAAgC,KAAU,EAAE,KAAQ;QAChD,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,CAAC;YACF,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;IACL,CAAC;IARe,eAAY,eAQ3B,CAAA;IAKD,wBAAkC,KAAsB,EAAE,KAAQ;QAC9D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC3B,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;IACL,CAAC;IARe,iBAAc,iBAQ7B,CAAA;IAKD,oBAA8B,KAAuB,EAAE,QAAqC;QAArC,yBAAA,EAAA,wBAAqC;QACxF,MAAM,CAAC,KAAK;aACP,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,EAAD,CAAC,CAAC;aAChB,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,EAAnD,CAAmD,CAAC;aACnE,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,KAAK,CAAC,CAAC,CAAC,EAAR,CAAQ,CAAC,CAAC;IAC5B,CAAC;IALe,aAAU,aAKzB,CAAA;IAED,qBAA+B,MAAwB,EAAE,MAAwB,EAAE,GAAW,EAAE,GAAW;QACvG,OAAO,GAAG,GAAG,GAAG,EAAE,CAAC;YACf,EAAE,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YACD,GAAG,EAAE,CAAC;QACV,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IARe,cAAW,cAQ1B,CAAA;IAMD,mBAA6B,KAAmC,EAAE,MAAc;QAC5E,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,GAAG,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;YACjC,EAAE,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACzB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,YAAS,YAQxB,CAAA;IAKD,0BAAoC,KAAuB;QACvD,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAC/B,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,eAAyB,KAAuB;QAC5C,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;QACjC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAHe,QAAK,QAGpB,CAAA;IAKD,yBAAmC,KAAuB;QACtD,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;IAChC,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,cAAwB,KAAuB;QAC3C,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;QACjC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACnC,CAAC;IAHe,OAAI,OAGnB,CAAA;IAKD,2BAAqC,KAAuB;QACxD,MAAM,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;YAC9B,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,CAAC,CAAC,SAAS,CAAC;IACpB,CAAC;IAJe,oBAAiB,oBAIhC,CAAA;IAQD,sBAAgC,KAAU;QACtC,MAAM,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;YAC9B,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,CAAC,CAAC,KAAK,CAAC;IAChB,CAAC;IAJe,eAAY,eAI3B,CAAA;IAED,wBAAkC,KAAuB,EAAE,KAAa,EAAE,KAAQ;QAC9E,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QACtB,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAJe,iBAAc,iBAI7B,CAAA;IAWD,sBAAgC,KAAuB,EAAE,KAAQ,EAAE,QAAsB,EAAE,MAAe;QACtG,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC/B,MAAM,CAAC,CAAC,CAAC,CAAC;QACd,CAAC;QAED,IAAI,GAAG,GAAG,MAAM,IAAI,CAAC,CAAC;QACtB,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;QAC5B,QAAQ,GAAG,QAAQ,KAAK,SAAS;YAC7B,CAAC,CAAC,QAAQ;YACV,CAAC,CAAC,UAAC,EAAE,EAAE,EAAE,IAAK,OAAA,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAlC,CAAkC,CAAC;QAErD,OAAO,GAAG,IAAI,IAAI,EAAE,CAAC;YACjB,IAAM,MAAM,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;YACzC,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;YAE/B,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAClC,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACrC,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC;YACtB,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,GAAG,GAAG,MAAM,GAAG,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,CAAC,GAAG,CAAC;IAChB,CAAC;IA3Be,eAAY,eA2B3B,CAAA;IAID,oBAA8B,KAAU,EAAE,CAAsC,EAAE,OAAW,EAAE,KAAc,EAAE,KAAc;QACzH,EAAE,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;YAC1B,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;gBACX,IAAI,GAAG,GAAG,KAAK,KAAK,SAAS,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACvD,IAAM,GAAG,GAAG,KAAK,KAAK,SAAS,IAAI,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,KAAK,CAAC;gBACnF,IAAI,MAAM,SAAG,CAAC;gBACd,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBACxB,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpB,GAAG,EAAE,CAAC;gBACV,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,MAAM,GAAG,OAAO,CAAC;gBACrB,CAAC;gBACD,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;oBAChB,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;oBACpC,GAAG,EAAE,CAAC;gBACV,CAAC;gBACD,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,OAAO,CAAC;IACnB,CAAC;IAtBe,aAAU,aAsBzB,CAAA;IAID,qBAA+B,KAAU,EAAE,CAAsC,EAAE,OAAW,EAAE,KAAc,EAAE,KAAc;QAC1H,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,IAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;YAC1B,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;gBACX,IAAI,GAAG,GAAG,KAAK,KAAK,SAAS,IAAI,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACrE,IAAM,GAAG,GAAG,KAAK,KAAK,SAAS,IAAI,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,KAAK,CAAC;gBACrE,IAAI,MAAM,SAAG,CAAC;gBACd,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBACxB,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpB,GAAG,EAAE,CAAC;gBACV,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,MAAM,GAAG,OAAO,CAAC;gBACrB,CAAC;gBACD,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;oBAChB,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;oBACpC,GAAG,EAAE,CAAC;gBACV,CAAC;gBACD,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,OAAO,CAAC;IACnB,CAAC;IAtBe,cAAW,cAsB1B,CAAA;IAED,IAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;IAQvD,qBAA4B,GAAiB,EAAE,GAAW;QACtD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACzC,CAAC;IAFe,cAAW,cAE1B,CAAA;IAQD,qBAA+B,GAAe,EAAE,GAAW;QACvD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAChE,CAAC;IAFe,cAAW,cAE1B,CAAA;IAKD,oBAA8B,GAAe;QACzC,IAAM,IAAI,GAAa,EAAE,CAAC;QAC1B,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;YACpB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBAChC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACnB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IATe,aAAU,aASzB,CAAA;IAED,sBAAgC,WAAgB;QAC5C,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC;YAC5B,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YAClC,CAAC;QACL,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IATe,eAAY,eAS3B,CAAA;IAKD,mBAA0B,QAAuB,EAAE,GAAqB;QACpE,IAAM,MAAM,GAAU,EAAE,CAAC;QACzB,GAAG,CAAC,CAAK,IAAA,oBAAiC,EAA/B,gBAAK,EAAE,cAAI,EAAsB,CAAC,IAAI,EAAE,oBAAiC,EAA/B,gBAAK,EAAE,cAAI,MAAsB,CAAC;YACnF,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAC1C,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;;IAClB,CAAC;IANe,YAAS,YAMxB,CAAA;IAQD,sBAAmC,GAAqD,EAAE,QAA+D;QACrJ,IAAM,QAAQ,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAC/B,GAAG,CAAC,CAAK,IAAA,oBAAuC,EAArC,eAAW,EAAE,cAAI,EAAsB,CAAC,IAAI,EAAE,oBAAuC,EAArC,eAAW,EAAE,cAAI,MAAsB,CAAC;YACxF,IAAA,aAAG,EAAE,eAAK,CAAS;YAC1B,IAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,EAAE,GAA0B,CAAC,CAAC;YAC3D,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;;IACrB,CAAC;IAVe,eAAY,eAU3B,CAAA;IAKD,oBAA8B,GAAuD,EAAE,QAAmD;QACtI,IAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;QAC5B,GAAG,CAAC,CAAK,IAAA,oBAAsC,EAApC,cAAU,EAAE,cAAI,EAAsB,CAAC,IAAI,EAAE,oBAAsC,EAApC,cAAU,EAAE,cAAI,MAAsB,CAAC;YAC7F,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAwB,CAAC,CAAC;YAClD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;;IACrB,CAAC;IATe,aAAU,aASzB,CAAA;IAKD,qBAA2E,MAAS,EAAE,MAAS;QAC1F,MAAiB,CAAC,OAAO,CAAC,UAAC,KAAK,EAAE,GAAG;YACjC,MAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACvC,CAAC,CAAC,CAAC;IACP,CAAC;IAJe,cAAW,cAI1B,CAAA;IAKD,gBAA+C,CAAK;QAAE,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,6BAAc;;QAChE,GAAG,CAAC,CAAc,UAAI,EAAJ,aAAI,EAAJ,kBAAI,EAAJ,IAAI;YAAjB,IAAM,GAAG,aAAA;YACV,GAAG,CAAC,CAAC,IAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtB,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClB,CAAC;YACL,CAAC;SACJ;QACD,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IATe,SAAM,SASrB,CAAA;IAQD,4BAAsC,IAAgB,EAAE,KAAiB,EAAE,gBAAiD;QACxH,EAAE,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAChC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAClC,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBACjC,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,SAAS,CAAC;oBAAC,MAAM,CAAC,KAAK,CAAC;gBACjE,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC;oBAAC,MAAM,CAAC,KAAK,CAAC;YAC7G,CAAC;QACL,CAAC;QAED,GAAG,CAAC,CAAC,IAAM,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClC,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;oBAAC,MAAM,CAAC,KAAK,CAAC;YACtD,CAAC;QACL,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAjBe,qBAAkB,qBAiBjC,CAAA;IAcD,oBAAiC,KAAuB,EAAE,OAA6B,EAAE,SAA2B;QAChH,IAAM,MAAM,GAAG,SAAS,EAAS,CAAC;QAClC,GAAG,CAAC,CAAgB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;YAApB,IAAM,KAAK,cAAA;YACZ,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;SACpE;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IANe,aAAU,aAMzB,CAAA;IAED,2BAAqC,KAAuB,EAAE,OAA6B;QACvF,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,GAAG,CAAC,CAAgB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;YAApB,IAAM,KAAK,cAAA;YACZ,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC;SAClC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IANe,oBAAiB,oBAMhC,CAAA;IASD,oBAA2B,KAAyB,EAAE,OAAgC;QAClF,MAAM,CAAC,UAAU,CAAY,KAAK,EAAE,OAAO,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,EAAD,CAAC,CAAC,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI,CAAC,CAAC;IACzE,CAAC;IAFe,aAAU,aAEzB,CAAA;IAID,kBAA4B,GAAiC;QACzD,IAAM,KAAK,GAAG,SAAS,EAAK,CAAC;QAC7B,WAAW,CAAC,GAAa,EAAE,KAAK,CAAC,CAAC;QAClC,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAJe,WAAQ,WAIvB,CAAA;IAED,eAAyB,MAAS;QAC9B,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,MAAM,CAAC,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;gBAClC,MAAM,CAAC,EAAE,CAAC,GAAS,MAAO,CAAC,EAAE,CAAC,CAAC;YACnC,CAAC;QACL,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IARe,QAAK,QAQpB,CAAA;IAED,gBAA+B,KAAS,EAAE,MAAU;QAChD,IAAM,MAAM,GAAiB,EAAE,CAAC;QAChC,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,MAAM,CAAC,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;gBACjC,MAAc,CAAC,EAAE,CAAC,GAAI,MAAc,CAAC,EAAE,CAAC,CAAC;YAC9C,CAAC;QACL,CAAC;QAED,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;gBAChC,MAAc,CAAC,EAAE,CAAC,GAAI,KAAa,CAAC,EAAE,CAAC,CAAC;YAC7C,CAAC;QACL,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAfe,SAAM,SAerB,CAAA;IAgBD;QACI,IAAM,GAAG,GAAG,SAAS,EAAsB,CAAC;QAC5C,GAAG,CAAC,GAAG,GAAG,WAAW,CAAC;QACtB,GAAG,CAAC,MAAM,GAAG,cAAc,CAAC;QAC5B,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IALe,iBAAc,iBAK7B,CAAA;IACD,qBAA2C,GAAW,EAAE,KAAQ;QAC5D,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC3B,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC;QACD,IAAI,CAAC,CAAC;YACF,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;QACpC,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAElB,CAAC;IACD,wBAA8C,GAAW,EAAE,KAAQ;QAC/D,IAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC7B,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACT,mBAAmB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YACnC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACjB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;IACL,CAAC;IAKD,iBAAwB,KAAU;QAC9B,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC;IACzE,CAAC;IAFe,UAAO,UAEtB,CAAA;IAKD,kBAAyB,IAAS;QAC9B,MAAM,CAAC,OAAO,IAAI,KAAK,QAAQ,CAAC;IACpC,CAAC;IAFe,WAAQ,WAEvB,CAAA;IAED,iBAAqD,KAAsB,EAAE,IAAmC;QAC5G,MAAM,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;IAClE,CAAC;IAFe,UAAO,UAEtB,CAAA;IAED,cAAkD,KAAsB,EAAE,IAAmC;QACzG,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QACrD,KAAK,CAAC,IAAI,CAAC,6DAA2D,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,OAAI,CAAC,CAAC;IAC3G,CAAC;IAHe,OAAI,OAGnB,CAAA;IAGD,kBAA+B,CAAC;IAAhB,OAAI,OAAY,CAAA;IAGhC,yBAAuC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IAAtC,cAAW,cAA2B,CAAA;IAGtD,wBAAqC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAAnC,aAAU,aAAyB,CAAA;IAGnD,kBAA4B,CAAI,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAA/B,WAAQ,WAAuB,CAAA;IAG/C;QACI,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACvC,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,iBAA2B,QAAiB;QACxC,IAAI,KAAQ,CAAC;QACb,MAAM,CAAC;YACH,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACX,KAAK,GAAG,QAAQ,EAAE,CAAC;gBACnB,QAAQ,GAAG,SAAS,CAAC;YACzB,CAAC;YACD,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC,CAAC;IACN,CAAC;IATe,UAAO,UAStB,CAAA;IASD,eAA4B,CAAwB,EAAE,CAAwB,EAAE,CAAwB,EAAE,CAAwB,EAAE,CAAwB;QACxJ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACJ,IAAM,MAAI,GAA8B,EAAE,CAAC;YAC3C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACxC,MAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,CAAC;YAED,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,OAAO,eAAI,GAAG,CAAC,MAAI,EAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC,GAA/B,CAAgC,CAAC;QACjD,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAA/B,CAA+B,CAAC;QAChD,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAzB,CAAyB,CAAC;QAC1C,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAAC;QACpC,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC;QAC9B,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,UAAA,CAAC,IAAI,OAAA,CAAC,EAAD,CAAC,EAAN,CAAM,CAAC;QACvB,CAAC;IACL,CAAC;IAxBe,QAAK,QAwBpB,CAAA;IASD,iBAA2B,CAAc,EAAE,CAAc,EAAE,CAAc,EAAE,CAAc,EAAE,CAAc;QACrG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACJ,IAAM,MAAI,GAAoB,EAAE,CAAC;YACjC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACxC,MAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,CAAC;YAED,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,UAAU,CAAC,MAAI,EAAE,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,EAAE,CAAC,CAAC,EAAnC,CAAmC,CAAC;QACpD,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC;QAC9B,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAV,CAAU,CAAC;QAC3B,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAP,CAAO,CAAC;QACxB,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC;QACrB,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,EAAD,CAAC,CAAC;QAClB,CAAC;IACL,CAAC;IAxBe,UAAO,UAwBtB,CAAA;IAED,8BAAqC,IAAY,EAAE,IAAkC,EAAE,SAAkB;QACrG,SAAS,GAAG,SAAS,IAAI,CAAC,CAAC;QAE3B,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,UAAC,MAAM,EAAE,KAAM,IAAK,OAAA,IAAI,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC,EAAxB,CAAwB,CAAC,CAAC;IAClF,CAAC;IAJe,uBAAoB,uBAInC,CAAA;IAEU,8BAA2B,GAAoB,SAAS,CAAC;IAEpE,kCAAyC,OAA0B;QAC/D,MAAM,CAAC,GAAA,2BAA2B,IAAI,GAAA,2BAA2B,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC;IACtG,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAGD,8BAAqC,IAAgB,EAAE,KAAa,EAAE,MAAc,EAAE,OAA0B;QAC5G,KAAK,CAAC,wBAAwB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACzC,KAAK,CAAC,wBAAwB,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QAE1C,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,KAAK,CAAC,qBAAqB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrD,KAAK,CAAC,qBAAqB,CAAC,KAAK,GAAG,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,IAAI,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAC;QAE7C,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,GAAG,oBAAoB,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,MAAM,CAAC;YACH,IAAI,MAAA;YACJ,KAAK,OAAA;YACL,MAAM,QAAA;YAEN,WAAW,EAAE,IAAI;YACjB,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,IAAI,EAAE,OAAO,CAAC,IAAI;SACrB,CAAC;IACN,CAAC;IAxBe,uBAAoB,uBAwBnC,CAAA;IAGD,uBAA8B,MAAW,EAAE,OAA0B;QACjE,IAAI,IAAI,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAC;QAE7C,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,GAAG,oBAAoB,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IARe,gBAAa,gBAQ5B,CAAA;IAGD,kCAAyC,OAA0B;QAC/D,IAAI,IAAI,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAC;QAE7C,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,GAAG,oBAAoB,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,MAAM,CAAC;YACH,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,SAAS;YAChB,MAAM,EAAE,SAAS;YAEjB,WAAW,EAAE,IAAI;YACjB,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,IAAI,EAAE,OAAO,CAAC,IAAI;SACrB,CAAC;IACN,CAAC;IAhBe,2BAAwB,2BAgBvC,CAAA;IAED,kDAAyD,KAA6B;QAClF,MAAM,CAAC;YACH,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,SAAS;YAChB,MAAM,EAAE,SAAS;YAEjB,IAAI,EAAE,KAAK,CAAC,IAAI;YAChB,QAAQ,EAAE,KAAK,CAAC,QAAQ;YACxB,WAAW,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW;SACtD,CAAC;IACN,CAAC;IAVe,2CAAwC,2CAUvD,CAAA;IAGD,iCAAwC,OAA+B,EAAE,OAA0B;QAC/F,IAAI,IAAI,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAC;QAE7C,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,GAAG,oBAAoB,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,MAAM,CAAC;YACH,WAAW,EAAE,IAAI;YACjB,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,IAAI,EAAE,OAAO,CAAC,IAAI;YAElB,IAAI,EAAE,OAAO;SAChB,CAAC;IACN,CAAC;IAde,0BAAuB,0BActC,CAAA;IAED,4CAAmD,SAAiC,EAAE,SAAiC;QACnH,IAAI,SAAS,GAAG,SAAS,CAAC;QAC1B,OAAO,SAAS,CAAC,IAAI,EAAE,CAAC;YACpB,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC;QAC/B,CAAC;QAED,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC;QAC3B,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,qCAAkC,qCAQjD,CAAA;IAED,uBAAiC,CAAI,EAAE,CAAI;QACvC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,GAAoB;QACvC,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,IAAqB;QAChD,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,GAAwB;QACnD,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAqB,CAAC,EAAuB,CAAC;IAChE,CAAC;IALe,gBAAa,gBAK5B,CAAA;IAED,wBAA+B,CAAS,EAAE,CAAS,EAAE,UAAoB;QACrE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,GAAoB;QACvC,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,IAAqB;QAChD,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,GAAwB;QACnD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YAGb,EAAE,CAAC,CAAC,GAAA,QAAQ,CAAC,CAAC,CAAC;gBACX,IAAM,MAAM,GAAG,GAAA,sBAAsB,CAAC,CAAC;oBACnC,GAAA,QAAQ,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBACxB,CAAC,CAAC,aAAa,CAAC,CAAC,EAAc,SAAS,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC,CAAC;gBACxF,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAqB,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAwB,CAAC,EAAmB,CAAC;YACvG,CAAC;YAED,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;YACpB,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;YACpB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAAC,MAAM,GAAoB;QAC3C,CAAC;QAED,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAqB,CAAC,EAAuB,CAAC;IAChE,CAAC;IApBe,iBAAc,iBAoB7B,CAAA;IAED,uCAA8C,CAAS,EAAE,CAAS;QAC9D,MAAM,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,EAAiB,IAAI,CAAC,CAAC;IACrD,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,+BAA+B,UAAsB;QACjD,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;IAClE,CAAC;IAED,4BAAmC,EAAc,EAAE,EAAc;QAC7D,MAAM,CAAC,aAAa,CAAC,qBAAqB,CAAC,EAAE,CAAC,EAAE,qBAAqB,CAAC,EAAE,CAAC,CAAC;YACtE,aAAa,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC;YACjC,aAAa,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC;YACnC,aAAa,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC;YAC/B,kBAAkB,CAAC,EAAE,CAAC,WAAW,EAAE,EAAE,CAAC,WAAW,CAAC;aAChC,CAAC;IAC3B,CAAC;IAPe,qBAAkB,qBAOjC,CAAA;IAED,4BAA4B,KAAsC,EAAE,KAAsC;QACtG,OAAO,KAAK,IAAI,KAAK,EAAE,CAAC;YAEpB,IAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC;YAC5D,IAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC;YAE5D,IAAM,GAAG,GAAG,aAAa,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACN,MAAM,CAAC,GAAG,CAAC;YACf,CAAC;YAED,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;YACjD,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;QACrD,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAEnB,MAAM,GAAoB;QAC9B,CAAC;QAGD,MAAM,CAAC,KAAK,CAAC,CAAC,GAAwB,CAAC,GAAoB,CAAC;IAChE,CAAC;IAED,uCAA8C,WAAyB;QACnE,MAAM,CAAC,4BAA4B,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;IAC9E,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,sCAA6C,WAAyB;QAClE,EAAE,CAAC,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,WAAW,CAAC;QACvB,CAAC;QAED,IAAM,cAAc,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QACxC,IAAI,kBAAkB,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACxC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,IAAM,iBAAiB,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YACzC,IAAM,MAAM,GAAG,kBAAkB,CAAC,iBAAiB,EAAE,kBAAkB,CAAC,MAAuB,CAAC;YAChG,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACV,cAAc,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;gBACvC,kBAAkB,GAAG,iBAAiB,CAAC;YAC3C,CAAC;QACL,CAAC;QAED,MAAM,CAAC,cAAc,CAAC;IAC1B,CAAC;IAjBe,+BAA4B,+BAiB3C,CAAA;IAED,0BAAiC,IAAY;QACzC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACpC,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAKD,uBAA8B,IAAY;QACtC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,OAAyB,CAAC,CAAC,CAAC;YAC9C,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,OAAyB,CAAC;gBAAC,MAAM,CAAC,CAAC,CAAC;YAC1D,IAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YAChC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;gBAAC,MAAM,CAAC,CAAC,CAAC;YACrB,IAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;gBAAC,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC;YAC1B,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC;QAClB,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,OAAyB,CAAC,CAAC,CAAC;YAC9C,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,OAAyB,CAAC;gBAAC,MAAM,CAAC,CAAC,CAAC;YAC1D,MAAM,CAAC,CAAC,CAAC;QACb,CAAC;QAMD,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACxC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC;QAC7B,CAAC;QACD,IAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAChC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;QAC9B,CAAC;QACD,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IA1Be,gBAAa,gBA0B5B,CAAA;IAOY,qBAAkB,GAAG,GAAG,CAAC;IACtC,IAAM,0BAA0B,KAAuB,CAAC;IACxD,4BAA4B,qBAA6B,EAAE,UAAkB;QACzE,IAAM,KAAK,GAAG,qBAAqB,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,GAAA,kBAAkB,CAAC,CAAC;QACjF,IAAM,UAAU,GAAa,EAAE,CAAC;QAChC,GAAG,CAAC,CAAe,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;YAAnB,IAAM,IAAI,cAAA;YACX,EAAE,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;gBACf,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,UAAU,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;oBACjF,UAAU,CAAC,GAAG,EAAE,CAAC;gBACrB,CAAC;gBACD,IAAI,CAAC,CAAC;oBAGF,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACP,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAC1B,CAAC;gBACL,CAAC;YACL,CAAC;SACJ;QAED,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAED,uBAA8B,IAAY;QACtC,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;IAC5C,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,+BAAsC,IAAY;QAC9C,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAM,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACvC,IAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QACxC,IAAM,KAAK,GAAG,kBAAkB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YACf,IAAM,WAAW,GAAG,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,GAAA,kBAAkB,CAAC,CAAC;YAC1D,MAAM,CAAC,EAAE,IAAI,EAAE,8BAA8B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,GAAG,GAAA,kBAAkB,CAAC,CAAC,CAAC,WAAW,EAAE,KAAK,OAAA,EAAE,CAAC;QAClH,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,OAAA,EAAE,CAAC;QACjC,CAAC;IACL,CAAC;IAZe,wBAAqB,wBAYpC,CAAA;IAGD,wCAA+C,IAAY;QACvD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,0BAA0B,CAAC;IAC3E,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IASD,0BAAiC,IAAY;QACzC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,GAAA,kBAAkB,CAAC,CAAC,CAAC,CAAC;IAC/F,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,eAAsB,IAAY;QAC9B,MAAM,CAAC,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC1E,CAAC;IAFe,QAAK,QAEpB,CAAA;IAED,wBAA+B,IAAY;QACvC,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxC,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAGD,kCAAyC,UAAkB;QACvD,MAAM,CAAC,CAAC,GAAA,4BAA4B,CAAC,UAAU,CAAC,CAAC;IACrD,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,6BAAoC,eAAgC;QAChE,MAAM,CAAC,eAAe,CAAC,MAAM,KAAoB,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,2BAAkC,eAAgC;QAC9D,MAAM,CAAC,OAAO,eAAe,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC;YAC/C,eAAe,CAAC,MAAM,CAAC,CAAC;YACxB,mBAAmB,CAAC,eAAe,CAAC,KAAuB,CAAC,CAAC,CAAC,GAAA,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,GAAA,UAAU,CAAC,QAAQ,CAAC;IAC9G,CAAC;IAJe,oBAAiB,oBAIhC,CAAA;IAED,qCAA4C,eAAgC;QACxE,IAAI,gBAAgB,GAAG,eAAe,CAAC,gBAAgB,CAAC;QACxD,EAAE,CAAC,CAAC,gBAAgB,KAAK,SAAS,CAAC,CAAC,CAAC;YACjC,gBAAgB,GAAG,iBAAiB,CAAC,eAAe,CAAC,KAAK,GAAA,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAA,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,GAAA,oBAAoB,CAAC,OAAO,CAAC;QAC/I,CAAC;QACD,MAAM,CAAC,gBAAgB,CAAC;IAC5B,CAAC;IANe,8BAA2B,8BAM1C,CAAA;IAED,uCAA8C,GAAW;QACrD,IAAI,YAAY,GAAG,KAAK,CAAC;QACzB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,OAA4B,CAAC,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBAChB,YAAY,GAAG,IAAI,CAAC;gBACxB,CAAC;gBACD,IAAI,CAAC,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAde,gCAA6B,gCAc5C,CAAA;IAED,0BAAiC,IAAY;QACzC,MAAM,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7C,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,+BAAsC,sBAA8B,EAAE,QAAgB,EAAE,oBAA8C;QAClI,MAAM,CAAC,CAAC,gBAAgB,CAAC,sBAAsB,CAAC;YAC5C,CAAC,CAAC,sBAAsB;YACxB,CAAC,CAAC,+BAA+B,CAAC,QAAQ,EAAE,sBAAsB,EAAE,QAAQ,EAAE,oBAAoB,EAA0B,KAAK,CAAC,CAAC;IAC3I,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAED,kCAAkC,IAAY,EAAE,UAAkB;QAC9D,IAAM,eAAe,GAAG,kBAAkB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QAC7D,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;IAChE,CAAC;IAED,qCAA4C,IAAY,EAAE,gBAAwB;QAC9E,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACrC,EAAE,CAAC,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC;YAEnB,IAAI,GAAG,YAAY,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,CAAC;YAC9D,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACrC,CAAC;QAED,MAAM,CAAC,wBAAwB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IACtD,CAAC;IAVe,8BAA2B,8BAU1C,CAAA;IAED,mCAA0C,QAAgB,EAAE,gBAAwB;QAChF,MAAM,CAAC,mCAAmC,CAAC,2BAA2B,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC,CAAC;IACxG,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,6CAAoD,cAAqC;QACrF,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;YAC1C,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAA,kBAAkB,CAAC,CAAC;QAChF,CAAC;IACL,CAAC;IAJe,sCAAmC,sCAIlD,CAAA;IAED,0CAA0C,GAAW;QAKjD,IAAM,SAAS,GAAG,GAAG,CAAC,MAAM,CAAC;QAE7B,IAAI,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;QACnD,OAAO,UAAU,GAAG,SAAS,EAAE,CAAC;YAG5B,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC,OAAyB,CAAC,CAAC,CAAC;gBACtD,UAAU,EAAE,CAAC;YACjB,CAAC;YACD,IAAI,CAAC,CAAC;gBAEF,KAAK,CAAC;YACV,CAAC;QACL,CAAC;QAGD,EAAE,CAAC,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC,CAAC;YAC3B,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;QACjB,CAAC;QAGD,IAAM,gBAAgB,GAAG,GAAG,CAAC,OAAO,CAAC,GAAA,kBAAkB,EAAE,UAAU,CAAC,CAAC;QACrE,EAAE,CAAC,CAAC,gBAAgB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAG1B,UAAU,GAAG,gBAAgB,GAAG,CAAC,CAAC;YAClC,MAAM,CAAC,wBAAwB,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;QACrD,CAAC;QACD,IAAI,CAAC,CAAC;YAKF,MAAM,CAAC,CAAC,GAAG,GAAG,GAAA,kBAAkB,CAAC,CAAC;QACtC,CAAC;IACL,CAAC;IAED,0CAA0C,SAAiB,EAAE,gBAAwB;QACjF,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACnB,MAAM,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;QACvD,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,2BAA2B,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QACpE,CAAC;IACL,CAAC;IAED,yCAAgD,kBAA0B,EAAE,sBAA8B,EAAE,gBAAwB,EAAE,oBAAkD,EAAE,mBAA4B;QAClN,IAAM,cAAc,GAAG,gCAAgC,CAAC,sBAAsB,EAAE,gBAAgB,CAAC,CAAC;QAClG,IAAM,mBAAmB,GAAG,gCAAgC,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;QACnG,EAAE,CAAC,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,mBAAmB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAGhF,mBAAmB,CAAC,GAAG,EAAE,CAAC;QAC9B,CAAC;QAGD,IAAI,cAAsB,CAAC;QAC3B,GAAG,CAAC,CAAC,cAAc,GAAG,CAAC,EAAE,cAAc,GAAG,cAAc,CAAC,MAAM,IAAI,cAAc,GAAG,mBAAmB,CAAC,MAAM,EAAE,cAAc,EAAE,EAAE,CAAC;YAC/H,EAAE,CAAC,CAAC,oBAAoB,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC,KAAK,oBAAoB,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrH,KAAK,CAAC;YACV,CAAC;QACL,CAAC;QAGD,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;YACjB,IAAI,YAAY,GAAG,EAAE,CAAC;YACtB,IAAM,sBAAsB,GAAG,cAAc,CAAC,KAAK,CAAC,cAAc,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;YAC3F,GAAG,CAAC,CAAC,EAAE,cAAc,GAAG,mBAAmB,CAAC,MAAM,EAAE,cAAc,EAAE,EAAE,CAAC;gBACnE,EAAE,CAAC,CAAC,mBAAmB,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;oBAC7C,YAAY,GAAG,YAAY,GAAG,IAAI,GAAG,GAAA,kBAAkB,CAAC;gBAC5D,CAAC;YACL,CAAC;YAED,MAAM,CAAC,YAAY,GAAG,sBAAsB,CAAC,IAAI,CAAC,GAAA,kBAAkB,CAAC,CAAC;QAC1E,CAAC;QAGD,IAAI,YAAY,GAAG,mCAAmC,CAAC,cAAc,CAAC,CAAC;QACvE,EAAE,CAAC,CAAC,mBAAmB,IAAI,gBAAgB,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YACxD,YAAY,GAAG,UAAU,GAAG,YAAY,CAAC;QAC7C,CAAC;QAED,MAAM,CAAC,YAAY,CAAC;IACxB,CAAC;IArCe,kCAA+B,kCAqC9C,CAAA;IAED,yBAAgC,IAAY;QACxC,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,IAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,GAAA,kBAAkB,CAAC,CAAC;QAC/C,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAChD,CAAC;IANe,kBAAe,kBAM9B,CAAA;IAED,sBAA6B,KAAa,EAAE,KAAa;QACrD,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC3C,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC3C,EAAE,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC7C,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAA,kBAAkB,CAAC;YAAC,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;QAChF,MAAM,CAAC,KAAK,GAAG,GAAA,kBAAkB,GAAG,KAAK,CAAC;IAC9C,CAAC;IANe,eAAY,eAM3B,CAAA;IAQD,0CAAiD,IAAY;QACzD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAA,kBAAkB,CAAC,CAAC,CAAC;YACtD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC3C,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IANe,mCAAgC,mCAM/C,CAAA;IAMD,0CAAiD,IAAY;QACzD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAA,kBAAkB,CAAC,CAAC,CAAC;YACtD,MAAM,CAAC,IAAI,GAAG,GAAA,kBAAkB,CAAC;QACrC,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IANe,mCAAgC,mCAM/C,CAAA;IAED,sBAA6B,CAAS,EAAE,CAAS,EAAE,gBAAwB,EAAE,UAAoB;QAC7F,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,GAAoB;QACvC,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,IAAqB;QAChD,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;YAAC,MAAM,GAAwB;QACnD,CAAC,GAAG,gCAAgC,CAAC,CAAC,CAAC,CAAC;QACxC,CAAC,GAAG,gCAAgC,CAAC,CAAC,CAAC,CAAC;QACxC,IAAM,WAAW,GAAG,2BAA2B,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC;QACrE,IAAM,WAAW,GAAG,2BAA2B,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC;QACrE,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;QACtE,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,MAAM,GAAG,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,MAAM,MAAuB,CAAC,CAAC,CAAC;gBAChC,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;IACjE,CAAC;IAjBe,eAAY,eAiB3B,CAAA;IAED,sBAA6B,MAAc,EAAE,KAAa,EAAE,gBAAwB,EAAE,UAAoB;QACtG,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC9D,EAAE,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAClC,MAAM,GAAG,gCAAgC,CAAC,MAAM,CAAC,CAAC;QAClD,KAAK,GAAG,gCAAgC,CAAC,KAAK,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAClC,IAAM,gBAAgB,GAAG,2BAA2B,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QAC/E,IAAM,eAAe,GAAG,2BAA2B,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;QAC7E,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;YACnD,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/C,IAAM,MAAM,GAAG,cAAc,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;YACnF,EAAE,CAAC,CAAC,MAAM,MAAuB,CAAC,CAAC,CAAC;gBAChC,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IApBe,eAAY,eAoB3B,CAAA;IAED,oBAA2B,GAAW,EAAE,MAAc;QAClD,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAFe,aAAU,aAEzB,CAAA;IAED,sBAA6B,GAAW,EAAE,MAAc;QACpD,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IACrE,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,kBAAyB,GAAW,EAAE,MAAc;QAChD,IAAM,WAAW,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;QAC/C,MAAM,CAAC,WAAW,IAAI,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,KAAK,WAAW,CAAC;IAChF,CAAC;IAHe,WAAQ,WAGvB,CAAA;IAED,wBAA+B,GAAW,EAAE,SAAiB;QACzD,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACzC,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,sBAA6B,QAAgB;QACzC,MAAM,CAAC,cAAc,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC;IAC1D,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,yBAAgC,IAAY,EAAE,SAAiB;QAC3D,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,QAAQ,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACvE,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,8BAAqC,IAAY,EAAE,UAAiC;QAChF,GAAG,CAAC,CAAoB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU;YAA7B,IAAM,SAAS,mBAAA;YAChB,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;gBACnC,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;SACJ;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,uBAAoB,uBAQnC,CAAA;IAKD,IAAM,wBAAwB,GAAG,YAAY,CAAC;IAC9C,IAAM,iBAAiB,GAAG,QAAkD,CAAC;IAEhE,uBAAoB,GAA0B,CAAC,cAAc,EAAE,kBAAkB,EAAE,eAAe,CAAC,CAAC;IAEjH,IAAM,+BAA+B,GAAG,SAAO,GAAA,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,YAAS,CAAC;IAQvF,IAAM,YAAY,GAAoB;QAOlC,2BAA2B,EAAE,8BAA8B;QAK3D,2BAA2B,EAAE,OAAK,+BAA+B,kBAAe;QAChF,wBAAwB,EAAE,UAAA,KAAK,IAAI,OAAA,wBAAwB,CAAC,KAAK,EAAE,YAAY,CAAC,2BAA2B,CAAC,EAAzE,CAAyE;KAC/G,CAAC;IAEF,IAAM,kBAAkB,GAAoB;QACxC,2BAA2B,EAAE,OAAO;QAKpC,2BAA2B,EAAE,OAAK,+BAA+B,kBAAe;QAChF,wBAAwB,EAAE,UAAA,KAAK,IAAI,OAAA,wBAAwB,CAAC,KAAK,EAAE,kBAAkB,CAAC,2BAA2B,CAAC,EAA/E,CAA+E;KACrH,CAAC;IAEF,IAAM,cAAc,GAAoB;QACpC,2BAA2B,EAAE,OAAO;QACpC,2BAA2B,EAAE,SAAS;QACtC,wBAAwB,EAAE,UAAA,KAAK,IAAI,OAAA,wBAAwB,CAAC,KAAK,EAAE,cAAc,CAAC,2BAA2B,CAAC,EAA3E,CAA2E;KACjH,CAAC;IAEF,IAAM,gBAAgB,GAAG;QACrB,KAAK,EAAE,YAAY;QACnB,WAAW,EAAE,kBAAkB;QAC/B,OAAO,EAAE,cAAc;QACvB,GAAG,EAAE,YAAY;QACjB,GAAG,EAAE,kBAAkB;QACvB,EAAE,EAAE,YAAY;KACnB,CAAC;IAEF,yCAAgD,KAA4B,EAAE,QAAgB,EAAE,KAAiE;QAC7J,IAAM,QAAQ,GAAG,iCAAiC,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC3E,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAED,IAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,MAAI,OAAO,MAAG,EAAd,CAAc,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAElE,IAAM,UAAU,GAAG,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,CAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC;QAC1E,MAAM,CAAC,OAAK,OAAO,SAAI,UAAY,CAAC;IACxC,CAAC;IAVe,kCAA+B,kCAU9C,CAAA;IAED,2CAA2C,KAA4B,EAAE,QAAgB,EAAE,KAAiE;QACxJ,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5C,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAED,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,UAAA,IAAI;YACtB,OAAA,IAAI,IAAI,qBAAqB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAA7E,CAA6E,CAAC,CAAC;IACvF,CAAC;IAMD,wBAA+B,iBAAyB;QACpD,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAC5C,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,+BAA+B,IAAY,EAAE,QAAgB,EAAE,KAAiE,EAAE,EAAuG;YAArG,4DAA2B,EAAE,4DAA2B,EAAE,sDAAwB;QAClN,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,IAAI,6BAA6B,GAAG,KAAK,CAAC;QAC1C,IAAI,mBAAmB,GAAG,KAAK,CAAC;QAChC,IAAM,UAAU,GAAG,2BAA2B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC/D,IAAM,aAAa,GAAG,eAAe,CAAC,UAAU,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,IAAG,KAAK,KAAK,IAAI,IAAK,aAAa,KAAK,IAAI,CAAC,CAAC,CAAC;YAClE,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAID,UAAU,CAAC,CAAC,CAAC,GAAG,gCAAgC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAEhE,EAAE,CAAC,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;YAChC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAC/B,CAAC;QAED,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,GAAG,CAAC,CAAkB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU;YAA3B,IAAI,SAAS,mBAAA;YACd,EAAE,CAAC,CAAC,SAAS,KAAK,IAAI,CAAC,CAAC,CAAC;gBACrB,EAAE,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC;oBAChC,MAAM,CAAC,SAAS,CAAC;gBACrB,CAAC;gBAED,UAAU,IAAI,2BAA2B,CAAC;gBAC1C,6BAA6B,GAAG,IAAI,CAAC;YACzC,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,EAAE,CAAC,CAAC,KAAK,KAAK,aAAa,IAAI,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC;oBAC7C,UAAU,IAAI,GAAG,CAAC;oBAClB,aAAa,EAAE,CAAC;gBACpB,CAAC;gBAED,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;oBACtB,UAAU,IAAI,GAAA,kBAAkB,CAAC;gBACrC,CAAC;gBAED,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,IAAG,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;oBACvC,IAAI,gBAAgB,GAAG,EAAE,CAAC;oBAI1B,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,OAA4B,CAAC,CAAC,CAAC;wBACtD,gBAAgB,IAAI,QAAQ,GAAG,2BAA2B,GAAG,IAAI,CAAC;wBAClE,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACpC,CAAC;oBACD,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,OAA4B,CAAC,CAAC,CAAC;wBAC3D,gBAAgB,IAAI,OAAO,CAAC;wBAC5B,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACpC,CAAC;oBAED,gBAAgB,IAAI,SAAS,CAAC,OAAO,CAAC,wBAAwB,EAAE,wBAAwB,CAAC,CAAC;oBAQ1F,EAAE,CAAC,CAAC,gBAAgB,KAAK,SAAS,CAAC,CAAC,CAAC;wBACjC,UAAU,IAAI,+BAA+B,CAAC;oBAClD,CAAC;oBAED,UAAU,IAAI,gBAAgB,CAAC;gBACnC,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,UAAU,IAAI,SAAS,CAAC,OAAO,CAAC,wBAAwB,EAAE,wBAAwB,CAAC,CAAC;gBACxF,CAAC;YACL,CAAC;YAED,mBAAmB,GAAG,IAAI,CAAC;SAC9B;QAED,OAAO,aAAa,GAAG,CAAC,EAAE,CAAC;YACvB,UAAU,IAAI,IAAI,CAAC;YACnB,aAAa,EAAE,CAAC;QACpB,CAAC;QAED,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAED,kCAAkC,KAAa,EAAE,2BAAmC;QAChF,MAAM,CAAC,KAAK,KAAK,GAAG,CAAC,CAAC,CAAC,2BAA2B,CAAC,CAAC,CAAC,KAAK,KAAK,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC;IAC/F,CAAC;IAiBD,gCAAuC,IAAY,EAAE,QAA+B,EAAE,QAA+B,EAAE,yBAAkC,EAAE,gBAAwB;QAC/K,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QAC3B,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC,CAAC;QACnD,IAAM,YAAY,GAAG,YAAY,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;QAE1D,MAAM,CAAC;YACH,mBAAmB,EAAE,GAAG,CAAC,iCAAiC,CAAC,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC,EAAE,UAAA,OAAO,IAAI,OAAA,MAAI,OAAO,MAAG,EAAd,CAAc,CAAC;YACvH,kBAAkB,EAAE,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC,IAAI,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,CAAC;YACtJ,uBAAuB,EAAE,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,aAAa,CAAC,IAAI,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,CAAC;YACjK,cAAc,EAAE,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,SAAS,CAAC,IAAI,+BAA+B,CAAC,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC;YACnJ,SAAS,EAAE,YAAY,CAAC,IAAI,EAAE,QAAQ,EAAE,yBAAyB,CAAC;SACrE,CAAC;IACN,CAAC;IAZe,yBAAsB,yBAYrC,CAAA;IAED,oBAA2B,IAAY,EAAE,UAAiC,EAAE,QAA+B,EAAE,QAA+B,EAAE,yBAAkC,EAAE,gBAAwB,EAAE,KAAyB,EAAE,oBAAyD;QAC5R,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QAC3B,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC,CAAC;QAEnD,IAAM,QAAQ,GAAG,sBAAsB,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,yBAAyB,EAAE,gBAAgB,CAAC,CAAC;QAE/G,IAAM,SAAS,GAAG,yBAAyB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;QACvD,IAAM,kBAAkB,GAAG,QAAQ,CAAC,mBAAmB,IAAI,QAAQ,CAAC,mBAAmB,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,IAAI,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,EAA9B,CAA8B,CAAC,CAAC;QACvI,IAAM,qBAAqB,GAAG,QAAQ,CAAC,uBAAuB,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,uBAAuB,EAAE,SAAS,CAAC,CAAC;QAC1H,IAAM,YAAY,GAAG,QAAQ,CAAC,cAAc,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;QAI/F,IAAM,OAAO,GAAe,kBAAkB,CAAC,CAAC,CAAC,kBAAkB,CAAC,GAAG,CAAC,cAAM,OAAA,EAAE,EAAF,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAEzF,IAAM,QAAQ,GAAG,yBAAyB,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,6BAA6B,CAAC;QAC5F,GAAG,CAAC,CAAmB,UAAkB,EAAlB,KAAA,QAAQ,CAAC,SAAS,EAAlB,cAAkB,EAAlB,IAAkB;YAApC,IAAM,QAAQ,SAAA;YACf,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC,gBAAgB,EAAE,QAAQ,CAAC,EAAE,KAAK,CAAC,CAAC;SAC7E;QAED,MAAM,CAAC,OAAO,CAAS,OAAO,CAAC,CAAC;QAEhC,wBAAwB,IAAY,EAAE,YAAoB,EAAE,KAAyB;YAC7E,IAAA,+BAAmD,EAAjD,gBAAK,EAAE,4BAAW,CAAgC;YACxD,KAAK,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oCAE1B,OAAO;gBACd,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBACzC,IAAM,YAAY,GAAG,YAAY,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACzD,EAAE,CAAC,CAAC,UAAU,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;sCAAU;gBACpE,EAAE,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;sCAAU;gBAC9D,EAAE,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;oBACtB,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC1B,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,IAAM,YAAY,GAAG,SAAS,CAAC,kBAAkB,EAAE,UAAA,EAAE,IAAI,OAAA,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,EAArB,CAAqB,CAAC,CAAC;oBAChF,EAAE,CAAC,CAAC,YAAY,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtB,OAAO,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACrC,CAAC;gBACL,CAAC;YACL,CAAC;YAdD,GAAG,CAAC,CAAkB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;gBAAtB,IAAM,OAAO,cAAA;wBAAP,OAAO;aAcjB;YAED,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;gBACtB,KAAK,EAAE,CAAC;gBACR,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;oBACd,MAAM,CAAC;gBACX,CAAC;YACL,CAAC;YAED,WAAW,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACjD,GAAG,CAAC,CAAkB,UAAW,EAAX,2BAAW,EAAX,yBAAW,EAAX,IAAW;gBAA5B,IAAM,OAAO,oBAAA;gBACd,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBACzC,IAAM,YAAY,GAAG,YAAY,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACzD,EAAE,CAAC,CAAC,CAAC,CAAC,qBAAqB,IAAI,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;oBACpE,CAAC,CAAC,YAAY,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtD,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;gBAC9C,CAAC;aACJ;QACL,CAAC;IACL,CAAC;IA3De,aAAU,aA2DzB,CAAA;IAKD,sBAAsB,IAAY,EAAE,QAA+B,EAAE,yBAAkC;QAEnG,IAAM,SAAS,GAAa,CAAC,IAAI,CAAC,CAAC;QAEnC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEX,IAAM,gBAAgB,GAAa,EAAE,CAAC;YACtC,GAAG,CAAC,CAAkB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;gBAAzB,IAAM,OAAO,iBAAA;gBAGd,IAAM,QAAQ,GAAW,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,aAAa,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;gBAE1G,gBAAgB,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC;aACvD;YAGD,gBAAgB,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,6BAA6B,CAAC,CAAC;oCAIvF,eAAe;gBACtB,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,SAAS,EAAE,UAAA,QAAQ,IAAI,OAAA,CAAC,YAAY,CAAC,QAAQ,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,yBAAyB,CAAC,EAA1E,CAA0E,CAAC,CAAC,CAAC,CAAC;oBAC9G,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;gBACpC,CAAC;YACL,CAAC;YAJD,GAAG,CAAC,CAA0B,UAAgB,EAAhB,qCAAgB,EAAhB,8BAAgB,EAAhB,IAAgB;gBAAzC,IAAM,eAAe,yBAAA;wBAAf,eAAe;aAIzB;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAED,4BAA4B,QAAgB;QACxC,IAAM,cAAc,GAAG,kBAAkB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;QACvE,EAAE,CAAC,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;YAErB,MAAM,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC;gBAC1B,CAAC,CAAC,QAAQ;gBACV,CAAC,CAAC,gCAAgC,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC;QACvE,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,WAAW,CAAC,GAAA,kBAAkB,EAAE,cAAc,CAAC,CAAC,CAAC;IAC3F,CAAC;IAED,0BAAiC,QAAgB,EAAE,UAAkC;QAOjF,MAAM,CAAC,UAAU,IAAI,yBAAyB,CAAC,QAAQ,CAAC,KAAiB,CAAC;IAC9E,CAAC;IARe,mBAAgB,mBAQ/B,CAAA;IAED,mCAA0C,QAAgB;QACtD,IAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;QACvD,MAAM,CAAC,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;YACxB;gBACI,MAAM,GAAe;YACzB;gBACI,MAAM,GAAgB;YAC1B;gBACI,MAAM,GAAe;YACzB;gBACI,MAAM,GAAgB;YAC1B;gBACI,MAAM,GAAgB;YAC1B;gBACI,MAAM,GAAiB;YAC3B;gBACI,MAAM,GAAiB;YAC3B;gBACI,MAAM,GAAoB;QAClC,CAAC;IACL,CAAC;IApBe,4BAAyB,4BAoBxC,CAAA;IAKY,gCAA6B,GAA6B,mDAA2F,CAAC;IAEtJ,mDAAgD,GAA6B,mDAA2F,CAAC;IACzK,gCAA6B,GAA6B,eAA6B,CAAC;IACrG,IAAM,sBAAsB,GAAiC,GAAA,6BAA6B,QAAK,GAAA,6BAA6B,CAAC,CAAC;IAE9H,gCAAuC,OAAyB,EAAE,mBAAwD;QACtH,IAAM,iBAAiB,GAAG,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC;QACrD,EAAE,CAAC,CAAC,CAAC,mBAAmB,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACjF,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,GAAA,6BAA6B,CAAC;QACtF,CAAC;QACD,MAAM,CAAC,WAAW,CAAK,sBAAsB,QAAK,mBAAmB,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,SAAS,EAAX,CAAW,CAAC,EAAE,CAAC;IAClG,CAAC;IANe,yBAAsB,yBAMrC,CAAA;IAED,oCAA2C,QAAgB;QACvD,MAAM,CAAC,OAAO,CAAC,GAAA,6BAA6B,EAAE,UAAA,SAAS,IAAI,OAAA,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,EAApC,CAAoC,CAAC,CAAC;IACrG,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,oCAA2C,QAAgB;QACvD,MAAM,CAAC,OAAO,CAAC,GAAA,6BAA6B,EAAE,UAAA,SAAS,IAAI,OAAA,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,EAApC,CAAoC,CAAC,CAAC;IACrG,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,mCAA0C,QAAgB,EAAE,eAAiC,EAAE,mBAAwD;QACnJ,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAAC,CAAC;QAEhC,GAAG,CAAC,CAAoB,UAA4D,EAA5D,KAAA,sBAAsB,CAAC,eAAe,EAAE,mBAAmB,CAAC,EAA5D,cAA4D,EAA5D,IAA4D;YAA/E,IAAM,SAAS,SAAA;YAChB,EAAE,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;SACJ;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IATe,4BAAyB,4BASxC,CAAA;IAOD,IAAkB,iBAMjB;IAND,WAAkB,iBAAiB;QAC/B,+EAAmB,CAAA;QACnB,2GAAiC,CAAA;QAEjC,+DAAyB,CAAA;QACzB,6DAAsC,CAAA;IAC1C,CAAC,EANiB,iBAAiB,GAAjB,oBAAiB,KAAjB,oBAAiB,QAMlC;IAED,8BAAqC,IAAY,EAAE,mBAA0C;QACzF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACvD,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChD,MAAM,CAAC,uBAAuB,CAAoB,CAAC,EAAE,mBAAmB,CAAC,CAAC;YAC9E,CAAC;QACL,CAAC;QAID,MAAM,GAA2B;IACrC,CAAC;IAVe,uBAAoB,uBAUnC,CAAA;IAKD,iCAAwC,iBAAoC,EAAE,mBAA0C;QACpH,EAAE,CAAC,CAAC,iBAAiB,IAAkD,CAAC,CAAC,CAAC;YACtE,MAAM,GAAmC;QAC7C,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,iBAAiB,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC;YACtD,MAAM,GAAiD;QAC3D,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC;QACtC,CAAC;IACL,CAAC;IAVe,0BAAuB,0BAUtC,CAAA;IAKD,wCAA+C,iBAAoC,EAAE,mBAA0C;QAC3H,EAAE,CAAC,CAAC,iBAAiB,IAAkD,CAAC,CAAC,CAAC;YACtE,MAAM,GAAiD;QAC3D,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC;QACtC,CAAC;IACL,CAAC;IAPe,iCAA8B,iCAO7C,CAAA;IAED,IAAM,kBAAkB,GAAG,kEAAuH,CAAC;IACnJ,6BAAoC,IAAY;QAC5C,GAAG,CAAC,CAAc,UAAkB,EAAlB,yCAAkB,EAAlB,gCAAkB,EAAlB,IAAkB;YAA/B,IAAM,GAAG,2BAAA;YACV,IAAM,aAAa,GAAG,kBAAkB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,aAAa,CAAC;YACzB,CAAC;SACJ;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IARe,sBAAmB,sBAQlC,CAAA;IAED,4BAAmC,IAAY,EAAE,SAAiB;QAC9D,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAC3F,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,yBAAgC,IAAY,EAAE,SAAiB;QAC3D,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;IAC7D,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,yBAAyD,IAAO,EAAE,YAAoB;QAClF,MAAM,CAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,CAAC;IACzD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAcD,gBAA8B,KAAkB,EAAE,IAAc;QAC5D,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;IAClC,CAAC;IAED,YAAsB,EAAQ,EAAE,EAAY;QACxC,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;IACjB,CAAC;IAED,cAA0B,OAAoB,EAAE,KAAgB;QAC5D,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,EAAE,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAC3B,CAAC;IACL,CAAC;IAED;IACA,CAAC;IAED,cAA0B,IAAgB,EAAE,GAAW,EAAE,GAAW;QAChE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,KAAK,IAAiB,CAAC;QAC5B,IAAI,CAAC,kBAAkB,IAAqB,CAAC;QAC7C,IAAI,CAAC,cAAc,IAAsB,CAAC;QAC1C,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;IAC9B,CAAC;IAED,yBAAgD,QAAgB,EAAE,IAAY,EAAE,UAAoC;QAChH,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,EAAH,CAAG,CAAC,CAAC;IACjD,CAAC;IAEU,kBAAe,GAAoB;QAC1C,kBAAkB,EAAE,cAAM,OAAK,IAAI,EAAT,CAAS;QACnC,mBAAmB,EAAE,cAAM,OAAK,IAAI,EAAT,CAAS;QACpC,wBAAwB,EAAE,cAAM,OAAK,IAAI,EAAT,CAAS;QACzC,wBAAwB,EAAE,cAAM,OAAK,IAAI,EAAT,CAAS;QACzC,oBAAoB,EAAE,cAAM,OAAK,MAAM,EAAX,CAAW;QACvC,kBAAkB,EAAE,cAAM,OAAK,IAAI,EAAT,CAAS;QACnC,uBAAuB,EAAE,cAAM,OAAK,SAAS,EAAd,CAAc;QAC7C,SAAS,EAAE,cAAM,OAAK,EAAE,EAAP,CAAO;QACxB,6BAA6B,EAAE,cAAM,OAAK,eAAe,EAApB,CAAoB;KAC5D,CAAC;IAEF,IAAkB,cAKjB;IALD,WAAkB,cAAc;QAC5B,mDAAQ,CAAA;QACR,uDAAU,CAAA;QACV,+DAAc,CAAA;QACd,uEAAkB,CAAA;IACtB,CAAC,EALiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QAK/B;IAED,IAAiB,KAAK,CAoErB;IApED,WAAiB,KAAK;QACP,2BAAqB,IAAsB,CAAC;QAC5C,iBAAW,GAAG,KAAK,CAAC;QAE/B,sBAA6B,KAAqB;YAC9C,MAAM,CAAC,MAAA,qBAAqB,IAAI,KAAK,CAAC;QAC1C,CAAC;QAFe,kBAAY,eAE3B,CAAA;QAED,gBAAuB,UAAmB,EAAE,OAAgB,EAAE,gBAA0C,EAAE,cAAyB;YAC/H,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;gBACd,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;oBACnB,OAAO,IAAI,iCAAiC,GAAG,CAAC,OAAO,gBAAgB,KAAK,QAAQ,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC,CAAC;gBAClI,CAAC;gBACD,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,GAAG,OAAO,CAAC,CAAC,CAAC,mBAAmB,EAAE,cAAc,IAAI,MAAM,CAAC,CAAC;YACnG,CAAC;QACL,CAAC;QAPe,YAAM,SAOrB,CAAA;QAED,qBAA+B,CAAI,EAAE,CAAI,EAAE,GAAY,EAAE,IAAa;YAClE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACV,IAAM,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAI,GAAG,SAAI,IAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;gBACzD,IAAI,CAAC,cAAY,CAAC,aAAQ,CAAC,UAAK,OAAS,CAAC,CAAC;YAC/C,CAAC;QACL,CAAC;QALe,iBAAW,cAK1B,CAAA;QAED,wBAA+B,CAAS,EAAE,CAAS,EAAE,GAAY;YAC7D,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACT,IAAI,CAAC,cAAY,CAAC,WAAM,CAAC,WAAK,GAAG,IAAI,EAAE,CAAE,CAAC,CAAC;YAC/C,CAAC;QACL,CAAC;QAJe,oBAAc,iBAI7B,CAAA;QAED,+BAAsC,CAAS,EAAE,CAAS;YACtD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACR,IAAI,CAAC,cAAY,CAAC,YAAO,CAAG,CAAC,CAAC;YAClC,CAAC;QACL,CAAC;QAJe,2BAAqB,wBAIpC,CAAA;QAED,kCAAyC,CAAS,EAAE,CAAS;YACzD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACR,IAAI,CAAC,cAAY,CAAC,YAAO,CAAG,CAAC,CAAC;YAClC,CAAC;QACL,CAAC;QAJe,8BAAwB,2BAIvC,CAAA;QAED,cAAqB,OAAgB,EAAE,cAAyB;YAC5D,QAAQ,CAAC;YACT,IAAM,CAAC,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAkB,OAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;YAC9E,EAAE,CAAC,CAAO,KAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBAC3B,KAAM,CAAC,iBAAiB,CAAC,CAAC,EAAE,cAAc,IAAI,IAAI,CAAC,CAAC;YAC9D,CAAC;YACD,MAAM,CAAC,CAAC;QACZ,CAAC;QAPe,UAAI,OAOnB,CAAA;QAED,qBAA4B,MAAa,EAAE,OAAgB,EAAE,cAAyB;YAClF,MAAM,CAAC,IAAI,CAAC,OAAO,IAAI,oBAAkB,MAAQ,EAAE,cAAc,IAAI,WAAW,CAAC,CAAC;QACtF,CAAC;QAFe,iBAAW,cAE1B,CAAA;QAED,yBAAgC,IAAc;YAC1C,EAAE,CAAC,CAAC,OAAO,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC;gBAC7B,MAAM,CAAC,EAAE,CAAC;YACd,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBACnC,MAAM,CAAO,IAAK,CAAC,IAAI,CAAC;YAC5B,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,IAAM,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACpD,IAAM,KAAK,GAAG,4BAA4B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACtD,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACjC,CAAC;QACL,CAAC;QAZe,qBAAe,kBAY9B,CAAA;IACL,CAAC,EApEgB,KAAK,GAAL,QAAK,KAAL,QAAK,QAoErB;IAGD,2BAAqC,KAAU,EAAE,IAAO;QACpD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;gBACpB,mBAAmB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,oBAAiB,oBAQhC,CAAA;IAGD,6BAAuC,KAAU,EAAE,KAAa;QAE5D,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5C,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,CAAC;QACD,KAAK,CAAC,GAAG,EAAE,CAAC;IAChB,CAAC;IANe,sBAAmB,sBAMlC,CAAA;IAED,+BAAyC,KAAU,EAAE,KAAa;QAE9D,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvC,KAAK,CAAC,GAAG,EAAE,CAAC;IAChB,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAGD,6BAAuC,KAAU,EAAE,IAAO;QACtD,6BAA6B,CAAC,KAAK,EAAE,UAAA,OAAO,IAAI,OAAA,OAAO,KAAK,IAAI,EAAhB,CAAgB,CAAC,CAAC;IACtE,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAGD,uCAA0C,KAAU,EAAE,SAAkC;QACpF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,EAAE,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,qBAAqB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBAChC,KAAK,CAAC;YACV,CAAC;QACL,CAAC;IACL,CAAC;IAED,oCAA2C,yBAAkC;QACzE,MAAM,CAAC,yBAAyB;YAC5B,CAAC,CAAC,CAAC,UAAC,QAAQ,IAAK,OAAA,QAAQ,EAAR,CAAQ,CAAC;YAC1B,CAAC,CAAC,CAAC,UAAC,QAAQ,IAAK,OAAA,QAAQ,CAAC,WAAW,EAAE,EAAtB,CAAsB,CAAC,CAAC;IACjD,CAAC;IAJe,6BAA0B,6BAIzC,CAAA;IAOD,6BAAoC,cAAqC,EAAE,SAAiB;QACxF,IAAM,QAAQ,GAAc,EAAE,CAAC;QAC/B,GAAG,CAAC,CAAwB,UAAc,EAAd,iCAAc,EAAd,4BAAc,EAAd,IAAc;YAArC,IAAM,aAAa,uBAAA;YACpB,IAAM,OAAO,GAAG,eAAe,CAAC,aAAa,CAAC,CAAC;YAC/C,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACV,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;gBAEnC,MAAM,CAAC,aAAa,CAAC;YACzB,CAAC;SACJ;QAED,MAAM,CAAC,oBAAoB,CAAC,QAAQ,EAAE,UAAA,CAAC,IAAI,OAAA,CAAC,EAAD,CAAC,EAAE,SAAS,CAAC,CAAC;IAC7D,CAAC;IAde,sBAAmB,sBAclC,CAAA;IAED,qBAA4B,EAAyB;YAAxB,kBAAM,EAAE,kBAAM;QACvC,MAAM,CAAI,MAAM,SAAI,MAAQ,CAAC;IACjC,CAAC;IAFe,cAAW,cAE1B,CAAA;IAMD,qBAA4B,OAAgB,EAAE,SAAiB;QAC3D,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;QACjD,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC7F,CAAC;IAHe,cAAW,cAG1B,CAAA;IAGD,8BAAwC,MAAwB,EAAE,UAAiC,EAAE,SAAiB;QAClH,IAAI,YAAY,GAAkB,SAAS,CAAC;QAE5C,IAAI,wBAAwB,GAAG,CAAC,CAAC,CAAC;QAElC,GAAG,CAAC,CAAY,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM;YAAjB,IAAM,CAAC,eAAA;YACR,IAAM,OAAO,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9B,EAAE,CAAC,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,GAAG,wBAAwB,CAAC,CAAC,CAAC;gBACzF,wBAAwB,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC;gBACjD,YAAY,GAAG,CAAC,CAAC;YACrB,CAAC;SACJ;QAED,MAAM,CAAC,YAAY,CAAC;IACxB,CAAC;IAde,uBAAoB,uBAcnC,CAAA;IAED,wBAAwB,EAAyB,EAAE,SAAiB;YAA3C,kBAAM,EAAE,kBAAM;QACnC,MAAM,CAAC,SAAS,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM;YACpD,UAAU,CAAC,SAAS,EAAE,MAAM,CAAC;YAC7B,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;IACpC,CAAC;IAED,yBAAgC,OAAe;QAE3C,KAAK,CAAC,MAAM,CAAC,6BAA6B,CAAC,OAAO,CAAC,CAAC,CAAC;QACrD,IAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACzC,MAAM,CAAC,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACpC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,WAAW,CAAC;YACtC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC;SAC1C,CAAC;IACN,CAAC;IARe,kBAAe,kBAQ9B,CAAA;IAED,+BAAsC,GAAW;QAG7C,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACvB,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAGD,+BAAsC,GAAc;QAChD,MAAM,CAAC,GAAG,UAAiB,IAAI,GAAG,WAAkB,IAAI,GAAG,WAAkB,IAAI,GAAG,YAAmB,IAAI,GAAG,YAAkB,IAAG,GAAG,aAAmB,CAAC;IAC9J,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAMD,2BAAkC,IAAY;QAC1C,IAAM,GAAG,GAAG,uBAAuB,CAAC,IAAI,CAAC,CAAC;QAC1C,EAAE,CAAC,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,GAAG,CAAC;QACf,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,UAAQ,IAAI,4BAAyB,CAAC,CAAC;IACtD,CAAC;IANe,oBAAiB,oBAMhC,CAAA;IAED,qCAA4C,IAAY;QACpD,MAAM,CAAC,uBAAuB,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;IACvD,CAAC;IAFe,8BAA2B,8BAE1C,CAAA;IAED,iCAAwC,IAAY;QAChD,MAAM,CAAC,IAAI,CAAY,GAAA,gDAAgD,EAAE,UAAA,CAAC,IAAI,OAAA,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,EAAxB,CAAwB,CAAC,IAAI,IAAI,CAAC,GAAA,6BAA6B,EAAE,UAAA,CAAC,IAAI,OAAA,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,EAAxB,CAAwB,CAAC,CAAC;IAClL,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAID,iCAAwC,IAAY;QAChD,IAAM,YAAY,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAM,cAAc,GAAG,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACrD,EAAE,CAAC,CAAC,cAAc,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;QAClD,CAAC;IACL,CAAC;IANe,0BAAuB,0BAMtC,CAAA;IAED,iCAAwC,UAAsB,EAAE,eAAgC;QAC5F,MAAM,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC,UAAU,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe,CAAC,OAAO,CAAC;IACvG,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,aAAuB,CAAsB,EAAE,CAAsB;QACjE,MAAM,CAAC,UAAC,GAAM,IAAK,OAAA,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,EAAhB,CAAgB,CAAC;IACxC,CAAC;IAFe,MAAG,MAElB,CAAA;IAED,2BAAkC,CAAQ,IAAU,CAAC;IAArC,oBAAiB,oBAAoB,CAAA;IAmBrD,4CAAmD,IAA4B;QAC3E,IAAM,yBAAyB,GAAG,SAAS,EAA4B,CAAC;QACxE,IAAM,mBAAmB,GAAG,OAAO,CAAC,cAAM,OAAA,IAAI,CAAC,mBAAmB,EAAE,EAA1B,CAA0B,CAAC,CAAC;QACtE,IAAM,oBAAoB,GAAG,0BAA0B,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC;QACxF,MAAM,CAAC;YACH,yBAAyB,EAAE,IAAI,CAAC,yBAAyB;YACzD,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,QAAQ,EAAE,UAAC,IAAI,EAAE,QAAQ,IAAK,OAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,EAA7B,CAA6B;YAC3D,KAAK,EAAE,UAAA,CAAC,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAb,CAAa;YACzB,SAAS,WAAA;YACT,UAAU,YAAA;YACV,eAAe,iBAAA;YACf,eAAe,iBAAA;YACf,mBAAmB,qBAAA;YACnB,cAAc,gBAAA;YACd,aAAa,eAAA;YACb,0BAA0B,4BAAA;YAC1B,eAAe,iBAAA;YACf,UAAU,YAAA;YACV,IAAI,EAAE,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAf,CAAe;SAChC,CAAC;QAEF,gBAAgB,QAAgB;YAC5B,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,mBAAmB,EAAE,EAAE,oBAAoB,CAAC,CAAC;QAC5E,CAAC;QAED,oCAAoC,WAAiB;YACjD,MAAM,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACtD,CAAC;QAED,8CAA8C,IAAU;YACpD,MAAM,CAAC,0BAA0B,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,+BAA+B,QAAgB;YAC3C,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,uCAAuC,OAAe,EAAE,WAAiB;YACrE,IAAM,cAAc,GAA6B;gBAC7C,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,EAAiB,SAAS,EAAc,SAAS,EAAa,CAAC,KAAK,CAAC,CAAC,EAAE,qBAAqB,CAAC,IAAI,EAAE;gBACzI,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE;aAClD,CAAC;YAEF,yBAAyB,CAAC,GAAG,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;YAC3D,MAAM,CAAC,cAAc,CAAC;QAC1B,CAAC;QAOD,0BAA0B,OAAe,EAAE,WAAiB;YACxD,IAAM,YAAY,GAAG,0BAA0B,CAAC,WAAW,CAAC,CAAC;YAC7D,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,YAAY,CAAC;YACxB,CAAC;YAED,IAAI,CAAC;gBACD,MAAM,CAAC,6BAA6B,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAC/D,CAAC;YACD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAER,KAAK,CAAC,MAAM,CAAC,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;gBAC1D,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;QACL,CAAC;QAED,uBAAuB,KAAa,EAAE,KAAa;YAC/C,MAAM,CAAC,oBAAoB,CAAC,KAAK,CAAC,KAAK,oBAAoB,CAAC,KAAK,CAAC,CAAC;QACvE,CAAC;QAED,kBAAkB,OAA8B,EAAE,IAAY;YAC1D,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,UAAA,IAAI,IAAI,OAAA,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;QAC5D,CAAC;QAED,+BAA+B,OAAiB,EAAE,QAAgB,EAAE,OAAgB;YAChF,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9B,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;oBACX,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,UAAA,KAAK,IAAI,OAAA,CAAC,aAAa,CAAC,KAAK,EAAE,QAAQ,CAAC,EAA/B,CAA+B,CAAC,CAAC;gBAC3E,CAAC;YACL,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC;QACL,CAAC;QAED,mBAAmB,QAAgB,EAAE,IAAY,EAAE,kBAA4B;YAC3E,IAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC9B,IAAM,MAAM,GAAG,oCAAoC,CAAC,IAAI,CAAC,CAAC;YAC1D,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,4BAA4B,CAAC,MAAM,EAAE,qBAAqB,CAAC,QAAQ,CAAC,EAAiB,IAAI,CAAC,CAAC;YAC/F,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC;QAC9D,CAAC;QAED,oBAAoB,QAAgB;YAChC,IAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC9B,IAAM,MAAM,GAAG,oCAAoC,CAAC,IAAI,CAAC,CAAC;YAC1D,MAAM,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,qBAAqB,CAAC,QAAQ,CAAC,CAAC;gBACpE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QAClC,CAAC;QAED,yBAAyB,OAAe;YACpC,IAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YAC7B,MAAM,CAAC,yBAAyB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QAChF,CAAC;QAED,yBAAyB,OAAe;YACpC,IAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YAC7B,IAAM,MAAM,GAAG,oCAAoC,CAAC,IAAI,CAAC,CAAC;YAC1D,IAAM,YAAY,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,qBAAqB,CAAC,MAAM,CAAC,WAAW,EAAE,YAAY,EAAc,IAAI,CAAC,CAAC;YAC9E,CAAC;YACD,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC;QAED,wBAAwB,OAAe;YACnC,IAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YACpC,IAAM,MAAM,GAAG,gBAAgB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACtD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;YACtC,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACxC,CAAC;QAED,uBAAuB,OAAe,EAAE,UAAkC,EAAE,QAAgC,EAAE,QAAgC,EAAE,KAAc;YAC1J,IAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YACpC,IAAM,MAAM,GAAG,gBAAgB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACtD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,UAAU,CAAC,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,yBAAyB,EAAE,mBAAmB,EAAE,EAAE,KAAK,EAAE,oBAAoB,CAAC,CAAC;YACnJ,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;YAE1E,8BAA8B,GAAW;gBACrC,IAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBACzB,EAAE,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC,CAAC;oBACvB,MAAM,CAAC,MAAM,CAAC;gBAClB,CAAC;gBACD,MAAM,CAAC,0BAA0B,CAAC,IAAI,CAAC,IAAI,6BAA6B,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACxF,CAAC;QACL,CAAC;QAED,oCAAoC,eAAuB,EAAE,mBAAyB;YAClF,IAAM,cAAc,GAAG,0BAA0B,CAAC,mBAAmB,CAAC,CAAC;YACvE,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;gBAEjB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;oBACzC,yBAAyB,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;gBAC1D,CAAC;YACL,CAAC;YACD,IAAI,CAAC,CAAC;gBAGF,IAAM,YAAY,GAAG,oCAAoC,CAAC,mBAAmB,CAAC,CAAC;gBAC/E,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBACf,IAAM,QAAQ,GAAG,qBAAqB,CAAC,eAAe,CAAC,CAAC;oBACxD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;wBACf,IAAM,aAAa,GAA8B;4BAC7C,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC;4BAChD,eAAe,EAAE,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC;yBAC7D,CAAC;wBACF,4BAA4B,CAAC,YAAY,EAAE,QAAQ,EAAE,aAAa,CAAC,UAAU,CAAC,CAAC;wBAC/E,qBAAqB,CAAC,YAAY,CAAC,WAAW,EAAE,QAAQ,EAAE,aAAa,CAAC,eAAe,CAAC,CAAC;wBACzF,MAAM,CAAC,aAAa,CAAC;oBACzB,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QAED,yBAAyB,QAAgB,EAAE,QAAc,EAAE,SAA+B;YACtF,EAAE,CAAC,CAAC,SAAS,KAAK,GAAA,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC7C,MAAM,CAAC;YACX,CAAC;YAED,IAAM,YAAY,GAAG,oCAAoC,CAAC,QAAQ,CAAC,CAAC;YACpE,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACf,4BAA4B,CAAC,YAAY,EAAE,qBAAqB,CAAC,QAAQ,CAAC,EAAE,SAAS,KAAK,GAAA,oBAAoB,CAAC,OAAO,CAAC,CAAC;YAC5H,CAAC;QACL,CAAC;QAED,sCAAsC,YAAsC,EAAE,QAAgB,EAAE,UAAmB;YAC/G,qBAAqB,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;QACpE,CAAC;QAED;YACI,yBAAyB,CAAC,KAAK,EAAE,CAAC;QACtC,CAAC;IACL,CAAC;IA9Le,qCAAkC,qCA8LjD,CAAA;AACL,CAAC,EAl2FS,EAAE,KAAF,EAAE,QAk2FX;ACl3FD,IAAU,EAAE,CAkmBX;AAlmBD,WAAU,EAAE;IAOR;QACI,EAAE,CAAC,CAAE,KAAa,CAAC,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;YACtC,KAAa,CAAC,eAAe,GAAG,GAAG,CAAC;QACzC,CAAC;IACL,CAAC;IAJe,qBAAkB,qBAIjC,CAAA;IAED,IAAY,oBAIX;IAJD,WAAY,oBAAoB;QAC5B,qEAAO,CAAA;QACP,qEAAO,CAAA;QACP,qEAAO,CAAA;IACX,CAAC,EAJW,oBAAoB,GAApB,uBAAoB,KAApB,uBAAoB,QAI/B;IAmED;QACI,EAAE,CAAC,CAAC,OAAO,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC;YACjC,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,IAAM,OAAO,GAAW,OAAO,CAAC,OAAO,CAAC;QACxC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,IAAM,GAAG,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC;IAbe,sBAAmB,sBAalC,CAAA;IAwBU,MAAG,GAAW,CAAC;QACtB;YACI,IAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;YAC9B,IAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;YAElC,IAAM,qBAAqB,GAAG,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC;YAEjE;gBACI,IAAM,WAAW,GAAG,GAAA,SAAS,EAAoB,CAAC;gBAElD,IAAM,oBAAoB,GAAG,GAAA,cAAc,EAAuB,CAAC;gBACnE,MAAM,CAAC,EAAE,OAAO,SAAA,EAAE,UAAU,YAAA,EAAE,CAAC;gBAE/B,yCAAyC,QAAgB;oBACrD,IAAM,OAAO,GAAG,GAAA,gBAAgB,CAAC,QAAQ,CAAC,CAAC;oBAC3C,IAAM,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBACzC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACV,OAAO,CAAC,cAAc,IAAI,CAAC,CAAC;wBAC5B,EAAE,CAAC,CAAC,OAAO,CAAC,cAAc,IAAI,CAAC,CAAC,CAAC,CAAC;4BAC9B,OAAO,CAAC,KAAK,EAAE,CAAC;4BAChB,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;wBAChC,CAAC;oBACL,CAAC;gBACL,CAAC;gBAED,uBAAuB,OAAe;oBAClC,IAAI,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBACvC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACV,OAAO,CAAC,cAAc,IAAI,CAAC,CAAC;wBAC5B,MAAM,CAAC;oBACX,CAAC;oBACD,OAAO,GAAG,gBAAgB,CACtB,OAAO,IAAI,GAAG,EACd,UAAC,SAAiB,EAAE,gBAAwB,IAAK,OAAA,gBAAgB,CAAC,SAAS,EAAE,gBAAgB,EAAE,OAAO,CAAC,EAAtD,CAAsD,CACtF,CAAC;oBACtB,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC;oBAC3B,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;oBAClC,MAAM,CAAC;gBACX,CAAC;gBAED,gCAAgC,QAAgB,EAAE,QAA6B;oBAC3E,oBAAoB,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBACjD,CAAC;gBAED,iBAAiB,QAAgB,EAAE,QAA6B;oBAC5D,sBAAsB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;oBAC3C,aAAa,CAAC,GAAA,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAE1C,MAAM,CAAC,EAAE,QAAQ,UAAA,EAAE,QAAQ,UAAA,EAAE,CAAC;gBAClC,CAAC;gBAED,oBAAoB,WAAwB;oBACxC,yBAAyB,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;oBACtE,+BAA+B,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC1D,CAAC;gBAED,mCAAmC,QAAgB,EAAE,QAA6B;oBAC9E,oBAAoB,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBACpD,CAAC;gBAED,0BAA0B,SAAiB,EAAE,gBAAoC,EAAE,WAAmB;oBAElG,IAAM,QAAQ,GAAG,CAAC,GAAA,QAAQ,CAAC,gBAAgB,CAAC;wBACxC,CAAC,CAAC,SAAS;wBACX,CAAC,CAAC,EAAE,CAAC,yBAAyB,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;oBAElE,EAAE,CAAC,CAAC,CAAC,SAAS,KAAK,QAAQ,IAAI,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACrD,IAAM,SAAS,GAAG,oBAAoB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;wBACrD,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;4BACZ,GAAG,CAAC,CAAuB,UAAS,EAAT,uBAAS,EAAT,uBAAS,EAAT,IAAS;gCAA/B,IAAM,YAAY,kBAAA;gCACnB,YAAY,CAAC,QAAQ,EAAE,oBAAoB,CAAC,OAAO,CAAC,CAAC;6BACxD;wBACL,CAAC;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YACD,IAAM,cAAc,GAAG,oBAAoB,EAAE,CAAC;YAE9C,IAAM,WAAW,GAAG,mBAAmB,EAAE,CAAC;YAC1C,IAAM,cAAc,GAAG,WAAW,IAAI,CAAC,CAAC;YAExC;gBAEI,EAAE,CAAC,CAAC,QAAQ,KAAK,OAAO,IAAI,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;gBAED,MAAM,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;YAC7C,CAAC;YAGD,kBAAkB,CAAS;gBACvB,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,UAAC,EAAE;oBACvB,IAAM,EAAE,GAAG,EAAE,CAAC,WAAW,EAAE,CAAC;oBAC5B,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7C,CAAC,CAAC,CAAC;YACP,CAAC;YAED,IAAM,QAAQ,GAAW,GAAG,CAAC,QAAQ,EAAE,CAAC;YACxC,IAAM,yBAAyB,GAAG,yBAAyB,EAAE,CAAC;YAE9D,qBAAqB,QAAgB,EAAE,QAA6B,EAAE,eAAwB;gBAC1F,GAAG,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,eAAe,IAAI,GAAG,EAAE,EAAE,WAAW,CAAC,CAAC;gBAC7F,MAAM,CAAC;oBACH,KAAK,EAAE,cAAM,OAAA,GAAG,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAtC,CAAsC;iBACtD,CAAC;gBAEF,qBAAqB,IAAS,EAAE,IAAS;oBACrC,IAAM,UAAU,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC;oBACrC,IAAM,UAAU,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC;oBACrC,IAAM,OAAO,GAAG,CAAC,UAAU,IAAI,UAAU,CAAC;oBAC1C,IAAM,OAAO,GAAG,UAAU,IAAI,CAAC,UAAU,CAAC;oBAE1C,IAAM,SAAS,GAAG,OAAO;wBACrB,CAAC,CAAC,oBAAoB,CAAC,OAAO;wBAC9B,CAAC,CAAC,OAAO;4BACL,CAAC,CAAC,oBAAoB,CAAC,OAAO;4BAC9B,CAAC,CAAC,oBAAoB,CAAC,OAAO,CAAC;oBAEvC,EAAE,CAAC,CAAC,SAAS,KAAK,oBAAoB,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;wBAC3E,MAAM,CAAC;oBACX,CAAC;oBAED,QAAQ,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBAClC,CAAC;YACL,CAAC;YAED,0BAA0B,aAAqB,EAAE,QAA+D,EAAE,SAAmB;gBACjI,IAAI,OAAY,CAAC;gBAEjB,IAAI,OAAO,GAAG,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC;oBAC3C,qBAAqB,EAAE,CAAC,CAAC;oBACzB,qBAAqB,EAAE,CAAC;gBAC5B,MAAM,CAAC;oBACH,KAAK,EAAE;wBAEH,OAAO,CAAC,KAAK,EAAE,CAAC;oBACpB,CAAC;iBACJ,CAAC;gBAMF;oBAGI,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC;wBACxB,EAAE,CAAC,CAAC,cAAc,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC;4BACpF,OAAO,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,SAAS,EAAE,CAAC;wBAC3D,CAAC;wBACD,IAAI,CAAC,CAAC;4BACF,OAAO,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;wBACnC,CAAC;oBACL,CAAC;oBAED,IAAM,UAAU,GAAG,GAAG,CAAC,KAAK,CACxB,aAAa,EACb,OAAO,EACP,QAAQ,CACX,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE;wBACnB,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;4BAElC,OAAO,GAAG,qBAAqB,EAAE,CAAC;4BAElC,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;wBAC3B,CAAC;oBACL,CAAC,CAAC,CAAC;oBACH,MAAM,CAAC,UAAU,CAAC;gBACtB,CAAC;gBAMD;oBACI,MAAM,CAAC,WAAW,CAAC,aAAa,EAAE,UAAC,SAAS,EAAE,SAAS;wBACnD,EAAE,CAAC,CAAC,SAAS,KAAK,oBAAoB,CAAC,OAAO,IAAI,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;4BAC/E,OAAO,CAAC,KAAK,EAAE,CAAC;4BAChB,OAAO,GAAG,qBAAqB,EAAE,CAAC;4BAIlC,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;wBAC3B,CAAC;oBACL,CAAC,CAAC,CAAC;gBACP,CAAC;YACL,CAAC;YAED,kBAAkB,QAAgB,EAAE,SAAkB;gBAClD,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACxB,MAAM,CAAC,SAAS,CAAC;gBACrB,CAAC;gBACD,IAAM,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;gBAC1C,IAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;gBACxB,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;oBAGvD,GAAG,IAAI,CAAC,CAAC,CAAC;oBACV,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;wBAC9B,IAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;wBACvB,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBAC1B,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;oBACzB,CAAC;oBACD,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;gBACzC,CAAC;gBACD,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;oBAEvD,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;gBACzC,CAAC;gBACD,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;oBAE7E,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBACtC,CAAC;gBAED,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACnC,CAAC;YAED,mBAAmB,QAAgB,EAAE,IAAY,EAAE,kBAA4B;gBAE3E,EAAE,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;oBACrB,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC;gBAC3B,CAAC;gBAED,IAAI,EAAU,CAAC;gBAEf,IAAI,CAAC;oBACD,EAAE,GAAG,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;oBACjC,GAAG,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,EAAe,SAAS,EAAE,MAAM,CAAC,CAAC;gBAC5D,CAAC;wBACO,CAAC;oBACL,EAAE,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC,CAAC;wBACnB,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;oBACtB,CAAC;gBACL,CAAC;YACL,CAAC;YAED,wCAAwC,IAAY;gBAChD,IAAI,CAAC;oBACD,IAAM,OAAO,GAAG,GAAG,CAAC,WAAW,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;oBACpD,IAAM,KAAK,GAAa,EAAE,CAAC;oBAC3B,IAAM,WAAW,GAAa,EAAE,CAAC;oBACjC,GAAG,CAAC,CAAgB,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;wBAAtB,IAAM,KAAK,gBAAA;wBAGZ,EAAE,CAAC,CAAC,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;4BAClC,QAAQ,CAAC;wBACb,CAAC;wBACD,IAAM,IAAI,GAAG,GAAA,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;wBAEvC,IAAI,IAAI,SAAK,CAAC;wBACd,IAAI,CAAC;4BACD,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;wBAC9B,CAAC;wBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BACP,QAAQ,CAAC;wBACb,CAAC;wBAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;4BAChB,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACtB,CAAC;wBACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;4BAC1B,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBAC5B,CAAC;qBACJ;oBACD,MAAM,CAAC,EAAE,KAAK,OAAA,EAAE,WAAW,aAAA,EAAE,CAAC;gBAClC,CAAC;gBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACP,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC;gBAC1C,CAAC;YACL,CAAC;YAED,uBAAuB,IAAY,EAAE,UAAkC,EAAE,QAAgC,EAAE,QAAgC,EAAE,KAAc;gBACvJ,MAAM,CAAC,GAAA,UAAU,CAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,yBAAyB,EAAE,OAAO,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,8BAA8B,CAAC,CAAC;YAC7I,CAAC;YAED,IAAW,mBAGV;YAHD,WAAW,mBAAmB;gBAC1B,6DAAI,CAAA;gBACJ,uEAAS,CAAA;YACb,CAAC,EAHU,mBAAmB,KAAnB,mBAAmB,QAG7B;YAED,+BAA+B,IAAY,EAAE,SAA8B;gBACvE,IAAI,CAAC;oBACD,IAAM,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;oBAChC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;wBAChB,QAA+B,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;wBACpD,QAAoC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;oBAClE,CAAC;gBACL,CAAC;gBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACP,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;YACL,CAAC;YAED,oBAAoB,IAAY;gBAC5B,MAAM,CAAC,qBAAqB,CAAC,IAAI,IAA2B,CAAC;YACjE,CAAC;YAED,yBAAyB,IAAY;gBACjC,MAAM,CAAC,qBAAqB,CAAC,IAAI,IAAgC,CAAC;YACtE,CAAC;YAED,wBAAwB,IAAY;gBAChC,MAAM,CAAC,GAAA,MAAM,CAAS,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,UAAA,GAAG,IAAI,OAAA,qBAAqB,CAAC,GAAA,YAAY,CAAC,IAAI,EAAE,GAAG,CAAC,IAAgC,EAA7E,CAA6E,CAAC,CAAC;YACvI,CAAC;YAED,IAAM,UAAU,GAAW;gBACvB,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC3B,OAAO,EAAE,GAAG,CAAC,GAAG;gBAChB,yBAAyB,2BAAA;gBACzB,KAAK,EAAL,UAAM,CAAS;oBACX,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC5B,CAAC;gBACD,QAAQ,UAAA;gBACR,SAAS,WAAA;gBACT,SAAS,EAAE,UAAC,QAAQ,EAAE,QAAQ,EAAE,eAAe;oBAC3C,EAAE,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC;wBACxB,IAAM,aAAW,GAAG,cAAc,CAAC,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;wBAC/D,MAAM,CAAC;4BACH,KAAK,EAAE,cAAM,OAAA,cAAc,CAAC,UAAU,CAAC,aAAW,CAAC,EAAtC,CAAsC;yBACtD,CAAC;oBACN,CAAC;oBACD,IAAI,CAAC,CAAC;wBACF,MAAM,CAAC,WAAW,CAAC,QAAQ,EAAE,QAAQ,EAAE,eAAe,CAAC,CAAC;oBAC5D,CAAC;gBACL,CAAC;gBACD,cAAc,EAAE,UAAC,aAAa,EAAE,QAAQ,EAAE,SAAS;oBAG/C,MAAM,CAAC,gBAAgB,CAAC,aAAa,EAAE,UAAC,SAAS,EAAE,gBAAgB;wBAI/D,EAAE,CAAC,CAAC,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC;4BAEzB,QAAQ,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,GAAA,aAAa,CAAC,GAAA,YAAY,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC;wBAClH,CAAC;oBACL,CAAC,EAAE,SAAS,CAAC,CAAC;gBAClB,CAAC;gBACD,WAAW,EAAE,UAAA,IAAI,IAAI,OAAA,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAnB,CAAmB;gBACxC,UAAU,YAAA;gBACV,eAAe,iBAAA;gBACf,eAAe,YAAC,aAAqB;oBACjC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;wBAC7C,GAAG,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;oBACjC,CAAC;gBACL,CAAC;gBACD,oBAAoB;oBAChB,MAAM,CAAC,UAAU,CAAC;gBACtB,CAAC;gBACD,mBAAmB;oBACf,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;gBACzB,CAAC;gBACD,cAAc,gBAAA;gBACd,sBAAsB,YAAC,IAAY;oBAC/B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACnC,CAAC;gBACD,aAAa,eAAA;gBACb,eAAe,YAAC,IAAI;oBAChB,IAAI,CAAC;wBACD,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;oBACpC,CAAC;oBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACP,MAAM,CAAC,SAAS,CAAC;oBACrB,CAAC;gBACL,CAAC;gBACD,UAAU,YAAC,IAAI;oBACX,IAAM,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;oBACvC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAClB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC9B,CAAC;gBACD,cAAc;oBACV,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;wBACZ,MAAM,CAAC,EAAE,EAAE,CAAC;oBAChB,CAAC;oBACD,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC;gBAC1C,CAAC;gBACD,WAAW,YAAC,IAAI;oBACZ,IAAI,CAAC;wBACD,IAAM,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;wBAChC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;4BAChB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;wBACrB,CAAC;oBACL,CAAC;oBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACb,MAAM,CAAC,CAAC,CAAC;gBACb,CAAC;gBACD,IAAI,EAAJ,UAAK,QAAiB;oBAClB,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3B,CAAC;gBACD,QAAQ,EAAR,UAAS,IAAY;oBACjB,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBAClC,CAAC;gBACD,SAAS,EAAE,GAAA,IAAI,CAAW,OAAO,CAAC,QAAQ,EAAE,UAAA,GAAG,IAAI,OAAA,oCAAoC,CAAC,IAAI,CAAC,GAAG,CAAC,EAA9C,CAA8C,CAAC;gBAClG,0BAA0B;oBACtB,IAAI,CAAC;wBACD,OAAO,CAAC,oBAAoB,CAAC,CAAC,OAAO,EAAE,CAAC;oBAC5C,CAAC;oBACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAEX,CAAC;gBACL,CAAC;gBACD,UAAU,YAAA;gBACV,YAAY,cAAA;aACf,CAAC;YACF,MAAM,CAAC,UAAU,CAAC;QACtB,CAAC;QAED;YACI,IAAM,QAAQ,GAAG,UAAU,CAAC,QAAQ,IAAI,CAAC,UAAC,IAAY,IAAK,OAAA,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;YACtF,MAAM,CAAC;gBACH,OAAO,EAAE,UAAU,CAAC,OAAO,IAAI,MAAM;gBACrC,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,yBAAyB,EAAE,CAAC,CAAC,UAAU,CAAC,yBAAyB;gBACjE,KAAK,EAAE,UAAU,CAAC,IAAI;gBACtB,QAAQ,YAAC,IAAY,EAAE,SAAkB;oBAErC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACrC,CAAC;gBACD,SAAS,YAAC,IAAY,EAAE,IAAY,EAAE,kBAA4B;oBAE9D,EAAE,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;wBACrB,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC;oBAC3B,CAAC;oBAED,UAAU,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBACrC,CAAC;gBACD,WAAW,EAAE,UAAU,CAAC,WAAW;gBACnC,UAAU,EAAE,UAAU,CAAC,UAAU;gBACjC,eAAe,EAAE,UAAU,CAAC,eAAe;gBAC3C,eAAe,EAAE,UAAU,CAAC,eAAe;gBAC3C,oBAAoB,EAAE,cAAM,OAAA,UAAU,CAAC,aAAa,EAAxB,CAAwB;gBACpD,mBAAmB,EAAE,cAAM,OAAA,UAAU,CAAC,gBAAgB,EAA3B,CAA2B;gBACtD,cAAc,EAAE,UAAU,CAAC,cAAc;gBACzC,sBAAsB,EAAE,UAAU,CAAC,sBAAsB,IAAI,CAAC,cAAM,OAAA,EAAE,EAAF,CAAE,CAAC;gBACvE,aAAa,YAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM;oBACtD,IAAM,OAAO,GAAG,GAAA,sBAAsB,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC,UAAU,CAAC,yBAAyB,EAAE,UAAU,CAAC,gBAAgB,CAAC,CAAC;oBACtI,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,cAAc,EAAE,OAAO,CAAC,kBAAkB,EAAE,OAAO,CAAC,uBAAuB,CAAC,CAAC;gBAC9J,CAAC;gBACD,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,QAAQ,UAAA;aACX,CAAC;QACN,CAAC;QAED,kCAAkC,aAAqB,EAAE,GAAW;YAChE,IAAM,QAAQ,GAAG,GAAA,gBAAgB,CAAC,aAAa,CAAC,CAAC;YACjD,IAAM,kBAAkB,GAAG,QAAQ,KAAK,EAAE,IAAI,aAAa,KAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC3G,EAAE,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;gBACrB,wBAAwB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAC5C,CAAC;YACD,EAAE,CAAC,CAAC,kBAAkB,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC5D,GAAG,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;YACvC,CAAC;QACL,CAAC;QAED,IAAI,GAAW,CAAC;QAChB,EAAE,CAAC,CAAC,OAAO,UAAU,KAAK,WAAW,CAAC,CAAC,CAAC;YACpC,GAAG,GAAG,eAAe,EAAE,CAAC;QAC5B,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO,CAAC,QAAQ,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC;YAGhH,GAAG,GAAG,aAAa,EAAE,CAAC;QAC1B,CAAC;QACD,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAEN,IAAM,mBAAiB,GAAG,GAAG,CAAC,SAAS,CAAC;YACxC,GAAG,CAAC,SAAS,GAAG,UAAS,IAAI,EAAE,IAAI,EAAE,QAAQ;gBACzC,IAAM,aAAa,GAAG,GAAA,gBAAgB,CAAC,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/D,EAAE,CAAC,CAAC,aAAa,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;oBACvD,wBAAwB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;gBACjD,CAAC;gBACD,mBAAiB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;YACtD,CAAC,CAAC;QACN,CAAC;QACD,MAAM,CAAC,GAAG,CAAC;IACf,CAAC,CAAC,EAAE,CAAC;IAEL,EAAE,CAAC,CAAC,GAAA,GAAG,IAAI,GAAA,GAAG,CAAC,sBAAsB,CAAC,CAAC,CAAC;QACpC,GAAA,KAAK,CAAC,qBAAqB,GAAG,gBAAgB,CAAC,IAAI,CAAC,GAAA,GAAG,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;YACvF,CAAC;YACD,CAAC,EAAoB,CAAC;IAC9B,CAAC;IACD,EAAE,CAAC,CAAC,GAAA,GAAG,IAAI,GAAA,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;QACvB,GAAA,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;IAC7B,CAAC;AACL,CAAC,EAlmBS,EAAE,KAAF,EAAE,QAkmBX;ACpmBD,IAAU,EAAE,CA27BX;AA37BD,WAAU,EAAE;IACR,cAAc,IAAY,EAAE,QAA4B,EAAE,GAAW,EAAE,OAAe;QAClF,MAAM,CAAC,EAAE,IAAI,MAAA,EAAE,QAAQ,UAAA,EAAE,GAAG,KAAA,EAAE,OAAO,SAAA,EAAE,CAAC;IAC5C,CAAC;IACY,cAAW,GAAG;QACvB,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kCAAkC,EAAE,8BAA8B,CAAC;QACrI,mBAAmB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0BAA0B,EAAE,sBAAsB,CAAC;QAC7G,WAAW,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kBAAkB,EAAE,iBAAiB,CAAC;QACxF,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,2CAA2C,CAAC;QAC5K,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,6BAA6B,CAAC;QAClI,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,gBAAgB,CAAC;QAC/G,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uBAAuB,EAAE,mBAAmB,CAAC;QACpG,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,oDAAoD,CAAC;QACvM,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,sDAAsD,CAAC;QAC7M,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACjM,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,qEAAqE,CAAC;QAC1P,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,0DAA0D,CAAC;QACzN,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,iDAAiD,CAAC;QAC9L,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,iEAAiE,CAAC;QACtO,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,mFAAmF,CAAC;QAChS,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,sCAAsC,CAAC;QAC7J,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,6CAA6C,CAAC;QACpK,wBAAwB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+BAA+B,EAAE,8BAA8B,CAAC;QAC/H,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,kDAAkD,CAAC;QAC3L,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,gEAAgE,CAAC;QACvO,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,iDAAiD,CAAC;QAC9L,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,oEAAoE,CAAC;QACnP,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,sDAAsD,CAAC;QACvM,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,yDAAyD,CAAC;QAChN,+BAA+B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sCAAsC,EAAE,qCAAqC,CAAC;QACpJ,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,kDAAkD,CAAC;QAC3L,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,gEAAgE,CAAC;QACrO,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,gEAAgE,CAAC;QACnO,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,+EAA+E,CAAC;QAClR,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,sCAAsC,CAAC;QAC7J,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,8CAA8C,CAAC;QACrL,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,mDAAmD,CAAC;QAChM,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,qDAAqD,CAAC;QACtM,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,wDAAwD,CAAC;QAC/M,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,8CAA8C,CAAC;QACjL,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,0CAA0C,CAAC;QACrK,oIAAoI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sIAAsI,CAAC;QAC/Z,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,sEAAsE,CAAC;QAC7P,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,sEAAsE,CAAC;QAC7P,8GAA8G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mHAAmH,CAAC;QACtX,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,sCAAsC,CAAC;QACzJ,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,2EAA2E,CAAC;QACxQ,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,4FAA4F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mGAAmG,EAAE,iGAAiG,CAAC;QAC1U,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,oFAAoF,CAAC;QACrS,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,8EAA8E,CAAC;QACrR,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,8EAA8E,CAAC;QAC7Q,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,gDAAgD,CAAC;QACrL,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,qDAAqD,CAAC;QACpM,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,6DAA6D,CAAC;QAC1N,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,uCAAuC,CAAC;QAC5J,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,gGAAgG,CAAC;QACjU,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,4DAA4D,CAAC;QACzN,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,8CAA8C,CAAC;QAC/K,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,6DAA6D,CAAC;QAClO,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,6DAA6D,CAAC;QAClO,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,0CAA0C,CAAC;QACzK,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,wDAAwD,CAAC;QAC/M,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,6BAA6B,CAAC;QAC5H,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,sCAAsC,CAAC;QAC7J,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,qCAAqC,CAAC;QAC1J,+BAA+B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sCAAsC,EAAE,sCAAsC,CAAC;QACrJ,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,mDAAmD,CAAC;QAChM,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,4DAA4D,CAAC;QAC3N,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,yFAAyF,CAAC;QAClT,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,kFAAkF,CAAC;QAC7R,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,yFAAyF,CAAC;QAClT,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QAClL,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,+DAA+D,CAAC;QACpO,mBAAmB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0BAA0B,EAAE,sBAAsB,CAAC;QAC7G,aAAa,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oBAAoB,EAAE,gBAAgB,CAAC;QAC3F,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,iBAAiB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wBAAwB,EAAE,wBAAwB,CAAC;QAC3G,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,sFAAsF,CAAC;QACzS,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,yEAAyE,CAAC;QAClQ,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,sFAAsF,CAAC;QAC7S,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,8EAA8E,CAAC;QAC/R,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,yEAAyE,CAAC;QACtQ,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QAClL,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,gDAAgD,CAAC;QAC3L,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,cAAc,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qBAAqB,EAAE,iBAAiB,CAAC;QAC9F,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,6BAA6B,CAAC;QAClI,sBAAsB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6BAA6B,EAAE,yBAAyB,CAAC;QACtH,iBAAiB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wBAAwB,EAAE,oBAAoB,CAAC;QACvG,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yBAAyB,EAAE,qBAAqB,CAAC;QAC1G,wBAAwB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+BAA+B,EAAE,+BAA+B,CAAC;QAChI,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAC9I,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2BAA2B,EAAE,uBAAuB,CAAC;QAChH,6BAA6B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,gCAAgC,CAAC;QAC3I,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QACxI,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QACxI,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QACxI,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAC9I,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,sCAAsC,CAAC;QAC7J,sBAAsB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6BAA6B,EAAE,yBAAyB,CAAC;QACtH,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,0BAA0B,CAAC;QACzH,6BAA6B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,gCAAgC,CAAC;QAC3I,WAAW,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kBAAkB,EAAE,sBAAsB,CAAC;QAC7F,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2BAA2B,EAAE,uBAAuB,CAAC;QAChH,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,+DAA+D,CAAC;QACxO,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,iFAAiF,CAAC;QAC9Q,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,+EAA+E,CAAC;QACxQ,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,4EAA4E,CAAC;QAC3P,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,2CAA2C,CAAC;QACxK,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,2DAA2D,CAAC;QACxN,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,yDAAyD,CAAC;QAClN,6BAA6B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,gCAAgC,CAAC;QAC3I,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,0CAA0C,CAAC;QACzK,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,+CAA+C,CAAC;QACxL,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,2DAA2D,CAAC;QACxN,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,uFAAuF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8FAA8F,EAAE,0FAA0F,CAAC;QACzT,iGAAiG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wGAAwG,EAAE,oGAAoG,CAAC;QACvV,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,yFAAyF,CAAC;QACtT,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,oFAAoF,CAAC;QACvS,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,sFAAsF,CAAC;QAC7S,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,gEAAgE,CAAC;QAC3O,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kCAAkC,EAAE,gCAAgC,CAAC;QACvI,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,oDAAoD,CAAC;QAC/L,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,yCAAyC,CAAC;QACtK,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,mCAAmC,CAAC;QAChJ,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,wDAAwD,CAAC;QAC/M,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4BAA4B,EAAE,wBAAwB,CAAC;QACnH,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2BAA2B,EAAE,uBAAuB,CAAC;QAChH,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gCAAgC,EAAE,iCAAiC,CAAC;QACpI,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,0CAA0C,CAAC;QACzK,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,+CAA+C,CAAC;QACxL,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QACxI,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,mEAAmE,CAAC;QACpP,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,gFAAgF,CAAC;QACnR,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,gFAAgF,CAAC;QACnR,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,8CAA8C,CAAC;QACrL,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,qCAAqC,CAAC;QAClJ,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,8CAA8C,CAAC;QACrL,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,sDAAsD,CAAC;QAC7M,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,8EAA8E,CAAC;QACrR,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,uCAAuC,CAAC;QAChK,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QAClL,qLAAqL,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,yMAAyM,CAAC;QACnhB,iIAAiI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,uIAAuI,CAAC;QAC7Z,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,wEAAwE,CAAC;QAC3P,6BAA6B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,gCAAgC,CAAC;QAC3I,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,8EAA8E,CAAC;QAC/R,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,oFAAoF,CAAC;QAC/R,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,2EAA2E,CAAC;QAClQ,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,sEAAsE,CAAC;QACzP,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,+DAA+D,CAAC;QAC9N,0GAA0G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mHAAmH,CAAC;QAClX,gGAAgG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uGAAuG,EAAE,yGAAyG,CAAC;QAC1V,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,iEAAiE,CAAC;QACpO,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,2GAA2G,CAAC;QAClW,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,sEAAsE,CAAC;QACjP,2JAA2J,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,iKAAiK,CAAC;QACjd,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,yEAAyE,CAAC;QACtQ,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,0DAA0D,CAAC;QACzN,wBAAwB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+BAA+B,EAAE,8BAA8B,CAAC;QAC/H,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,8BAA8B,CAAC;QAC7H,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,kDAAkD,CAAC;QACjL,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,iEAAiE,CAAC;QAC9N,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yFAAyF,EAAE,qFAAqF,CAAC;QAC1S,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,uEAAuE,CAAC;QACxP,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,oDAAoD,CAAC;QACvM,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACjP,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,2EAA2E,CAAC;QAC5Q,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,mEAAmE,CAAC;QACpP,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,kFAAkF,CAAC;QACzR,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,mFAAmF,CAAC;QAC5R,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,8EAA8E,CAAC;QACrR,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,kFAAkF,CAAC;QACjS,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,iFAAiF,CAAC;QAC9R,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,+EAA+E,CAAC;QACxR,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,kFAAkF,CAAC;QACzR,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,oDAAoD,CAAC;QACzL,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,4DAA4D,CAAC;QAC/N,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,2EAA2E,CAAC;QACpQ,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,+CAA+C,CAAC;QAChL,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,yEAAyE,CAAC;QACpQ,4FAA4F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mGAAmG,EAAE,mGAAmG,CAAC;QAC5U,+IAA+I,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,uJAAuJ,CAAC;QAC3b,qIAAqI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6IAA6I,CAAC;QACva,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,kEAAkE,CAAC;QAC3O,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,kFAAkF,CAAC;QAC7R,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,+DAA+D,CAAC;QACpO,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,8DAA8D,CAAC;QACjO,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,uFAAuF,CAAC;QACxS,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,8DAA8D,CAAC;QACjO,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,wDAAwD,CAAC;QACnN,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,6DAA6D,CAAC;QAClO,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,iEAAiE,CAAC;QAC9O,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACjP,+FAA+F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sGAAsG,EAAE,sGAAsG,CAAC;QACrV,qHAAqH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,4HAA4H,CAAC;QACtY,+HAA+H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8HAA8H,CAAC;QAClZ,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,uEAAuE,CAAC;QAChQ,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,wDAAwD,CAAC;QACnN,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,2CAA2C,CAAC;QAC9K,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QAClL,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,uHAAuH,CAAC;QACrX,qGAAqG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mHAAmH,CAAC;QAC7W,sBAAsB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6BAA6B,EAAE,6BAA6B,CAAC;QAC1H,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,8GAA8G,CAAC;QACrW,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,wDAAwD,CAAC;QACnN,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,4CAA4C,CAAC;QACvK,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yBAAyB,EAAE,yBAAyB,CAAC;QAC9G,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,4CAA4C,CAAC;QAC/J,sBAAsB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6BAA6B,EAAE,6BAA6B,CAAC;QAC1H,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2BAA2B,EAAE,2BAA2B,CAAC;QACpH,wGAAwG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kHAAkH,CAAC;QAC/W,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,+EAA+E,CAAC;QACxR,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,0DAA0D,CAAC;QACjN,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,wCAAwC,CAAC;QACnK,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,4DAA4D,CAAC;QAC/N,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,iDAAiD,CAAC;QACtL,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,mDAAmD,CAAC;QACtL,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4BAA4B,EAAE,4BAA4B,CAAC;QACvH,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,sDAAsD,CAAC;QACrM,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,oDAAoD,CAAC;QACzL,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gCAAgC,EAAE,gCAAgC,CAAC;QACnI,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,kEAAkE,CAAC;QACzN,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,qEAAqE,CAAC;QAClO,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,wDAAwD,CAAC;QACnM,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,6CAA6C,CAAC;QAClK,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,+BAA+B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sCAAsC,EAAE,0CAA0C,CAAC;QACzJ,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,gEAAgE,CAAC;QACnN,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,sEAAsE,CAAC;QACrO,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,uDAAuD,CAAC;QAChM,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,4DAA4D,CAAC;QAC3N,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,kDAAkD,CAAC;QAC7L,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,uDAAuD,CAAC;QAC5M,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,+DAA+D,CAAC;QACpO,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,oDAAoD,CAAC;QACnM,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,wDAAwD,CAAC;QAC/M,6FAA6F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oGAAoG,EAAE,gGAAgG,CAAC;QAC3U,8GAA8G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QACxX,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,8CAA8C,CAAC;QACrK,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,6FAA6F,CAAC;QAC9T,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,mEAAmE,CAAC;QACpO,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,sFAAsF,CAAC;QACvR,qFAAqF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4FAA4F,EAAE,qGAAqG,CAAC;QAChU,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,mDAAmD,CAAC;QACpL,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,sEAAsE,CAAC;QAC7O,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,8CAA8C,CAAC;QACrL,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,qEAAqE,CAAC;QAC5O,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8GAA8G,CAAC;QACzW,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,4DAA4D,CAAC;QAC3N,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,qFAAqF,CAAC;QACtS,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,+CAA+C,CAAC;QACxK,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,2FAA2F,CAAC;QAC1S,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,2EAA2E,CAAC;QACpQ,0EAA0E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iFAAiF,EAAE,iFAAiF,CAAC;QACtR,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,wEAAwE,CAAC;QACzP,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,4FAA4F,CAAC;QAC/T,qGAAqG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6GAA6G,CAAC;QACvW,0HAA0H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mIAAmI,CAAC;QAClZ,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yFAAyF,EAAE,kGAAkG,CAAC;QACvT,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qGAAqG,EAAE,sGAAsG,CAAC;QACnV,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,gGAAgG,CAAC;QACjU,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,iGAAiG,CAAC;QACpU,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,yFAAyF,CAAC;QACtT,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,4DAA4D,CAAC;QACvM,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,sFAAsF,CAAC;QACzS,+BAA+B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sCAAsC,EAAE,sCAAsC,CAAC;QACrJ,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,uEAAuE,CAAC;QAChQ,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,sFAAsF,CAAC;QAC7S,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,0DAA0D,CAAC;QACjN,0EAA0E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iFAAiF,EAAE,qFAAqF,CAAC;QAC1R,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uCAAuC,EAAE,mCAAmC,CAAC;QACpJ,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uCAAuC,EAAE,mCAAmC,CAAC;QACpJ,oIAAoI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,yIAAyI,CAAC;QACla,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,+DAA+D,CAAC;QACpO,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,uCAAuC,CAAC;QAC5J,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,yDAAyD,CAAC;QACtN,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,mDAAmD,CAAC;QAC5L,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,sEAAsE,CAAC;QAC7P,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,oFAAoF,CAAC;QACvS,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,yDAAyD,CAAC;QACtN,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,+DAA+D,CAAC;QACtO,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uCAAuC,EAAE,mCAAmC,CAAC;QACpJ,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,uCAAuC,CAAC;QAChK,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,6CAA6C,CAAC;QAC1K,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,wCAAwC,CAAC;QACnK,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,kFAAkF,CAAC;QACjS,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,oEAAoE,CAAC;QACvP,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,wFAAwF,CAAC;QAC3S,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,4FAA4F,CAAC;QACrT,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,mEAAmE,CAAC;QAC5O,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,uGAAuG,CAAC;QAC9U,6FAA6F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oGAAoG,EAAE,qGAAqG,CAAC;QAChV,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,wFAAwF,CAAC;QACrS,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,qFAAqF,CAAC;QACpS,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,2HAA2H,CAAC;QACzX,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,4EAA4E,CAAC;QACvQ,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,iFAAiF,CAAC;QAC9Q,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,uFAAuF,CAAC;QACxS,gGAAgG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uGAAuG,EAAE,0GAA0G,CAAC;QAC3V,6BAA6B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,gCAAgC,CAAC;QAC3I,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,4FAA4F,CAAC;QAC/T,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yFAAyF,EAAE,4FAA4F,CAAC;QACjT,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,4EAA4E,CAAC;QACvP,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,6EAA6E,CAAC;QAC1P,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,wEAAwE,CAAC;QACnP,sBAAsB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6BAA6B,EAAE,6BAA6B,CAAC;QAC1H,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,mDAAmD,CAAC;QACpL,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,2EAA2E,CAAC;QAC5P,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,qDAAqD,CAAC;QAC1L,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,wDAAwD,CAAC;QACnN,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sHAAsH,CAAC;QACjX,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sHAAsH,CAAC;QACjX,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sHAAsH,CAAC;QACjX,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sHAAsH,CAAC;QACjX,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,iCAAiC,CAAC;QACtI,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,gEAAgE,CAAC;QACnO,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,sDAAsD,CAAC;QAC7L,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4BAA4B,EAAE,4BAA4B,CAAC;QACvH,6GAA6G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,iHAAiH,CAAC;QACnX,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,yGAAyG,CAAC;QACpW,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qGAAqG,EAAE,iGAAiG,CAAC;QAC9U,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACjP,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,iEAAiE,CAAC;QAC9O,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,mEAAmE,CAAC;QAC5O,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,8BAA8B,CAAC;QAC7H,kHAAkH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QAC5X,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,+DAA+D,CAAC;QAChO,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,0FAA0F,CAAC;QACvS,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,+DAA+D,CAAC;QAChO,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,+EAA+E,CAAC;QAChQ,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,qEAAqE,CAAC;QAClO,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,wFAAwF,CAAC;QACnS,0EAA0E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iFAAiF,EAAE,qFAAqF,CAAC;QAC1R,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,oFAAoF,CAAC;QACrR,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,0DAA0D,CAAC;QACjN,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,0CAA0C,CAAC;QACjK,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,yCAAyC,CAAC;QAC9J,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,+CAA+C,CAAC;QAChL,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QAC/K,0HAA0H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kIAAkI,CAAC;QACjZ,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+CAA+C,EAAE,+CAA+C,CAAC;QAChL,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,8GAA8G,CAAC;QACrW,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,gDAAgD,CAAC;QACnL,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kCAAkC,EAAE,kCAAkC,CAAC;QACzI,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,sDAAsD,CAAC;QAC7M,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,iEAAiE,CAAC;QAC9N,wBAAwB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+BAA+B,EAAE,mCAAmC,CAAC;QACpI,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kCAAkC,EAAE,kCAAkC,CAAC;QACzI,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,yDAAyD,CAAC;QACtN,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,gFAAgF,CAAC;QAC3R,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,kFAAkF,CAAC;QAC3Q,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,0DAA0D,CAAC;QACrN,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,2DAA2D,CAAC;QACxN,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,sFAAsF,CAAC;QAC7S,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,iCAAiC,CAAC;QACtI,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,wDAAwD,CAAC;QACvM,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,4EAA4E,CAAC;QAC3Q,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,sEAAsE,CAAC;QACjP,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,gGAAgG,CAAC;QACvU,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,8EAA8E,CAAC;QACjR,yIAAyI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8IAA8I,CAAC;QAC5a,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACjP,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,sEAAsE,CAAC;QACzP,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,sDAAsD,CAAC;QACzL,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,6EAA6E,CAAC;QACtQ,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,oGAAoG,CAAC;QACvU,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,4EAA4E,CAAC;QACvQ,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,kEAAkE,CAAC;QACzO,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,uFAAuF,CAAC;QACxS,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,yEAAyE,CAAC;QAC1P,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,0CAA0C,CAAC;QACjK,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,uFAAuF,CAAC;QACpS,0EAA0E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iFAAiF,EAAE,iFAAiF,CAAC;QACtR,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,oDAAoD,CAAC;QAC/L,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,mFAAmF,CAAC;QAC5Q,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,wFAAwF,CAAC;QAC3S,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,mDAAmD,CAAC;QAC5L,2HAA2H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,iIAAiI,CAAC;QACjZ,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,2FAA2F,CAAC;QACpT,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,kEAAkE,CAAC;QAC3O,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,yFAAyF,CAAC;QAChU,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,uFAAuF,CAAC;QAC1T,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACjM,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,wEAAwE,CAAC;QAC7P,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,8BAA8B,CAAC;QAC7H,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,oFAAoF,CAAC;QAC3R,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,mDAAmD,CAAC;QAChM,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,wEAAwE,CAAC;QAC7P,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,gDAAgD,CAAC;QACnL,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,iEAAiE,CAAC;QAC9O,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,sEAAsE,CAAC;QACrP,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAChN,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,wDAAwD,CAAC;QAC3M,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,2DAA2D,CAAC;QAC5N,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,+EAA+E,CAAC;QACxQ,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,8DAA8D,CAAC;QACrO,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,+FAA+F,CAAC;QAChT,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,6DAA6D,CAAC;QAClO,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,gFAAgF,CAAC;QAC3R,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,gFAAgF,CAAC;QACvR,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,gDAAgD,CAAC;QACnL,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,yFAAyF,CAAC;QACpS,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,kGAAkG,CAAC;QACzU,oIAAoI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,0IAA0I,CAAC;QACna,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,gEAAgE,CAAC;QACvO,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,gEAAgE,CAAC;QACvO,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,sGAAsG,CAAC;QAC7V,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,iFAAiF,CAAC;QAC1R,0FAA0F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iGAAiG,EAAE,oGAAoG,CAAC;QACzU,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,gDAAgD,CAAC;QAC3L,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QACnX,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,sDAAsD,CAAC;QACrM,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,4BAA4B,CAAC;QAC3H,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,iCAAiC,CAAC;QAC1I,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,iEAAiE,CAAC;QAC1O,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,sEAAsE,CAAC;QACrP,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,gDAAgD,CAAC;QAC3K,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,4DAA4D,CAAC;QAC/M,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,6CAA6C,CAAC;QAC1K,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,sDAAsD,CAAC;QACrM,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,0EAA0E,CAAC;QACjQ,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,sEAAsE,CAAC;QAC7P,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,qDAAqD,CAAC;QAClM,yHAAyH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qIAAqI,CAAC;QACnZ,sHAAsH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8HAA8H,CAAC;QACzY,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,qFAAqF,CAAC;QAClS,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,gFAAgF,CAAC;QAC3Q,4GAA4G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QACtX,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qGAAqG,EAAE,2GAA2G,CAAC;QACxV,+GAA+G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,4HAA4H,CAAC;QAChY,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,uEAAuE,CAAC;QAChQ,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,kEAAkE,CAAC;QACvN,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,6CAA6C,CAAC;QAChK,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,0EAA0E,CAAC;QACzQ,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,sCAAsC,CAAC;QACnJ,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,+CAA+C,CAAC;QAC9K,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,mDAAmD,CAAC;QAC1L,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,4DAA4D,CAAC;QACrN,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,2CAA2C,CAAC;QAClK,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,yDAAyD,CAAC;QACtM,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,2FAA2F,CAAC;QAC1S,uGAAuG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,wHAAwH,CAAC;QACpX,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,gEAAgE,CAAC;QAC3O,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,gFAAgF,CAAC;QAC3R,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,4DAA4D,CAAC;QACvN,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,0EAA0E,CAAC;QACzQ,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,6FAA6F,CAAC;QAC1T,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,+DAA+D,CAAC;QAChN,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,wEAAwE,CAAC;QAC3P,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,wEAAwE,CAAC;QAC3P,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,8EAA8E,CAAC;QAC7Q,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,0FAA0F,CAAC;QACjT,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,gEAAgE,CAAC;QACnO,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,yCAAyC,CAAC;QACtK,qFAAqF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4FAA4F,EAAE,4FAA4F,CAAC;QACvT,8HAA8H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kIAAkI,CAAC;QACrZ,gIAAgI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,4IAA4I,CAAC;QACja,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,oGAAoG,CAAC;QACvU,+IAA+I,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mJAAmJ,CAAC;QACvb,2HAA2H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mIAAmI,CAAC;QACnZ,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,+CAA+C,CAAC;QACxL,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,uDAAuD,CAAC;QAChM,qGAAqG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8GAA8G,CAAC;QACxW,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,6FAA6F,CAAC;QAC9T,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,6EAA6E,CAAC;QACxQ,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,mEAAmE,CAAC;QAC9N,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,sEAAsE,CAAC;QAC3O,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,oEAAoE,CAAC;QAC7O,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sHAAsH,CAAC;QACpX,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,2EAA2E,CAAC;QAC5Q,uGAAuG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,2GAA2G,CAAC;QACvW,2GAA2G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,gHAAgH,CAAC;QAChX,iHAAiH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oHAAoH,CAAC;QAC1X,6GAA6G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kHAAkH,CAAC;QACpX,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,yEAAyE,CAAC;QAC9P,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,qEAAqE,CAAC;QAC1O,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yFAAyF,EAAE,yFAAyF,CAAC;QAC9S,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,2FAA2F,CAAC;QACpT,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,sEAAsE,CAAC;QACnP,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACjM,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,qEAAqE,CAAC;QAC1P,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,6CAA6C,CAAC;QAClK,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,4FAA4F,CAAC;QACnT,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,gDAAgD,CAAC;QACnL,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,+CAA+C,CAAC;QACpL,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,0DAA0D,CAAC;QAC7M,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,8EAA8E,CAAC;QAC7Q,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,sFAAsF,CAAC;QACrR,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,sDAAsD,CAAC;QACzM,4FAA4F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mGAAmG,EAAE,oGAAoG,CAAC;QAC7U,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0DAA0D,EAAE,0DAA0D,CAAC;QACjN,sCAAsC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6CAA6C,EAAE,6CAA6C,CAAC;QAC1K,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,8DAA8D,CAAC;QACvN,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,qFAAqF,CAAC;QACxR,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,wFAAwF,CAAC;QACzR,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,iEAAiE,CAAC;QACtO,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,+CAA+C,CAAC;QACxK,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,gEAAgE,CAAC;QAC3O,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qGAAqG,EAAE,sGAAsG,CAAC;QACnV,mIAAmI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,iJAAiJ,CAAC;QACza,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,qDAAqD,CAAC;QAC1M,uFAAuF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8FAA8F,EAAE,sGAAsG,CAAC;QACrU,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACpM,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,kFAAkF,CAAC;QACjS,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qEAAqE,EAAE,qEAAqE,CAAC;QAClP,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,gEAAgE,CAAC;QAC3O,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACjP,8KAA8K,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,wLAAwL,CAAC;QAC3f,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,mEAAmE,CAAC;QACpP,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6DAA6D,EAAE,iEAAiE,CAAC;QAC9N,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,wCAAwC,CAAC;QAC3J,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uCAAuC,EAAE,uCAAuC,CAAC;QACxJ,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,2EAA2E,CAAC;QAC5P,yHAAyH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,uIAAuI,CAAC;QACrZ,wKAAwK,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kLAAkL,CAAC;QAC/e,2HAA2H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6JAA6J,CAAC;QAC7a,oGAAoG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,uGAAuG,CAAC;QAChW,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,+EAA+E,CAAC;QACxQ,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8CAA8C,EAAE,8CAA8C,CAAC;QAC7K,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,uDAAuD,CAAC;QAChM,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,4EAA4E,CAAC;QAC/P,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,gFAAgF,CAAC;QAC3Q,gGAAgG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uGAAuG,EAAE,2GAA2G,CAAC;QAC5V,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,oGAAoG,CAAC;QACvU,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,sGAAsG,CAAC;QAC7U,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,+FAA+F,CAAC;QACxT,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,4FAA4F,CAAC;QAC/S,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,+EAA+E,CAAC;QACxQ,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,+EAA+E,CAAC;QACxQ,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wEAAwE,EAAE,8EAA8E,CAAC;QACjQ,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,kFAAkF,CAAC;QAC7Q,qFAAqF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4FAA4F,EAAE,kGAAkG,CAAC;QAC7T,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,+EAA+E,CAAC;QAChQ,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,6DAA6D,CAAC;QAClN,4GAA4G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,yHAAyH,CAAC;QAC1X,uFAAuF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8FAA8F,EAAE,sGAAsG,CAAC;QACrU,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gFAAgF,EAAE,oFAAoF,CAAC;QACvR,qGAAqG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kHAAkH,CAAC;QAC5W,gFAAgF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uFAAuF,EAAE,+FAA+F,CAAC;QAChT,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,6EAA6E,CAAC;QAClQ,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,4FAA4F,CAAC;QACvS,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,0EAA0E,CAAC;QACzP,6GAA6G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,4HAA4H,CAAC;QAC9X,+FAA+F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sGAAsG,EAAE,0GAA0G,CAAC;QACzV,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QAChX,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,mGAAmG,CAAC;QACpU,kIAAkI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,2IAA2I,CAAC;QACla,6GAA6G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,wHAAwH,CAAC;QAC1X,+FAA+F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sGAAsG,EAAE,sGAAsG,CAAC;QACrV,2HAA2H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oIAAoI,CAAC;QACpZ,sGAAsG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,iHAAiH,CAAC;QAC5W,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,+FAA+F,CAAC;QAChU,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oHAAoH,CAAC;QAClX,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,kGAAkG,CAAC;QACzU,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yGAAyG,EAAE,6GAA6G,CAAC;QAClW,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,2FAA2F,CAAC;QACpT,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,8GAA8G,CAAC;QACrW,qFAAqF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4FAA4F,EAAE,4FAA4F,CAAC;QACvT,yHAAyH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,kIAAkI,CAAC;QAChZ,oGAAoG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,+GAA+G,CAAC;QACxW,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,6FAA6F,CAAC;QAC1T,kHAAkH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,2HAA2H,CAAC;QAClY,6FAA6F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oGAAoG,EAAE,wGAAwG,CAAC;QACnV,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,sFAAsF,CAAC;QACrS,0FAA0F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iGAAiG,EAAE,qGAAqG,CAAC;QAC1U,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,mFAAmF,CAAC;QAC5R,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yGAAyG,EAAE,2GAA2G,CAAC;QAChW,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,wFAAwF,CAAC;QACnS,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,sEAAsE,CAAC;QACrP,gHAAgH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6HAA6H,CAAC;QAClY,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,0GAA0G,CAAC;QACjV,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,wFAAwF,CAAC;QACnS,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,wHAAwH,CAAC;QACtX,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kGAAkG,EAAE,sGAAsG,CAAC;QAC7U,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yGAAyG,EAAE,iHAAiH,CAAC;QACtW,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2FAA2F,EAAE,+FAA+F,CAAC;QACxT,yHAAyH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,sIAAsI,CAAC;QACpZ,oGAAoG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,mHAAmH,CAAC;QAC5W,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,iGAAiG,CAAC;QAC9T,kHAAkH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,+HAA+H,CAAC;QACtY,6FAA6F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oGAAoG,EAAE,4GAA4G,CAAC;QACvV,+EAA+E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sFAAsF,EAAE,0FAA0F,CAAC;QACzS,0FAA0F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iGAAiG,EAAE,yGAAyG,CAAC;QAC9U,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,uFAAuF,CAAC;QAChS,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yGAAyG,EAAE,+GAA+G,CAAC;QACpW,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,4FAA4F,CAAC;QACvS,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sEAAsE,EAAE,0EAA0E,CAAC;QACzP,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,+DAA+D,CAAC;QACxN,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,kEAAkE,CAAC;QACzO,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,iFAAiF,CAAC;QAC9Q,6HAA6H,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2GAA2G,EAAE,6IAA6I,CAAC;QACja,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,kHAAkH,CAAC;QACzW,qFAAqF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4FAA4F,EAAE,gGAAgG,CAAC;QAC3T,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8EAA8E,EAAE,8EAA8E,CAAC;QAC7Q,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,qDAAqD,CAAC;QAClM,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,+DAA+D,CAAC;QACxO,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gGAAgG,EAAE,gFAAgF,CAAC;QACnT,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yGAAyG,EAAE,yFAAyF,CAAC;QAC9U,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,8BAA8B,CAAC;QACnI,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,kCAAkC,CAAC;QAC/I,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gCAAgC,EAAE,gCAAgC,CAAC;QACnI,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,qDAAqD,CAAC;QAC9L,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,kCAAkC,CAAC;QAC/I,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yEAAyE,EAAE,uEAAuE,CAAC;QAC5P,kHAAkH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,+HAA+H,CAAC;QACtY,4FAA4F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mGAAmG,EAAE,0GAA0G,CAAC;QACnV,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,mEAAmE,CAAC;QACpO,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,qDAAqD,CAAC;QAC1L,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,sDAAsD,CAAC;QAC3M,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,gEAAgE,CAAC;QACnO,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,kFAAkF,CAAC;QACzR,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,qEAAqE,CAAC;QAC5P,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,2CAA2C,CAAC;QAC9K,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,wEAAwE,CAAC;QACjP,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,sEAAsE,CAAC;QACjP,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,mDAAmD,CAAC;QACtM,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,4EAA4E,CAAC;QACzQ,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qDAAqD,EAAE,qDAAqD,CAAC;QAClM,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,wFAAwF,CAAC;QACnR,gIAAgI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,8HAA8H,CAAC;QACnZ,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8DAA8D,EAAE,8DAA8D,CAAC;QAC7N,0EAA0E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iFAAiF,EAAE,oFAAoF,CAAC;QACzR,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QACpL,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wCAAwC,EAAE,uCAAuC,CAAC;QAC5J,0FAA0F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iGAAiG,EAAE,6FAA6F,CAAC;QACpU,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qGAAqG,EAAE,iGAAiG,CAAC;QAChV,iBAAiB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,oBAAoB,CAAC;QACzG,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iDAAiD,EAAE,6CAA6C,CAAC;QACpL,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6DAA6D,EAAE,yDAAyD,CAAC;QACxN,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACnM,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAChJ,mBAAmB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0BAA0B,EAAE,sBAAsB,CAAC;QAC/G,0GAA0G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2GAA2G,EAAE,+GAA+G,CAAC;QAChX,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8CAA8C,EAAE,0CAA0C,CAAC;QAC3K,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+CAA+C,EAAE,2CAA2C,CAAC;QAC9K,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6FAA6F,EAAE,uGAAuG,CAAC;QACtU,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yFAAyF,EAAE,oGAAoG,CAAC;QAC3T,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yBAAyB,EAAE,qBAAqB,CAAC;QAC5G,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QAC1I,gGAAgG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uGAAuG,EAAE,sGAAsG,CAAC;QACzV,cAAc,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qBAAqB,EAAE,aAAa,CAAC;QAC5F,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,cAAc,EAAE,SAAS,CAAC;QAC1E,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC;QACjE,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uBAAuB,EAAE,eAAe,CAAC;QAClG,aAAa,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oBAAoB,EAAE,UAAU,CAAC;QACvF,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gBAAgB,EAAE,aAAa,CAAC;QAClF,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wDAAwD,EAAE,oDAAoD,CAAC;QACzM,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4DAA4D,EAAE,2DAA2D,CAAC;QACxN,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC;QACjE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC;QACjE,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,cAAc,EAAE,SAAS,CAAC;QAC1E,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,eAAe,EAAE,UAAU,CAAC;QAC7E,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gBAAgB,EAAE,WAAW,CAAC;QAChF,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,eAAe,EAAE,UAAU,CAAC;QAC7E,iBAAiB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,mBAAmB,CAAC;QACxG,8CAA8C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qDAAqD,EAAE,kDAAkD,CAAC;QACjM,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uCAAuC,EAAE,sCAAsC,CAAC;QACzJ,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,4CAA4C,CAAC;QACvK,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,oDAAoD,CAAC;QAC/L,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4CAA4C,EAAE,yCAAyC,CAAC;QACpK,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,8FAA8F,CAAC;QACvS,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2BAA2B,EAAE,2BAA2B,CAAC;QACpH,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4BAA4B,EAAE,4BAA4B,CAAC;QACvH,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,4BAA4B,CAAC;QAC3H,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2EAA2E,EAAE,yEAAyE,CAAC;QACpQ,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uBAAuB,EAAE,uBAAuB,CAAC;QACxG,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,8EAA8E,CAAC;QACvQ,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kFAAkF,EAAE,8EAA8E,CAAC;QACvR,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wEAAwE,EAAE,uEAAuE,CAAC;QAC5P,mGAAmG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0GAA0G,EAAE,yGAAyG,CAAC;QAClW,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,6FAA6F,CAAC;QACxS,yFAAyF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gGAAgG,EAAE,+FAA+F,CAAC;QACpU,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,cAAc,EAAE,SAAS,CAAC;QAC1E,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,6DAA6D,CAAC;QACtN,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACnM,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6EAA6E,EAAE,yEAAyE,CAAC;QACxQ,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAClN,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0FAA0F,EAAE,yFAAyF,CAAC;QAClT,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wEAAwE,EAAE,oEAAoE,CAAC;QACzP,yCAAyC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gDAAgD,EAAE,4CAA4C,CAAC;QACjL,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0DAA0D,EAAE,sDAAsD,CAAC;QAC/M,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uEAAuE,EAAE,qEAAqE,CAAC;QACxP,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4CAA4C,EAAE,wCAAwC,CAAC;QACrK,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACnP,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8DAA8D,EAAE,0DAA0D,CAAC;QAC3N,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+CAA+C,EAAE,2CAA2C,CAAC;QAC9K,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gEAAgE,EAAE,4DAA4D,CAAC;QACjO,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oEAAoE,EAAE,2DAA2D,CAAC;QACxO,gEAAgE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uEAAuE,EAAE,sEAAsE,CAAC;QACzP,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yDAAyD,EAAE,0DAA0D,CAAC;QACjN,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4DAA4D,EAAE,gEAAgE,CAAC;QAC3N,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0DAA0D,EAAE,sDAAsD,CAAC;QAC/M,4GAA4G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2GAA2G,EAAE,uHAAuH,CAAC;QAC1X,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oDAAoD,EAAE,gDAAgD,CAAC;QAC7L,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gCAAgC,EAAE,sDAAsD,CAAC;QAC3J,mDAAmD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0DAA0D,EAAE,qDAAqD,CAAC;QAC9M,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sDAAsD,EAAE,uDAAuD,CAAC;QACxM,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mDAAmD,EAAE,yEAAyE,CAAC;QACpN,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,uDAAuD,CAAC;QACtK,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6EAA6E,EAAE,gFAAgF,CAAC;QAC/Q,+BAA+B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sCAAsC,EAAE,2CAA2C,CAAC;QAC5J,uDAAuD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8DAA8D,EAAE,8DAA8D,CAAC;QAC/N,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uDAAuD,EAAE,iEAAiE,CAAC;QACpN,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yFAAyF,EAAE,2FAA2F,CAAC;QAClT,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4BAA4B,EAAE,4BAA4B,CAAC;QACzH,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sDAAsD,EAAE,wDAAwD,CAAC;QACzM,4DAA4D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mEAAmE,EAAE,0EAA0E,CAAC;QACrP,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8BAA8B,EAAE,gCAAgC,CAAC;QACjI,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,6CAA6C,CAAC;QACxK,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mDAAmD,EAAE,6DAA6D,CAAC;QACxM,qCAAqC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4CAA4C,EAAE,wCAAwC,CAAC;QACrK,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,uDAAuD,CAAC;QACxM,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2DAA2D,EAAE,qEAAqE,CAAC;QAChO,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kEAAkE,EAAE,2EAA2E,CAAC;QACpP,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wFAAwF,EAAE,+FAA+F,CAAC;QACpT,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wEAAwE,EAAE,2EAA2E,CAAC;QAChQ,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yCAAyC,EAAE,6CAA6C,CAAC;QACpK,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yDAAyD,EAAE,kEAAkE,CAAC;QACzN,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uCAAuC,EAAE,qCAAqC,CAAC;QACxJ,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kDAAkD,EAAE,gDAAgD,CAAC;QACzL,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yDAAyD,EAAE,uDAAuD,CAAC;QAC9M,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gCAAgC,EAAE,4BAA4B,CAAC;QACjI,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,oDAAoD,CAAC;QAC7L,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+DAA+D,EAAE,+DAA+D,CAAC;QAClO,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8EAA8E,EAAE,0GAA0G,CAAC;QAC3S,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,yCAAyC,CAAC;QACpK,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yCAAyC,EAAE,uCAAuC,CAAC;QAC9J,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gFAAgF,EAAE,oGAAoG,CAAC;QACzS,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kDAAkD,EAAE,oEAAoE,CAAC;QAC7M,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACtK,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wEAAwE,EAAE,qEAAqE,CAAC;QAC1P,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oFAAoF,EAAE,4GAA4G,CAAC;QACzT,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2DAA2D,EAAE,uDAAuD,CAAC;QAClN,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2DAA2D,EAAE,8DAA8D,CAAC;QACzN,+GAA+G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2GAA2G,EAAE,qHAAqH,CAAC;QAC3X,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oFAAoF,EAAE,4GAA4G,CAAC;QACzT,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0FAA0F,EAAE,8GAA8G,CAAC;QACvU,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yCAAyC,EAAE,8CAA8C,CAAC;QACrK,6EAA6E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oFAAoF,EAAE,4FAA4F,CAAC;QACvS,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iDAAiD,EAAE,uDAAuD,CAAC;QAC9L,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,gDAAgD,CAAC;QACrL,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAChJ,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yCAAyC,EAAE,qCAAqC,CAAC;QAC5J,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0FAA0F,EAAE,sFAAsF,CAAC;QAC/S,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,kFAAkF,CAAC;QAC/Q,kDAAkD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yDAAyD,EAAE,yDAAyD,CAAC;QAC9M,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,mCAAmC,CAAC;QAClJ,oHAAoH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oIAAoI,CAAC;QAC7Y,6DAA6D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oEAAoE,EAAE,oEAAoE,CAAC;QACjP,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,6DAA6D,CAAC;QACxM,kEAAkE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yEAAyE,EAAE,6EAA6E,CAAC;QACpQ,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6FAA6F,EAAE,iGAAiG,CAAC;QAChU,kGAAkG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yGAAyG,EAAE,6GAA6G,CAAC;QACpW,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iDAAiD,EAAE,iDAAiD,CAAC;QACxL,qDAAqD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4DAA4D,EAAE,6DAA6D,CAAC;QAC1N,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kCAAkC,EAAE,8BAA8B,CAAC;QACvI,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0CAA0C,EAAE,sCAAsC,CAAC;QAC/J,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4EAA4E,EAAE,wEAAwE,CAAC;QACrQ,6GAA6G,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2GAA2G,EAAE,yHAAyH,CAAC;QAC7X,sEAAsE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6EAA6E,EAAE,6EAA6E,CAAC;QAC5Q,sDAAsD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6DAA6D,EAAE,yDAAyD,CAAC;QACxN,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mDAAmD,EAAE,+CAA+C,CAAC;QAC1L,8DAA8D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qEAAqE,EAAE,qEAAqE,CAAC;QACpP,uEAAuE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8EAA8E,EAAE,8EAA8E,CAAC;QAC/Q,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uDAAuD,EAAE,qDAAqD,CAAC;QACxM,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2FAA2F,EAAE,uFAAuF,CAAC;QAClT,2FAA2F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kGAAkG,EAAE,qGAAqG,CAAC;QAC9U,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACtM,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sDAAsD,EAAE,kDAAkD,CAAC;QACnM,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,uCAAuC,CAAC;QAClK,iEAAiE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wEAAwE,EAAE,sEAAsE,CAAC;QAC3P,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAChJ,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uDAAuD,EAAE,mDAAmD,CAAC;QACtM,oFAAoF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2FAA2F,EAAE,yFAAyF,CAAC;QACpT,8FAA8F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qGAAqG,EAAE,iGAAiG,CAAC;QAChV,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gCAAgC,EAAE,4BAA4B,CAAC;QACjI,yEAAyE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gFAAgF,EAAE,kFAAkF,CAAC;QACvR,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2BAA2B,EAAE,sBAAsB,CAAC;QACjH,aAAa,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oBAAoB,EAAE,eAAe,CAAC;QAC5F,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mCAAmC,EAAE,8BAA8B,CAAC;QACzI,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gCAAgC,EAAE,2BAA2B,CAAC;QAChI,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yBAAyB,EAAE,oBAAoB,CAAC;QAC3G,iBAAiB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,mBAAmB,CAAC;QACxG,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2BAA2B,EAAE,sBAAsB,CAAC;QACjH,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uBAAuB,EAAE,kBAAkB,CAAC;QACrG,+FAA+F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sGAAsG,EAAE,0GAA0G,CAAC;QAC3V,uCAAuC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8CAA8C,EAAE,0CAA0C,CAAC;QAC3K,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uCAAuC,EAAE,mCAAmC,CAAC;QACtJ,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACtK,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gEAAgE,EAAE,oEAAoE,CAAC;QACzO,4FAA4F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mGAAmG,EAAE,mGAAmG,CAAC;QAC9U,+DAA+D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sEAAsE,EAAE,kEAAkE,CAAC;QACnP,wCAAwC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+CAA+C,EAAE,2CAA2C,CAAC;QAC9K,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,8CAA8C,CAAC;QACrK,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,+CAA+C,CAAC;QACxK,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,4CAA4C,CAAC;QAC/J,kFAAkF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yFAAyF,EAAE,2FAA2F,CAAC;QAChT,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,iFAAiF,CAAC;QAC5Q,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,+FAA+F,CAAC;QAC5T,wFAAwF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+FAA+F,EAAE,+FAA+F,CAAC;QAChU,iFAAiF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,wFAAwF,CAAC;QAC3S,2EAA2E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kFAAkF,EAAE,yFAAyF,CAAC;QAChS,wEAAwE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+EAA+E,EAAE,iFAAiF,CAAC;QAClR,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,+DAA+D,CAAC;QACxN,2CAA2C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kDAAkD,EAAE,sDAAsD,CAAC;QAC7L,mFAAmF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0FAA0F,EAAE,0FAA0F,CAAC;QACjT,qIAAqI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6IAA6I,CAAC;QACva,6JAA6J,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,qKAAqK,CAAC;QACvd,mKAAmK,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,wKAAwK,CAAC;QAChe,qGAAqG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,6GAA6G,CAAC;QACvW,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,8EAA8E,CAAC;QACzQ,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gCAAgC,EAAE,4BAA4B,CAAC;QAC/H,YAAY,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mBAAmB,EAAE,eAAe,CAAC;QACxF,0BAA0B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iCAAiC,EAAE,6BAA6B,CAAC;QAClI,iCAAiC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wCAAwC,EAAE,oCAAoC,CAAC;QACvJ,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,qDAAqD,CAAC;QAC1L,6FAA6F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oGAAoG,EAAE,uGAAuG,CAAC;QAClV,0FAA0F,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iGAAiG,EAAE,oGAAoG,CAAC;QACzU,sFAAsF,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6FAA6F,EAAE,iGAAiG,CAAC;QAC9T,yGAAyG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oHAAoH,CAAC;QAClX,qEAAqE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4EAA4E,EAAE,+EAA+E,CAAC;QAC1Q,8BAA8B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qCAAqC,EAAE,iCAAiC,CAAC;QAC9I,8EAA8E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qFAAqF,EAAE,iFAAiF,CAAC;QAC9R,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,gDAAgD,CAAC;QACzK,oCAAoC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2CAA2C,EAAE,2CAA2C,CAAC;QACpK,yDAAyD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gEAAgE,EAAE,+DAA+D,CAAC;QAClO,gDAAgD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uDAAuD,EAAE,sDAAsD,CAAC;QACvM,oDAAoD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2DAA2D,EAAE,0DAA0D,CAAC;QACnN,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,uDAAuD,CAAC;QAC1M,0CAA0C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iDAAiD,EAAE,gDAAgD,CAAC;QACrL,gCAAgC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uCAAuC,EAAE,uCAAuC,CAAC;QACxJ,mCAAmC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0CAA0C,EAAE,yCAAyC,CAAC;QAChK,4CAA4C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mDAAmD,EAAE,kDAAkD,CAAC;QAC3L,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,uDAAuD,CAAC;QAC1M,iDAAiD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,uDAAuD,CAAC;QAC1M,+CAA+C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,qDAAqD,CAAC;QACpM,wDAAwD,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,+DAA+D,EAAE,8DAA8D,CAAC;QAC/N,2DAA2D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,mEAAmE,CAAC;QAC1O,4EAA4E,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mFAAmF,EAAE,oFAAoF,CAAC;QAC7R,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gCAAgC,EAAE,6BAA6B,CAAC;QAClI,0DAA0D,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iEAAiE,EAAE,6DAA6D,CAAC;QAClO,gGAAgG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uGAAuG,EAAE,4GAA4G,CAAC;QAC7V,kCAAkC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,0CAA0C,CAAC;QAC/J,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,2DAA2D,CAAC;QACtM,mEAAmE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0EAA0E,EAAE,8EAA8E,CAAC;QACrQ,oEAAoE,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,6EAA6E,CAAC;QACtQ,oHAAoH,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2GAA2G,EAAE,oHAAoH,CAAC;QAC7X,6CAA6C,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,kDAAkD,CAAC;QAC7L,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mCAAmC,EAAE,+BAA+B,CAAC;QACxI,2DAA2D,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,mEAAmE,EAAE,gEAAgE,CAAC;QACzO,+DAA+D,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uEAAuE,EAAE,kEAAkE,CAAC;QACnP,4CAA4C,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oDAAoD,EAAE,mDAAmD,CAAC;QAC9L,sBAAsB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,8BAA8B,EAAE,yBAAyB,CAAC;QACxH,8CAA8C,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,qDAAqD,CAAC;QACpM,qEAAqE,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,6EAA6E,EAAE,4EAA4E,CAAC;QACzQ,6JAA6J,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4GAA4G,EAAE,qKAAqK,CAAC;QACzd,iJAAiJ,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4GAA4G,EAAE,qJAAqJ,CAAC;QAC7b,8CAA8C,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sDAAsD,EAAE,qDAAqD,CAAC;QACpM,gFAAgF,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wFAAwF,EAAE,uFAAuF,CAAC;QAC1S,iCAAiC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,yCAAyC,EAAE,wCAAwC,CAAC;QAC7J,+FAA+F,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,uGAAuG,EAAE,sGAAsG,CAAC;QACvV,4DAA4D,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oEAAoE,EAAE,2EAA2E,CAAC;QACtP,wGAAwG,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4GAA4G,EAAE,iHAAiH,CAAC;QAChX,0DAA0D,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,kEAAkE,EAAE,yDAAyD,CAAC;QAChO,mEAAmE,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,2EAA2E,EAAE,6EAA6E,CAAC;QACtQ,wCAAwC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,gDAAgD,EAAE,iDAAiD,CAAC;QACpL,6FAA6F,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,qGAAqG,EAAE,iHAAiH,CAAC;QAC9V,sBAAsB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8BAA8B,EAAE,6BAA6B,CAAC;QAC9H,sDAAsD,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,8DAA8D,EAAE,6DAA6D,CAAC;QAC9N,4BAA4B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oCAAoC,EAAE,mCAAmC,CAAC;QAChJ,8BAA8B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sCAAsC,EAAE,gCAAgC,CAAC;QACjJ,qBAAqB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,6BAA6B,EAAE,4BAA4B,CAAC;QAC3H,kCAAkC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0CAA0C,EAAE,qCAAqC,CAAC;QAC9J,+BAA+B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uCAAuC,EAAE,qCAAqC,CAAC;QACxJ,mKAAmK,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4GAA4G,EAAE,mJAAmJ,CAAC;QAC7c,kGAAkG,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0GAA0G,EAAE,+GAA+G,CAAC;QACtW,eAAe,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uBAAuB,EAAE,4BAA4B,CAAC;QAC/G,aAAa,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qBAAqB,EAAE,wBAAwB,CAAC;QACvG,2CAA2C,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mDAAmD,EAAE,wDAAwD,CAAC;QACnM,kBAAkB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0BAA0B,EAAE,yBAAyB,CAAC;QAClH,kCAAkC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,0CAA0C,EAAE,yCAAyC,CAAC;QAClK,8BAA8B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sCAAsC,EAAE,iCAAiC,CAAC;QAClJ,yBAAyB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iCAAiC,EAAE,4BAA4B,CAAC;QACnI,wCAAwC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,gDAAgD,EAAE,+CAA+C,CAAC;QACpL,4BAA4B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,oCAAoC,EAAE,mCAAmC,CAAC;QAChJ,oBAAoB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4BAA4B,EAAE,2BAA2B,CAAC;QACxH,gBAAgB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,uBAAuB,CAAC;QAC5G,uBAAuB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+BAA+B,EAAE,8BAA8B,CAAC;QACjI,2BAA2B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mCAAmC,EAAE,kCAAkC,CAAC;QAC7I,oCAAoC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,4CAA4C,EAAE,2CAA2C,CAAC;QACxK,yBAAyB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iCAAiC,EAAE,gCAAgC,CAAC;QACvI,yBAAyB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,iCAAiC,EAAE,4BAA4B,CAAC;QACnI,mCAAmC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,2CAA2C,EAAE,qCAAqC,CAAC;QAChK,2BAA2B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,mCAAmC,EAAE,iCAAiC,CAAC;QAC5I,cAAc,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sBAAsB,EAAE,gBAAgB,CAAC;QACjG,iBAAiB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,yBAAyB,EAAE,uBAAuB,CAAC;QAC9G,gBAAgB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,kBAAkB,CAAC;QACvG,gBAAgB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wBAAwB,EAAE,kBAAkB,CAAC;QACvG,+BAA+B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,uCAAuC,EAAE,mCAAmC,CAAC;QACtJ,uBAAuB,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,+BAA+B,EAAE,6BAA6B,CAAC;QAChI,6BAA6B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,qCAAqC,EAAE,+BAA+B,CAAC;QAC9I,8BAA8B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,sCAAsC,EAAE,gCAAgC,CAAC;QACjJ,0BAA0B,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,kCAAkC,EAAE,iCAAiC,CAAC;QAC1I,gCAAgC,EAAE,IAAI,CAAC,KAAK,EAAE,GAAA,kBAAkB,CAAC,OAAO,EAAE,wCAAwC,EAAE,mCAAmC,CAAC;QACxJ,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,iBAAiB,EAAE,WAAW,CAAC;QAChF,mBAAmB,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,4BAA4B,EAAE,yBAAyB,CAAC;QACpH,2BAA2B,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,oCAAoC,EAAE,iCAAiC,CAAC;QAC5I,iBAAiB,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,0BAA0B,EAAE,oBAAoB,CAAC;QAC3G,eAAe,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wBAAwB,EAAE,kBAAkB,CAAC;QACrG,+CAA+C,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,wDAAwD,EAAE,iDAAiD,CAAC;QACpM,6BAA6B,EAAE,IAAI,CAAC,MAAM,EAAE,GAAA,kBAAkB,CAAC,KAAK,EAAE,sCAAsC,EAAE,+BAA+B,CAAC;KACjJ,CAAC;AACN,CAAC,EA37BS,EAAE,KAAF,EAAE,QA27BX;AC37BD,IAAU,EAAE,CAwiHX;AAxiHD,WAAU,EAAE;IACK,aAAU,GAAY,EAAa,CAAC;IACpC,WAAQ,GAAuB,GAAA,SAAS,EAAS,CAAC;IAElD,gCAA6B,GAAG,OAAO,CAAC;IASrD,8BAA4D,MAAc,EAAE,IAAe;QACvF,IAAM,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;QACzC,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YACf,GAAG,CAAC,CAAsB,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY;gBAAjC,IAAM,WAAW,qBAAA;gBAClB,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;oBAC5B,MAAM,CAAC,WAAgB,CAAC;gBAC5B,CAAC;aACJ;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAXe,uBAAoB,uBAWnC,CAAA;IAMD,IAAM,YAAY,GAAG,4BAA4B,EAAE,CAAC;IAEpD;QACI,IAAI,GAAG,GAAG,EAAE,CAAC;QAEb,IAAM,SAAS,GAA2B,UAAA,IAAI,IAAI,OAAA,GAAG,IAAI,IAAI,EAAX,CAAW,CAAC;QAC9D,MAAM,CAAC;YACH,MAAM,EAAE,cAAM,OAAA,GAAG,EAAH,CAAG;YACjB,YAAY,EAAE,SAAS;YACvB,aAAa,EAAE,SAAS;YACxB,gBAAgB,EAAE,SAAS;YAC3B,UAAU,EAAE,SAAS;YACrB,kBAAkB,EAAE,SAAS;YAC7B,cAAc,EAAE,SAAS;YACzB,aAAa,EAAE,SAAS;YACxB,WAAW,EAAE,SAAS;YAItB,SAAS,EAAE,cAAM,OAAA,GAAG,IAAI,GAAG,EAAV,CAAU;YAC3B,cAAc,EAAE,GAAA,IAAI;YACpB,cAAc,EAAE,GAAA,IAAI;YACpB,KAAK,EAAE,cAAM,OAAA,GAAG,GAAG,EAAE,EAAR,CAAQ;YACrB,WAAW,EAAE,GAAA,IAAI;YACjB,2BAA2B,EAAE,GAAA,IAAI;YACjC,oCAAoC,EAAE,GAAA,IAAI;SAC7C,CAAC;IACN,CAAC;IAED,qCAA4C,MAA4C;QACpF,IAAM,SAAS,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC;QACxC,IAAI,CAAC;YACD,MAAM,CAAC,YAAY,CAAC,CAAC;YACrB,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;QACjC,CAAC;gBACO,CAAC;YACL,YAAY,CAAC,KAAK,EAAE,CAAC;YACrB,YAAY,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QACzC,CAAC;IACL,CAAC;IAVe,8BAA2B,8BAU1C,CAAA;IAED,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;IAC/B,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,2BAAkC,UAAsB,EAAE,cAAsB;QAC5E,MAAM,CAAC,UAAU,IAAI,UAAU,CAAC,eAAe,IAAI,UAAU,CAAC,eAAe,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IACtG,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,2BAAkC,UAAsB,EAAE,cAAsB,EAAE,cAAkC;QAChH,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC;YAC9B,UAAU,CAAC,eAAe,GAAG,GAAA,SAAS,EAAsB,CAAC;QACjE,CAAC;QAED,UAAU,CAAC,eAAe,CAAC,GAAG,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IACnE,CAAC;IANe,oBAAiB,oBAMhC,CAAA;IAED,2CAAkD,UAAsB,EAAE,0BAAkC,EAAE,8BAA8D;QACxK,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,mCAAmC,CAAC,CAAC,CAAC;YAClD,UAAU,CAAC,mCAAmC,GAAG,GAAA,SAAS,EAAkC,CAAC;QACjG,CAAC;QAED,UAAU,CAAC,mCAAmC,CAAC,GAAG,CAAC,0BAA0B,EAAE,8BAA8B,CAAC,CAAC;IACnH,CAAC;IANe,oCAAiC,oCAMhD,CAAA;IAED,mCAA0C,aAAiC,EAAE,aAAiC;QAC1G,MAAM,CAAC,aAAa,CAAC,uBAAuB,KAAK,aAAa,CAAC,uBAAuB;YAClF,aAAa,CAAC,SAAS,KAAK,aAAa,CAAC,SAAS;YACnD,aAAa,CAAC,gBAAgB,KAAK,aAAa,CAAC,gBAAgB;YACjE,gBAAgB,CAAC,aAAa,CAAC,SAAS,EAAE,aAAa,CAAC,SAAS,CAAC,CAAC;IAC3E,CAAC;IALe,4BAAyB,4BAKxC,CAAA;IAED,0BAA0B,CAAwB,EAAE,CAAwB;QACxE,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,aAAa,KAAK,CAAC,CAAC,aAAa,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,OAAO,CAAC;IACpH,CAAC;IAED,gCAAuC,aAA6C,EAAE,aAA6C;QAC/H,MAAM,CAAC,aAAa,CAAC,gBAAgB,KAAK,aAAa,CAAC,gBAAgB,IAAI,aAAa,CAAC,OAAO,KAAK,aAAa,CAAC,OAAO,CAAC;IAChI,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,iCACI,KAA4B,EAC5B,cAAgC,EAChC,cAA8B,EAC9B,QAAyD;QACzD,GAAA,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,cAAc,CAAC,MAAM,CAAC,CAAC;QAErD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,IAAM,aAAa,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YACxC,IAAM,aAAa,GAAG,cAAc,IAAI,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACrE,IAAM,OAAO,GACT,aAAa;gBACT,CAAC,CAAC,CAAC,aAAa,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;gBAC3D,CAAC,CAAC,aAAa,CAAC;YACxB,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAnBe,0BAAuB,0BAmBtC,CAAA;IAGD,4BAAmC,IAAU;QACzC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACzB,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,SAA0C,CAAC,KAAK,CAAC,CAAC;IACxE,CAAC;IAHe,qBAAkB,qBAGjC,CAAA;IAED,4BAA4B,IAAU;QAClC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,SAAmC,CAAC,CAAC,CAAC,CAAC;YAInD,IAAM,6BAA6B,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,QAA6B,CAAC,KAAK,CAAC,CAAC;gBACnF,GAAA,YAAY,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;YAG3C,EAAE,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC;gBAChC,IAAI,CAAC,KAAK,UAA2C,CAAC;YAC1D,CAAC;YAKD,IAAI,CAAC,KAAK,UAAoC,CAAC;QACnD,CAAC;IACL,CAAC;IAED,6BAAoC,IAAU;QAC1C,OAAO,IAAI,IAAI,IAAI,CAAC,IAAI,QAA0B,EAAE,CAAC;YACjD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAa,IAAI,CAAC;IAC5B,CAAC;IALe,sBAAmB,sBAKlC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAsB;YACtB,SAA0B;YAC1B,SAA6B;YAC7B,SAA+B;YAC/B;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAVe,wBAAqB,wBAUpC,CAAA;IAED,gCAAuC,IAAY,EAAE,UAA0B;QAC3E,GAAA,KAAK,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;QACxB,MAAM,CAAC,GAAA,aAAa,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC;IAHe,yBAAsB,yBAGrC,CAAA;IAGD,yBAAgC,IAAU;QACtC,IAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;QACvC,IAAM,GAAG,GAAG,GAAA,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1D,MAAM,CAAI,IAAI,CAAC,QAAQ,UAAI,GAAG,CAAC,IAAI,GAAG,CAAC,WAAI,GAAG,CAAC,SAAS,GAAG,CAAC,OAAG,CAAC;IACpE,CAAC;IAJe,kBAAe,kBAI9B,CAAA;IAED,4BAAmC,IAAY,EAAE,UAA0B;QACvE,GAAA,KAAK,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;QACxB,IAAM,UAAU,GAAG,GAAA,aAAa,CAAC,UAAU,CAAC,CAAC;QAE7C,IAAM,SAAS,GAAG,IAAI,CAAC;QACvB,IAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;QACnC,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,KAAK,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YAEtC,MAAM,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,CAAC,CAAC;YAEF,IAAM,KAAK,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC;YAEpC,IAAI,GAAG,GAAG,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;YACxC,GAAA,KAAK,CAAC,MAAM,CAAC,GAAA,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAKtD,OAAO,KAAK,IAAI,GAAG,IAAI,GAAA,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;gBAC7D,GAAG,EAAE,CAAC;YACV,CAAC;YACD,MAAM,CAAC,GAAG,CAAC;QACf,CAAC;IACL,CAAC;IAzBe,qBAAkB,qBAyBjC,CAAA;IAcD,uBAA8B,IAAU;QACpC,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,MAA8B,CAAC;IAC7F,CAAC;IANe,gBAAa,gBAM5B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAOD,wCAA+C,IAAY,EAAE,UAAkB,EAAE,UAAkB;QAG/F,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,CAAC,OAAyB;YACxD,UAAU,GAAG,CAAC,GAAG,UAAU;YAC3B,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,CAAC,OAAyB,CAAC,CAAC,CAAC;YAC3D,IAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YAC1D,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,GAAA,iCAAiC,CAAC;gBACtD,UAAU,CAAC,KAAK,CAAC,GAAA,mCAAmC,CAAC;gBACrD,UAAU,CAAC,KAAK,CAAC,GAAA,oCAAoC,CAAC;gBACtD,UAAU,CAAC,KAAK,CAAC,GAAA,sCAAsC,CAAC;gBACxD,UAAU,CAAC,KAAK,CAAC,mDAAmD,CAAC;gBACrE,UAAU,CAAC,KAAK,CAAC,qDAAqD,CAAC;gBACvE,UAAU,CAAC,KAAK,CAAC,wBAAwB,CAAC;gBAC1C,UAAU,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAAC;gBAC9C,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAlBe,iCAA8B,iCAkB7C,CAAA;IAED,yBAAgC,IAAY,EAAE,OAAqB;QAC/D,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,OAA4B;YAC/D,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,OAA+B,CAAC;IACxE,CAAC;IAHe,kBAAe,kBAG9B,CAAA;IAED,2BAAkC,IAAU,EAAE,UAA2B,EAAE,YAAsB;QAG7F,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;QACpB,CAAC;QAED,EAAE,CAAC,CAAC,GAAA,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,GAAA,UAAU,CAAC,CAAC,UAAU,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,EAAyB,KAAK,EAAqB,IAAI,CAAC,CAAC;QACvI,CAAC;QAED,EAAE,CAAC,CAAC,YAAY,IAAI,GAAA,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC;QAMD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAA0B,IAAiB,IAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACjF,MAAM,CAAC,iBAAiB,CAAc,IAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;QACxF,CAAC;QAED,MAAM,CAAC,GAAA,UAAU,CAAC,CAAC,UAAU,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IAChF,CAAC;IAxBe,oBAAiB,oBAwBhC,CAAA;IAED,uCAA8C,IAAU,EAAE,UAA2B;QACjF,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YAC1C,MAAM,CAAC,iBAAiB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QAC/C,CAAC;QAED,MAAM,CAAC,GAAA,UAAU,CAAC,CAAC,UAAU,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAC3F,CAAC;IANe,gCAA6B,gCAM5C,CAAA;IAED,2CAAkD,UAAsB,EAAE,IAAU,EAAE,aAAqB;QAArB,8BAAA,EAAA,qBAAqB;QACvG,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;QAED,IAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC7B,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAA,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3F,CAAC;IAPe,oCAAiC,oCAOhD,CAAA;IAED,qCAA4C,UAAkB,EAAE,IAAU;QACtE,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;QAED,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,GAAA,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC5E,CAAC;IANe,8BAA2B,8BAM1C,CAAA;IAED,uBAA8B,IAAU,EAAE,aAAqB;QAArB,8BAAA,EAAA,qBAAqB;QAC3D,MAAM,CAAE,iCAAiC,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC;IAC9F,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAMD,qBAA4B,SAA8B,EAAE,IAAU;QAClE,MAAM,CAAC,GAAA,YAAY,CAAC,SAAS,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC;IACzD,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,wBAAwB,EAAmB,EAAE,EAAmB;YAAtC,aAAS;YAAY,aAAS;QACpD,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,IAAqB,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,GAAwB,CAAC,EAAmB,CAAC;IACzG,CAAC;IAKD,sBAA6B,IAAU;QACnC,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC;IACtC,CAAC;IAHe,eAAY,eAG3B,CAAA;IAED,wBAA+B,IAAqB,EAAE,UAAsB;QAGxE,EAAE,CAAC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YAC1C,MAAM,CAAC,GAAA,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QAC1C,CAAC;QAED,IAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,WAA4B,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,oBAAoB,CAAC;QACxG,IAAM,IAAI,GAAG,CAAiB,IAAK,CAAC,EAAE,IAAoB,IAAK,CAAC,EAAE,CAAC,EAAE,IAAU,CAAC,CAAC,CAAC,CAAiB,IAAK,CAAC,EAAE,CAAC,EAAY,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAA;QAIpI,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,EAAE,CAAC,CAAiB,IAAK,CAAC,WAAW,CAAC,CAAC,CAAC;oBACpC,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA6B,GAAG,GAAG,CAAC;gBACpE,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA6B,GAAG,GAAG,CAAC;gBACpE,CAAC;YACL;gBACI,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA0B,GAAG,GAAG,CAAC;YACjE;gBACI,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA0B,GAAG,IAAI,CAAC;YAClE;gBACI,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA0B,GAAG,IAAI,CAAC;YAClE;gBACI,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,KAA0B,GAAG,GAAG,CAAC;YACjE,OAA+B;YAC/B;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QAED,GAAA,KAAK,CAAC,IAAI,CAAC,mBAAiB,IAAI,CAAC,IAAI,yBAAsB,CAAC,CAAC;IACjE,CAAC;IAlCe,iBAAc,iBAkC7B,CAAA;IAED,gCAAuC,KAAsB;QACzD,MAAM,CAAC,GAAA,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,oBAAoB,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,KAAK,CAAC;IAClF,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAGD,kCAAyC,UAAkB;QACvD,MAAM,CAAC,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,OAAqB,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,OAAqB,CAAC,CAAC,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAa,CAAC;IAClL,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAMD,0BAAiC,UAAkB;QAC/C,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAID,sCAA6C,UAAkB;QAC3D,MAAM,CAAC,GAAA,eAAe,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACnF,CAAC;IAFe,+BAA4B,+BAE3C,CAAA;IAED,8BAAqC,WAAwB;QACzD,MAAM,CAAC,CAAC,GAAA,oBAAoB,CAAC,WAAW,CAAC,IAAwB,CAAC,KAAK,CAAC;YACpE,gDAAgD,CAAC,WAAW,CAAC,CAAC;IACtE,CAAC;IAHe,uBAAoB,uBAGnC,CAAA;IAED,0DAAiE,WAAwB;QACrF,IAAM,IAAI,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,QAA2B,CAAC;IACvG,CAAC;IAHe,mDAAgD,mDAG/D,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAiC;YACrD,CAAqB,IAAK,CAAC,IAAI,CAAC,IAAI,MAA6B,IAAI,yBAAyB,CAAoB,IAAI,CAAC,CAAC,CAAC;IACjI,CAAC;IAHe,kBAAe,kBAG9B,CAAA;IAED,uCAA8C,IAAU;QACpD,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,MAA6B,CAAC;IACpF,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,kCAAyC,IAAU;QAC/C,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC,IAAI,GAAA,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACnE,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAGD,wCAA+C,YAAoB;QAC/D,MAAM,CAAC,wBAAwB,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;IACnE,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,kCAAkC,IAAU;QAExC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAiC,IAAI,CAAC,CAAqB,IAAK,CAAC,IAAI,CAAC,CAAC;IACnG,CAAC;IAED,wCAA+C,IAAU;QACrD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B;YACtC,IAAI,CAAC,IAAI,QAAiC;YAC1C,GAAA,cAAc,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAJe,iCAA8B,iCAI7C,CAAA;IAED,mCAA0C,MAAyB;QAC/D,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,MAA+B,CAAC,CAAC;IAC3D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,sCAA6C,IAAU;QAInD,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YACvB;gBACI,MAAM,CAAC,GAAA,gBAAgB,CAAa,IAAI,CAAC,MAAM,CAAC,CAAC;YACrD;gBACI,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAA,gBAAgB,CAAa,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC/G,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAde,+BAA4B,+BAc3C,CAAA;IAED,mCAA0C,IAAgB,EAAE,eAAgC;QACxF,MAAM,CAAC,GAAA,gBAAgB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,eAAe,CAAC;IACrE,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAGD,sBAA6B,IAAU,EAAE,UAAgB;QACrD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA2B;YAC3B,SAA0B;YAC1B,SAA4B;YAC5B,SAAkC;YAClC,SAA6B;YAC7B,SAA+B;YAC/B,SAA+B;YAC/B,SAA4B;YAC5B,SAAkC;YAClC,SAA4B;YAC5B,SAA4B;YAC5B,SAAoC;YACpC,SAAmC;YACnC;gBACI,MAAM,CAAC,IAAI,CAAC;YAEhB;gBAGI,MAAM,CAAC,UAAU,IAAI,CAAC,GAAA,cAAc,CAAC,UAAU,CAAC,CAAC;QACzD,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAzBe,eAAY,eAyB3B,CAAA;IAID,yCAAgD,IAAmC;QAC/E,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA8B;YAC9B,SAAmC;YACnC,SAAgC;YAChC,SAA+B;YAC/B,SAA6B;YAC7B,SAAgC;YAChC,SAAkC;YAClC,SAAiC;YACjC,SAAgC;YAChC,SAAqC;YACrC,SAAqC;YACrC,SAAiC;YACjC,SAAoC;YACpC,SAAkC;YAClC,SAA4B;YAC5B,SAA4B;YAC5B,SAA4B;YAC5B,SAAmC;YACnC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,GAAA,iBAAiB,CAAC,IAAI,CAAC,CAAC;gBACxB,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IA1Be,kCAA+B,kCA0B9C,CAAA;IAGD,2BAAkC,IAAU;QACxC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAkC;YAClC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IARe,oBAAiB,oBAQhC,CAAA;IAID,yCAAgD,IAAU;QACtD,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,OAAO,OAAO,EAAE,CAAC;YACb,EAAE,CAAC,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBACxC,MAAM,CAAC,OAAO,CAAC;YACnB,CAAC;YAED,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC;QAC7B,CAAC;IACL,CAAC;IATe,kCAA+B,kCAS9C,CAAA;IAKD,iCAAwC,IAAqB;QACzD,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IACxE,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,8BAAqC,IAAe;QAChD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,uBAAuB,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACvG,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,+BAAsC,IAAkB;QACpD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAc,IAAK,CAAC,WAAW,CAAC;YAC1C,OAA8B;YAC9B;gBACI,MAAM,CAAC,wBAAwB,CAAqB,IAAK,CAAC,IAAI,CAAC,CAAC;YACpE;gBACI,EAAE,CAAC,CAAC,wBAAwB,CAAwB,IAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACpE,MAAM,CAAC,wBAAwB,CAA4C,IAAK,CAAC,UAAW,CAAC,IAAI,CAAC,CAAC;gBACvG,CAAC;QACT,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAde,wBAAqB,wBAcpC,CAAA;IAED,4BAAmC,IAAsC;QACrE,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAA,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACzE;gBACI,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAChF;gBACI,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzF,CAAC;IACL,CAAC;IATe,qBAAkB,qBASjC,CAAA;IAED,iCAAwC,IAAU,EAAE,OAA0B,EAAE,IAAsB,EAAE,IAAsB,EAAE,IAAsB;QAClJ,IAAM,UAAU,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAC7C,MAAM,CAAC,mCAAmC,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAC5F,CAAC;IAHe,0BAAuB,0BAGtC,CAAA;IAED,6CAAoD,UAAsB,EAAE,IAAU,EAAE,OAA0B,EAAE,IAAsB,EAAE,IAAsB,EAAE,IAAsB;QACtL,IAAM,IAAI,GAAG,mBAAmB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QACnD,MAAM,CAAC,GAAA,oBAAoB,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAChG,CAAC;IAHe,sCAAmC,sCAGlD,CAAA;IAED,iDAAwD,IAAU,EAAE,YAAoC;QACpG,IAAM,UAAU,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAM,IAAI,GAAG,mBAAmB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QACnD,MAAM,CAAC;YACH,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,IAAI,EAAE,YAAY,CAAC,IAAI;YACvB,QAAQ,EAAE,YAAY,CAAC,QAAQ;YAC/B,WAAW,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,WAAW;SAC3E,CAAC;IACN,CAAC;IAXe,0CAAuC,0CAWtD,CAAA;IAED,kCAAyC,UAAsB,EAAE,GAAW;QACxE,IAAM,OAAO,GAAG,GAAA,aAAa,CAAC,UAAU,CAAC,eAAe,EAAiB,IAAI,EAAE,UAAU,CAAC,eAAe,EAAE,UAAU,CAAC,IAAI,EAAe,SAAS,EAAE,GAAG,CAAC,CAAC;QACzJ,OAAO,CAAC,IAAI,EAAE,CAAC;QACf,IAAM,KAAK,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;QACpC,MAAM,CAAC,GAAA,wBAAwB,CAAC,KAAK,EAAE,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC;IACjE,CAAC;IALe,2BAAwB,2BAKvC,CAAA;IAED,sCAAsC,UAAsB,EAAE,IAAmB;QAC7E,IAAM,GAAG,GAAG,GAAA,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,QAAqB,CAAC,CAAC,CAAC;YAC3C,IAAA,4EAAe,CAA8D;YAC7E,IAAA,0EAAa,CAA8D;YACnF,EAAE,CAAC,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC;gBAGtB,MAAM,CAAC,GAAA,cAAc,CAAC,GAAG,EAAE,kBAAkB,CAAC,SAAS,EAAE,UAAU,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;YACpF,CAAC;QACL,CAAC;QACD,MAAM,CAAC,GAAA,wBAAwB,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IACnD,CAAC;IAED,6BAAoC,UAAsB,EAAE,IAAU;QAClE,IAAI,SAAS,GAAG,IAAI,CAAC;QACrB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,IAAM,KAAG,GAAG,GAAA,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,EAAyB,KAAK,CAAC,CAAC;gBACzE,EAAE,CAAC,CAAC,KAAG,KAAK,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;oBAEjC,MAAM,CAAC,GAAA,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAChC,CAAC;gBACD,MAAM,CAAC,wBAAwB,CAAC,UAAU,EAAE,KAAG,CAAC,CAAC;YAGrD,SAAoC;YACpC,SAA+B;YAC/B,SAAiC;YACjC,SAAgC;YAChC,SAAqC;YACrC,SAAkC;YAClC,SAAgC;YAChC,SAA2B;YAC3B,SAAoC;YACpC,SAAmC;YACnC,SAAkC;YAClC,SAA4B;YAC5B,SAA4B;YAC5B;gBACI,SAAS,GAAsB,IAAK,CAAC,IAAI,CAAC;gBAC1C,KAAK,CAAC;YACV;gBACI,MAAM,CAAC,4BAA4B,CAAC,UAAU,EAAiB,IAAI,CAAC,CAAC;QAC7E,CAAC;QAED,EAAE,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC,CAAC;YAG1B,MAAM,CAAC,wBAAwB,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1D,CAAC;QAED,IAAM,GAAG,GAAG,aAAa,CAAC,SAAS,CAAC;YAChC,CAAC,CAAC,SAAS,CAAC,GAAG;YACf,CAAC,CAAC,GAAA,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC;QAEjD,MAAM,CAAC,GAAA,wBAAwB,CAAC,GAAG,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC;IACxD,CAAC;IA3Ce,sBAAmB,sBA2ClC,CAAA;IAED,oCAA2C,IAAgB;QACvD,MAAM,CAAC,CAAC,IAAI,CAAC,uBAAuB,IAAI,IAAI,CAAC,uBAAuB,CAAC,KAAK,SAAS,CAAC;IACxF,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;IACrE,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,iBAAwB,IAAU;QAC9B,MAAM,CAAC,CAAC,CAAC,CAAC,GAAA,oBAAoB,CAAC,IAAI,CAAC,IAAkB,CAAC;eAChD,CAAC,CAAC,CAAC,GAAA,wBAAwB,CAAC,IAAI,CAAC,OAAsB,CAAC,CAAC;IACpE,CAAC;IAHe,UAAO,UAGtB,CAAA;IAED,eAAsB,IAAU;QAC5B,MAAM,CAAC,CAAC,CAAC,CAAC,GAAA,oBAAoB,CAAC,IAAI,CAAC,IAAgB,CAAC,CAAC;IAC1D,CAAC;IAFe,QAAK,QAEpB,CAAA;IAED,qBAA4B,CAAO;QAC/B,MAAM,CAAC,CAAC,CAAC,IAAI,QAA8B,IAAqB,CAAE,CAAC,UAAU,CAAC,IAAI,OAA4B,CAAC;IACnH,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,sBAA6B,CAAO;QAChC,MAAM,CAAC,CAAC,CAAC,IAAI,QAA8B,IAAqB,CAAE,CAAC,UAAU,CAAC,IAAI,OAA6B,CAAC;IACpH,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC;eACtB,IAAK,CAAC,UAAU,CAAC,IAAI,MAA6B,CAAC;IACpF,CAAC;IAHe,sBAAmB,sBAGlC,CAAA;IAED,uCAA8C,IAAU,EAAE,gBAA4B;QAClF,MAAM,CAAC,IAAI,CAAC,IAAI,OAAuB,CAAC,CAAC,CAAC,GAAA,uBAAuB,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACnH,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,+BAAsC,IAAU,EAAE,IAAY;QAC1D,IAAM,aAAa,GAAG,CAAC,IAAI,CAAC,IAAI,QAAyB;YACrD,IAAI,CAAC,IAAI,QAA6B;YACtC,IAAI,CAAC,IAAI,QAAkC;YAC3C,IAAI,CAAC,IAAI,QAA6B;YACtC,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YACnD,GAAA,WAAW,CAAC,GAAA,wBAAwB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,GAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAChG,GAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAE5C,MAAM,CAAC,GAAA,MAAM,CAAC,aAAa,EAAE,UAAA,OAAO;YAChC,OAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,OAA4B;gBAC5D,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,OAA4B;gBAC5D,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,OAAyB;QAFzD,CAEyD,CAAC,CAAC;IACnE,CAAC;IAbe,wBAAqB,wBAapC,CAAA;IAKY,oCAAiC,GAAG,wDAAwD,CAAC;IAC7F,sCAAmC,GAAG,+CAA+C,CAAC;IAEnG,IAAM,mDAAmD,GAAG,yDAAyD,CAAC;IACtH,IAAM,qDAAqD,GAAG,gDAAgD,CAAC;IAElG,uCAAoC,GAAG,6DAA6D,CAAC;IACrG,yCAAsC,GAAG,kDAAkD,CAAC;IAEzG,IAAM,wBAAwB,GAAG,kEAAkE,CAAC;IACpG,IAAM,0BAA0B,GAAG,qDAAqD,CAAC;IAEzF,0BAAiC,IAAU;QACvC,EAAE,CAAC,CAAC,OAA4B,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,OAA2B,CAAC,CAAC,CAAC;YAChF,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA2B;YAC3B,SAA8B;YAC9B,SAA8B;YAC9B,SAA+B;YAC/B,SAA8B;YAC9B,SAAiC;YACjC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAA8B,CAAC;YAC1D;gBACI,MAAM,CAAC,CAAC,iDAAiD,CAAC,IAAI,CAAC,CAAC;YAIpE;gBAEI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAA6B,IAAoB,IAAI,CAAC,MAAO,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;oBAC/F,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;gBACvB,CAAC;gBACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAwC,IAA+B,IAAI,CAAC,MAAO,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;oBACzH,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;gBACvB,CAAC;gBAED,GAAA,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA0B,IAAI,IAAI,CAAC,IAAI,QAA6B,IAAI,IAAI,CAAC,IAAI,QAAwC,EAC3I,kGAAkG,CAAC,CAAC;YAE5G,SAA8B;YAC9B,SAAyC;YACzC;gBACI,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;gBAC3B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAAyB,CAAC,CAAC,CAAC;oBACvC,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;gBAOD,EAAE,CAAC,CAAC,OAA4B,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,OAA2B,CAAC,CAAC,CAAC;oBACpF,MAAM,CAAC,IAAI,CAAC;gBAChB,CAAC;gBACD,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;oBAClB;wBACI,MAAM,CAAC,CAAC,iDAAiD,CAAC,MAAM,CAAC,CAAC;oBACtE;wBACI,MAAM,CAAC,IAAI,KAAgC,MAAO,CAAC,UAAU,CAAC;oBAClE,SAAoC;oBACpC,SAAkC;oBAClC,SAA0B;oBAC1B;wBACI,MAAM,CAAC,IAAI,KAA+B,MAAO,CAAC,IAAI,CAAC;oBAC3D,SAAoC;oBACpC,SAAmC;oBACnC,SAA8B;oBAC9B,SAA4B;oBAC5B,SAAkC;oBAClC,SAAgC;oBAChC,SAA4B;oBAC5B;wBACI,MAAM,CAAC,IAAI,KAA+B,MAAO,CAAC,IAAI,CAAC;oBAC3D,SAA8B;oBAC9B,SAAmC;oBACnC;wBACI,MAAM,CAAC,IAAI,KAA4B,MAAO,CAAC,IAAI,CAAC;oBACxD;wBACI,MAAM,CAAC,IAAI,KAAqB,MAAO,CAAC,IAAI,CAAC;oBACjD,SAA+B;oBAC/B;wBACI,MAAM,CAAkB,MAAO,CAAC,aAAa,IAAI,GAAA,OAAO,CAAkB,MAAO,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChH;wBAEI,MAAM,CAAC,KAAK,CAAC;gBACrB,CAAC;QACT,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IApFe,mBAAgB,mBAoF/B,CAAA;IAED,+BAAsC,IAAU,EAAE,IAAgB;QAC9D,OAAO,IAAI,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,wBAAqB,wBAQpC,CAAA;IAID,gCAA0C,IAAW,EAAE,OAAqC;QAExF,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEtB,kBAAkB,IAAU;YACxB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB;oBACI,MAAM,CAAC,OAAO,CAAkB,IAAI,CAAC,CAAC;gBAC1C,SAA0B;gBAC1B,SAAsB;gBACtB,SAA4B;gBAC5B,SAA4B;gBAC5B,SAA+B;gBAC/B,SAA6B;gBAC7B,SAA+B;gBAC/B,SAA+B;gBAC/B,SAA8B;gBAC9B,SAAgC;gBAChC,SAA2B;gBAC3B,SAA8B;gBAC9B,SAAiC;gBACjC,SAA6B;gBAC7B;oBACI,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YAC5C,CAAC;QACL,CAAC;IACL,CAAC;IA1Be,yBAAsB,yBA0BrC,CAAA;IAED,gCAAuC,IAAW,EAAE,OAAwC;QAExF,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEtB,kBAAkB,IAAU;YACxB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB;oBACI,OAAO,CAAkB,IAAI,CAAC,CAAC;oBAC/B,IAAM,OAAO,GAAqB,IAAK,CAAC,UAAU,CAAC;oBACnD,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACV,QAAQ,CAAC,OAAO,CAAC,CAAC;oBACtB,CAAC;oBACD,MAAM,CAAC;gBACX,SAAgC;gBAChC,SAAqC;gBACrC,SAAkC;gBAClC,SAAqC;gBACrC,SAAiC;gBACjC;oBAII,MAAM,CAAC;gBACX;oBACI,EAAE,CAAC,CAAC,GAAA,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACvB,IAAM,IAAI,GAA6B,IAAK,CAAC,IAAI,CAAC;wBAClD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAoC,CAAC,CAAC,CAAC;4BAGxD,QAAQ,CAAwB,IAAK,CAAC,UAAU,CAAC,CAAC;4BAClD,MAAM,CAAC;wBACX,CAAC;oBACL,CAAC;oBACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBAG/B,GAAA,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;oBACjC,CAAC;YACT,CAAC;QACL,CAAC;IACL,CAAC;IAxCe,yBAAsB,yBAwCrC,CAAA;IAQD,qCAA4C,IAAc;QACtD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAyB,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAiB,IAAK,CAAC,WAAW,CAAC;QAC7C,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAA6B,CAAC,CAAC,CAAC;YACtD,MAAM,CAAC,GAAA,iBAAiB,CAAqB,IAAK,CAAC,aAAa,CAAC,CAAC;QACtE,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;IACL,CAAC;IAVe,8BAA2B,8BAU1C,CAAA;IAED,wBAA+B,IAAU;QACrC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB,SAA+B;gBAC/B,SAA2B;gBAC3B,SAA0B;gBAC1B,SAAmC;gBACnC,SAAoC;gBACpC,SAAkC;gBAClC,SAA4C;gBAC5C;oBACI,MAAM,CAAC,IAAI,CAAC;YACpB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAfe,iBAAc,iBAe7B,CAAA;IAED,yCAAgD,IAAU;QACtD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAkC;YAClC,SAAgC;YAChC,SAA4B;YAC5B,SAA4B;YAC5B,SAA4B;YAC5B,SAAoC;YACpC;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAZe,kCAA+B,kCAY9C,CAAA;IAED,yCAAgD,IAAsB,EAAE,yBAA4D;QAChI,OAAO,IAAI,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,yBAAyB,CAAC,CAAC,CAAC;gBAC5B,yBAAyB,CAAC,IAAI,CAAC,CAAC;YACpC,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,QAAgC,CAAC,CAAC,CAAC;gBACtD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;YAC1B,CAAC;YACD,IAAI,GAAqB,IAAI,CAAC,SAAS,CAAC;QAC5C,CAAC;IACL,CAAC;IAVe,kCAA+B,kCAU9C,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAqB,IAAI,GAAA,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjF,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAiC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,QAAuC,CAAC;IACzH,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,gDAAuD,IAAU;QAC7D,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC;YAC7C,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAuC;gBACpD,IAAI,CAAC,MAAM,CAAC,IAAI,QAA+B,CAAC,CAAC;IAC7D,CAAC;IAJe,yCAAsC,yCAIrD,CAAA;IAED,mCAA0C,SAAwB;QAC9D,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,MAAiC,CAAC;IACxE,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,6BAAoC,SAAwB;QACxD,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,MAA2B,CAAC;IAClE,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,+BAAsC,aAAsC,EAAE,GAAW,EAAE,IAAa;QACpG,MAAM,CAAC,GAAA,MAAM,CAAC,aAAa,CAAC,UAAU,EAAE,UAAC,QAAQ;YAC7C,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,QAAkC,CAAC,CAAC,CAAC;gBAClD,IAAM,QAAQ,GAAG,qBAAqB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACtD,MAAM,CAAC,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAC;YAC3D,CAAC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAPe,wBAAqB,wBAOpC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,GAAA,cAAc,CAAC,CAAC;IACrD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,GAAA,WAAW,CAAC,CAAC;IAClD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,0BAAiC,IAAU,EAAE,qBAA8B;QACvE,OAAO,IAAI,EAAE,CAAC;YACV,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;YACnB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;YACD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB;oBAKI,EAAE,CAAC,CAAC,GAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAClC,MAAM,CAAC,IAAI,CAAC;oBAChB,CAAC;oBAMD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;oBACnB,KAAK,CAAC;gBACV;oBAEI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAyB,IAAI,GAAA,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAGlF,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;oBAC9B,CAAC;oBACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAA,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAGnC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;oBACvB,CAAC;oBACD,KAAK,CAAC;gBACV;oBACI,EAAE,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC;wBACzB,QAAQ,CAAC;oBACb,CAAC;gBAEL,SAAoC;gBACpC,SAAmC;gBACnC,SAAkC;gBAClC,SAAoC;gBACpC,SAAkC;gBAClC,SAAkC;gBAClC,SAAgC;gBAChC,SAA4B;gBAC5B,SAA4B;gBAC5B,SAA4B;gBAC5B,SAA8B;gBAC9B,SAAmC;gBACnC,SAA+B;gBAC/B,SAAgC;gBAChC;oBACI,MAAM,CAAC,IAAI,CAAC;YACpB,CAAC;QACL,CAAC;IACL,CAAC;IA1De,mBAAgB,mBA0D/B,CAAA;IAED,+BAAsC,IAAU;QAC5C,IAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,EAA4B,KAAK,CAAC,CAAC;QAC1E,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;gBACrB,SAA4B;gBAC5B,SAAoC;gBACpC;oBACI,MAAM,CAAC,SAAS,CAAC;YACzB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAZe,wBAAqB,wBAYpC,CAAA;IAUD,2BAAkC,IAAU,EAAE,eAAwB;QAClE,OAAO,IAAI,EAAE,CAAC;YACV,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;YACnB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YACD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB;oBACI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;oBACnB,KAAK,CAAC;gBACV,SAAoC;gBACpC,SAAmC;gBACnC;oBACI,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;wBACnB,QAAQ,CAAC;oBACb,CAAC;gBAEL,SAAoC;gBACpC,SAAkC;gBAClC,SAAkC;gBAClC,SAAgC;gBAChC,SAA4B;gBAC5B,SAA4B;gBAC5B;oBACI,MAAM,CAAC,IAAI,CAAC;gBAChB;oBAEI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAyB,IAAI,GAAA,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAGlF,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;oBAC9B,CAAC;oBACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAA,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAGnC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;oBACvB,CAAC;oBACD,KAAK,CAAC;YACd,CAAC;QACL,CAAC;IACL,CAAC;IAxCe,oBAAiB,oBAwChC,CAAA;IAED,iDAAwD,IAAU;QAC9D,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAkC,IAAI,IAAI,CAAC,IAAI,QAA6B,CAAC,CAAC,CAAC;YACxF,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YACzB,OAAO,MAAM,CAAC,IAAI,QAAuC,EAAE,CAAC;gBACxD,IAAI,GAAG,MAAM,CAAC;gBACd,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;YAC3B,CAAC;YACD,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAA8B,IAAK,MAAyB,CAAC,UAAU,KAAK,IAAI,CAAC,CAAC,CAAC;gBAC9F,MAAM,CAAC,MAAwB,CAAC;YACpC,CAAC;QACL,CAAC;IACL,CAAC;IAZe,0CAAuC,0CAYtD,CAAA;IAKD,yBAAgC,IAAU;QACtC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,CAAC,IAAI,QAAwC,IAAI,IAAI,QAAuC,CAAC;eACxC,IAAK,CAAC,UAAU,CAAC,IAAI,OAA4B,CAAC;IAClH,CAAC;IAJe,kBAAe,kBAI9B,CAAA;IAED,mCAA0C,IAAc;QACpD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAqB,IAAK,CAAC,QAAQ,CAAC;YAE9C;gBACI,MAAM,CAAC,sBAAsB,CAA+B,IAAK,CAAC,UAAU,CAAC;oBACzE,CAAC,CAAqD,IAAK,CAAC,UAAU;oBACtE,CAAC,CAAC,SAAS,CAAC;YAEpB,QAA2B;YAC3B;gBACI,MAAM,CAAoB,IAAK,CAAC;QACxC,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAhBe,4BAAyB,4BAgBxC,CAAA;IAED,8BAAqC,IAAwB;QACzD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAwC,CAAC,CAAC,CAAC;YACpD,MAAM,CAA4B,IAAK,CAAC,GAAG,CAAC;QAChD,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAA,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;QAGD,MAAM,CAA8B,IAAK,CAAC,UAAU,CAAC;IACzD,CAAC;IAVe,uBAAoB,uBAUnC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBAEI,MAAM,CAAC,IAAI,CAAC;YAEhB;gBAEI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAgC,CAAC;YAE5D,SAA4B;YAC5B,SAA4B;YAC5B;gBAEI,MAAM,CAA2B,IAAK,CAAC,IAAI,KAAK,SAAS;uBAClD,IAAI,CAAC,MAAM,CAAC,IAAI,QAAgC,CAAC;YAE5D;gBAEI,MAAM,CAA2B,IAAI,CAAC,MAAO,CAAC,IAAI,KAAK,SAAS;uBACzD,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAA2B;2BACxC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAiC;2BACjD,IAAI,CAAC,MAAM,CAAC,IAAI,QAA2B,CAAC;uBAChD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,QAAgC,CAAC;QACvE,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IA3Be,qBAAkB,qBA2BjC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,UAAU,KAAK,SAAS;eAC7B,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAHe,kBAAe,kBAG9B,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAC3D,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAC,GAAA,OAAO,CAAoB,IAAK,CAAC,OAAO,EAAE,sBAAsB,CAAC,CAAC;YAC7E,SAAkC;YAClC;gBACI,MAAM,CAAC,GAAA,OAAO,CAA2B,IAAK,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;QACpF,CAAC;IACL,CAAC;IARe,mBAAgB,mBAQ/B,CAAA;IAED,sBAA6B,IAAU;QACnC,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAAiC;YAC5C,MAAM,CAAC,IAAI,QAAqC;YAChD,MAAM,CAAC,IAAI,QAAiC,CAAC,CAAC,CAAC;YAC/C,MAAM,CAAyB,MAAO,CAAC,OAAO,KAAK,IAAI,CAAC;QAC5D,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,eAAY,eAQ3B,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,QAA6B;YAC7B,QAA4B;YAC5B,SAA4B;YAC5B,QAA6B;YAC7B,QAAyC;YACzC,SAAuC;YACvC,SAAwC;YACxC,SAAyC;YACzC,SAAwC;YACxC,SAA+B;YAC/B,SAA8B;YAC9B,SAAyC;YACzC,SAA6B;YAC7B,SAAwC;YACxC,SAAkC;YAClC,SAAwC;YACxC,SAAmC;YACnC,SAAgC;YAChC,SAA8B;YAC9B,SAA+B;YAC/B,SAAiC;YACjC,SAAiC;YACjC,SAAsC;YACtC,SAAuC;YACvC,SAAiC;YACjC,SAAsC;YACtC,SAA8B;YAC9B,SAAmC;YACnC,QAA8C;YAC9C,SAAkC;YAClC,SAA2B;YAC3B,SAAsC;YACtC,SAAgC;YAChC,SAAgC;YAChC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,QAA6B,EAAE,CAAC;oBACnD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;gBACvB,CAAC;gBACD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAyB,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;YAC3E;gBACI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAyB,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAClE,MAAM,CAAC,IAAI,CAAC;gBAChB,CAAC;YAEL,OAA+B;YAC/B,OAA8B;YAC9B;gBACI,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACvC;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAvDe,qBAAkB,qBAuDjC,CAAA;IAED,+BAAsC,IAAU;QAC5C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,SAAoC;YACpC,SAA0B;YAC1B,SAAoC;YACpC,SAAkC;YAClC,SAA2B;YAC3B,SAAmC;YACnC;gBACI,MAAM,CAA2B,MAAO,CAAC,WAAW,KAAK,IAAI,CAAC;YAClE,SAAoC;YACpC,SAA4B;YAC5B,SAA4B;YAC5B,SAA+B;YAC/B,SAAgC;YAChC,SAA8B;YAC9B,SAAgC;YAChC,SAA2B;YAC3B;gBACI,MAAM,CAAuB,MAAO,CAAC,UAAU,KAAK,IAAI,CAAC;YAC7D;gBACI,IAAM,YAAY,GAAiB,MAAM,CAAC;gBAC1C,MAAM,CAAC,CAAC,YAAY,CAAC,WAAW,KAAK,IAAI,IAAI,YAAY,CAAC,WAAW,CAAC,IAAI,QAAuC,CAAC;oBAC9G,YAAY,CAAC,SAAS,KAAK,IAAI;oBAC/B,YAAY,CAAC,WAAW,KAAK,IAAI,CAAC;YAC1C,SAA+B;YAC/B;gBACI,IAAM,cAAc,GAAoC,MAAM,CAAC;gBAC/D,MAAM,CAAC,CAAC,cAAc,CAAC,WAAW,KAAK,IAAI,IAAI,cAAc,CAAC,WAAW,CAAC,IAAI,QAAuC,CAAC;oBAClH,cAAc,CAAC,UAAU,KAAK,IAAI,CAAC;YAC3C,SAAwC;YACxC;gBACI,MAAM,CAAC,IAAI,KAA2B,MAAO,CAAC,UAAU,CAAC;YAC7D;gBACI,MAAM,CAAC,IAAI,KAAoB,MAAO,CAAC,UAAU,CAAC;YACtD;gBACI,MAAM,CAAC,IAAI,KAA4B,MAAO,CAAC,UAAU,CAAC;YAC9D,SAA0B;YAC1B,SAA8B;YAC9B,SAAmC;YACnC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAA+B,MAAO,CAAC,UAAU,KAAK,IAAI,IAAI,iDAAiD,CAAC,MAAM,CAAC,CAAC;YAClI;gBACI,MAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;QAC1C,CAAC;IACL,CAAC;IAhDe,wBAAqB,wBAgDpC,CAAA;IAED,iDAAwD,IAAU;QAC9D,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,IAA8B,IAAK,CAAC,eAAe,CAAC,IAAI,QAAuC,CAAC;IAC3J,CAAC;IAFe,0CAAuC,0CAEtD,CAAA;IAED,4DAAmE,IAAU;QACzE,GAAA,KAAK,CAAC,MAAM,CAAC,uCAAuC,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5D,MAAM,CAAqD,IAAK,CAAC,eAAgB,CAAC,UAAU,CAAC;IACjG,CAAC;IAHe,qDAAkD,qDAGjE,CAAA;IAED,iDAAwD,IAAU;QAC9D,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,IAA8B,IAAK,CAAC,eAAe,CAAC,IAAI,QAAuC,CAAC;IAC3J,CAAC;IAFe,0CAAuC,0CAEtD,CAAA;IAED,gCAAuC,IAAgB;QACnD,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,4BAAmC,IAAsB;QACrD,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,QAA2B,CAAC,CAAC;IAC7D,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,mBAA0B,IAAsB;QAC5C,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,UAAkB,CAAC,CAAC;IACpD,CAAC;IAFe,YAAS,YAExB,CAAA;IAED,+BAAsC,IAAqD;QACvF,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC;YAC5B,GAAA,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC3B,IAAI,CAAC,QAAQ,CAAC,WAAW,KAAK,QAAQ;YACtC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC;YACrD,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,QAA6B,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,QAA6B,CAAC,CAAC;IAC7H,CAAC;IANe,wBAAqB,wBAMpC,CAAA;IAOD,uBAA8B,cAAoB,EAAE,4BAAqC;QACrF,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,QAA8B,CAAC,CAAC,CAAC;YACpD,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACK,IAAA,mBAAkE,EAAhE,0BAAU,EAAE,mBAAe,CAAsC;QAEzE,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,OAA0B,IAAI,CAAE,UAAyB,CAAC,WAAW,KAAK,SAAS,IAAK,UAAyB,CAAC,WAAW,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;YACzJ,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,IAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACpB,MAAM,CAAC,CAAC,4BAA4B,IAAI,GAAG,CAAC,IAAI,MAA6B,IAAI,GAAG,CAAC,IAAI,OAA6C,CAAC;IAC3I,CAAC;IAfe,gBAAa,gBAe5B,CAAA;IAED,+BAAsC,QAAgB;QAClD,MAAM,CAAC,QAAQ,OAA+B,IAAI,QAAQ,OAA+B,CAAC;IAC9F,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,8BAAqC,MAAqB,EAAE,UAAsB;QAC9E,MAAM,CAAC,iCAAiC,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,OAA+B,CAAC;IAC9G,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAMD,kDAAyD,CAAS;QAC9D,EAAE,CAAC,CAAC,CAAC,CAAC,gBAAgB,IAAI,CAAC,CAAC,gBAAgB,CAAC,IAAI,QAAmC,CAAC,CAAC,CAAC;YACnF,IAAM,WAAW,GAAG,CAAC,CAAC,gBAAuC,CAAC;YAC9D,MAAM,CAAC,WAAW,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,QAAkC,IAAI,WAAW,CAAC,WAAW,CAAC,IAAI,QAA+B,CAAC,CAAC;QACtK,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IANe,2CAAwC,2CAMvD,CAAA;IAED,wCAA+C,IAAU;QACrD,OAAO,sBAAsB,CAAC,IAAI,EAAkC,IAAI,CAAC,EAAE,CAAC;YACxE,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;QACtB,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IALe,iCAA8B,iCAK7C,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC;IAChE,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,iDAAwD,IAAU;QAC9D,MAAM,CAAC,GAAA,0BAA0B,CAAC,IAAI,CAAC,IAAI,GAAA,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,WAAW,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC;IAChK,CAAC;IAFe,0CAAuC,0CAEtD,CAAA;IAID,0CAAiD,IAAyB;QACtE,EAAE,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,GAAoC;QAC9C,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,OAA2B,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,QAAwC,CAAC,CAAC,CAAC;YAC/G,MAAM,GAAoC;QAC9C,CAAC;QACD,IAAM,GAAG,GAA6B,IAAI,CAAC,IAAI,CAAC;QAChD,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;YAChD,IAAM,KAAK,GAAe,GAAG,CAAC,UAAU,CAAC;YACzC,EAAE,CAAC,CAAC,KAAK,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC;gBAElC,MAAM,GAA+C;YACzD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,WAAW,KAAK,QAAQ,IAAI,GAAG,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC;gBAE5E,MAAM,GAA6C;YACvD,CAAC;YACD,IAAI,CAAC,CAAC;gBAEF,MAAM,GAAwC;YAClD,CAAC;QACL,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,OAA2B,CAAC,CAAC,CAAC;YACtD,MAAM,GAA4C;QACtD,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,QAAwC,CAAC,CAAC,CAAC;YAEnE,IAAM,mBAAmB,GAA6B,GAAG,CAAC,UAAU,CAAC;YACrE,EAAE,CAAC,CAAC,mBAAmB,CAAC,UAAU,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;gBAEhE,IAAM,6BAA6B,GAAe,mBAAmB,CAAC,UAAU,CAAC;gBACjF,EAAE,CAAC,CAAC,6BAA6B,CAAC,WAAW,KAAK,QAAQ,IAAI,mBAAmB,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC;oBAC/G,MAAM,GAA+C;gBACzD,CAAC;gBACD,EAAE,CAAC,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,KAAK,WAAW,CAAC,CAAC,CAAC;oBACvD,MAAM,GAAiD;gBAC3D,CAAC;YACL,CAAC;QACL,CAAC;QAGD,MAAM,GAAoC;IAC9C,CAAC;IA3Ce,mCAAgC,mCA2C/C,CAAA;IAED,+BAAsC,IAAU;QAC5C,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAqB,IAAK,CAAC,eAAe,CAAC;QACrD,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YACnD,IAAM,SAAS,GAA6B,IAAK,CAAC,eAAe,CAAC;YAClE,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;gBACxD,MAAM,CAA2B,SAAU,CAAC,UAAU,CAAC;YAC3D,CAAC;QACL,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAqB,IAAK,CAAC,eAAe,CAAC;QACrD,CAAC;QACD,EAAE,CAAC,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;IACL,CAAC;IAhBe,wBAAqB,wBAgBpC,CAAA;IAED,qCAA4C,IAAqE;QAC7G,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YACnD,MAAM,CAA0B,IAAI,CAAC;QACzC,CAAC;QAED,IAAM,YAAY,GAAuB,IAAK,CAAC,YAAY,CAAC;QAC5D,EAAE,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,aAAa,IAAI,YAAY,CAAC,aAAa,CAAC,IAAI,QAA+B,CAAC,CAAC,CAAC;YAC/G,MAAM,CAAkB,YAAY,CAAC,aAAa,CAAC;QACvD,CAAC;IACL,CAAC;IATe,8BAA2B,8BAS1C,CAAA;IAED,yBAAgC,IAAqE;QACjG,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC;eACtB,IAAK,CAAC,YAAY;eACtC,CAAC,CAAqB,IAAK,CAAC,YAAY,CAAC,IAAI,CAAC;IACzD,CAAC;IAJe,kBAAe,kBAI9B,CAAA;IAED,0BAAiC,IAAU;QACvC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChB,SAA0B;gBAC1B,SAAkC;gBAClC,SAAgC;gBAChC,SAA4C;gBAC5C,SAAmC;gBACnC,SAAoC;gBACpC;oBACI,MAAM,CAAkE,IAAK,CAAC,aAAa,KAAK,SAAS,CAAC;YAClH,CAAC;QACL,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAfe,mBAAgB,mBAe/B,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC;YAC5C,IAA0B,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;YAChD,IAA0B,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI;YAC5C,IAA0B,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAmB,CAAC,WAAW,KAAK,KAAK,CAAC;IAC7F,CAAC;IALe,4BAAyB,4BAKxC,CAAA;IAED,sBAA6B,IAAU;QACnC,EAAE,CAAC,CAAC,GAAA,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACzB,CAAC;QACD,MAAM,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IALe,eAAY,eAK3B,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,GAAA,qBAAqB,CAAC,IAAI,CAAC;YAC9B,IAAI,CAAC,UAAU,IAAI,GAAA,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC;YACtD,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,OAA2B;YAC7D,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;IAC9B,CAAC;IALe,wBAAqB,wBAKpC,CAAA;IAED,iDAAwD,IAAU,EAAE,KAAY;QAC5E,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC;YAC5B,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;YAC5C,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,KAAK,CAAC;YACtE,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IACzD,CAAC;IALe,0CAAuC,0CAKtD,CAAA;IAED,8CAAqD,IAAU,EAAE,KAAY;QACzE,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC;YAC5B,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;YAC5C,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC;YAC1D,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IALe,uCAAoC,uCAKnD,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC;YAC5C,IAA0B,CAAC,IAAI;YAC/B,IAA0B,CAAC,IAAI,CAAC,IAAI,QAAiC;YACrE,IAA0B,CAAC,IAAI,CAAC;IACzC,CAAC;IALe,6BAA0B,6BAKzC,CAAA;IAED,iCAAwC,IAAU;QAC9C,IAAI,MAAwC,CAAC;QAC7C,6BAA6B,CAAC,IAAI,CAAC,CAAC;QACpC,MAAM,CAAC,MAAM,IAAI,GAAA,UAAU,CAAC;QAE5B,uCAAuC,IAAU;YAC7C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAO3B,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,QAAkC,IAAI,0BAA0B,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClG,6BAA6B,CAAC,MAAM,CAAC,CAAC;YAC1C,CAAC;YACD,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM;gBACvB,CAAC,oCAAoC,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,qBAAqB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtG,6BAA6B,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACjD,CAAC;YACD,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,IAAI,uCAAuC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBACzH,6BAA6B,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACxD,CAAC;YAGD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC,CAAC,CAAC;gBACrC,MAAM,GAAG,GAAA,QAAQ,CAAC,MAAM,EAAE,GAAA,qBAAqB,CAAC,IAA4B,CAAC,CAAC,CAAC;YACnF,CAAC;YAED,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,IAAI,GAAA,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC9E,MAAM,GAAG,GAAA,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YACtD,CAAC;YAED,EAAE,CAAC,CAAC,GAAA,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACtB,MAAM,GAAG,GAAA,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YAC1C,CAAC;QACL,CAAC;IACL,CAAC;IArCe,0BAAuB,0BAqCtC,CAAA;IAGD,qCAA4C,IAAuB;QAC/D,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACd,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;QACnC,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAChC,IAAM,IAAI,GAAG,qBAAqB,CAAC,IAAI,CAAC;YACpC,uCAAuC,CAAC,IAAI,CAAC;YAC7C,oCAAoC,CAAC,IAAI,CAAC;YAC1C,0BAA0B,CAAC,IAAI,CAAC;YAChC,IAAI,CAAC;QACT,EAAE,CAAC,CAAC,IAAI,IAAI,GAAA,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAM,SAAS,GAAG,GAAA,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,EAApE,CAAoE,CAAC,CAAC;YACnH,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,CAAC;QACzC,CAAC;IACL,CAAC;IAlBe,8BAA2B,8BAkB1C,CAAA;IAED,sBAA6B,IAAc;QACvC,GAAA,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAO,CAAC,IAAI,QAA4B,CAAC,CAAC;QAC5D,MAAM,CAAC,IAAI,CAAC,MAAO,CAAC,MAAO,CAAC;IAChC,CAAC;IAHe,eAAY,eAG3B,CAAA;IAED,mCAA0C,IAA6D;QACnG,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;QAC3B,IAAA,yDAAc,CAA4G;QAClI,MAAM,CAAC,GAAA,IAAI,CAAC,cAAc,EAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,EAA3B,CAA2B,CAAC,CAAC;IAClE,CAAC;IAJe,4BAAyB,4BAIxC,CAAA;IAED,0BAAiC,CAAuB;QACpD,IAAM,IAAI,GAAG,GAAA,eAAe,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAC3C,MAAM,CAAC,IAAI,IAAI,eAAe,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IAHe,mBAAgB,mBAG/B,CAAA;IAED,yBAAgC,IAA0B;QACtD,MAAM,CAAC,IAAI,CAAC,cAAc,KAAK,SAAS,CAAC;IAC7C,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,IAAkB,cAEjB;IAFD,WAAkB,cAAc;QAC5B,mDAAI,CAAA;QAAE,2DAAQ,CAAA;QAAE,2DAAQ,CAAA;IAC5B,CAAC,EAFiB,cAAc,GAAd,iBAAc,KAAd,iBAAc,QAE/B;IAED,iCAAwC,IAAU;QAC9C,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,OAAO,IAAI,EAAE,CAAC;YACV,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB;oBACI,IAAM,cAAc,GAAsB,MAAO,CAAC,aAAa,CAAC,IAAI,CAAC;oBACrE,MAAM,CAAC,oBAAoB,CAAC,cAAc,CAAC,IAAuB,MAAO,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;wBACrF,cAAc,OAA2B,CAAC,CAAC,GAAyB,CAAC,EAAwB,CAAC,CAAC;yBAC5E,CAAC;gBAC5B,SAAsC;gBACtC;oBACI,IAAM,aAAa,GAAoD,MAAO,CAAC,QAAQ,CAAC;oBACxF,MAAM,CAAC,aAAa,OAA6B,IAAI,aAAa,OAA+B,CAAC,CAAC,GAAyB,CAAC,EAAoB,CAAC;gBACtJ,SAA+B;gBAC/B;oBACI,MAAM,CAAsB,MAAO,CAAC,WAAW,KAAK,IAAI,CAAC,CAAC,GAAyB,CAAC,EAAoB,CAAC;gBAC7G,SAAwC;gBACxC,SAAuC;gBACvC;oBACI,IAAI,GAAG,MAAM,CAAC;oBACd,KAAK,CAAC;gBACV;oBACI,EAAE,CAAC,CAAE,MAAsC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;wBACxD,MAAM,GAAqB;oBAC/B,CAAC;oBACD,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC;oBACrB,KAAK,CAAC;gBACV;oBACI,EAAE,CAAC,CAAE,MAAsC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;wBACxD,MAAM,GAAqB;oBAC/B,CAAC;oBACD,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC;oBACrB,KAAK,CAAC;gBACV;oBACI,MAAM,GAAqB;YACnC,CAAC;YACD,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,CAAC;IACL,CAAC;IAtCe,0BAAuB,0BAsCtC,CAAA;IAMD,4BAAmC,IAAU;QACzC,MAAM,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAwB,CAAC;IACjE,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAGD,wBAA+B,IAAU;QACrC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAwC,IAAI,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YACxG,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACnB,OAAO,IAAI,IAAI,IAAI,CAAC,IAAI,QAAuC,EAAE,CAAC;YAC9D,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAgC,CAAC;IAC7D,CAAC;IATe,iBAAc,iBAS7B,CAAA;IAED,4BAAmC,IAAU,EAAE,QAAc;QACzD,OAAO,IAAI,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,IAAI,KAAK,QAAQ,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YACnC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IANe,qBAAkB,qBAMjC,CAAA;IAED,4BAAmC,IAAU;QACzC,OAAO,IAAI,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,IAAwB,IAAI,CAAC,IAAI,CAAC,IAAI,QAA0B,IAAK,IAAmB,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBAC9H,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,qBAAkB,qBAQjC,CAAA;IAGD,2BAAkC,IAAU;QACxC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,QAA2B;YAC3B,OAA8B;YAC9B;gBACI,MAAM,CAAC,GAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC;YACnE;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IATe,oBAAiB,oBAShC,CAAA;IAID,8BAAqC,IAAU;QAC3C,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,QAA2B;YAC3B,OAA8B;YAC9B;gBACI,EAAE,CAAC,CAAC,GAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC;gBACrC,CAAC;gBACD,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;gBAClC,MAAM,CAAC,GAAA,kBAAkB,CAAC,MAAM,CAAC,IAAI,gCAAgC,CAAC,MAAM,CAAC,MAAuC,IAAI,GAAA,oBAAoB,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC;YAClK;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAbe,uBAAoB,uBAanC,CAAA;IAED,kDAAyD,IAAU;QAC/D,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B,IAAI,IAAI,CAAC,IAAI,MAA8B,CAAC;YACtF,IAAI,CAAC,MAAM,CAAC,IAAI,QAAoC;YACpD,GAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC1C,CAAC;IAJe,2CAAwC,2CAIvD,CAAA;IAGD,0BAAiC,IAAgB;QAC7C,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,SAAoC;YACpC,SAAkC;YAClC,SAAkC;YAClC,SAAgC;YAChC,SAA4B;YAC5B,SAA4B;YAC5B,SAA2B;YAC3B,SAAmC;YACnC;gBAEI,MAAM,CAA+C,MAAO,CAAC,IAAI,KAAK,IAAI,CAAC;YAC/E;gBAEI,EAAE,CAAC,CAAiB,MAAO,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;oBACzC,OAAO,MAAM,CAAC,IAAI,QAA6B,EAAE,CAAC;wBAC9C,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;oBAC3B,CAAC;oBACD,MAAM,CAAC,MAAM,CAAC,IAAI,QAAyB,CAAC;gBAChD,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC;YACjB,SAA+B;YAC/B;gBAEI,MAAM,CAAoC,MAAO,CAAC,YAAY,KAAK,IAAI,CAAC;YAC5E,SAAgC;YAChC;gBAEI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAjCe,mBAAgB,mBAiC/B,CAAA;IAUD,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC;YACnD,IAAI,CAAC,IAAI,QAA0C;YACnD,IAAI,CAAC,IAAI,QAA4B,IAAI,CAAC,CAAgB,IAAK,CAAC,IAAI;YACpE,IAAI,CAAC,IAAI,QAA+B;YACxC,IAAI,CAAC,IAAI,QAA+B;YACxC,IAAI,CAAC,IAAI,QAA+B;YACxC,IAAI,CAAC,IAAI,QAAgC,IAAI,uBAAuB,CAAmB,IAAI,CAAC,CAAC;IACrG,CAAC;IARe,2BAAwB,2BAQvC,CAAA;IAED,iCAAwC,IAAsB;QAC1D,MAAM,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,8CAAqD,IAAiD;QAClG,IAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,CAAC,eAAe,KAA4B,CAAC;QAC1F,MAAM,CAAC,cAAc,IAAI,cAAc,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACnG,CAAC;IAHe,uCAAoC,uCAGnD,CAAA;IAED,kDAAyD,IAA0B;QAC/E,IAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,CAAC,eAAe,MAA+B,CAAC;QAC7F,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;IAC7D,CAAC;IAHe,2CAAwC,2CAGvD,CAAA;IAED,mCAA0C,IAA0B;QAChE,IAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,CAAC,eAAe,KAA4B,CAAC;QAC1F,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;IAC7D,CAAC;IAHe,4BAAyB,4BAGxC,CAAA;IAED,2BAAkC,OAAkC,EAAE,IAAgB;QAClF,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACV,GAAG,CAAC,CAAiB,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;gBAAvB,IAAM,MAAM,gBAAA;gBACb,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;oBACxB,MAAM,CAAC,MAAM,CAAC;gBAClB,CAAC;aACJ;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAVe,oBAAiB,oBAUhC,CAAA;IAED,mCAA0C,IAAyB,EAAE,UAAsB,EAAE,SAAwB;QACjH,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;YACvC,IAAM,iBAAiB,GAAG,GAAA,gBAAgB,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAA,YAAY,CAAC,GAAA,gBAAgB,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC;YAC9J,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;QACjD,CAAC;IACL,CAAC;IALe,4BAAyB,4BAKxC,CAAA;IAED,qBAA4B,IAAsB,EAAE,IAAgB;QAChE,OAAO,IAAI,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;YACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IARe,cAAW,cAQ1B,CAAA;IAED,2CAAkD,OAAe,EAAE,YAA0B;QACzF,IAAM,oBAAoB,GAAG,4BAA4B,CAAC;QAC1D,IAAM,sBAAsB,GAAG,qBAAqB,CAAC;QACrD,IAAM,mBAAmB,GAAG,IAAI,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAC/E,IAAM,qBAAqB,GAAG,IAAI,MAAM,CAAC,0BAA0B,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QACnF,EAAE,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,sBAAsB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7E,EAAE,CAAC,CAAC,mBAAmB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,qBAAqB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC3E,MAAM,CAAC,EAAE,cAAc,EAAE,IAAI,EAAE,CAAC;YACpC,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,IAAM,cAAc,GAAG,GAAA,iCAAiC,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAA,mCAAmC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5H,IAAM,YAAY,GAAG,CAAC,cAAc,IAAI,CAAC,mDAAmD,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,qDAAqD,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;gBACnL,IAAM,KAAK,GAAG,cAAc,IAAI,YAAY,CAAC;gBAC7C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACR,IAAM,GAAG,GAAG,YAAY,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;oBACjE,MAAM,CAAC;wBACH,aAAa,EAAE;4BACX,GAAG,KAAA;4BACH,GAAG,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM;4BAC1B,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;yBACrB;wBACD,cAAc,EAAE,KAAK;wBACrB,wBAAwB,EAAE,CAAC,CAAC,YAAY;qBAC3C,CAAC;gBACN,CAAC;gBAED,MAAM,CAAC;oBACH,iBAAiB,EAAE,GAAA,WAAW,CAAC,kCAAkC;oBACjE,cAAc,EAAE,KAAK;iBACxB,CAAC;YACN,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAlCe,oCAAiC,oCAkChD,CAAA;IAED,mBAA0B,KAAiB;QACvC,MAAM,CAAC,MAA2B,KAAK,IAAI,KAAK,OAA0B,CAAC;IAC/E,CAAC;IAFe,YAAS,YAExB,CAAA;IAED,kBAAyB,KAAiB;QACtC,MAAM,CAAC,KAA+B,KAAK,IAAI,KAAK,KAA8B,CAAC;IACvF,CAAC;IAFe,WAAQ,WAEvB,CAAA;IAED,IAAkB,aAMjB;IAND,WAAkB,aAAa;QAC3B,qDAAU,CAAA;QACV,2DAAkB,CAAA;QAClB,mDAAc,CAAA;QACd,uDAAgB,CAAA;QAChB,qEAAkC,CAAA;IACtC,CAAC,EANiB,aAAa,GAAb,gBAAa,KAAb,gBAAa,QAM9B;IAED,0BAAiC,IAA8B;QAC3D,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,MAAM,GAAuB;QACjC,CAAC;QAED,IAAI,KAAK,IAAuB,CAAC;QACjC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAoC;YACpC,SAAmC;YACnC;gBACI,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;oBACrB,KAAK,KAA2B,CAAC;gBACrC,CAAC;YAEL;gBACI,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,MAAsB,CAAC,CAAC,CAAC;oBACzC,KAAK,KAAuB,CAAC;gBACjC,CAAC;gBACD,KAAK,CAAC;QACd,CAAC;QAED,EAAE,CAAC,CAAC,CAAE,IAAgC,CAAC,IAAI,CAAC,CAAC,CAAC;YAC1C,KAAK,KAAyB,CAAC;QACnC,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IA1Be,mBAAgB,mBA0B/B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAoC;YACpC,SAAmC;YACnC,SAA8B;YAC9B;gBACI,MAAM,CAA2B,IAAK,CAAC,IAAI,KAAK,SAAS;uBACxB,IAAK,CAAC,aAAa,KAAK,SAAS;uBAC3D,WAAW,CAAC,IAAI,MAAsB,CAAC;QACtD,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAXe,kBAAe,kBAW9B,CAAA;IAED,kCAAyC,IAAU;QAC/C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,MAA6B;eACjC,IAAI,MAA8B,CAAC;IAC9C,CAAC;IAJe,2BAAwB,2BAIvC,CAAA;IASD,wBAA+B,WAAwB;QACnD,IAAM,IAAI,GAAG,GAAA,oBAAoB,CAAC,WAAW,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,CAAC;IACvC,CAAC;IAHe,iBAAc,iBAG7B,CAAA;IAED,uBAA8B,IAAqB;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC;YAChD,CAAC,wBAAwB,CAAwB,IAAK,CAAC,UAAU,CAAC;YAClE,CAAC,8BAA8B,CAAwB,IAAK,CAAC,UAAU,CAAC,CAAC;IACjF,CAAC;IAJe,gBAAa,gBAI5B,CAAA;IAOD,wCAA+C,IAAgB;QAC3D,MAAM,CAAC,GAAA,0BAA0B,CAAC,IAAI,CAAC,IAAI,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACrF,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,4CAAmD,IAAqB;QACpE,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;QAC5B,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B,IAAI,IAAI,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;YACpF,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC,CAAC,CAAC;YAChD,IAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC;YACvC,EAAE,CAAC,CAAC,8BAA8B,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gBACjD,MAAM,CAAC,iCAAiC,CAAC,GAAA,MAAM,CAA4B,cAAe,CAAC,IAAI,CAAC,CAAC,CAAC;YACtG,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,MAA6B,IAAI,cAAc,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;gBAC7G,MAAM,CAAC,wBAAwB,CAAqB,cAAe,CAAC,IAAI,CAAC,CAAC;YAC9E,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAlBe,qCAAkC,qCAkBjD,CAAA;IAED,sCAA6C,IAAkC;QAC3E,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;gBACtC,MAAM,CAAC,GAAA,MAAM,CAAC,IAAkB,CAAC,CAAC;YACtC,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B;gBACtC,IAAI,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAE,IAAwB,CAAC,IAAI,CAAC;YAC1C,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAZe,+BAA4B,+BAY3C,CAAA;IAED,6CAAoD,IAAkC;QAClF,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;gBACtC,MAAM,CAAE,IAAmB,CAAC,WAAW,CAAC;YAC5C,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B;gBACtC,IAAI,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;gBAE1C,MAAM,CAAC,wBAAwB,CAAE,IAAwB,CAAC,IAAI,CAAC,CAAC;YACpE,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAbe,sCAAmC,sCAalD,CAAA;IAED,2CAAkD,UAAkB;QAChE,MAAM,CAAC,KAAK,GAAG,UAAsB,CAAC;IAC1C,CAAC;IAFe,oCAAiC,oCAEhD,CAAA;IAKD,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,OAA0B,IAAiB,IAAK,CAAC,WAAW,KAAK,QAAQ,CAAC;IAC9F,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,mCAA0C,IAAgB;QACtD,MAAM,CAAC,IAAI,CAAC,WAAW,KAAK,MAAM,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC;IACzE,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,gCAAuC,IAA6B;QAChE,IAAM,IAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAHe,yBAAsB,yBAGrC,CAAA;IAED,4BAAmC,IAAU;QACzC,OAAO,IAAI,CAAC,IAAI,QAA8B,EAAE,CAAC;YAC7C,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAC9B,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IALe,qBAAkB,qBAKjC,CAAA;IAED,yCAAgD,IAAU;QACtD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA2B;eAC/B,IAAI,QAAkC;eACtC,IAAI,QAAmC;eACvC,IAAI,QAA6B;eACjC,IAAI,QAAiC;eACrC,IAAI,QAA2B;eAC/B,IAAI,QAA2B;eAC/B,IAAI,QAAiC;eACrC,IAAI,QAA0B,CAAC;IAC1C,CAAC;IAXe,kCAA+B,kCAW9C,CAAA;IAED,2BAAkC,KAAgB;QAC9C,MAAM,CAAC,GAAA,qBAAqB,CAAC,KAAK,CAAC,GAAG,CAAC;eAChC,GAAA,qBAAqB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC5C,CAAC;IAHe,oBAAiB,oBAGhC,CAAA;IAED,+BAAsC,UAAsB;QACxD,MAAM,CAAC,GAAA,gBAAgB,CAAC,UAAU,EAAE,GAAA,YAAY,CAAC,IAAI,UAAU,CAAC;IACpE,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,IAAkB,aAGjB;IAHD,WAAkB,aAAa;QAC3B,iDAAI,CAAA;QACJ,mDAAK,CAAA;IACT,CAAC,EAHiB,aAAa,GAAb,gBAAa,KAAb,gBAAa,QAG9B;IAED,oCAA2C,UAAsB;QAC7D,IAAM,QAAQ,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;QACzC,IAAM,YAAY,GAAG,UAAU,CAAC,IAAI,QAA6B,IAAoB,UAAW,CAAC,SAAS,KAAK,SAAS,CAAC;QACzH,MAAM,CAAC,wBAAwB,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC;IAC7E,CAAC;IAJe,6BAA0B,6BAIzC,CAAA;IAED,kCAAyC,IAAgB,EAAE,QAAoB,EAAE,YAAsB;QACnG,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX;gBACI,MAAM,CAAC,YAAY,CAAC,CAAC,GAAoB,CAAC,EAAoB,CAAC;YAEnE,SAAsC;YACtC,SAAiC;YACjC,SAA+B;YAC/B,SAAiC;YACjC,SAAgC;YAChC,SAAsC;YACtC;gBACI,MAAM,GAAqB;YAE/B;gBACI,MAAM,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACf,QAAsC;oBACtC,QAA4B;oBAC5B,QAAgC;oBAChC,QAAiC;oBACjC,QAA4C;oBAC5C,QAAoC;oBACpC,QAAiC;oBACjC,QAAmC;oBACnC,QAA4C;oBAC5C,QAAkD;oBAClD,QAA6D;oBAC7D,QAAqC;oBACrC,QAAiC;oBACjC;wBACI,MAAM,GAAqB;gBACnC,CAAC;QACT,CAAC;QACD,MAAM,GAAoB;IAC9B,CAAC;IAlCe,2BAAwB,2BAkCvC,CAAA;IAED,iCAAwC,UAAsB;QAC1D,IAAM,QAAQ,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;QACzC,IAAM,YAAY,GAAG,UAAU,CAAC,IAAI,QAA6B,IAAoB,UAAW,CAAC,SAAS,KAAK,SAAS,CAAC;QACzH,MAAM,CAAC,qBAAqB,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC;IAC1E,CAAC;IAJe,0BAAuB,0BAItC,CAAA;IAED,qBAA4B,UAAsB;QAC9C,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,QAAgC,CAAC,CAAC,CAAC;YAClD,MAAM,CAAoB,UAAW,CAAC,aAAa,CAAC,IAAI,CAAC;QAC7D,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,QAAqC,IAAI,UAAU,CAAC,IAAI,QAAsC,CAAC,CAAC,CAAC;YACrH,MAAM,CAAkD,UAAW,CAAC,QAAQ,CAAC;QACjF,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC;QAC3B,CAAC;IACL,CAAC;IAVe,cAAW,cAU1B,CAAA;IAED,+BAAsC,QAAoB,EAAE,YAAwB,EAAE,YAAsB;QACxG,MAAM,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACf,QAA4B;YAC5B,QAA6B;YAC7B,QAA2B;YAC3B,QAA4B;YAC5B,SAA4B;YAC5B,QAA6B;YAC7B,OAA+B;YAC/B,OAA8B;YAC9B,SAAuC;YACvC,SAAwC;YACxC,SAAmC;YACnC,SAA8B;YAC9B,SAAgC;YAChC,SAA2B;YAC3B,SAAsC;YACtC,QAAyC;YACzC,QAA8C;YAC9C,SAAmC;YACnC,SAAwC;YACxC;gBACI,MAAM,CAAC,EAAE,CAAC;YAEd,SAAyC;YACzC,SAAyC;YACzC;gBACI,MAAM,CAAC,EAAE,CAAC;YAEd;gBACI,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;YAElC;gBACI,MAAM,CAAC,EAAE,CAAC;YAEd;gBACI,MAAM,CAAC,EAAE,CAAC;YAEd,SAAsC;YACtC,SAAiC;YACjC,SAA+B;YAC/B,SAAiC;YACjC;gBACI,MAAM,CAAC,EAAE,CAAC;YAEd;gBACI,MAAM,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBACnB,QAAiC;oBACjC;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd,QAAsC;oBACtC,QAA8B;oBAC9B,QAA2B;oBAC3B;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd,QAA0B;oBAC1B;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd,QAAsC;oBACtC,QAA4C;oBAC5C;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd,QAA8B;oBAC9B,QAAoC;oBACpC,QAAiC;oBACjC,QAAuC;oBACvC,QAA0B;oBAC1B;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd,QAAkC;oBAClC,QAAwC;oBACxC,QAAuC;oBACvC;wBACI,MAAM,CAAC,EAAE,CAAC;oBAEd;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb,QAA4B;oBAC5B,QAAgC;oBAChC,QAAiC;oBACjC,QAA4C;oBAC5C,QAAoC;oBACpC,QAAiC;oBACjC,QAAmC;oBACnC,QAA4C;oBAC5C,QAAkD;oBAClD,QAA6D;oBAC7D,QAAqC;oBACrC,QAAiC;oBACjC;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC;oBAEb;wBACI,MAAM,CAAC,CAAC,CAAC,CAAC;gBAClB,CAAC;YAEL;gBACI,MAAM,CAAC,CAAC,CAAC;YAEb;gBACI,MAAM,CAAC,CAAC,CAAC;YAEb;gBACI,MAAM,CAAC,CAAC,CAAC;YAEb;gBACI,MAAM,CAAC,CAAC,CAAC;YAEb;gBACI,MAAM,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACL,CAAC;IApIe,wBAAqB,wBAoIpC,CAAA;IAED;QACI,IAAI,kBAAkB,GAAiB,EAAE,CAAC;QAC1C,IAAM,eAAe,GAAG,GAAA,SAAS,EAAgB,CAAC;QAElD,IAAI,mBAAmB,GAAG,KAAK,CAAC;QAChC,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAE1B,MAAM,CAAC;YACH,GAAG,KAAA;YACH,oBAAoB,sBAAA;YACpB,cAAc,gBAAA;YACd,oBAAoB,sBAAA;YACpB,uBAAuB,yBAAA;SAC1B,CAAC;QAEF;YACI,MAAM,CAAC,iBAAiB,CAAC;QAC7B,CAAC;QAED,iCAAiC,OAAmB;YAChD,GAAA,OAAO,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,IAAI,GAAG,OAAO,EAAzB,CAAyB,CAAC,CAAC;QAC5F,CAAC;QAED,aAAa,UAAsB;YAC/B,IAAI,WAAyB,CAAC;YAC9B,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB,WAAW,GAAG,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC5D,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBACf,WAAW,GAAG,EAAE,CAAC;oBACjB,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBAC/D,CAAC;YACL,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,WAAW,GAAG,kBAAkB,CAAC;YACrC,CAAC;YAED,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC7B,mBAAmB,GAAG,IAAI,CAAC;YAC3B,iBAAiB,EAAE,CAAC;QACxB,CAAC;QAED;YACI,kBAAkB,EAAE,CAAC;YACrB,MAAM,CAAC,kBAAkB,CAAC;QAC9B,CAAC;QAED,wBAAwB,QAAiB;YACrC,kBAAkB,EAAE,CAAC;YACrB,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACX,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC/C,CAAC;YAED,IAAM,cAAc,GAAiB,EAAE,CAAC;YACxC,wBAAwB,CAAa;gBACjC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,CAAC;YAED,GAAA,OAAO,CAAC,kBAAkB,EAAE,cAAc,CAAC,CAAC;YAE5C,eAAe,CAAC,OAAO,CAAC,UAAA,WAAW;gBAC/B,GAAA,OAAO,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;YACzC,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,GAAA,6BAA6B,CAAC,cAAc,CAAC,CAAC;QACzD,CAAC;QAED;YACI,EAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBACvB,MAAM,CAAC;YACX,CAAC;YAED,mBAAmB,GAAG,KAAK,CAAC;YAC5B,kBAAkB,GAAG,GAAA,6BAA6B,CAAC,kBAAkB,CAAC,CAAC;YAEvE,eAAe,CAAC,OAAO,CAAC,UAAC,WAAW,EAAE,GAAG;gBACrC,eAAe,CAAC,GAAG,CAAC,GAAG,EAAE,GAAA,6BAA6B,CAAC,WAAW,CAAC,CAAC,CAAC;YACzE,CAAC,CAAC,CAAC;QACP,CAAC;IACL,CAAC;IA9Ee,6BAA0B,6BA8EzC,CAAA;IAOD,IAAM,6BAA6B,GAAG,oDAAoD,CAAC;IAC3F,IAAM,6BAA6B,GAAG,oDAAoD,CAAC;IAC3F,IAAM,+BAA+B,GAAG,oDAAoD,CAAC;IAC7F,IAAM,eAAe,GAAG,GAAA,qBAAqB,CAAC;QAC1C,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,MAAM;QACZ,QAAQ,EAAE,SAAS;QACnB,QAAQ,EAAE,SAAS;QACnB,QAAQ,EAAE,SAAS;KACtB,CAAC,CAAC;IACH,IAAM,iBAAiB,GAAG,WAAW,CAAC;IAOtC,sBAA6B,CAAS,EAAE,SAA6F;QACjI,IAAM,kBAAkB,GACpB,SAAS,OAA4B,CAAC,CAAC,CAAC,+BAA+B,CAAC,CAAC;YACrE,SAAS,OAA+B,CAAC,CAAC,CAAC,6BAA6B,CAAC,CAAC;gBACtE,6BAA6B,CAAC;QAC1C,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,kBAAkB,EAAE,cAAc,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;IACrG,CAAC;IANe,eAAY,eAM3B,CAAA;IAED,yBAAyB,CAAS;QAC9B,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC5C,CAAC;IAED,wBAAwB,CAAS;QAC7B,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,6BAA6B,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF,CAAC;IAED,4BAAmC,IAAuB;QAGtD,IAAM,EAAE,GAAI,IAAe,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACzC,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,CAAC;IACnC,CAAC;IALe,qBAAkB,qBAKjC,CAAA;IAED,uCAAuC,QAAgB;QACnD,IAAM,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QACxD,IAAM,aAAa,GAAG,CAAC,MAAM,GAAG,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,MAAM,CAAC,KAAK,GAAG,aAAa,CAAC;IACjC,CAAC;IAED,IAAM,kBAAkB,GAAG,mBAAmB,CAAC;IAC/C,8BAAqC,CAAS,EAAE,SAA6F;QACzI,CAAC,GAAG,YAAY,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QAG/B,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/B,CAAC,CAAC,OAAO,CAAC,kBAAkB,EAAE,UAAA,CAAC,IAAI,OAAA,6BAA6B,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAA9C,CAA8C,CAAC,CAAC,CAAC;YACpF,CAAC,CAAC;IACV,CAAC;IAPe,uBAAoB,uBAOnC,CAAA;IAED,IAAM,aAAa,GAAa,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;IAC7C,yBAAgC,KAAa;QACzC,EAAE,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;YACrC,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;QACzE,CAAC;QACD,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IALe,kBAAe,kBAK9B,CAAA;IAED;QACI,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IACnC,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,0BAAiC,OAAe;QAC5C,IAAI,MAAc,CAAC;QACnB,IAAI,MAAc,CAAC;QACnB,IAAI,SAAkB,CAAC;QACvB,IAAI,SAAiB,CAAC;QACtB,IAAI,OAAe,CAAC;QAEpB,eAAe,CAAS;YACpB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChB,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACZ,MAAM,IAAI,eAAe,CAAC,MAAM,CAAC,CAAC;oBAClC,SAAS,GAAG,KAAK,CAAC;gBACtB,CAAC;gBACD,MAAM,IAAI,CAAC,CAAC;YAChB,CAAC;QACL,CAAC;QAED;YACI,MAAM,GAAG,EAAE,CAAC;YACZ,MAAM,GAAG,CAAC,CAAC;YACX,SAAS,GAAG,IAAI,CAAC;YACjB,SAAS,GAAG,CAAC,CAAC;YACd,OAAO,GAAG,CAAC,CAAC;QAChB,CAAC;QAED,kBAAkB,CAAS;YACvB,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACZ,SAAS,GAAG,KAAK,CAAC;gBACtB,CAAC;gBACD,MAAM,IAAI,CAAC,CAAC;YAChB,CAAC;QACL,CAAC;QAED,sBAAsB,CAAS;YAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChB,KAAK,CAAC,CAAC,CAAC,CAAC;gBACT,IAAM,aAAa,GAAG,GAAA,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBAC3C,EAAE,CAAC,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3B,SAAS,GAAG,SAAS,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;oBACjD,OAAO,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,GAAG,GAAA,eAAe,CAAC,aAAa,CAAC,CAAC;gBACxE,CAAC;YACL,CAAC;QACL,CAAC;QAED;YACI,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACb,MAAM,IAAI,OAAO,CAAC;gBAClB,SAAS,EAAE,CAAC;gBACZ,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;gBACxB,SAAS,GAAG,IAAI,CAAC;YACrB,CAAC;QACL,CAAC;QAED,yBAAyB,IAAY,EAAE,IAAU;YAC7C,KAAK,CAAC,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QACnD,CAAC;QAED,KAAK,EAAE,CAAC;QAER,MAAM,CAAC;YACH,KAAK,OAAA;YACL,QAAQ,UAAA;YACR,eAAe,iBAAA;YACf,YAAY,cAAA;YACZ,SAAS,WAAA;YACT,cAAc,EAAE,cAAQ,MAAM,EAAE,CAAC,CAAC,CAAC;YACnC,cAAc,EAAE,cAAQ,MAAM,EAAE,CAAC,CAAC,CAAC;YACnC,SAAS,EAAE,cAAM,OAAA,MAAM,EAAN,CAAM;YACvB,UAAU,EAAE,cAAM,OAAA,MAAM,CAAC,MAAM,EAAb,CAAa;YAC/B,OAAO,EAAE,cAAM,OAAA,SAAS,GAAG,CAAC,EAAb,CAAa;YAC5B,SAAS,EAAE,cAAM,OAAA,SAAS,CAAC,CAAC,CAAC,MAAM,GAAG,aAAa,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,OAAO,GAAG,CAAC,EAAtE,CAAsE;YACvF,OAAO,EAAE,cAAM,OAAA,MAAM,EAAN,CAAM;YACrB,eAAe,EAAE,cAAM,OAAA,SAAS,EAAT,CAAS;YAChC,KAAK,OAAA;SACR,CAAC;IACN,CAAC;IA5Ee,mBAAgB,mBA4E/B,CAAA;IAED,uCAA8C,IAAc,EAAE,IAAgB;QAC1E,MAAM,CAAC,IAAI,CAAC,UAAU,IAAI,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IACjF,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,8CAAqD,IAAc,EAAE,QAAsB,EAAE,WAAgG;QACzL,IAAM,IAAI,GAAG,QAAQ,CAAC,oCAAoC,CAAC,WAAW,CAAC,CAAC;QACxE,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACrD,CAAC;IANe,uCAAoC,uCAMnD,CAAA;IAKD,uCAA8C,IAAc,EAAE,QAAgB;QAC1E,IAAM,oBAAoB,GAAG,UAAC,CAAS,IAAK,OAAA,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAA5B,CAA4B,CAAC;QACzE,IAAM,GAAG,GAAG,GAAA,MAAM,CAAC,IAAI,CAAC,wBAAwB,EAAE,EAAE,IAAI,CAAC,mBAAmB,EAAE,EAAE,oBAAoB,CAAC,CAAC;QACtG,IAAM,QAAQ,GAAG,GAAA,yBAAyB,CAAC,QAAQ,EAAE,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;QACjF,IAAM,YAAY,GAAG,GAAA,+BAA+B,CAAC,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,oBAAoB,EAA0B,KAAK,CAAC,CAAC;QAC9H,MAAM,CAAC,GAAA,mBAAmB,CAAC,YAAY,CAAC,CAAC;IAC7C,CAAC;IANe,gCAA6B,gCAM5C,CAAA;IAED,kCAAyC,UAAsB,EAAE,IAAc,EAAE,SAAiB;QAC9F,IAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAClD,IAAI,kCAA0C,CAAC;QAC/C,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;YACzB,kCAAkC,GAAG,GAAA,mBAAmB,CAAC,yBAAyB,CAAC,UAAU,EAAE,IAAI,EAAE,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;QAClI,CAAC;QACD,IAAI,CAAC,CAAC;YACF,kCAAkC,GAAG,GAAA,mBAAmB,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QAClF,CAAC;QAED,MAAM,CAAC,kCAAkC,GAAG,SAAS,CAAC;IAC1D,CAAC;IAXe,2BAAwB,2BAWvC,CAAA;IAED,0CAAiD,UAAsB,EAAE,IAAc;QACnF,IAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1C,IAAM,SAAS,GAAG,OAAO,CAAC,cAAc,IAAI,OAAO,CAAC,MAAM,CAAC;QAG3D,IAAM,IAAI,GAAG,SAAS;YAClB,CAAC,CAAC,yBAAyB,CAAC,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC;YACxD,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC;QAE1B,IAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,UAAgB,CAAC,QAAc,CAAA;QAC1D,MAAM,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;IAC3C,CAAC;IAXe,mCAAgC,mCAW/C,CAAA;IAiBD,8BAAqC,IAAc,EAAE,gBAA6B;QAC9E,IAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1C,IAAM,+BAA+B,GAAG,UAAC,IAAgB,IAAK,OAAA,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,EAA1C,CAA0C,CAAC;QACzG,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;YACjC,IAAM,UAAU,GAAG,GAAA,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAC9C,IAAM,mBAAiB,GAAG,UAAU,KAAK,GAAA,UAAU,CAAC,GAAG,IAAI,UAAU,KAAK,GAAA,UAAU,CAAC,MAAM,CAAC;YAE5F,MAAM,CAAC,GAAA,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE,UAAA,UAAU;gBAC3C,OAAA,CAAC,mBAAiB,IAAI,CAAC,GAAA,gBAAgB,CAAC,UAAU,CAAC,CAAC,IAAI,sBAAsB,CAAC,UAAU,EAAE,OAAO,EAAE,+BAA+B,CAAC;YAApI,CAAoI,CAAC,CAAC;QAC9I,CAAC;QACD,IAAI,CAAC,CAAC;YACF,IAAM,WAAW,GAAG,gBAAgB,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;YAChG,MAAM,CAAC,GAAA,MAAM,CAAC,WAAW,EAAE,UAAA,UAAU,IAAI,OAAA,sBAAsB,CAAC,UAAU,EAAE,OAAO,EAAE,+BAA+B,CAAC,EAA5E,CAA4E,CAAC,CAAC;QAC3H,CAAC;IACL,CAAC;IAde,uBAAoB,uBAcnC,CAAA;IAGD,gCAAuC,UAAsB,EAAE,OAAwB,EAAE,+BAA8D;QACnJ,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,IAAI,sBAAsB,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,iBAAiB,IAAI,CAAC,+BAA+B,CAAC,UAAU,CAAC,CAAC;IAC9J,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,mCAA0C,UAAsB,EAAE,IAAc,EAAE,UAAkB;QAChG,IAAI,cAAc,GAAG,GAAA,yBAAyB,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAChG,IAAM,qBAAqB,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAC9D,IAAM,mCAAmC,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,CAAC,CAAC,KAAK,CAAC,CAAC;QACtJ,cAAc,GAAG,mCAAmC,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;QAC/H,MAAM,CAAC,GAAA,YAAY,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IACpD,CAAC;IANe,4BAAyB,4BAMxC,CAAA;IAED,mBAA0B,IAAc,EAAE,WAAiC,EAAE,QAAgB,EAAE,IAAY,EAAE,kBAA2B,EAAE,WAAuC;QAC7K,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,kBAAkB,EAAE,UAAA,gBAAgB;YAC/D,WAAW,CAAC,GAAG,CAAC,GAAA,wBAAwB,CAAC,GAAA,WAAW,CAAC,8BAA8B,EAAE,QAAQ,EAAE,gBAAgB,CAAC,CAAC,CAAC;QACtH,CAAC,EAAE,WAAW,CAAC,CAAC;IACpB,CAAC;IAJe,YAAS,YAIxB,CAAA;IAED,gCAAuC,iBAA6B,EAAE,GAAW;QAC7E,MAAM,CAAC,GAAA,6BAA6B,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC;IACtE,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,2CAAkD,OAA8B,EAAE,GAAW;QACzF,MAAM,CAAC,GAAA,iCAAiC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC;IAChE,CAAC;IAFe,oCAAiC,oCAEhD,CAAA;IAED,qCAA4C,IAA0B;QAClE,MAAM,CAAC,GAAA,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,UAAA,MAAM;YAC/B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAA2B,IAAI,aAAa,CAA0B,MAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACjG,MAAM,CAAyB,MAAM,CAAC;YAC1C,CAAC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IANe,8BAA2B,8BAM1C,CAAA;IAED,sCAAsC,QAAgC;QAClE,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7C,IAAM,OAAO,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,sBAAsB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YACnG,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC;IACL,CAAC;IAGD,0CAAiD,QAAgC;QAC7E,IAAM,SAAS,GAAG,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACzD,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC;IACvC,CAAC;IAHe,mCAAgC,mCAG/C,CAAA;IAED,0BAAiC,SAA+B;QAC5D,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9B,IAAM,aAAa,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9C,EAAE,CAAC,CAAC,sBAAsB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBACxC,MAAM,CAAC,aAAa,CAAC;YACzB,CAAC;QACL,CAAC;IACL,CAAC;IAPe,mBAAgB,mBAO/B,CAAA;IAED,gCAAuC,SAA+B;QAClE,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IAC5C,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,0BAAiC,IAAsB;QACnD,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,OAA0B,IAAI,uBAAuB,CAAC,IAAkB,CAAC,CAAC;IACtG,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,iCAAwC,EAAc;QAClD,MAAM,CAAC,EAAE,CAAC,mBAAmB,OAA2B,CAAC;IAC7D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IASD,oCAA2C,YAAoC,EAAE,QAA6B;QAC1G,IAAI,aAAkC,CAAC;QACvC,IAAI,cAAmC,CAAC;QACxC,IAAI,WAAgC,CAAC;QACrC,IAAI,WAAgC,CAAC;QACrC,EAAE,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3B,aAAa,GAAG,QAAQ,CAAC;YACzB,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,QAA2B,CAAC,CAAC,CAAC;gBAC3C,WAAW,GAAG,QAAQ,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,QAA2B,CAAC,CAAC,CAAC;gBAChD,WAAW,GAAG,QAAQ,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,GAAA,KAAK,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC;YAC1C,CAAC;QACL,CAAC;QACD,IAAI,CAAC,CAAC;YACF,GAAA,OAAO,CAAC,YAAY,EAAE,UAAC,MAAmB;gBACtC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,QAA2B,IAAI,MAAM,CAAC,IAAI,QAA2B,CAAC;uBAC/E,WAAW,CAAC,MAAM,KAAuB,KAAK,WAAW,CAAC,QAAQ,KAAuB,CAAC,CAAC,CAAC;oBAC/F,IAAM,UAAU,GAAG,kCAAkC,CAAE,MAA2B,CAAC,IAAI,CAAC,CAAC;oBACzF,IAAM,YAAY,GAAG,kCAAkC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;oBACvE,EAAE,CAAC,CAAC,UAAU,KAAK,YAAY,CAAC,CAAC,CAAC;wBAC9B,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;4BACjB,aAAa,GAAwB,MAAM,CAAC;wBAChD,CAAC;wBACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;4BACvB,cAAc,GAAwB,MAAM,CAAC;wBACjD,CAAC;wBAED,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAA2B,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;4BACzD,WAAW,GAAwB,MAAM,CAAC;wBAC9C,CAAC;wBAED,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,QAA2B,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;4BACzD,WAAW,GAAwB,MAAM,CAAC;wBAC9C,CAAC;oBACL,CAAC;gBACL,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;QACD,MAAM,CAAC;YACH,aAAa,eAAA;YACb,cAAc,gBAAA;YACd,WAAW,aAAA;YACX,WAAW,aAAA;SACd,CAAC;IACN,CAAC;IAhDe,6BAA0B,6BAgDzC,CAAA;IAMD,wCAA+C,IAA6B,EAAE,UAAoB;QAC9F,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACzC,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC;IACL,CAAC;IAPe,iCAA8B,iCAO7C,CAAA;IAMD,oCAA2C,IAA0B,EAAE,UAAoB;QACvF,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACzC,MAAM,CAAC,GAAA,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;IACL,CAAC;IAPe,6BAA0B,6BAOzC,CAAA;IAMD,+CAAsD,IAAmC,EAAE,UAAoB;QAC3G,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACzC,IAAM,WAAW,GAAG,GAAA,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC9C,MAAM,CAAC,WAAW,IAAI,WAAW,CAAC,cAAc,CAAC;QACrD,CAAC;IACL,CAAC;IARe,wCAAqC,wCAQpD,CAAA;IAMD,mDAA0D,IAA4B,EAAE,UAAoB;QACxG,IAAM,SAAS,GAAG,4BAA4B,CAAC,IAAI,CAAC,CAAC;QACrD,MAAM,CAAC,SAAS,IAAI,8BAA8B,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;IAC9E,CAAC;IAHe,4CAAyC,4CAGxD,CAAA;IAED,0CAAiD,OAA8B,EAAE,MAAsB,EAAE,IAAe,EAAE,eAA4C;QAClK,0CAA0C,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,EAAE,eAAe,CAAC,CAAC;IAC3F,CAAC;IAFe,mCAAgC,mCAE/C,CAAA;IAED,oDAA2D,OAA8B,EAAE,MAAsB,EAAE,GAAW,EAAE,eAA4C;QAExK,EAAE,CAAC,CAAC,eAAe,IAAI,eAAe,CAAC,MAAM,IAAI,GAAG,KAAK,eAAe,CAAC,CAAC,CAAC,CAAC,GAAG;YAC3E,iCAAiC,CAAC,OAAO,EAAE,GAAG,CAAC,KAAK,iCAAiC,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACzH,MAAM,CAAC,SAAS,EAAE,CAAC;QACvB,CAAC;IACL,CAAC;IANe,6CAA0C,6CAMzD,CAAA;IAED,mDAA0D,OAA8B,EAAE,MAAsB,EAAE,GAAW,EAAE,UAAkB;QAE7I,EAAE,CAAC,CAAC,GAAG,KAAK,UAAU;YAClB,iCAAiC,CAAC,OAAO,EAAE,GAAG,CAAC,KAAK,iCAAiC,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;YAC7G,MAAM,CAAC,SAAS,EAAE,CAAC;QACvB,CAAC;IACL,CAAC;IANe,4CAAyC,4CAMxD,CAAA;IAED,sBACI,IAAY,EACZ,OAA8B,EAC9B,MAAsB,EACtB,QAAqC,EACrC,gBAAyB,EACzB,iBAA0B,EAC1B,OAAe,EACf,YAAqJ;QACrJ,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBACnB,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACtB,CAAC;YAED,IAAI,wBAAwB,GAAG,KAAK,CAAC;YACrC,GAAG,CAAC,CAAkB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;gBAAzB,IAAM,OAAO,iBAAA;gBACd,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;oBAC3B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAClB,wBAAwB,GAAG,KAAK,CAAC;gBACrC,CAAC;gBAED,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;gBACvE,EAAE,CAAC,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,SAAS,EAAE,CAAC;gBACvB,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,wBAAwB,GAAG,IAAI,CAAC;gBACpC,CAAC;aACJ;YAED,EAAE,CAAC,CAAC,wBAAwB,IAAI,iBAAiB,CAAC,CAAC,CAAC;gBAChD,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACtB,CAAC;QACL,CAAC;IACL,CAAC;IAlCe,eAAY,eAkC3B,CAAA;IAMD,8BAAqC,IAAY,EAAE,OAA8B,EAAE,MAAsB,EACrG,YAAqJ,EACrJ,IAAe,EAAE,OAAe,EAAE,cAAuB;QACzD,IAAI,eAA+B,CAAC;QACpC,IAAI,0BAA8E,CAAC;QACnF,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;YAMjB,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACjB,eAAe,GAAG,GAAA,MAAM,CAAC,GAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,oBAAoB,CAAC,CAAC;YAC5F,CAAC;QACL,CAAC;QACD,IAAI,CAAC,CAAC;YAEF,eAAe,GAAG,GAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC9D,CAAC;QAED,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YAClB,IAAM,gBAAgB,GAAmB,EAAE,CAAC;YAC5C,IAAI,WAAW,SAAc,CAAC;YAE9B,GAAG,CAAC,CAAkB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAe;gBAAhC,IAAM,OAAO,wBAAA;gBACd,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBACd,IAAM,eAAe,GAAG,iCAAiC,CAAC,OAAO,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC;oBACpF,IAAM,WAAW,GAAG,iCAAiC,CAAC,OAAO,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;oBAE5E,EAAE,CAAC,CAAC,WAAW,IAAI,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;wBAIrC,KAAK,CAAC;oBACV,CAAC;gBACL,CAAC;gBAED,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC/B,WAAW,GAAG,OAAO,CAAC;aACzB;YAED,EAAE,CAAC,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;gBAI1B,IAAM,eAAe,GAAG,iCAAiC,CAAC,OAAO,EAAE,GAAA,eAAe,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,CAAC;gBAC1G,IAAM,QAAQ,GAAG,iCAAiC,CAAC,OAAO,EAAE,GAAA,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;gBACxF,EAAE,CAAC,CAAC,QAAQ,IAAI,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;oBAElC,gCAAgC,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,eAAe,CAAC,CAAC;oBACzE,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,gBAAgB,EAAuB,KAAK,EAAwB,IAAI,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;oBACrI,0BAA0B,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE,qBAAqB,EAAE,GAAA,eAAe,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,CAAC;gBACrH,CAAC;YACL,CAAC;QACL,CAAC;QAED,MAAM,CAAC,0BAA0B,CAAC;QAElC,8BAA8B,OAAqB;YAC/C,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC1C,CAAC;IAEL,CAAC;IA9De,uBAAoB,uBA8DnC,CAAA;IAED,2BAAkC,IAAY,EAAE,OAA8B,EAAE,MAAsB,EAAE,UAAkB,EAAE,UAAkB,EAAE,OAAe;QAC3J,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,CAAC,OAA4B,CAAC,CAAC,CAAC;YAC9D,IAAM,4BAA4B,GAAG,GAAA,iCAAiC,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;YAC5F,IAAM,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC;YACjC,IAAI,sBAAsB,SAAQ,CAAC;YACnC,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,UAAU,EAAE,WAAW,GAAG,4BAA4B,CAAC,IAAI,EAAE,GAAG,GAAG,UAAU,EAAE,WAAW,EAAE,EAAE,CAAC;gBAC1G,IAAM,aAAa,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,KAAK,SAAS;oBACjD,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;oBACjB,CAAC,CAAC,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;gBAE/B,EAAE,CAAC,CAAC,GAAG,KAAK,UAAU,CAAC,CAAC,CAAC;oBAErB,EAAE,CAAC,CAAC,sBAAsB,KAAK,SAAS,CAAC,CAAC,CAAC;wBACvC,sBAAsB,GAAG,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,4BAA4B,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,CAAC;oBAC3G,CAAC;oBAGD,IAAM,0BAA0B,GAAG,MAAM,CAAC,SAAS,EAAE,GAAG,aAAa,EAAE,CAAC;oBAgBxE,IAAM,YAAY,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,eAAe,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;oBACrH,EAAE,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;wBACnB,IAAI,0BAA0B,GAAG,YAAY,GAAG,aAAa,EAAE,CAAC;wBAChE,IAAM,qBAAqB,GAAG,eAAe,CAAC,CAAC,YAAY,GAAG,0BAA0B,CAAC,GAAG,aAAa,EAAE,CAAC,CAAC;wBAG7G,MAAM,CAAC,QAAQ,CAAC,qBAAqB,CAAC,CAAC;wBAGvC,OAAO,0BAA0B,EAAE,CAAC;4BAChC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;4BACrB,0BAA0B,EAAE,CAAC;wBACjC,CAAC;oBACL,CAAC;oBACD,IAAI,CAAC,CAAC;wBAEF,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;oBACxB,CAAC;gBACL,CAAC;gBAGD,uBAAuB,CAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;gBAE/E,GAAG,GAAG,aAAa,CAAC;YACxB,CAAC;QACL,CAAC;QACD,IAAI,CAAC,CAAC;YAEF,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;QACzD,CAAC;IACL,CAAC;IA/De,oBAAiB,oBA+DhC,CAAA;IAED,iCAAiC,IAAY,EAAE,UAAkB,EAAE,MAAsB,EAAE,OAAe,EAAE,GAAW,EAAE,aAAqB;QAC1I,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,aAAa,GAAG,CAAC,CAAC,CAAC;QACpD,IAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAC3E,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YAElB,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAC9B,EAAE,CAAC,CAAC,GAAG,KAAK,UAAU,CAAC,CAAC,CAAC;gBACrB,MAAM,CAAC,SAAS,EAAE,CAAC;YACvB,CAAC;QACL,CAAC;QACD,IAAI,CAAC,CAAC;YAEF,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QACjC,CAAC;IACL,CAAC;IAED,yBAAyB,IAAY,EAAE,GAAW,EAAE,GAAW;QAC3D,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,GAAG,IAAI,GAAA,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,CAAC;YACtE,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAuB,CAAC,CAAC,CAAC;gBAE9C,iBAAiB,IAAI,aAAa,EAAE,GAAG,CAAC,iBAAiB,GAAG,aAAa,EAAE,CAAC,CAAC;YACjF,CAAC;YACD,IAAI,CAAC,CAAC;gBAEF,iBAAiB,EAAE,CAAC;YACxB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,iBAAiB,CAAC;IAC7B,CAAC;IAED,sBAA6B,IAAU;QACnC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAuB,CAAC;IACzD,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,qBAA4B,IAAU,EAAE,KAAoB;QACxD,MAAM,CAAC,CAAC,CAAC,wBAAwB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACnD,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,kCAAyC,IAAU,EAAE,KAAoB;QACrE,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;IAC1C,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,0BAAiC,IAAU;QACvC,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,YAAiC,CAAC,CAAC,CAAC;YAC3D,MAAM,CAAC,IAAI,CAAC,kBAAkB,GAAG,UAA+B,CAAC;QACrE,CAAC;QAED,IAAM,KAAK,GAAG,uBAAuB,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAI,CAAC,kBAAkB,GAAG,KAAK,YAAiC,CAAC;QACjE,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,mBAAgB,mBAQ/B,CAAA;IAGD,iCAAwC,IAAU;QAE9C,IAAI,KAAK,IAAqB,CAAC;QAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACjB,GAAG,CAAC,CAAmB,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc;gBAAhC,IAAM,QAAQ,SAAA;gBACf,KAAK,IAAI,cAAc,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aAC1C;QACL,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAA4B,IAAI,CAAC,IAAI,CAAC,IAAI,OAA0B,IAAiB,IAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;YAC3H,KAAK,KAAwB,CAAC;QAClC,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAde,0BAAuB,0BActC,CAAA;IAED,wBAA+B,KAAiB;QAC5C,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACZ,UAA+B,MAAM,IAAsB;YAC3D,UAA+B,MAAM,GAAsB;YAC3D,UAAkC,MAAM,IAAyB;YACjE,UAAgC,MAAM,GAAuB;YAC7D,UAAiC,MAAM,KAAwB;YAC/D,SAA+B,MAAM,GAAsB;YAC3D,UAAgC,MAAM,GAAuB;YAC7D,SAA8B,MAAM,MAAqB;YACzD,SAAgC,MAAM,KAAuB;YAC7D,UAA8B,MAAM,KAAqB;YACzD,UAAiC,MAAM,IAAwB;QACnE,CAAC;QACD,MAAM,GAAoB;IAC9B,CAAC;IAfe,iBAAc,iBAe7B,CAAA;IAED,2BAAkC,KAAiB;QAC/C,MAAM,CAAC,KAAK,OAA2B;eAChC,KAAK,OAAuC;eAC5C,KAAK,OAAgC,CAAC;IACjD,CAAC;IAJe,oBAAiB,oBAIhC,CAAA;IAED,8BAAqC,KAAiB;QAClD,MAAM,CAAC,KAAK,MAA8B,IAAI,KAAK,MAA6B,CAAC;IACrF,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAGD,yDAAgE,IAAU;QACtE,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAA2C;YACnC,IAAI,CAAC,MAAO,CAAC,KAAK,OAA8B;YACjE,GAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAC9B,CAAC;IACL,CAAC;IANe,kDAA+C,kDAM9D,CAAA;IAID,gCAAuC,IAAU,EAAE,yBAAmC;QAClF,MAAM,CAAC,GAAA,kBAAkB,CAAC,IAAI,CAAC;eACxB,CAAC,yBAAyB;gBACzB,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,OAA2B;gBACpD,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;eACjD,GAAA,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/C,CAAC;IANe,yBAAsB,yBAMrC,CAAA;IAED,mCAA0C,IAAU;QAChD,EAAE,CAAC,CAAC,sBAAsB,CAAC,IAAI,EAAgC,IAAI,CAAC,CAAC,CAAC,CAAC;YACnE,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YAC5B,MAAM,CAAC,IAAI,QAAuC;mBAC3C,IAAI,QAAsC,CAAC;QACtD,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,4BAAyB,4BAQxC,CAAA;IAED,2DAAkE,IAAU;QACxE,MAAM,CAAC,+CAA+C,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;IAC/E,CAAC;IAFe,oDAAiD,oDAEhE,CAAA;IAED,8DAAqE,IAAU;QAC3E,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2C;eACpD,sBAAsB,CAAE,IAAoC,CAAC,UAAU,CAAC;eACxE,IAAI,CAAC,MAAM;eACM,IAAI,CAAC,MAAO,CAAC,KAAK,QAAiC;eACpE,IAAI,CAAC,MAAM,CAAC,MAAM;eAClB,GAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC3C,CAAC;IAPe,uDAAoD,uDAOnE,CAAA;IAED,gCAAuC,IAAgB;QACnD,MAAM,CAAC,IAAI,CAAC,IAAI,OAA0B;YACtC,IAAI,CAAC,IAAI,QAAwC,IAAI,sBAAsB,CAA4B,IAAK,CAAC,UAAU,CAAC,CAAC;IACjI,CAAC;IAHe,yBAAsB,yBAGrC,CAAA;IAED,oDAA2D,IAAU;QACjE,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAA6B,IAAoB,IAAI,CAAC,MAAO,CAAC,KAAK,KAAK,IAAI,CAAC;YACjG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAwC,IAA+B,IAAI,CAAC,MAAO,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC5H,CAAC;IAHe,6CAA0C,6CAGzD,CAAA;IAED,8BAAqC,UAAgB;QACjD,MAAM,CAAC,UAAU,CAAC,IAAI,QAAuC;YAC/B,UAAW,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;IACtE,CAAC;IAHe,uBAAoB,uBAGnC,CAAA;IAED,6BAAoC,UAAgB;QAChD,MAAM,CAAC,UAAU,CAAC,IAAI,QAAsC;YAC/B,UAAW,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC;IACnE,CAAC;IAHe,sBAAmB,sBAGlC,CAAA;IAED,wCAA+C,MAAc;QACzD,MAAM,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC;IAC1F,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,+BAA+B,MAAc;QACzC,MAAM,CAAC,MAAM,IAAI,GAAA,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,MAAwB,CAAC;IACnH,CAAC;IAGD,uCAA8C,QAAgB;QAC1D,MAAM,CAAC,GAAA,IAAI,CAAC,GAAA,gDAAgD,EAAE,UAAA,SAAS,IAAI,OAAA,GAAA,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,EAApC,CAAoC,CAAC,CAAC;IACrH,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAKD,8BAA8B,KAAa;QACvC,IAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAE5B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC9B,IAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAGrC,EAAE,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC;gBAClB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC1B,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,GAAG,GAAU,CAAC,CAAC;gBAC1C,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;YACtD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC,GAAG,GAAU,CAAC,CAAC;gBAC3C,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;gBACzD,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;YACtD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC,GAAG,GAAU,CAAC,CAAC;gBAC3C,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;gBAC1D,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;gBACzD,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,EAAU,CAAC,GAAG,GAAU,CAAC,CAAC;YACtD,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,GAAA,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,uBAAuB,CAAC,CAAC;YACjD,CAAC;QACL,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAED,IAAM,YAAY,GAAG,mEAAmE,CAAC;IAKzF,yBAAgC,KAAa;QACzC,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAM,SAAS,GAAG,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAC9C,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAM,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;QAChC,IAAI,KAAa,EAAE,KAAa,EAAE,KAAa,EAAE,KAAa,CAAC;QAE/D,OAAO,CAAC,GAAG,MAAM,EAAE,CAAC;YAGhB,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YAC1B,KAAK,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAU,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;YACjE,KAAK,GAAG,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAU,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;YACrE,KAAK,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAU,CAAC;YAItC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC;gBAClB,KAAK,GAAG,KAAK,GAAG,EAAE,CAAC;YACvB,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC;gBACvB,KAAK,GAAG,EAAE,CAAC;YACf,CAAC;YAGD,MAAM,IAAI,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAE5H,CAAC,IAAI,CAAC,CAAC;QACX,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IA/Be,kBAAe,kBA+B9B,CAAA;IAED,IAAM,sBAAsB,GAAG,MAAM,CAAC;IACtC,IAAM,QAAQ,GAAG,IAAI,CAAC;IACtB,6BAAoC,OAAyC,EAAE,MAA4B;QACvG,MAAM,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;YACtB;gBACI,MAAM,CAAC,sBAAsB,CAAC;YAClC;gBACI,MAAM,CAAC,QAAQ,CAAC;QACxB,CAAC;QACD,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,GAAA,GAAG,CAAC,CAAC,CAAC,GAAA,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,sBAAsB,CAAC;IAChF,CAAC;IARe,sBAAmB,sBAQlC,CAAA;IAKD,oBAAoB,KAAS,EAAE,UAAe,EAAE,OAAiB;QAA7C,sBAAA,EAAA,SAAS;QACzB,IAAM,OAAO,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;QAC3C,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;YACd,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAC3E,CAAC;QACD,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACV,IAAI,MAAM,GAAG,EAAE,CAAC;YAChB,IAAI,cAAc,GAAG,KAAK,CAAC;YAC3B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,cAAc,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7D,IAAA,eAAkC,EAAjC,iBAAS,EAAE,gBAAQ,CAAe;gBACzC,EAAE,CAAC,CAAC,SAAS,KAAK,CAAC,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;oBAChE,cAAc,IAAI,CAAC,SAAS,CAAC;oBAC7B,MAAM,GAAG,KAAG,QAAQ,IAAG,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAG,MAAQ,CAAC;gBACzD,CAAC;YACL,CAAC;YACD,EAAE,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,CAAC,CAAC;gBACvB,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,IAAI,CAAC,CAAC;YACF,GAAG,CAAC,CAAgC,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;gBAAhC,IAAA,kBAAqB,EAApB,iBAAS,EAAE,gBAAQ;gBAC3B,EAAE,CAAC,CAAC,SAAS,KAAK,KAAK,CAAC,CAAC,CAAC;oBACtB,MAAM,CAAC,QAAQ,CAAC;gBACpB,CAAC;aACJ;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;IAC5B,CAAC;IAED,wBAAwB,UAAe;QACnC,IAAM,MAAM,GAAuB,EAAE,CAAC;QACtC,GAAG,CAAC,CAAC,IAAM,IAAI,IAAI,UAAU,CAAC,CAAC,CAAC;YAC5B,IAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAC/B,EAAE,CAAC,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;YAC/B,CAAC;QACL,CAAC;QAED,MAAM,CAAC,GAAA,UAAU,CAAmB,MAAM,EAAE,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,GAAA,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAzB,CAAyB,CAAC,CAAC;IACrF,CAAC;IAED,0BAAiC,IAAgB;QAC7C,MAAM,CAAC,UAAU,CAAC,IAAI,EAAQ,EAAG,CAAC,UAAU,EAAc,KAAK,CAAC,CAAC;IACrE,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,6BAAoC,KAAoB;QACpD,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,aAAa,EAAc,IAAI,CAAC,CAAC;IACxE,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,8BAAqC,KAAqB;QACtD,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,cAAc,EAAc,IAAI,CAAC,CAAC;IACzE,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,yBAAgC,KAAgB;QAC5C,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,SAAS,EAAc,IAAI,CAAC,CAAC;IACpE,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,2BAAkC,KAAkB;QAChD,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,WAAW,EAAc,IAAI,CAAC,CAAC;IACtE,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,yBAAgC,KAAgB;QAC5C,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,SAAS,EAAc,IAAI,CAAC,CAAC;IACpE,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,2BAAkC,KAAkB;QAChD,MAAM,CAAC,UAAU,CAAC,KAAK,EAAQ,EAAG,CAAC,WAAW,EAAc,IAAI,CAAC,CAAC;IACtE,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAQD,qBAA4B,GAAW,EAAE,GAAW;QAChD,MAAM,CAAC,EAAE,GAAG,KAAA,EAAE,GAAG,KAAA,EAAE,CAAC;IACxB,CAAC;IAFe,cAAW,cAE1B,CAAA;IAQD,sBAA6B,KAAgB,EAAE,GAAW;QACtD,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACvC,CAAC;IAFe,eAAY,eAE3B,CAAA;IAQD,sBAA6B,KAAgB,EAAE,GAAW;QACtD,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,CAAC;IAFe,eAAY,eAE3B,CAAA;IAKD,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;YAChD,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;YACzC,CAAC,CAAC,IAAI,CAAC;IACf,CAAC;IAJe,0BAAuB,0BAItC,CAAA;IAKD,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC;YAC9C,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;YACxC,CAAC,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;IACxC,CAAC;IAJe,yBAAsB,yBAIrC,CAAA;IAOD,0BAAiC,KAAgB;QAC7C,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;IACnC,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAQD,0BAAiC,GAAW,EAAE,KAAiB;QAC3D,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,GAAG,GAAA,aAAa,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;IAC/D,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,6BAAoC,KAAgB,EAAE,UAAsB;QACxE,MAAM,CAAC,gCAAgC,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;IACtE,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,0CAAiD,MAAiB,EAAE,MAAiB,EAAE,UAAsB;QACzG,MAAM,CAAC,sBAAsB,CAAC,uBAAuB,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,uBAAuB,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;IACxI,CAAC;IAFe,mCAAgC,mCAE/C,CAAA;IAED,wCAA+C,MAAiB,EAAE,MAAiB,EAAE,UAAsB;QACvG,MAAM,CAAC,sBAAsB,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;IACtE,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,0CAAiD,MAAiB,EAAE,MAAiB,EAAE,UAAsB;QACzG,MAAM,CAAC,sBAAsB,CAAC,uBAAuB,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;IACvG,CAAC;IAFe,mCAAgC,mCAE/C,CAAA;IAED,0CAAiD,MAAiB,EAAE,MAAiB,EAAE,UAAsB;QACzG,MAAM,CAAC,sBAAsB,CAAC,MAAM,CAAC,GAAG,EAAE,uBAAuB,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;IACvG,CAAC;IAFe,mCAAgC,mCAE/C,CAAA;IAED,gCAAuC,IAAY,EAAE,IAAY,EAAE,UAAsB;QACrF,MAAM,CAAC,IAAI,KAAK,IAAI;YAChB,sBAAsB,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,sBAAsB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IAC9F,CAAC;IAHe,yBAAsB,yBAGrC,CAAA;IAED,iCAAwC,KAAgB,EAAE,UAAsB;QAC5E,MAAM,CAAC,GAAA,qBAAqB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAA,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC;IAC1F,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAMD,4CAAmD,IAAgB;QAC/D,IAAM,SAAS,GAAG,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACzC,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC5B,SAAgC;gBAChC;oBACI,MAAM,CAAC,SAAS,KAA2C,SAAS,CAAC,MAAO,CAAC,IAAI,CAAC;YAC1F,CAAC;QACL,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAVe,qCAAkC,qCAUjD,CAAA;IAED,iCAAwC,IAA6B;QACjE,MAAM,CAAC,GAAA,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,qBAAqB,CAAC,CAAC;IAC5D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,+BAA+B,IAAyB;QACpD,MAAM,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC;IAC1C,CAAC;IAED,oBAA2B,OAAwB;QAE/C,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IAC5D,CAAC;IAHe,aAAU,aAGzB,CAAA;IAED,uBAA8B,MAAc;QACxC,MAAM,CAAC,MAAM,CAAC,KAAK,WAAwB,CAAC,CAAC,CAAmB,MAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3F,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,+CAAsD,CAAS;QAC3D,EAAE,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACrB,IAAM,KAAK,GAAG,GAAA,wBAAwB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;YAC3D,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,KAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,GAAoC,CAAC;QACjH,CAAC;QACD,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,IAAuB,CAAC,CAAC,CAAC;YAC1C,IAAM,UAAU,GAAqB,CAAE,CAAC,UAAU,CAAC;YACnD,IAAM,cAAc,GAAG,UAAU,MAA6B,CAAC,CAAC,GAAuB,CAAC;gBACpF,UAAU,KAA4B,CAAC,CAAC,GAAsB,CAAC;sBACpC,CAAC;YAChC,IAAM,cAAc,GAAG,UAAU,MAA4B,CAAC,CAAC,IAAsB,CAAC,CAAC,CAAC,CAAC;YACzF,MAAM,CAAC,cAAc,GAAG,cAAc,CAAC;QAC3C,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,UAAwB,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,MAA2C,CAAC;QACvD,CAAC;QACD,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAjBe,wCAAqC,wCAiBpD,CAAA;IAED,qBAA4B,EAAU,EAAE,EAAU;QAC9C,IAAI,QAAQ,GAAa,IAAI,KAAK,CAAC,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAClD,IAAI,OAAO,GAAa,IAAI,KAAK,CAAC,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACjD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YAChB,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACpB,CAAC;QACD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACf,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBACrC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CACjB,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EACf,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAClB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7D,CAAC;YAED,IAAM,GAAG,GAAG,QAAQ,CAAC;YACrB,QAAQ,GAAG,OAAO,CAAC;YACnB,OAAO,GAAG,GAAG,CAAC;QAClB,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC;IArBe,cAAW,cAqB1B,CAAA;IAED,mBAA0B,MAAc,EAAE,OAAoB;QAC1D,MAAM,CAAC,MAAM,CAAC,KAAK,UAAoB,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IACxF,CAAC;IAFe,YAAS,YAExB,CAAA;IAGD,8CAAqD,MAAc;QAC/D,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;IACzF,CAAC;IAFe,uCAAoC,uCAEnD,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,MAAqB,CAAC;IACjD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,MAAoB,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,IAAW,UAOV;IAPD,WAAW,UAAU;QAEjB,2CAAI,CAAA;QAEJ,6CAAK,CAAA;QAEL,qDAAS,CAAA;IACb,CAAC,EAPU,UAAU,KAAV,UAAU,QAOpB;IACD,oBAAoB,IAAU;QAClB,IAAA,oBAAM,CAAU;QACxB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;YAAC,MAAM,GAAiB;QAEpC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,SAAuC;YACvC;gBACY,IAAA,0BAAQ,CAA8D;gBAC9E,MAAM,CAAC,QAAQ,OAA6B,IAAI,QAAQ,OAA+B,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC,CAAC,EAAgB,CAAC;YACnI;gBACU,IAAA,WAAoD,EAAlD,cAAI,EAAE,gCAAa,CAAgC;gBAC3D,MAAM,CAAC,IAAI,KAAK,IAAI,IAAI,oBAAoB,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC,CAAC,EAAgB,CAAC;YAC5G;gBACI,MAAM,CAAE,MAAmC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,GAAiB,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACrG;gBACI,MAAM,GAAiB;QAC/B,CAAC;QAED;YAEI,MAAM,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,QAAmC,CAAC,CAAC,GAAkB,CAAC,EAAqB,CAAC;QAC5H,CAAC;IACL,CAAC;IAED,4BAAmC,GAAQ,EAAE,GAAQ;QACjD,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACtE,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,GAAG,CAAC,CAAC,IAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YAClB,EAAE,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC;gBAC7B,EAAE,CAAC,CAAC,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtC,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;YACL,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,CAAC,CAAC;gBACpC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpB,MAAM,CAAC,KAAK,CAAC;gBACjB,CAAC;YACL,CAAC;QACL,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAlBe,qBAAkB,qBAkBjC,CAAA;IAKD,kBAA4B,GAAW,EAAE,aAAmD;QAExF,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;QAC3B,GAAG,CAAC,KAAK,EAAE,CAAC;IAChB,CAAC;IAJe,WAAQ,WAIvB,CAAA;IAkBD,mBAAgC,GAAW,EAAE,MAAsB,EAAE,OAA+B;QACxF,IAAA,uCAAc,EAAE,qCAAa,EAAE,yCAAe,CAAa;QAEnE,GAAG,CAAC,OAAO,CAAC,UAAC,aAAa,EAAE,GAAG;YAC3B,IAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAEtC,EAAE,CAAC,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC9B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBAChB,aAAa,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YACtC,CAAC;YAED,IAAI,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;gBACvB,eAAe,CAAC,aAAa,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;YACvD,CAAC;QACL,CAAC,CAAC,CAAC;QAGH,MAAM,CAAC,OAAO,CAAC,UAAC,aAAa,EAAE,GAAG;YAC9B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAEhB,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,cAAc,CAAC,GAAG,EAAE,aAAa,CAAC,CAAC,CAAC;YACrD,CAAC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAvBe,YAAS,YAuBxB,CAAA;IAGD,kCAA4C,SAAiB,EAAE,QAAkC;QAC7F,OAAO,IAAI,EAAE,CAAC;YACV,IAAM,MAAM,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;YACnC,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;gBACvB,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;YAED,IAAM,UAAU,GAAG,GAAA,gBAAgB,CAAC,SAAS,CAAC,CAAC;YAC/C,EAAE,CAAC,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;YAED,SAAS,GAAG,UAAU,CAAC;QAC3B,CAAC;IACL,CAAC;IAde,2BAAwB,2BAcvC,CAAA;AACL,CAAC,EAxiHS,EAAE,KAAF,EAAE,QAwiHX;AAED,WAAU,EAAE;IACR,+BAAsC,OAAwB;QAC1D,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;YACrB;gBACI,MAAM,CAAC,sBAAsB,CAAC;YAClC;gBACI,MAAM,CAAC,sBAAsB,CAAC;YAClC;gBACI,MAAM,CAAC,sBAAsB,CAAC;YAClC;gBACI,MAAM,CAAC,cAAc,CAAC;YAC1B;gBACI,MAAM,CAAC,UAAU,CAAC;QAC1B,CAAC;IACL,CAAC;IAbe,wBAAqB,wBAapC,CAAA;IAED,qBAA4B,IAAc;QACtC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;IACpC,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,yBAAgC,IAAc;QAC1C,MAAM,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;IAC7B,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,kCAAyC,IAAc,EAAE,QAAgB;QACrE,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;IAClE,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAGD,kCAAyC,IAAc,EAAE,KAAe;QACpE,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC;IAChF,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,8BAAqC,IAAc,EAAE,KAAe;QAChE,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QACvD,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;QACnE,MAAM,CAAC,YAAY,GAAG,UAAU,CAAC;IACrC,CAAC;IAJe,uBAAoB,uBAInC,CAAA;IAED,yBAAgC,KAAe,EAAE,KAAe;QAC5D,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QACxD,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;QACpE,EAAE,CAAC,CAAC,YAAY,GAAG,UAAU,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,wBAAwB,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;QAC9D,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAPe,kBAAe,kBAO9B,CAAA;IAED,wCAA+C,IAAc,EAAE,KAAe;QAC1E,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC;IAChF,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,gCAAuC,IAAc,EAAE,KAAa,EAAE,MAAc;QAChF,IAAM,GAAG,GAAG,KAAK,GAAG,MAAM,CAAC;QAC3B,MAAM,CAAC,KAAK,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC;IAC3D,CAAC;IAHe,yBAAsB,yBAGrC,CAAA;IAED,uCAA8C,MAAc,EAAE,OAAe,EAAE,MAAc,EAAE,OAAe;QAC1G,IAAM,IAAI,GAAG,MAAM,GAAG,OAAO,CAAC;QAC9B,IAAM,IAAI,GAAG,MAAM,GAAG,OAAO,CAAC;QAC9B,MAAM,CAAC,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,CAAC;IAC5C,CAAC;IAJe,gCAA6B,gCAI5C,CAAA;IAED,wCAA+C,IAAc,EAAE,QAAgB;QAC3E,MAAM,CAAC,QAAQ,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC;IACnE,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,8BAAqC,KAAe,EAAE,KAAe;QACjE,IAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QAC1D,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;QACtE,EAAE,CAAC,CAAC,cAAc,IAAI,YAAY,CAAC,CAAC,CAAC;YACjC,MAAM,CAAC,wBAAwB,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;QAClE,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAPe,uBAAoB,uBAOnC,CAAA;IAED,wBAA+B,KAAa,EAAE,MAAc;QACxD,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;YACZ,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC;QACjC,CAAC;QACD,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACb,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QAClC,CAAC;QAED,MAAM,CAAC,EAAE,KAAK,OAAA,EAAE,MAAM,QAAA,EAAE,CAAC;IAC7B,CAAC;IATe,iBAAc,iBAS7B,CAAA;IAED,kCAAyC,KAAa,EAAE,GAAW;QAC/D,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC;IAC9C,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,gCAAuC,KAAsB;QACzD,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;IAC7D,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,oCAA2C,KAAsB;QAC7D,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,SAAS,KAAK,CAAC,CAAC;IAChE,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,+BAAsC,IAAc,EAAE,SAAiB;QACnE,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACrC,CAAC;QAED,MAAM,CAAC,EAAE,IAAI,MAAA,EAAE,SAAS,WAAA,EAAE,CAAC;IAC/B,CAAC;IANe,wBAAqB,wBAMpC,CAAA;IAEU,2BAAwB,GAAG,qBAAqB,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAUrF,wDAA+D,OAAuC;QAClG,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,GAAA,wBAAwB,CAAC;QACpC,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACtB,CAAC;QAID,IAAM,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QAE3B,IAAI,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;QACnC,IAAI,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,OAAO,GAAG,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QAE5C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,IAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAkF9B,IAAM,SAAS,GAAG,SAAS,CAAC;YAC5B,IAAM,OAAO,GAAG,OAAO,CAAC;YACxB,IAAM,OAAO,GAAG,OAAO,CAAC;YAExB,IAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC;YACxC,IAAM,OAAO,GAAG,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAM,OAAO,GAAG,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;YAEjD,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;YAC3C,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC;YAC3D,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,MAAM,CAAC,qBAAqB,CAAC,wBAAwB,CAAC,SAAS,EAAE,OAAO,CAAC,EAAgB,OAAO,GAAG,SAAS,CAAC,CAAC;IAClH,CAAC;IAlHe,iDAA8C,iDAkH7D,CAAA;IAED,+BAAsC,CAAc;QAChD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,QAA6B,CAAC,CAAC,CAAC;YAC3C,GAAG,CAAC,CAAC,IAAI,OAAO,GAAS,CAAC,EAAE,OAAO,EAAE,OAAO,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC5D,EAAE,CAAC,CAAC,GAAA,cAAc,CAAC,OAAO,CAAC,IAAI,GAAA,WAAW,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,IAAI,QAAoC,CAAC,CAAC,CAAC;oBACtG,MAAM,CAAc,OAAO,CAAC;gBAChC,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IARe,wBAAqB,wBAQpC,CAAA;IAED,wCAA+C,IAAU;QACrD,MAAM,CAAC,GAAA,WAAW,CAAC,IAAI,KAA0C,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,QAA2B,IAAI,GAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACxJ,CAAC;IAFe,iCAA8B,iCAE7C,CAAA;IAED,+BAAsC,IAAiB;QACnD,EAAE,CAAC,CAAC,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,GAAA,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,qBAAqB,CAAC,CAAC;QACvD,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IALe,wBAAqB,wBAKpC,CAAA;IAED,+BAAsC,IAAoB;QACtD,EAAE,CAAC,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5C,CAAC;IALe,wBAAqB,wBAKpC,CAAA;IAED,0CAA0C,IAAU;QAChD,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,QAA8B,IAAI,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;YACjF,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED,kCAAyC,IAAU;QAC/C,IAAI,GAAG,gCAAgC,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,KAAK,GAAG,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACnC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC,CAAC,CAAC;YAC/C,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YAC3D,KAAK,IAAI,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC;YAChC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAiC,CAAC,CAAC,CAAC;YACrD,KAAK,IAAI,GAAA,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAjBe,2BAAwB,2BAiBvC,CAAA;IASD,8BAAqC,IAAU;QAC3C,IAAI,GAAG,gCAAgC,CAAC,IAAI,CAAC,CAAC;QAE9C,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACvB,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC,CAAC,CAAC;YAC/C,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAuC,CAAC,CAAC,CAAC;YAC3D,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;YACpB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,QAAiC,CAAC,CAAC,CAAC;YACrD,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;QACxB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAlBe,uBAAoB,uBAkBnC,CAAA;IAMD,sCACI,MAAc,EACd,GAAiK,EACjK,MAAyB;QACzB,IAAM,WAAW,GAAG,4BAA4B,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC;QAE5E,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACf,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,MAAM,CAAC,IAAI,CAAC,GAAA,wBAAwB,CAAC,GAAA,WAAW,CAAC,4EAA4E,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;YACnJ,CAAC;YACD,MAAM,CAAC;QACX,CAAC;QAED,IAAM,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAChC,IAAM,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAIjC,EAAE,CAAC,CAAC,CAAC,0BAA0B,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;YAC3D,0BAA0B,CAAC,QAAQ,EAAgB,SAAS,EAAE,MAAM,CAAC,CAAC;QAC1E,CAAC;QAED,oCAAoC,QAAgB,EAAE,SAAiB,EAAE,MAAyB;YAC9F,IAAM,gBAAgB,GAAG,GAAA,aAAa,CAAC,GAAG,CAAC,oBAAoB,EAAE,CAAC,CAAC;YACnE,IAAM,uBAAuB,GAAG,GAAA,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;YAEnE,IAAI,QAAQ,GAAG,GAAA,YAAY,CAAC,uBAAuB,EAAE,QAAQ,CAAC,CAAC;YAE/D,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACZ,QAAQ,GAAG,QAAQ,GAAG,GAAG,GAAG,SAAS,CAAC;YAC1C,CAAC;YAED,QAAQ,GAAG,GAAG,CAAC,WAAW,CAAC,GAAA,YAAY,CAAC,QAAQ,EAAE,mCAAmC,CAAC,CAAC,CAAC;YAExF,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YAGD,IAAI,YAAY,GAAG,EAAE,CAAC;YACtB,IAAI,CAAC;gBACD,YAAY,GAAG,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAC1C,CAAC;YACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACP,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACT,MAAM,CAAC,IAAI,CAAC,GAAA,wBAAwB,CAAC,GAAA,WAAW,CAAC,qBAAqB,EAAE,QAAQ,CAAC,CAAC,CAAC;gBACvF,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YACD,IAAI,CAAC;gBACD,EAAE,CAAC,2BAA2B,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;YAC9D,CAAC;YACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACP,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACT,MAAM,CAAC,IAAI,CAAC,GAAA,wBAAwB,CAAC,GAAA,WAAW,CAAC,uBAAuB,EAAE,QAAQ,CAAC,CAAC,CAAC;gBACzF,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;YAED,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;IACL,CAAC;IA7De,+BAA4B,+BA6D3C,CAAA;IAID,yBAAgC,IAAU,EAAE,QAAkC;QAC1E,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBACjC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;YACzB,CAAC;QACL,CAAC;QAED,MAAM,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;IAC1D,CAAC;IARe,kBAAe,kBAQ9B,CAAA;IAOD,yBAAgC,IAAU;QACtC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,IAAwB,CAAC,KAAK,CAAC,CAAC;IACtD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAkBD,0BAAiC,IAAU,EAAE,QAAkC;QAC3E,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,IAAI,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,IAAI,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;QAE7B,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACzD,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAZe,mBAAgB,mBAY/B,CAAA;IAQD,oCAA2C,UAAoB;QAC3D,IAAM,EAAE,GAAG,UAAoB,CAAC;QAChC,MAAM,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,OAAqB,IAAI,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,OAAqB,IAAI,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,OAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACzK,CAAC;IAHe,6BAA0B,6BAGzC,CAAA;IAED,gBAAuB,UAAsB;QACzC,MAAM,CAAC,0BAA0B,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;IAC9D,CAAC;IAFe,SAAM,SAErB,CAAA;IACD,oBAA2B,MAAc;QACrC,MAAM,CAAC,0BAA0B,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;IAC1D,CAAC;IAFe,aAAU,aAEzB,CAAA;IAQD,4BAAmC,EAAU;QACzC,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAOD,qCAAqC,WAA4B;QAC7D,IAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC;QAC3C,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QAED,EAAE,CAAC,CAAC,GAAA,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC;QAC9C,CAAC;QAED,MAAM,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YACpB;gBACI,EAAE,CAAC,CAAE,QAA8B,CAAC,eAAe;oBAC9C,QAA8B,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClE,MAAM,CAAC,wBAAwB,CAAE,QAA8B,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrG,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC;YACrB;gBACI,IAAM,IAAI,GAAI,QAAgC,CAAC,UAAU,CAAC;gBAC1D,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;oBAChB;wBACI,MAAM,CAAE,IAAiC,CAAC,IAAI,CAAC;oBACnD;wBACI,IAAM,GAAG,GAAI,IAAgC,CAAC,kBAAkB,CAAC;wBACjE,EAAE,CAAC,CAAC,GAAA,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;4BACpB,MAAM,CAAC,GAAG,CAAC;wBACf,CAAC;gBACT,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC;YACrB;gBACI,MAAM,CAAC,SAAS,CAAC;YACrB,UAAyC,CAAC;gBACtC,MAAM,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACzD,CAAC;YACD,UAAkC,CAAC;gBAC/B,EAAE,CAAC,CAAC,GAAA,aAAa,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,GAAA,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBACxE,MAAM,CAAC,wBAAwB,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;gBACxD,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;YACD;gBACI,GAAA,KAAK,CAAC,WAAW,CAAC,QAAQ,EAAE,4DAA4D,CAAC,CAAC;QAClG,CAAC;IACL,CAAC;IAED,kCAAkC,IAA8B;QAC5D,IAAM,IAAI,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;QACxC,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;IACjD,CAAC;IAED,+BAAsC,WAA4B;QAC9D,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,2BAA2B,CAAC,WAA8B,CAAC,CAAC;IAC3F,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,8BAAqC,WAAqC;QACtE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;YACvB,SAAiC;YACjC,UAAmC,CAAC;gBACxB,IAAA,uBAAI,CAAyC;gBACrD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;gBACtB,CAAC;gBACD,KAAK,CAAC;YACV,CAAC;YACD,UAAkC,CAAC;gBAC/B,IAAM,IAAI,GAAG,WAA+B,CAAC;gBAC7C,MAAM,CAAC,CAAC,GAAA,gCAAgC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC7C,OAAmD;oBACnD,OAAgD;oBAChD,OAA4C;oBAC5C;wBACI,MAAM,CAAE,IAAI,CAAC,IAAiC,CAAC,IAAI,CAAC;oBACxD;wBACI,MAAM,CAAC,SAAS,CAAC;gBACzB,CAAC;YACL,CAAC;YACD;gBACI,MAAM,CAAC,qBAAqB,CAAC,WAA8B,CAAC,CAAC;YACjE,UAAkC,CAAC;gBACvB,IAAA,mCAAU,CAAqC;gBACvD,MAAM,CAAC,GAAA,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC;YAC7D,CAAC;QACL,CAAC;QACD,MAAM,CAAE,WAAgC,CAAC,IAAI,CAAC;IAClD,CAAC;IAjCe,uBAAoB,uBAiCnC,CAAA;IAeD,+BAAsC,KAA2B;QAC7D,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,GAAA,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACzC,IAAM,MAAI,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC;YACpC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,IAA+B,OAAA,GAAA,mBAAmB,CAAC,GAAG,CAAC,IAAI,GAAA,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,WAAW,KAAK,MAAI,EAAnF,CAAmF,CAAwB,CAAC;QAC5L,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAPe,wBAAqB,wBAOpC,CAAA;IAQD,+BAAsC,IAAoD;QACtF,MAAM,CAAC,CAAC,CAAC,gBAAgB,CAAC,IAAI,MAA+B,CAAC;IAClE,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAGD,6BAAoC,IAAU;QAC1C,MAAM,CAAC,gBAAgB,CAAC,IAAI,MAAkD,CAAC;IACnF,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAGD,0BAAiC,IAAU;QACvC,MAAM,CAAC,gBAAgB,CAAC,IAAI,MAA4C,CAAC;IAC7E,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAGD,2BAAkC,IAAU;QACxC,MAAM,CAAC,gBAAgB,CAAC,IAAI,MAA8C,CAAC;IAC/E,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAGD,6BAAoC,IAAU;QAC1C,MAAM,CAAC,gBAAgB,CAAC,IAAI,MAAkD,CAAC;IACnF,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAGD,yBAAgC,IAAU;QAEtC,IAAM,GAAG,GAAG,gBAAgB,CAAC,IAAI,MAA0C,CAAC;QAC5E,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,cAAc,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;YACvD,MAAM,CAAC,GAAG,CAAC;QACf,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAPe,kBAAe,kBAO9B,CAAA;IAaD,sBAA6B,IAAU;QACnC,IAAI,GAAG,GAAqC,gBAAgB,CAAC,IAAI,MAA0C,CAAC;QAC5G,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,QAAyB,CAAC,CAAC,CAAC;YAC7C,IAAM,SAAS,GAAG,qBAAqB,CAAC,IAA4B,CAAC,CAAC;YACtE,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACZ,GAAG,GAAG,GAAA,IAAI,CAAC,SAAS,EAAE,UAAA,GAAG,IAAI,OAAA,CAAC,CAAC,GAAG,CAAC,cAAc,EAApB,CAAoB,CAAC,CAAC;YACvD,CAAC;QACL,CAAC;QAED,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,cAAc,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC;IAChE,CAAC;IAVe,eAAY,eAU3B,CAAA;IAQD,4BAAmC,IAAU;QACzC,IAAM,SAAS,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAC1C,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,cAAc,IAAI,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC;IAClF,CAAC;IAHe,qBAAkB,qBAGjC,CAAA;IAGD,sBAA6B,IAAU;QACnC,IAAI,IAAI,GAAI,IAAuB,CAAC,UAAU,CAAC;QAE/C,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACpB,IAAuB,CAAC,UAAU,GAAG,IAAI,GAAG,GAAA,OAAO,CAAC,GAAA,uBAAuB,CAAC,IAAI,CAAC,EAAE,UAAA,CAAC,IAAI,OAAA,GAAA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAvB,CAAuB,CAAC,CAAC;QACtH,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAPe,eAAY,eAO3B,CAAA;IAGD,0BAA0B,IAAU,EAAE,IAAgB;QAClD,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAChC,MAAM,CAAC,GAAA,IAAI,CAAC,IAAI,EAAE,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,KAAK,IAAI,EAAjB,CAAiB,CAAC,CAAC;IAChD,CAAC;IAGD,+BAAsC,IAAU,EAAE,IAAgB;QAC9D,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAChC,MAAM,CAAC,GAAA,MAAM,CAAC,IAAI,EAAE,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,KAAK,IAAI,EAAjB,CAAiB,CAAC,CAAC;IAClD,CAAC;IAHe,wBAAqB,wBAGpC,CAAA;AAEL,CAAC,EAjqBS,EAAE,KAAF,EAAE,QAiqBX;AAGD,WAAU,EAAE;IAER,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,MAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,MAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,mBAA0B,IAAU;QAChC,MAAM,CAAC,IAAI,CAAC,IAAI,OAAuB,CAAC;IAC5C,CAAC;IAFe,YAAS,YAExB,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,OAAwC,CAAC;IAC7D,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,yCAAgD,IAAU;QACtD,MAAM,CAAC,IAAI,CAAC,IAAI,OAA6C,CAAC;IAClE,CAAC;IAFe,kCAA+B,kCAE9C,CAAA;IAID,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC;IAC/C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAID,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC;IACzD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAID,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,cAAW,cAE1B,CAAA;IAID,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,yCAAgD,IAAU;QACtD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,kCAA+B,kCAE9C,CAAA;IAED,qCAA4C,IAAU;QAClD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,8BAA2B,8BAE1C,CAAA;IAID,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAwB,CAAC;IAC7C,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B,CAAC;IAC/C,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAID,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC;IACzD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAID,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAsC,CAAC;IAC3D,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAwC,CAAC;IAC7D,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAwC,CAAC;IAC7D,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAID,yCAAgD,IAAU;QACtD,OAAO,IAAI,CAAC,IAAI,QAA0C,EAAE,CAAC;YACzD,IAAI,GAAgC,IAAK,CAAC,UAAU,CAAC;QACzD,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IANe,kCAA+B,kCAM9C,CAAA;IAED,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAqC,CAAC;IAC1D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,kCAAyC,IAAU;QAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAsC,CAAC;IAC3D,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAqC,CAAC;IAC1D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,uCAA8C,IAAU;QACpD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2C,CAAC;IAChE,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAID,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAqC,CAAC;IAC1D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAID,iBAAwB,IAAU;QAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,QAAqB,CAAC;IAC1C,CAAC;IAFe,UAAO,UAEtB,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC;IACzD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC;IACzD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAC;IAC9C,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,sCAA6C,IAAU;QACnD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0C,CAAC;IAC/D,CAAC;IAFe,+BAA4B,+BAE3C,CAAA;IAED,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAID,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAuC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAID,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B,CAAC;IAC/C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,iCAAwC,IAAU;QAC9C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAqC,CAAC;IAC1D,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAID,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B,CAAC;IAC/C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,yBAAgC,IAAU;QACtC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC;IAClD,CAAC;IAFe,kBAAe,kBAE9B,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAID,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAkC,CAAC;IACvD,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAED,uCAA8C,IAAU;QACpD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2C,CAAC;IAChE,CAAC;IAFe,gCAA6B,gCAE5C,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAID,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B,CAAC;IAC/C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAGD,sBAA6B,IAAU;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0B,CAAC;IAC/C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,kBAAyB,IAAU;QAC/B,MAAM,CAAC,IAAI,CAAC,IAAI,QAAsB,CAAC;IAC3C,CAAC;IAFe,WAAQ,WAEvB,CAAA;IAID,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,wBAA+B,IAAkB;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC;IACzD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,iBAAwB,IAAU;QAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,UAAO,UAEtB,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAC;IACtD,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAED,0BAAiC,IAAU;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,CAAC;IACnD,CAAC;IAFe,mBAAgB,mBAE/B,CAAA;IAED,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,2BAAkC,IAAU;QACxC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA+B,CAAC;IACpD,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;IAED,gCAAuC,IAAU;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,IAAI,IAAI,CAAC,IAAI,QAAiC,CAAC;IACnG,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAED,4BAAmC,IAAU;QACzC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAgC,CAAC;IACrD,CAAC;IAFe,qBAAkB,qBAEjC,CAAA;AACL,CAAC,EAtoBS,EAAE,KAAF,EAAE,QAsoBX;AAMD,WAAU,EAAE;IAER,sBAA6B,CAAO;QAChC,MAAM,CAAC,CAAC,CAAC,IAAI,QAA0B,CAAC;IAC5C,CAAC;IAFe,eAAY,eAE3B,CAAA;IAGD,gBAAuB,IAAU;QAC7B,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC;IAFe,SAAM,SAErB,CAAA;IAGD,oBAA2B,IAAgB;QACvC,MAAM,CAAC,IAAI,OAAwB,CAAC;IACxC,CAAC;IAFe,aAAU,aAEzB,CAAA;IAMD,iBAAwB,CAAO;QAC3B,MAAM,CAAC,CAAC,CAAC,IAAI,KAAyB,IAAI,CAAC,CAAC,IAAI,OAAwB,CAAC;IAC7E,CAAC;IAFe,UAAO,UAEtB,CAAA;IAKD,qBAA4C,KAAuB;QAC/D,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC;IAFe,cAAW,cAE1B,CAAA;IAKD,uBAA8B,IAAgB;QAC1C,MAAM,CAAC,KAAgC,IAAI,IAAI,IAAI,MAA+B,CAAC;IACvF,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,6BAAoC,IAAU;QAC1C,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAFe,sBAAmB,sBAElC,CAAA;IAKD,+BAAsC,IAAgB;QAClD,MAAM,CAAC,MAAiC,IAAI,IAAI,IAAI,MAAgC,CAAC;IACzF,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,wCAA+C,IAAU;QACrD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,OAA8B;eAClC,IAAI,OAA4B,CAAC;IAC5C,CAAC;IAJe,iCAA8B,iCAI7C,CAAA;IAED,oCAA2C,IAAU;QACjD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,OAA8B;YAC9B,QAA6B;YAC7B,QAA+B;YAC/B,QAA6B;YAC7B;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAXe,6BAA0B,6BAWzC,CAAA;IAKD,+BAAsC,IAAU;QAE5C,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,gBAAgB,IAA+B,CAAC;IACtF,CAAC;IAHe,wBAAqB,wBAGpC,CAAA;IAKD,wBAA+B,KAAiB;QAC5C,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACZ,SAAgC;YAChC,SAA6B;YAC7B,QAA6B;YAC7B,SAA+B;YAC/B,QAA+B;YAC/B,QAA8B;YAC9B,SAA8B;YAC9B,SAA+B;YAC/B,SAAiC;YACjC,SAAgC;YAChC;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAhBe,iBAAc,iBAgB7B,CAAA;IAED,oBAA2B,IAAU;QACjC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAFe,aAAU,aAEzB,CAAA;IAED,sBAA6B,IAAU;QACnC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA6B;eACjC,IAAI,OAA0B,CAAC;IAC1C,CAAC;IAJe,eAAY,eAI3B,CAAA;IAED,wBAA+B,IAAU;QACrC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,OAA0B;eAC9B,IAAI,MAA6B;eACjC,IAAI,MAA8B;eAClC,IAAI,QAAoC,CAAC;IACpD,CAAC;IANe,iBAAc,iBAM7B,CAAA;IAED,uBAA8B,IAAU;QACpC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,OAA0B;eAC9B,IAAI,QAAoC;eACxC,IAAI,QAAmC,CAAC;IACnD,CAAC;IALe,gBAAa,gBAK5B,CAAA;IAID,wBAA+B,IAAU;QACrC,MAAM,CAAC,IAAI,IAAI,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjD,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAGD,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,IAAI,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5D,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,uCAAuC,IAAgB;QACnD,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,SAAoC;YACpC,SAAkC;YAClC,SAA4B;YAC5B,SAA4B;YAC5B,SAA4B;YAC5B,SAAmC;YACnC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAGD,4BAAmC,IAAgB;QAC/C,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,SAAgC;YAChC,SAA8B;YAC9B,SAAmC;YACnC,SAA+B;YAC/B,SAA6B;YAC7B,SAAkC;YAClC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;QACnD,CAAC;IACL,CAAC;IAbe,qBAAkB,qBAajC,CAAA;IAGD,iCAAwC,IAAU;QAC9C,MAAM,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,IAAI,GAAA,aAAa,CAAC,IAAI,CAAC,IAAI,GAAA,OAAO,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACrG,CAAC;IAFe,0BAAuB,0BAEtC,CAAA;IAGD,wBAA+B,IAAU;QACrC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA2B;eAC/B,IAAI,QAAmC;eACvC,IAAI,QAAiC;eACrC,IAAI,QAA2B;eAC/B,IAAI,QAA2B;eAC/B,IAAI,QAA8B;eAClC,IAAI,QAAqC;eACzC,IAAI,QAAkC,CAAC;IAClD,CAAC;IAVe,iBAAc,iBAU7B,CAAA;IAED,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,QAAgC,IAAI,IAAI,CAAC,IAAI,QAA+B,CAAC,CAAC;IAC3G,CAAC;IAFe,cAAW,cAE1B,CAAA;IAED,oBAA2B,IAAU;QACjC,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,QAA2B,IAAI,IAAI,CAAC,IAAI,QAA2B,CAAC,CAAC;IAClG,CAAC;IAFe,aAAU,aAEzB,CAAA;IAID,uBAA8B,IAAU;QACpC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAkC;eACtC,IAAI,QAA6B;eACjC,IAAI,QAAiC;eACrC,IAAI,QAA+B;eACnC,IAAI,QAA8B;eAClC,IAAI,QAAkC,CAAC;IAClD,CAAC;IARe,gBAAa,gBAQ5B,CAAA;IAED,oCAA2C,IAAU;QACjD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAkC;eACtC,IAAI,QAA2C;eAC/C,IAAI,QAAgC;eACpC,IAAI,QAAiC;eACrC,IAAI,QAA2B;eAC/B,IAAI,QAA2B;eAC/B,IAAI,QAAkC,CAAC;IAClD,CAAC;IATe,6BAA0B,6BASzC,CAAA;IAID,wBAAwB,IAAgB;QACpC,MAAM,CAAC,CAAC,IAAI,OAA4B,IAAI,IAAI,OAA2B,CAAC;eACrE,IAAI,QAA0B;eAC9B,IAAI,QAA6B;eACjC,IAAI,QAA6B;eACjC,IAAI,QAA8B;eAClC,IAAI,QAA6B;eACjC,IAAI,QAA6B;eACjC,IAAI,OAA2B;eAC/B,IAAI,QAA2B;eAC/B,IAAI,QAAgC;eACpC,IAAI,OAA2B;eAC/B,IAAI,QAA4B;eAChC,IAAI,QAA2C;eAC/C,IAAI,QAA4B;eAChC,IAAI,QAAgC;eACpC,IAAI,QAAiC;eACrC,IAAI,QAAoC;eACxC,IAAI,QAAiC;eACrC,IAAI,QAAiC;eACrC,IAAI,QAAiC,CAAC;IACjD,CAAC;IAOD,oBAA2B,IAAU;QACjC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAFe,aAAU,aAEzB,CAAA;IAED,yCAAgD,IAAU;QACtD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA6B;YAC7B;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,kCAA+B,kCAQ9C,CAAA;IAKD,0BAAiC,IAAU;QACvC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,CAAC,IAAI,QAAmC;mBACvC,IAAI,QAAoC,CAAC;QACpD,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,mBAAgB,mBAQ/B,CAAA;IAGD,6BAAoC,IAAU;QAC1C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAsC;eAC1C,IAAI,QAAuC,CAAC;IACvD,CAAC;IAJe,sBAAmB,sBAIlC,CAAA;IAID,+BAAsC,IAAU;QAC5C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA8B;eAClC,IAAI,QAAiC,CAAC;IACjD,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAOD,qCAA4C,cAA0C;QAClF,MAAM,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;YAC1B,SAAoC;YACpC,SAA0B;YAC1B;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IATe,8BAA2B,8BAS1C,CAAA;IAMD,sCAA6C,IAAsC;QAC/E,MAAM,CAAC,kCAAkC,CAAC,IAAI,CAAC;eACxC,iCAAiC,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC;IAHe,+BAA4B,+BAG3C,CAAA;IAMD,4CAAmD,IAAsC;QACrF,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAqC;YACrC;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,qCAAkC,qCAQjD,CAAA;IAMD,2CAAkD,IAAsC;QACpF,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAoC;YACpC;gBACI,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IARe,oCAAiC,oCAQhD,CAAA;IAID,yCAAgD,IAAU;QACtD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAwC;eAC5C,IAAI,QAA6B,CAAC;IAC7C,CAAC;IAJe,kCAA+B,kCAI9C,CAAA;IAED,8BAAqC,IAAU;QAC3C,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAAkC;YAClC,SAAsC;YACtC,SAA+B;YAC/B,SAA8B;YAC9B,SAAyC;YACzC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAZe,uBAAoB,uBAYnC,CAAA;IAED,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,IAAI,IAAI,CAAC,IAAI,QAA6B,CAAC;IAC7F,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAED,2BAAkC,IAAU;QACxC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAkC;eACtC,IAAI,OAA6C,CAAC;IAC7D,CAAC;IAJe,oBAAiB,oBAIhC,CAAA;IAGD,kCAAyC,IAAU;QAC/C,MAAM,CAAC,4BAA4B,CAAC,GAAA,+BAA+B,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;IACpF,CAAC;IAFe,2BAAwB,2BAEvC,CAAA;IAED,sCAAsC,IAAgB;QAClD,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,SAAyC;YACzC,SAAwC;YACxC,SAA8B;YAC9B,SAA+B;YAC/B,SAA2B;YAC3B,SAAsC;YACtC,SAAyC;YACzC,SAAuC;YACvC,SAAwC;YACxC,SAAwC;YACxC,SAAgC;YAChC,SAAmC;YACnC,QAA2B;YAC3B,QAAyC;YACzC,OAA+B;YAC/B,OAA8B;YAC9B,QAA8C;YAC9C,SAAmC;YACnC,QAA6B;YAC7B,QAA4B;YAC5B,QAA4B;YAC5B,SAA4B;YAC5B,QAA6B;YAC7B,SAAkC;YAClC,SAA6B;YAC7B;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAGD,2BAAkC,IAAU;QACxC,MAAM,CAAC,qBAAqB,CAAC,GAAA,+BAA+B,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;IAC7E,CAAC;IAFe,oBAAiB,oBAEhC,CAAA;IAED,+BAA+B,IAAgB;QAC3C,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,SAAsC;YACtC,SAAuC;YACvC,SAAiC;YACjC,SAAiC;YACjC,SAA+B;YAC/B,SAAgC;YAChC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;QAClD,CAAC;IACL,CAAC;IAGD,oCAA2C,IAAU;QACjD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAyB,IAAK,CAAC,QAAQ,OAA6B;oBAC9C,IAAK,CAAC,QAAQ,OAA+B,CAAC;YAC9E;gBACI,MAAM,CAAC,KAAK,CAAC;QACrB,CAAC;IACL,CAAC;IAVe,6BAA0B,6BAUzC,CAAA;IAOD,sBAA6B,IAAU;QACnC,MAAM,CAAC,gBAAgB,CAAC,GAAA,+BAA+B,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;IACxE,CAAC;IAFe,eAAY,eAE3B,CAAA;IAED,0BAA0B,IAAgB;QACtC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,SAAsC;YACtC,SAAgC;YAChC,SAA8B;YAC9B,SAAiC;YACjC,SAA8B;YAC9B,SAA6B;YAC7B,SAAkC;YAClC,SAAoC;YACpC;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;QAC3C,CAAC;IACL,CAAC;IAED,+BAAsC,IAAU;QAC5C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAuC;eAC3C,IAAI,QAA4B,CAAC;IAC5C,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAGD,sCAA6C,IAAU;QACnD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA0C,CAAC;IAC/D,CAAC;IAFe,+BAA4B,+BAE3C,CAAA;IAGD,+BAAsC,IAAU;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,QAAmC,CAAC;IACxD,CAAC;IAFe,wBAAqB,wBAEpC,CAAA;IAGD,4CAAmD,IAAU;QACzD,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC;eAC3B,4BAA4B,CAAC,IAAI,CAAC,CAAC;IAC9C,CAAC;IAHe,qCAAkC,qCAGjD,CAAA;IAID,8BAAqC,IAAU,EAAE,uBAAgC;QAC7E,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA6B;YAC7B,SAA+B;YAC/B,SAA+B;YAC/B,SAA4B;YAC5B;gBACI,MAAM,CAAC,IAAI,CAAC;YAChB;gBACI,MAAM,CAAC,uBAAuB,IAAI,oBAAoB,CAAoB,IAAK,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;QAC5H,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAbe,uBAAoB,uBAanC,CAAA;IAGD,8BAAqC,IAAU;QAC3C,MAAM,CAAC,IAAI,CAAC,IAAI,QAA8B,IAAI,IAAI,CAAC,IAAI,QAA8B,CAAC;IAC9F,CAAC;IAFe,uBAAoB,uBAEnC,CAAA;IAKD,uBAA8B,IAAU;QACpC,MAAM,CAAC,GAAA,OAAO,CAAC,IAAI,CAAC;eACb,YAAY,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAHe,gBAAa,gBAG5B,CAAA;IAGD,wBAA+B,IAAU;QACrC,MAAM,CAAC,GAAA,OAAO,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;IAFe,iBAAc,iBAE7B,CAAA;IAGD,0BAAiC,IAAU;QACvC,MAAM,CAAC,GAAA,yBAAyB,CAAC,IAAI,CAAC;eAC/B,YAAY,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAHe,mBAAgB,mBAG/B,CAAA;IAGD,sBAA6B,IAAU;QACnC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA2B;eAC/B,IAAI,QAAiC;eACrC,IAAI,OAA0B,CAAC;IAC1C,CAAC;IALe,eAAY,eAK3B,CAAA;IAGD,yBAAgC,IAAU;QACtC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA2B;eAC/B,IAAI,QAAiC,CAAC;IACjD,CAAC;IAJe,kBAAe,kBAI9B,CAAA;IAGD,8BAAqC,IAAU;QAC3C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,OAA0B;eAC9B,IAAI,QAAiC,CAAC;IACjD,CAAC;IAJe,uBAAoB,uBAInC,CAAA;IAGD,+BAAsC,IAAU;QAC5C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA4B;eAChC,IAAI,QAA+B,CAAC;IAC/C,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAGD,mCAA0C,IAAU;QAChD,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,IAAI,IAAI,CAAC,IAAI,QAA+B,CAAC;IAClG,CAAC;IAFe,4BAAyB,4BAExC,CAAA;IAED,2BAA2B,IAAgB;QACvC,MAAM,CAAC,IAAI,QAA6B;eACjC,IAAI,QAA8B;eAClC,IAAI,QAAgC;eACpC,IAAI,QAA+B;eACnC,IAAI,QAA2B;eAC/B,IAAI,QAA+B;eACnC,IAAI,QAA0B;eAC9B,IAAI,QAA+B;eACnC,IAAI,QAAmC;eACvC,IAAI,QAAkC;eACtC,IAAI,QAA2B;eAC/B,IAAI,QAA4B;eAChC,IAAI,QAAuC;eAC3C,IAAI,QAA+B;eACnC,IAAI,QAAoC;eACxC,IAAI,QAA4B;eAChC,IAAI,QAAiC;eACrC,IAAI,QAA+B;eACnC,IAAI,QAAiC;eACrC,IAAI,QAA0C;eAC9C,IAAI,QAA+B;eACnC,IAAI,QAAyB;eAC7B,IAAI,QAAkC;eACtC,IAAI,QAAmC;eACvC,IAAI,QAAiC;eACrC,IAAI,QAA2B;eAC/B,IAAI,QAA2C;eAC/C,IAAI,QAAoC;eACxC,IAAI,QAA6B;eACjC,IAAI,QAAmC;eACvC,IAAI,QAA+B,CAAC;IAC/C,CAAC;IAED,oCAAoC,IAAgB;QAChD,MAAM,CAAC,IAAI,QAAmC;eACvC,IAAI,QAAkC;eACtC,IAAI,QAAgC;eACpC,IAAI,QAAoC;eACxC,IAAI,QAAoC;eACxC,IAAI,QAA+B;eACnC,IAAI,QAAiC;eACrC,IAAI,QAAiC;eACrC,IAAI,QAAuC;eAC3C,IAAI,QAAiC;eACrC,IAAI,QAAgC;eACpC,IAAI,QAA0C,CAAC;IAC1D,CAAC;IAED,8CAA8C,IAAgB;QAC1D,MAAM,CAAC,IAAI,QAA8B;eAClC,IAAI,QAAiC;eACrC,IAAI,QAAiC;eACrC,IAAI,QAA2B;eAC/B,IAAI,QAAmC;eACvC,IAAI,QAA8B;eAClC,IAAI,QAA8B;eAClC,IAAI,QAA8B;eAClC,IAAI,QAA4B;eAChC,IAAI,QAA2B;eAC/B,IAAI,QAAgC;eACpC,IAAI,QAA+B;eACnC,IAAI,QAA+B;eACnC,IAAI,QAA8B;eAClC,IAAI,QAA4B;eAChC,IAAI,QAAiC;eACrC,IAAI,QAA8B;eAClC,IAAI,QAA6B;eACjC,IAAI,QAAmC;eACvC,IAAI,QAAsC;eAC1C,IAAI,QAAsC,CAAC;IACtD,CAAC;IAGD,uBAA8B,IAAU;QACpC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAC,CAAC,CAAC;YACzC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAgC,IAAI,GAAA,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACxF,CAAC;QAED,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxC,CAAC;IANe,gBAAa,gBAM5B,CAAA;IAGD,gCAAuC,IAAU;QAC7C,MAAM,CAAC,0BAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjD,CAAC;IAFe,yBAAsB,yBAErC,CAAA;IAMD,sCAA6C,IAAU;QACnD,MAAM,CAAC,oCAAoC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3D,CAAC;IAFe,+BAA4B,+BAE3C,CAAA;IAGD,qBAA4B,IAAU;QAClC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,oCAAoC,CAAC,IAAI,CAAC;eAC1C,0BAA0B,CAAC,IAAI,CAAC;eAChC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IALe,cAAW,cAK1B,CAAA;IAED,0BAA0B,IAAU;QAChC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAqB,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QACjD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;YAC5B,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAA4B,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,QAA2B,CAAC,CAAC,CAAC;gBAC9F,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,CAAC,GAAA,eAAe,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAKD,2BAAkC,IAAU;QACxC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAuC;eAC3C,IAAI,QAA6B;eACjC,IAAI,OAA0B,CAAC;IAC1C,CAAC;IALe,oBAAiB,oBAKhC,CAAA;IAKD,gCAAuC,IAAU;QAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,OAA2B;eAC/B,IAAI,OAA0B;eAC9B,IAAI,QAAwC,CAAC;IACxD,CAAC;IALe,yBAAsB,yBAKrC,CAAA;IAGD,oBAA2B,IAAU;QACjC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA0B;eAC9B,IAAI,QAA6B;eACjC,IAAI,QAAqC;eACzC,IAAI,OAAuB,CAAC;IACvC,CAAC;IANe,aAAU,aAMzB,CAAA;IAGD,4BAAmC,IAAU;QACzC,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA4B;eAChC,IAAI,QAAkC,CAAC;IAClD,CAAC;IAJe,qBAAkB,qBAIjC,CAAA;IAGD,wCAA+C,IAAU;QACrD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,MAA6B;eACjC,IAAI,QAA6B,CAAC;IAC7C,CAAC;IAJe,iCAA8B,iCAI7C,CAAA;IAED,iCAAwC,IAAU;QAC9C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAAiC;eACrC,IAAI,QAAqC,CAAC;IACrD,CAAC;IAJe,0BAAuB,0BAItC,CAAA;IAID,+BAAsC,IAAU;QAC5C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,CAAC,IAAI,QAA0B;eAC9B,IAAI,QAA6B,CAAC;IAC7C,CAAC;IAJe,wBAAqB,wBAIpC,CAAA;IAMD,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,OAA6B,IAAI,IAAI,CAAC,IAAI,OAA4B,CAAC;IAC3F,CAAC;IAFe,cAAW,cAE1B,CAAA;IAGD,sCAA6C,IAAU;QACnD,MAAM,CAAC,IAAI,CAAC,IAAI,QAA4B,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;IACrE,CAAC;IAFe,+BAA4B,+BAE3C,CAAA;IAID,oBAA2B,IAAU;QACjC,MAAM,CAAC,IAAI,CAAC,IAAI,OAAgC,IAAI,IAAI,CAAC,IAAI,OAA+B,CAAC;IACjG,CAAC;IAFe,aAAU,aAEzB,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA2B,CAAC;IAChD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAID,uBAA8B,IAAU;QACpC,MAAM,CAAC,CAAC,CAAE,IAAuB,CAAC,KAAK,IAAK,IAAuB,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACzF,CAAC;IAFe,gBAAa,gBAE5B,CAAA;AACL,CAAC,EA/vBS,EAAE,KAAF,EAAE,QA+vBX;AAED,WAAU,EAAE;IAER;QACI,IAAI,EAAE,GAAG,MAAM,CAAC,MAAM,CAAS,IAAI,CAAC,CAAA;QACpC,EAAE,CAAC,EAAE,GAAG,SAAS,CAAA;QACjB,OAAO,EAAE,CAAC,EAAE,CAAA;QACZ,MAAM,CAAC,EAAE,CAAA;IACb,CAAC;IALe,QAAK,QAKpB,CAAA;IAED,iBAAwB,IAAU,EAAE,IAAY;QAC5C,IAAM,aAAa,GAAG,GAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC9D,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAChB,IAAI,EAAE,GAAa,EAAE,CAAA;YACrB,GAAG,CAAC,CAAa,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa;gBAAzB,IAAM,EAAE,sBAAA;gBACT,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAyB;oBACpD,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAsB;oBACjD,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,QAA6B,CAAC,CAAC,CAAC;oBAC3D,IAAI,CAAC,GAAG,KAAK,EAAU,CAAA;oBACvB,CAAC,CAAC,IAAI,IAAY,CAAA;oBAClB,CAAC,CAAC,IAAI,GAAG,EAAE,CAAA;oBACX,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;gBACd,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAyB;oBAC3D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAsB;oBACjD,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAsB;oBACjD,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,QAA6B,CAAC,CAAC,CAAC;oBAC3D,IAAI,CAAC,GAAG,KAAK,EAAU,CAAA;oBACvB,CAAC,CAAC,IAAI,KAAY,CAAA;oBAClB,CAAC,CAAC,IAAI,GAAG,EAAE,CAAA;oBACX,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;gBACd,CAAC;aACJ;YACD,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACd,MAAM,CAAC,EAAE,CAAA;YACb,CAAC;QACL,CAAC;IACL,CAAC;IA1Be,UAAO,UA0BtB,CAAA;IACD,wBAA+B,IAAiB;QAC5C,IAAM,GAAG,GAAG,GAAA,oBAAoB,CAAC,IAAI,CAAC,CAAA;QACtC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,CAAC,GAAA,YAAY,CAAC,GAAG,CAAC,IAAI,GAAA,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC;IACzE,CAAC;IANe,iBAAc,iBAM7B,CAAA;IAED,iBAAwB,IAAU;QAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,QAAsB,CAAA;IAC1C,CAAC;IAFe,UAAO,UAEtB,CAAA;IAED,iBAAwB,IAAU;QAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,QAAsB,CAAA;IAC1C,CAAC;IAFe,UAAO,UAEtB,CAAA;IAKD,cAAc,KAAU;QACpB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAA;QAC9B,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED,aAAa,IAAS;QAClB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAA;QAC7B,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED,gBAAgB,IAAS;QACrB,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,KAA0B,CAAC,CAAC,CAAC,CAAC;YAC/D,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED,eAAe,IAAS;QACpB,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,WAAsB,CAAC,CAAC,CAAC,CAAC;YAC3D,MAAM,CAAC,IAAI,CAAA;QACf,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED,gBAAgB,IAAS;QACrB,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,MAA6B,CAAC,CAAC;IACzE,CAAC;IAED,kBAAkB,IAAS;QACvB,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,OAA6C,CAAC,CAAC;IACzF,CAAC;IAED,gBAAuB,EAAW,EAAE,EAAW;QAC3C,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;YACZ,MAAM,CAAC,IAAI,CAAA;QACf,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,GAAG,SAAU,EAAE,GAAG,SAAU,EAAE,GAAG,SAAU,EAAE,GAAG,SAAU,CAAC;YAC/D,EAAE,CAAC,CAAC,GAAA,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACf,GAAG,GAAI,EAAe,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAgB,CAAC,CAAC,CAAC,CAAC;gBAC9B,GAAG,GAAI,EAAiB,CAAC,WAAW,CAAC;gBACrC,GAAG,GAAI,EAAiB,CAAC,EAAE,IAAK,EAAiB,CAAC,EAAE,CAAC,EAAE,CAAC;YAC5D,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACf,GAAG,GAAI,EAAa,CAAC,WAAW,CAAC;gBACjC,GAAG,GAAI,EAAa,CAAC,EAAE,IAAK,EAAa,CAAC,EAAE,CAAC,EAAE,CAAC;YACpD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAClB,GAAG,GAAI,EAAwB,CAAC,KAAiB,CAAC;gBAClD,GAAG,GAAI,EAAwB,CAAC,EAAE,IAAK,EAAwB,CAAC,EAAE,CAAC,EAAE,CAAC;YAC1E,CAAC;YAED,EAAE,CAAC,CAAC,GAAA,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACf,GAAG,GAAI,EAAe,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAgB,CAAC,CAAC,CAAC,CAAC;gBAC9B,GAAG,GAAI,EAAiB,CAAC,WAAW,CAAC;gBACrC,GAAG,GAAI,EAAiB,CAAC,EAAE,IAAK,EAAiB,CAAC,EAAE,CAAC,EAAE,CAAC;YAC5D,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACf,GAAG,GAAI,EAAa,CAAC,WAAW,CAAC;gBACjC,GAAG,GAAI,EAAa,CAAC,EAAE,IAAK,EAAa,CAAC,EAAE,CAAC,EAAE,CAAC;YACpD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAClB,GAAG,GAAI,EAAwB,CAAC,KAAiB,CAAC;gBAClD,GAAG,GAAI,EAAwB,CAAC,EAAE,IAAK,EAAwB,CAAC,EAAE,CAAC,EAAE,CAAC;YAC1E,CAAC;YACD,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC7C,IAAM,EAAE,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;gBAC1D,MAAM,CAAC,EAAE,CAAA;YACb,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,MAAM,CAAC,KAAK,CAAA;YAChB,CAAC;QAEL,CAAC;IACL,CAAC;IA7Ce,SAAM,SA6CrB,CAAA;IAED,oBAAoB,EAAQ,EAAE,EAAQ;QAClC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED,gBAAgB,EAAqB,EAAE,IAAuB;QAC1D,IAAI,EAAE,GAAG,KAAK,EAAQ,CAAA;QACtB,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC;QACX,EAAE,CAAC,EAAE,GAAG,IAAI,CAAA;QACZ,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAED,gBAAuB,EAAM;QACzB,IAAI,EAAE,GAAG,KAAK,EAAM,CAAC;QACrB,EAAE,gBAAQ,EAAE,CAAE,CAAC;QACf,EAAE,CAAC,CAAC,gBAAQ,EAAE,CAAC,CAAC,IAAE,IAAI,QAAkB,CAAC;QACzC,EAAE,CAAC,CAAC,gBAAQ,EAAE,CAAC,CAAC,IAAE,IAAI,QAAkB,CAAC;QACzC,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,MAAY,CAAC,CAAC,GAAS,CAAC,EAAQ,CAAC;QAClD,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAPe,SAAM,SAOrB,CAAA;IAED,eAAsB,EAAM,EAAE,EAAS;QACnC,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,KAAK,GAAG,EAAE,CAAC,QAAQ,GAAG,EAAE,CAAC,KAAK,GAAG,EAAE,CAAC,KAAK,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC;IAClF,CAAC;IAFe,QAAK,QAEpB,CAAA;IAED,gBAAuB,EAAQ;QAC3B,MAAM,CAAC,EAAE,IAAU,CAAC,CAAC,CAAC,EAAE,IAAU,IAAU,CAAC,CAAC,CAAC,EAAE,IAAU,IAAU,CAAC;IAC1E,CAAC;IAFe,SAAM,SAErB,CAAA;IAED,oBAA8C,GAA4B,EAAE,EAAY,EAAE,IAAsB;QAC5G,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACP,MAAM,CAAA;QACV,CAAC;QACD,IAAI,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;QACpB,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACP,IAAI,IAAI,SAAQ,CAAA;gBAChB,EAAE,CAAC,CAAC,GAAA,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACjB,IAAI,GAAG,IAAI,CAAA;gBACf,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;oBACjB,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,EAAY,CAAA;gBAC/B,CAAC;gBACD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC;oBACtB,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,IAAgB,CAAC,CAAA;gBAClC,CAAC;YACL,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACN,EAAE,GAAG,GAAA,YAAY,CAAC,GAAG,EAAE,UAAA,CAAC;oBACpB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;wBAC9B,MAAM,CAAC,CAAC,CAAA;oBACZ,CAAC;gBACL,CAAC,CAAC,CAAA;YACN,CAAC;QACL,CAAC;QACD,MAAM,CAAC,EAAO,CAAA;IAClB,CAAC;IA1Be,aAAU,aA0BzB,CAAA;IAED,gBAAuB,EAAW;QAC9B,IAAI,KAAK,GAAa,CAAC,IAAI,CAAC,CAAA;QAC5B,YAAY,EAAU;YAClB,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACN,MAAM,CAAC,CAAC,CAAC,CAAA;YACb,CAAC;YACD,IAAI,EAAE,GAAG,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,CAAA;YAC9B,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACZ,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAA;YAC3B,CAAC;YACD,MAAM,CAAC,EAAE,CAAA;QACb,CAAC;QAED,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACL,EAAE,CAAC,EAAE,CAAC,CAAA;QACV,CAAC;QACD,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAA;QAC3B,MAAM,CAAC;YACH,IAAI,EAAE,KAAK;YACX,EAAE,IAAA;YACF,IAAI,MAAA;SACP,CAAA;IACL,CAAC;IAtBe,SAAM,SAsBrB,CAAA;IAED;QAA+B,YAAgB;aAAhB,UAAgB,EAAhB,qBAAgB,EAAhB,IAAgB;YAAhB,uBAAgB;;QAC3C,IAAM,GAAG,GAAa,EAAE,CAAA;QACxB,GAAG,CAAC,CAAY,UAAE,EAAF,SAAE,EAAF,gBAAE,EAAF,IAAE;YAAb,IAAM,CAAC,WAAA;YACR,IAAM,EAAE,GAAG,WAAW,CAAC,CAAC,CAAC,CAAA;YACzB,EAAE,CAAC,CAAC,EAAE,CAAC;gBAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;SACvB;QACD,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,OAAK,CAAC,GAAA,UAAU,CAAC,GAAG,EAAE,GAAA,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAI,IAAI,SAAS,CAAA;IACvF,CAAC;IAPe,iBAAc,iBAO7B,CAAA;IAED,qBAAqB,EAAW;QAC5B,IAAI,IAAc,CAAA;QAClB,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACV,IAAI,GAAG,EAAE,CAAC,WAAW,CAAA;QACzB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAClB,IAAI,GAAG,EAAE,CAAC,WAAW,CAAA;QACzB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,GAAG,EAAE,CAAC,KAAiB,CAAA;QAC/B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACnB,IAAI,GAAG,EAAE,CAAC,aAAyB,CAAA;QACvC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACpC,IAAI,GAAG,EAAE,CAAC,IAAgB,CAAA;QAC9B,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,MAAM,CAAC,SAAS,CAAA;QACpB,CAAC;QACD,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,CAAA;QACd,IAAI,GAAW,CAAA;QACf,IAAI,GAAW,CAAA;QACf,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACL,GAAG,GAAG,OAAI,GAAA,0BAA0B,CAAC,IAAI,CAAC,OAAG,CAAA;YAC7C,GAAG,GAAG,OAAI,GAAA,0BAA0B,CAAC,EAAE,CAAC,EAAE,CAAC,OAAG,CAAA;YAC9C,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,IAAU,CAAC,CAAC,CAAC;gBAClB,MAAM,CAAI,GAAG,SAAI,GAAK,CAAA;YAC1B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAI,GAAG,SAAI,GAAK,CAAA;YAC1B,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAA;IACpB,CAAC;IAED,mBAA0B,GAAY,EAAE,EAAW;QAC/C,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,IAAI,GAAA,QAAQ,CAAC,GAAG,CAAC,IAAI,GAAA,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACjF,MAAM,CAAA;QACV,CAAC;QACD,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;QACjB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,CAAA;QACjB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,SAAS,CAAC,GAAG,CAAC,CAAA;YACd,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBACT,SAAS,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;YACtB,CAAC;QACL,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACjB,SAAS,CAAC,EAAE,CAAC,CAAA;YACb,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBACR,SAAS,CAAC,GAAG,EAAE,EAAE,CAAC,CAAA;YACtB,CAAC;QACL,CAAC;IACL,CAAC;IAnBe,YAAS,YAmBxB,CAAA;IAED,mBAAmB,IAAY;QAC3B,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACZ,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChD,IAAI,KAAK,SAAA,CAAA;gBACT,GAAG,CAAC,CAAa,UAAiB,EAAjB,KAAA,IAAI,CAAC,YAAY,EAAjB,cAAiB,EAAjB,IAAiB;oBAA7B,IAAI,IAAI,SAAA;oBACT,IAAI,GAAG,GAAG,cAAc,CAAC,IAAI,CAAC,CAAA;oBAC9B,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;wBAChB,KAAK,GAAG,GAAG,CAAA;wBACX,KAAK,CAAA;oBACT,CAAC;iBACJ;gBACD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACR,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;gBAC1B,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAED,cAAqB,KAAc,EAAE,KAAc;QAC/C,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAA;QAC3B,IAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,CAAA;QAC5B,IAAM,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,CAAA;QACvB,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC;YACjC,KAAK,CAAC,EAAE,GAAG,IAAI,CAAA;QACnB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC;YAClD,IAAM,EAAE,GAAG,KAAK,EAAM,CAAA;YACtB,EAAE,CAAC,EAAE,GAAG,MAAkB,CAAA;YAC1B,EAAE,CAAC,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YACvB,KAAK,CAAC,EAAE,GAAG,EAAE,CAAA;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;YACzB,GAAG,CAAC,CAAe,UAAkB,EAAlB,KAAA,KAAK,CAAC,YAAY,EAAlB,cAAkB,EAAlB,IAAkB;gBAAhC,IAAM,IAAI,SAAA;gBACX,IAAI,GAAG,GAAG,cAAc,CAAC,IAAI,CAAC,CAAA;gBAC9B,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBACjB,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAA;oBACjB,EAAE,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACf,EAAE,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,KAAuB,CAAC,CAAC,CAAC;4BAC5C,IAAI,IAAI,GAAoB,GAAG,CAAC,QAAS,CAAC,IAAI,CAAA;4BAC9C,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gCACtB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAA;4BAC1B,CAAC;wBACL,CAAC;oBACL,CAAC;gBACL,CAAC;aACJ;QACL,CAAC;IACL,CAAC;IA5Be,OAAI,OA4BnB,CAAA;IAED,eAAe,EAAW;QACtB,IAAI,IAAI,GAAG,EAAE,CAAA;QACb,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACV,IAAI,GAAG,EAAE,CAAC,WAAqB,CAAA;QACnC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAClB,IAAI,GAAG,EAAE,CAAC,WAAqB,CAAA;QACnC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,GAAG,EAAE,CAAC,KAAK,CAAA;QACnB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACnB,IAAI,GAAG,EAAE,CAAC,aAAa,CAAA;QAC3B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACpC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAA;QAClB,CAAC;QACD,MAAM,CAAC,IAAI,CAAA;IACf,CAAC;IAED,aAAa,EAAW;QACpB,MAAM,CAAC,EAAE,CAAC,EAAE,CAAA;IAChB,CAAC;IAED,kBAAyB,IAAkB;QACvC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB;gBACI,MAAM,CAAa,IAAI,CAAC;YAC5B;gBACI,MAAM,CAAgB,IAAI,CAAC;YAC/B;gBACI,EAAE,CAAC,CAAC,GAAA,eAAe,CAAwB,IAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC3D,MAAM,CAAuC,IAAK,CAAC,UAAU,CAAA;gBACjE,CAAC;QACT,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAbe,WAAQ,WAavB,CAAA;IAED,gBAAuB,IAAU,EAAE,aAAqB;QAArB,8BAAA,EAAA,qBAAqB;QACpD,MAAM,CAAC,YAAY,CAAC,GAAA,mBAAmB,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC;IACxE,CAAC;IAFe,SAAM,SAErB,CAAA;IAED,sBAA6B,UAAsB,EAAE,IAAU,EAAE,aAAqB;QAArB,8BAAA,EAAA,qBAAqB;QAClF,EAAE,CAAC,CAAC,GAAA,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;QACD,IAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC7B,IAAI,KAAa,CAAC;QAClB,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAChB,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,GAAA,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACjE,CAAC;QACD,IAAM,EAAE,GAAG,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QAChC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACL,MAAM,CAAC,EAAE,CAAA;QACb,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAA,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3F,CAAC;IAde,eAAY,eAc3B,CAAA;IAED,cAAqB,IAAQ;QACzB,MAAM,CAAC,GAAA,0BAA0B,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAC9C,CAAC;IAFe,OAAI,OAEnB,CAAA;IAED,kBAAkB,IAAU,EAAE,IAAa;QACvC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,GAAA,YAAY,CAAC,IAAI,CAAC,IAAI,GAAA,eAAe,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACtE,MAAM,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAU,CAAC,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACP,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAG,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC7E,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAI,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC/D,CAAC;QACL,CAAC;QACD,MAAM,CAAC;IACX,CAAC;IAED,qBAA4B,IAAkC;QAC1D,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACP,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;gBACtC,MAAM,CAAE,IAAmB,CAAC,EAAE,CAAC,CAAC,CAAC,GAAA,0BAA0B,CAAE,IAAmB,CAAC,EAAE,CAAC,EAAE,CAAW,CAAC,CAAC,CAAC,GAAA,MAAM,CAAC,IAAkB,CAAC,CAAC;YACnI,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAE,IAAwB,CAAC,IAAI,CAAC;YAC1C,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B,CAAC,CAAC,CAAC;gBACzC,MAAM,CAAE,IAAsB,CAAC,EAAE,CAAC,CAAC,CAAE,IAAsB,CAAC,EAAE,CAAC,EAAY,CAAC,CAAC,CAAE,IAAsB,CAAC,IAAI,CAAC;YAC/G,CAAC;QACL,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAde,cAAW,cAc1B,CAAA;IAED,qBAA4B,IAAqB;QAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAA0B,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,CAAA;QAChC,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,MAA6B,CAAC,CAAC,CAAC;YACzC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,CAAA;QAChC,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,QAAoC,CAAC,CAAC,CAAC;YAChD,IAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC;YACvC,EAAE,CAAC,CAAC,GAAA,8BAA8B,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gBACjD,EAAE,CAAC,CAA4B,cAAe,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;oBACrD,MAAM,CAAC,CAAC,KAAK,GAAG,GAAA,0BAA0B,CAA4B,cAAe,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CAAa,CAAA;gBAClH,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC;YAErB,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,MAA6B,IAAI,cAAc,CAAC,IAAI,MAA8B,CAAC,CAAC,CAAC;gBAC7G,EAAE,CAAC,CAAc,cAAe,CAAC,EAAE,CAAC,CAAC,CAAC;oBAClC,MAAM,CAAc,cAAe,CAAC,EAAE,CAAC,EAAE,CAAA;gBAC7C,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC;YACrB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAxBe,cAAW,cAwB1B,CAAA;IAED,iBAAwB,IAAkB;QACtC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAA;IACzD,CAAC;IAFe,UAAO,UAEtB,CAAA;IAED,mBAA0B,IAAU;QAChC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA8B;YAC9B,SAAmC;YACnC,SAAgC;YAChC,SAA+B;YAC/B,SAA6B;YAC7B,SAAgC;YAChC,SAAkC;YAClC,SAAoC;YACpC,SAAkC;YAClC,SAA4B;YAC5B,SAA4B;YAC5B,SAA4B;YAC5B,SAAmC;YACnC,SAA8B;YAC9B,SAAoC;YACpC,SAA0B;YAC1B,SAAkC;YAClC,SAAoC;YACpC,SAA+B;YAC/B,SAAmC;YACnC,SAA6B;YAC7B,SAA4C;YAC5C,SAA2B;YAC3B,SAAiC;YACjC,SAAkC;YAClC,SAA8B;YAC9B,SAAkC;YAClC,SAA6B;YAC7B,SAA2B;YAC3B,SAAwC;YACxC,SAA6B;YAC7B,SAAqC;YACrC,SAAoC;YACpC,SAAqC;YACrC,SAAkC;YAClC,SAAkC;YAClC;gBACI,MAAM,CAAC,IAAI,CAAA;YACf;gBACI,MAAM,CAAC,KAAK,CAAA;QAEpB,CAAC;IACL,CAAC;IA5Ce,YAAS,YA4CxB,CAAA;IAED,mBAA0B,IAAU;QAChC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,SAA0B;YAC1B;gBACI,MAAM,CAAC,IAAI,CAAA;YACf;gBACI,MAAM,CAAC,KAAK,CAAA;QAEpB,CAAC;IACL,CAAC;IATe,YAAS,YASxB,CAAA;IAED,oBAA2B,IAAU;QACjC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,QAA2B;YAC3B,SAA8B;YAC9B,SAA+B;YAC/B,SAA4C;YAC5C;gBACI,MAAM,CAAC,IAAI,CAAA;YACf;gBACI,MAAM,CAAC,KAAK,CAAA;QAEpB,CAAC;IACL,CAAC;IAZe,aAAU,aAYzB,CAAA;IAED,oBAA2B,IAAU;QACjC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAA;IAC7C,CAAC;IAFe,aAAU,aAEzB,CAAA;IAED,qBAA4B,IAAU;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAyB,CAAA;IAE7C,CAAC;IAHe,cAAW,cAG1B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAA6B,CAAA;IACjD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAED,uBAA8B,IAAU;QACpC,MAAM,CAAC,IAAI,CAAC,IAAI,QAAiC,CAAA;IACrD,CAAC;IAFe,gBAAa,gBAE5B,CAAA;IAEY,aAAU,GAAG,GAAA,qBAAqB,CAAC;QAC5C,OAAO,EAAE,KAAK;QACd,UAAU,EAAE,OAAO;QACnB,OAAO,EAAE,KAAK;QACd,WAAW,EAAE,KAAK;QAClB,MAAM,EAAE,KAAK;QACb,QAAQ,EAAE,KAAK;QACf,WAAW,EAAE,QAAQ;QACrB,UAAU,EAAE,OAAO;QACnB,SAAS,EAAE,KAAK;QAChB,UAAU,EAAE,KAAK;QACjB,QAAQ,EAAE,IAAI;QACd,cAAc,EAAE,OAAO;QACvB,WAAW,EAAE,KAAK;KACrB,CAAC,CAAC;IAGU,eAAY,GAAG,uHAAuH,CAAC;IAEpJ,mBAA0B,IAAY;QAClC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAA,YAAY,EAAE,UAAC,CAAC;YAChC,MAAM,CAAC,GAAA,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACP,CAAC;IAJe,YAAS,YAIxB,CAAA;IAGD,kBAAyB,EAAU;QAC/B,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QACjD,cAAc,EAAU;YACpB,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAClC,CAAC;IACL,CAAC;IALe,WAAQ,WAKvB,CAAA;IAED,mBAA0B,EAAU;QAChC,IAAM,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9B,IAAI,IAAc,CAAC;QAEnB,GAAG,CAAC,CAAY,UAAE,EAAF,SAAE,EAAF,gBAAE,EAAF,IAAE;YAAb,IAAM,CAAC,WAAA;YACR,IAAM,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACzE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACN,CAAC,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACpC,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,CAAC,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC;SACJ;QAED,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAGvC,cAAc,EAAU;YACpB,IAAM,GAAG,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YACjC,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YACD,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YACD,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YACD,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;QAED,kBAAkB,CAAS;YACvB,MAAM,CAAC,mEAAmE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChF,CAAC,CAAC,OAAO,CAAC,mEAAmE,EAAE,kFAAyB,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAC9H,CAAC;QAED,eAAe,CAAS;YACpB,MAAM,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1C,CAAC,CAAC,OAAO,CAAC,4BAA4B,EAAE,aAAa,CAAC,CAAC,OAAO,CAAC,gCAAgC,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBAClH,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,OAAO,CAAC;oBACd,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC;gBACvD,CAAC,CAAC,CAAC,OAAO,CAAC,gCAAgC,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBAC9D,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,OAAO,CAAC;oBACd,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;gBAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACvB,CAAC;QAED,iBAAiB,CAAS;YACtB,MAAM,CAAC,iCAAiC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9C,CAAC,CAAC,OAAO,CAAC,iCAAiC,EAAE,aAAa,CAAC,CAAC,OAAO,CAAC,gCAAgC,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBACvH,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,OAAO,CAAC;oBACd,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC;gBACvD,CAAC,CAAC,CAAC,OAAO,CAAC,gCAAgC,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBAC9D,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,OAAO,CAAC;oBACd,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;gBAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACvB,CAAC;QAED,cAAc,CAAS;YACnB,MAAM,CAAC,2DAA2D,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxE,CAAC,CAAC,OAAO,CAAC,2DAA2D,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBACxF,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,cAAc,CAAC;oBACrB,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC;gBACvD,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACvB,CAAC;QAED,eAAe,CAAS;YACpB,MAAM,CAAC,4DAA4D,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzE,CAAC,CAAC,OAAO,CAAC,4DAA4D,EAAE,UAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK;oBACzF,EAAE,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,eAAe,CAAC;oBACtB,MAAM,CAAC,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;gBAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACvB,CAAC;IACL,CAAC;IA/Ee,YAAS,YA+ExB,CAAA;AAEL,CAAC,EAlpBS,EAAE,KAAF,EAAE,QAkpBX;AC7uMD,IAAU,EAAE,CA+uEX;AA/uED,WAAU,EAAE;IAMR,oCAA2C,KAAiB;QACxD,MAAM,CAAC,KAAK,MAAyB,CAAC;IAC1C,CAAC;IAFe,6BAA0B,6BAEzC,CAAA;IAmDD,IAAM,WAAW,GAAG,GAAA,qBAAqB,CAAC;QACtC,UAAU,KAA4B;QACtC,KAAK,KAAuB;QAC5B,IAAI,KAAsB;QAC1B,SAAS,KAA2B;QACpC,OAAO,IAAyB;QAChC,MAAM,IAAwB;QAC9B,OAAO,IAAyB;QAChC,OAAO,IAAyB;QAChC,UAAU,IAA4B;QACtC,OAAO,IAAyB;QAChC,aAAa,KAA+B;QAC5C,UAAU,IAA4B;QACtC,SAAS,KAA2B;QACpC,SAAS,IAA2B;QACpC,QAAQ,IAA0B;QAClC,IAAI,IAAsB;QAC1B,MAAM,IAAwB;QAC9B,MAAM,IAAwB;QAC9B,QAAQ,IAA0B;QAClC,SAAS,IAA2B;QACpC,OAAO,IAAyB;QAChC,SAAS,IAA2B;QACpC,KAAK,IAAuB;QAC5B,MAAM,KAAwB;QAC9B,UAAU,IAA4B;QACtC,KAAK,KAAuB;QAC5B,IAAI,IAAsB;QAC1B,YAAY,KAA8B;QAC1C,QAAQ,IAA0B;QAClC,IAAI,IAAsB;QAC1B,YAAY,IAA8B;QAC1C,WAAW,KAA6B;QACxC,IAAI,KAAsB;QAC1B,OAAO,KAAyB;QAChC,KAAK,KAAuB;QAC5B,QAAQ,KAA0B;QAClC,WAAW,KAA6B;QACxC,OAAO,KAAyB;QAChC,KAAK,IAAuB;QAC5B,MAAM,IAAwB;QAC9B,QAAQ,KAA0B;QAClC,QAAQ,KAA0B;QAClC,SAAS,KAA2B;QACpC,SAAS,KAA2B;QACpC,WAAW,KAA6B;QACxC,QAAQ,KAA0B;QAClC,UAAU,KAA4B;QACtC,SAAS,KAA2B;QACpC,QAAQ,KAA0B;QAClC,QAAQ,IAA0B;QAClC,KAAK,KAAuB;QAC5B,QAAQ,KAA0B;QAClC,QAAQ,KAA0B;QAClC,OAAO,IAAyB;QAChC,QAAQ,IAA0B;QAClC,QAAQ,KAA0B;QAClC,MAAM,IAAwB;QAC9B,OAAO,KAAyB;QAChC,MAAM,KAAwB;QAC9B,KAAK,KAAuB;QAC5B,MAAM,KAAwB;QAC9B,QAAQ,KAA0B;QAClC,WAAW,KAA6B;QACxC,KAAK,KAAuB;QAC5B,MAAM,KAAwB;QAC9B,OAAO,KAAyB;QAChC,MAAM,KAAwB;QAC9B,OAAO,KAAyB;QAChC,OAAO,KAAyB;QAChC,OAAO,KAAyB;QAChC,IAAI,KAAsB;QAC1B,GAAG,IAA2B;QAC9B,GAAG,IAA4B;QAC/B,GAAG,IAA2B;QAC9B,GAAG,IAA4B;QAC/B,GAAG,IAA6B;QAChC,GAAG,IAA8B;QACjC,GAAG,IAAqB;QACxB,KAAK,IAA2B;QAChC,GAAG,IAA2B;QAC9B,GAAG,IAAuB;QAC1B,GAAG,IAA0B;QAC7B,GAAG,IAA6B;QAChC,IAAI,IAAgC;QACpC,IAAI,IAAmC;QACvC,IAAI,IAA8B;QAClC,IAAI,IAAmC;QACvC,KAAK,IAAoC;QACzC,KAAK,IAAyC;QAC9C,IAAI,IAAmC;QACvC,GAAG,IAAsB;QACzB,GAAG,IAAuB;QAC1B,IAAI,IAAkC;QACtC,GAAG,IAA0B;QAC7B,GAAG,IAAuB;QAC1B,GAAG,IAAyB;QAC5B,IAAI,IAA0B;QAC9B,IAAI,IAA4B;QAChC,IAAI,IAAkC;QACtC,IAAI,IAA+B;QACnC,IAAI,IAAwC;QAC5C,KAAK,IAAmD;QACxD,GAAG,IAA2B;QAC9B,GAAG,IAAqB;QACxB,GAAG,IAAuB;QAC1B,GAAG,IAA6B;QAChC,GAAG,IAAuB;QAC1B,IAAI,IAAoC;QACxC,IAAI,IAAwB;QAC5B,GAAG,IAA0B;QAC7B,GAAG,IAAuB;QAC1B,GAAG,IAAwB;QAC3B,IAAI,IAA4B;QAChC,IAAI,IAA6B;QACjC,IAAI,IAAgC;QACpC,KAAK,IAAwC;QAC7C,IAAI,IAA6B;QACjC,IAAI,IAA+B;QACnC,KAAK,IAAwC;QAC7C,KAAK,IAA8C;QACnD,MAAM,IAAyD;QAC/D,IAAI,IAAiC;QACrC,IAAI,IAA2B;QAC/B,IAAI,IAA6B;QACjC,GAAG,IAAoB;KAC1B,CAAC,CAAC;IAEH,IAAM,QAAQ,GAAG,GAAA,qBAAqB,CAAC;QAEnC,IAAI,KAA4B;QAChC,IAAI,KAAuB;QAC3B,IAAI,KAAsB;QAC1B,IAAI,KAA2B;QAC/B,IAAI,IAAyB;QAC7B,IAAI,IAAwB;QAC5B,IAAI,IAAyB;QAE7B,IAAI,IAAyB;QAC7B,GAAG,IAAyB;QAE5B,IAAI,IAA4B;QAChC,IAAI,IAAyB;QAC7B,IAAI,KAA+B;QACnC,IAAI,IAA4B;QAChC,IAAI,KAA2B;QAC/B,IAAI,IAA2B;QAC/B,IAAI,IAA0B;QAC9B,IAAI,IAAsB;QAC1B,IAAI,IAAwB;QAC5B,IAAI,IAAwB;QAC5B,IAAI,IAA0B;QAC9B,IAAI,IAA2B;QAE/B,IAAI,IAAyB;QAC7B,IAAI,IAAyB;QAC7B,IAAI,IAAyB;QAC7B,GAAG,IAAyB;QAE5B,IAAI,IAA2B;QAC/B,IAAI,IAAuB;QAC3B,IAAI,KAAwB;QAC5B,IAAI,IAA4B;QAChC,IAAI,KAAuB;QAC3B,IAAI,IAAsB;QAC1B,IAAI,KAA8B;QAClC,IAAI,IAA0B;QAC9B,IAAI,IAAsB;QAC1B,IAAI,IAA8B;QAClC,IAAI,KAA6B;QAEjC,IAAI,KAAsB;QAC1B,IAAI,KAAyB;QAE7B,IAAI,KAAuB;QAE3B,IAAI,KAA0B;QAE9B,IAAI,KAA6B;QACjC,IAAI,KAAyB;QAE7B,IAAI,IAAuB;QAC3B,IAAI,IAAwB;QAC5B,IAAI,KAA0B;QAC9B,IAAI,KAA0B;QAE9B,IAAI,KAA2B;QAE/B,IAAI,KAA2B;QAC/B,IAAI,KAA6B;QACjC,IAAI,KAA0B;QAC9B,IAAI,KAA4B;QAChC,IAAI,KAA2B;QAC/B,IAAI,KAA0B;QAC9B,IAAI,IAA0B;QAC9B,IAAI,KAAuB;QAC3B,IAAI,KAA0B;QAC9B,IAAI,KAA0B;QAE9B,IAAI,IAAyB;QAC7B,IAAI,IAA0B;QAE9B,IAAI,KAA0B;QAE9B,IAAI,IAAwB;QAE5B,IAAI,KAAyB;QAE7B,IAAI,KAAwB;QAC5B,IAAI,KAAwB;QAC5B,IAAI,KAAwB;QAC5B,GAAG,KAAwB;QAE3B,IAAI,KAAuB;QAC3B,IAAI,KAAwB;QAE5B,IAAI,KAA0B;QAC9B,IAAI,KAA6B;QAEjC,IAAI,KAAuB;QAC3B,IAAI,KAAwB;QAC5B,IAAI,KAAyB;QAC7B,IAAI,KAAwB;QAC5B,IAAI,KAAyB;QAC7B,IAAI,KAAyB;QAC7B,IAAI,KAAyB;QAC7B,IAAI,KAAsB;QAE1B,GAAG,IAA2B;QAC9B,GAAG,IAA4B;QAC/B,GAAG,IAA2B;QAC9B,GAAG,IAA4B;QAC/B,GAAG,IAA6B;QAChC,GAAG,IAA8B;QACjC,GAAG,IAAqB;QACxB,KAAK,IAA2B;QAChC,GAAG,IAA2B;QAC9B,GAAG,IAAuB;QAC1B,GAAG,IAA0B;QAC7B,GAAG,IAA6B;QAChC,IAAI,IAAgC;QACpC,IAAI,IAAmC;QACvC,IAAI,IAA8B;QAClC,IAAI,IAAmC;QACvC,KAAK,IAAoC;QACzC,KAAK,IAAyC;QAC9C,IAAI,IAAmC;QACvC,GAAG,IAAsB;QACzB,GAAG,IAAuB;QAC1B,IAAI,IAAkC;QACtC,GAAG,IAA0B;QAC7B,GAAG,IAAuB;QAC1B,GAAG,IAAyB;QAC5B,IAAI,IAA0B;QAC9B,IAAI,IAA4B;QAChC,IAAI,IAAkC;QACtC,IAAI,IAA+B;QACnC,IAAI,IAAwC;QAC5C,KAAK,IAAmD;QACxD,GAAG,IAA2B;QAC9B,GAAG,IAAqB;QACxB,GAAG,IAAuB;QAC1B,GAAG,IAA6B;QAChC,GAAG,IAAuB;QAC1B,IAAI,IAAoC;QACxC,IAAI,IAAwB;QAC5B,GAAG,IAA0B;QAC7B,GAAG,IAAuB;QAC1B,GAAG,IAAwB;QAC3B,IAAI,IAA4B;QAChC,IAAI,IAA6B;QACjC,IAAI,IAAgC;QACpC,KAAK,IAAwC;QAC7C,IAAI,IAA6B;QACjC,IAAI,IAA+B;QACnC,KAAK,IAAwC;QAC7C,KAAK,IAA8C;QACnD,MAAM,IAAyD;QAC/D,IAAI,IAAiC;QACrC,IAAI,IAA2B;QAC/B,IAAI,IAA6B;QACjC,GAAG,IAAoB;KAC1B,CAAC,CAAC;IAqBH,IAAM,yBAAyB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IAC5kG,IAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IAwBvlI,IAAM,yBAAyB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IACljJ,IAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,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","file":"ctsInstaller.js","sourcesContent":["namespace ts {\r\n    /**\r\n     * Type of objects whose values are all of the same type.\r\n     * The `in` and `for-in` operators can *not* be safely used,\r\n     * since `Object.prototype` may be modified by outside code.\r\n     */\r\n    export interface MapLike<T> {\r\n        [index: string]: T;\r\n    }\r\n\r\n    /** ES6 Map interface, only read methods included. */\r\n    export interface ReadonlyMap<T> {\r\n        get(key: string): T | undefined;\r\n        has(key: string): boolean;\r\n        forEach(action: (value: T, key: string) => void): void;\r\n        readonly size: number;\r\n        keys(): Iterator<string>;\r\n        values(): Iterator<T>;\r\n        entries(): Iterator<[string, T]>;\r\n    }\r\n\r\n    /** ES6 Map interface. */\r\n    export interface Map<T> extends ReadonlyMap<T> {\r\n        set(key: string, value: T): this;\r\n        delete(key: string): boolean;\r\n        clear(): void;\r\n    }\r\n\r\n    /** ES6 Iterator type. */\r\n    export interface Iterator<T> {\r\n        next(): { value: T, done: false } | { value: never, done: true };\r\n    }\r\n\r\n    /** Array that is only intended to be pushed to, never read. */\r\n    export interface Push<T> {\r\n        push(...values: T[]): void;\r\n    }\r\n\r\n    // branded string type used to store absolute, normalized and canonicalized paths\r\n    // arbitrary file name can be converted to Path via toPath function\r\n    export type Path = string & { __pathBrand: any };\r\n\r\n    export interface TextRange {\r\n        pos: number;\r\n        end: number;\r\n    }\r\n\r\n    // token > SyntaxKind.Identifer => token is a keyword\r\n    // Also, If you add a new SyntaxKind be sure to keep the `Markers` section at the bottom in sync\r\n    export const enum SyntaxKind {\r\n        /** 未知的令牌 */\r\n        Unknown,\r\n        /** 文件结束令牌 */\r\n        EndOfFileToken,\r\n        /** 单行注释琐事  */\r\n        SingleLineCommentTrivia,\r\n        /** 多行注释琐事 */\r\n        MultiLineCommentTrivia,\r\n        /** 新行琐事 */\r\n        NewLineTrivia,\r\n        /** 空白琐事 */\r\n        WhitespaceTrivia,\r\n        // We detect and preserve #! on the first line\r\n        /** 工作琐事 我们发现和保存#！在第一行 */\r\n        ShebangTrivia,\r\n        // We detect and provide better error recovery when we encounter a git merge marker.  This\r\n        // allows us to edit files with git-conflict markers in them in a much more pleasant manner.\r\n        ConflictMarkerTrivia,\r\n        // Literals\r\n        /** 数组字面量 */\r\n        NumericLiteral,\r\n        /** 文本字面量 */\r\n        StringLiteral,\r\n        /** jsx文本 */\r\n        JsxText,\r\n        JsxTextAllWhiteSpaces,\r\n        /** 正则表达式的文字  */\r\n        RegularExpressionLiteral,\r\n        /** 无替换模板文字 */\r\n        NoSubstitutionTemplateLiteral,\r\n        // Pseudo-literals\r\n        /** 伪文字 模板的头  */\r\n        TemplateHead,\r\n        /** 伪文字 模板中间  */\r\n        TemplateMiddle,\r\n        /** 伪文字 模板的尾 */\r\n        TemplateTail,\r\n        // 标点符号\r\n        /** { */\r\n        OpenBraceToken,\r\n        /** } */\r\n        CloseBraceToken,\r\n        /** ( */\r\n        OpenParenToken,\r\n        /** ) */\r\n        CloseParenToken,\r\n        /** [ */\r\n        OpenBracketToken,\r\n        /** ] */\r\n        CloseBracketToken,\r\n        /**  . 点 */\r\n        DotToken,\r\n        /** ...  */\r\n        DotDotDotToken,\r\n        /** ; 分号标记 */\r\n        SemicolonToken,\r\n        /** , 逗号令牌 */\r\n        CommaToken,\r\n        /** < 小于令牌 */\r\n        LessThanToken,\r\n        /** </ 小于斜杠令牌 */\r\n        LessThanSlashToken,\r\n        /** > 大于令牌 */\r\n        GreaterThanToken,\r\n        /** <=小于等于令牌 */\r\n        LessThanEqualsToken,\r\n        /** >=  */\r\n        GreaterThanEqualsToken,\r\n        /** == */\r\n        EqualsEqualsToken,\r\n        /** != */\r\n        ExclamationEqualsToken,\r\n        /** === */\r\n        EqualsEqualsEqualsToken,\r\n        /** !== */\r\n        ExclamationEqualsEqualsToken,\r\n        /** => */\r\n        EqualsGreaterThanToken,\r\n        /*** + */\r\n        PlusToken,\r\n        /** -减 */\r\n        MinusToken,\r\n        /** *星 */\r\n        AsteriskToken,\r\n        /** ** 星星 */\r\n        AsteriskAsteriskToken,\r\n        /** / 斜杠 */\r\n        SlashToken,\r\n        /** %  */\r\n        PercentToken,\r\n        /** ++ */\r\n        PlusPlusToken,\r\n        /** -- */\r\n        MinusMinusToken,\r\n        /** << */\r\n        LessThanLessThanToken,\r\n        /** >> */\r\n        GreaterThanGreaterThanToken,\r\n        /** >>> */\r\n        GreaterThanGreaterThanGreaterThanToken,\r\n        /** & */\r\n        AmpersandToken,\r\n        /** | */\r\n        BarToken,\r\n        /** ^ */\r\n        CaretToken,\r\n        /** ! */\r\n        ExclamationToken,\r\n        /** ~ */\r\n        TildeToken,\r\n        /** && */\r\n        AmpersandAmpersandToken,\r\n        /** || */\r\n        BarBarToken,\r\n        /** ? */\r\n        QuestionToken,\r\n        /** : */\r\n        ColonToken,\r\n        /** @ */\r\n        AtToken,\r\n        // Assignments\r\n        /** = */\r\n        EqualsToken,\r\n        /** += */\r\n        PlusEqualsToken,\r\n        /** -= */\r\n        MinusEqualsToken,\r\n        /** *= */\r\n        AsteriskEqualsToken,\r\n        /** **= */\r\n        AsteriskAsteriskEqualsToken,\r\n        /** /= */\r\n        SlashEqualsToken,\r\n        /** %= */\r\n        PercentEqualsToken,\r\n        /** <<= */\r\n        LessThanLessThanEqualsToken,\r\n        /** >>= */\r\n        GreaterThanGreaterThanEqualsToken,\r\n        /** >>>= */\r\n        GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        /** &= */\r\n        AmpersandEqualsToken,\r\n        /** |= */\r\n        BarEqualsToken,\r\n        /** ^=  */\r\n        CaretEqualsToken,\r\n        // Identifiers\r\n        /** 标识符 */\r\n        Identifier,\r\n        // Reserved words\r\n        /** 跳出 */\r\n        BreakKeyword,\r\n        /** 为 */\r\n        CaseKeyword,\r\n        /** 捕获 */\r\n        CatchKeyword,\r\n        /** 类 */\r\n        ClassKeyword,\r\n        /** 常量 */\r\n        ConstKeyword,\r\n        /** 继续 */\r\n        ContinueKeyword,\r\n        /** 调试 */\r\n        DebuggerKeyword,\r\n        /** 默认 */\r\n        DefaultKeyword,\r\n        /** 删除 */\r\n        DeleteKeyword,\r\n        /** 做do */\r\n        DoKeyword,\r\n        /** 否则 */\r\n        ElseKeyword,\r\n        /** 枚举  */\r\n        EnumKeyword,\r\n        /** 导出 */\r\n        ExportKeyword,\r\n        /** 扩展  */\r\n        ExtendsKeyword,\r\n        /** 假 */\r\n        FalseKeyword,\r\n        /** 最后 */\r\n        FinallyKeyword,\r\n        /** 循环 */\r\n        ForKeyword,\r\n        /** 函数 */\r\n        FunctionKeyword,\r\n        /** 如果 */\r\n        IfKeyword,\r\n        /** 引入 */\r\n        ImportKeyword,\r\n        /** 在 */\r\n        InKeyword,\r\n        /** 类为 */\r\n        InstanceOfKeyword,\r\n        /** 新建 */\r\n        NewKeyword,\r\n        /** 空 */\r\n        NullKeyword,\r\n        /** 返回 */\r\n        ReturnKeyword,\r\n        /** 父构造器 */\r\n        SuperKeyword,\r\n        /** 静态 */\r\n        SwitchKeyword,\r\n        /** 本对象 */\r\n        ThisKeyword,\r\n        /** 抛出 */\r\n        ThrowKeyword,\r\n        /** 真 */\r\n        TrueKeyword,\r\n        /** 尝试 */\r\n        TryKeyword,\r\n        /** 类型为 */\r\n        TypeOfKeyword,\r\n        /** 自由变量 */\r\n        VarKeyword,\r\n        /** 无值 */\r\n        VoidKeyword,\r\n        /** 判断循环 */\r\n        WhileKeyword,\r\n        /** 外扩 */\r\n        WithKeyword,\r\n        // Strict mode reserved words\r\n        /** 实现 */\r\n        ImplementsKeyword,\r\n        /** 接口 */\r\n        InterfaceKeyword,\r\n        /** 变量 */\r\n        LetKeyword,\r\n        /** 包 */\r\n        PackageKeyword,\r\n        /** 私有 */\r\n        PrivateKeyword,\r\n        /** 保护 */\r\n        ProtectedKeyword,\r\n        /** 公开 */\r\n        PublicKeyword,\r\n        /** 静态 */\r\n        StaticKeyword,\r\n        /** 获取 */\r\n        YieldKeyword,\r\n        // Contextual keywords\r\n        /** 抽象 */\r\n        AbstractKeyword,\r\n        /** 转为 */\r\n        AsKeyword,\r\n        /** 任何 */\r\n        AnyKeyword,\r\n        /** 异步 */\r\n        AsyncKeyword,\r\n        /** 等待 */\r\n        AwaitKeyword,\r\n        /** 布尔 */\r\n        BooleanKeyword,\r\n        /** 构造器 */\r\n        ConstructorKeyword,\r\n        /** 声明 */\r\n        DeclareKeyword,\r\n        /** 取 */\r\n        GetKeyword,\r\n        /** 是 */\r\n        IsKeyword,\r\n        /** 键为 */\r\n        KeyOfKeyword,\r\n        /** 模块 */\r\n        ModuleKeyword,\r\n        /** 名称空间 */\r\n        NamespaceKeyword,\r\n        /** 不可及 */\r\n        NeverKeyword,\r\n        /** 只读 */\r\n        ReadonlyKeyword,\r\n        /** 需求 */\r\n        RequireKeyword,\r\n        /** 数字 */\r\n        NumberKeyword,\r\n        /** 基对象 */\r\n        ObjectKeyword,\r\n        /** 置 */\r\n        SetKeyword,\r\n        /** 文本 */\r\n        StringKeyword,\r\n        /** 符号 */\r\n        SymbolKeyword,\r\n        /** 类型 */\r\n        TypeKeyword,\r\n        /** 未定义 */\r\n        UndefinedKeyword,\r\n        /** 从  */\r\n        FromKeyword,\r\n        /** 全局  */\r\n        GlobalKeyword,\r\n        /** 属于 */\r\n        OfKeyword, // LastKeyword and LastToken\r\n\r\n        // Parse tree nodes\r\n\r\n        // Names\r\n        /** 限定名  */\r\n        QualifiedName,\r\n        /** 计算属性名 */\r\n        ComputedPropertyName,\r\n        // Signature elements\r\n        /** 类型参数 */\r\n        TypeParameter,\r\n        /** 参数 */\r\n        Parameter,\r\n        /** 装饰 */\r\n        Decorator,\r\n        // TypeMember\r\n        /** 属性签名  */\r\n        PropertySignature,\r\n        /** 属性声明 */\r\n        PropertyDeclaration,\r\n        /** 成员签名 */\r\n        MethodSignature,\r\n        /** 成员声明 */\r\n        MethodDeclaration,\r\n        /** 构造函数 */\r\n        Constructor,\r\n        /** get */\r\n        GetAccessor,\r\n        /** 置 */\r\n        SetAccessor,\r\n        /** call */\r\n        CallSignature,\r\n        /** 构造签名 */\r\n        ConstructSignature,\r\n        /** 索引签名 */\r\n        IndexSignature,\r\n        // Type\r\n        /** 类型谓词 */\r\n        TypePredicate,\r\n        /** 类型引用 */\r\n        TypeReference,\r\n        /** 函数类型 */\r\n        FunctionType,\r\n        /** 构造器类型 */\r\n        ConstructorType,\r\n        /** 类型查询  */\r\n        TypeQuery,\r\n        /** 类型字面量 */\r\n        TypeLiteral,\r\n        /** 数组类型 */\r\n        ArrayType,\r\n        /** 元组类型 */\r\n        TupleType,\r\n        /** 联合类型 */\r\n        UnionType,\r\n        /** 交叉类型 */\r\n        IntersectionType,\r\n        /** 括号类型 */\r\n        ParenthesizedType,\r\n        /** 本对象类型 */\r\n        ThisType,\r\n        /** 类型运算符  */\r\n        TypeOperator,\r\n        /** 索引访问类型 */\r\n        IndexedAccessType,\r\n        /** 映射类型 */\r\n        MappedType,\r\n        /** 字面量类型 */\r\n        LiteralType,\r\n        // Binding patterns\r\n        /** 基对象绑定类型 */\r\n        ObjectBindingPattern,\r\n        /** 数组绑定类型 */\r\n\r\n        ArrayBindingPattern,\r\n        /** 绑定元素 */\r\n        BindingElement,\r\n        // Expression\r\n        /** 数组字面量表达式 */\r\n        ArrayLiteralExpression,\r\n        /** 对象字面量表达式 */\r\n        ObjectLiteralExpression,\r\n        /** 属性访问表达式 */\r\n        PropertyAccessExpression,\r\n        /** 元数据访问表达式 */\r\n        ElementAccessExpression,\r\n        /** call表达式 */\r\n        CallExpression,\r\n        /** 新建表达式 */\r\n        NewExpression,\r\n        /** 标签模板表达式 */\r\n        TaggedTemplateExpression,\r\n        /** 类型声明表达式 */\r\n        TypeAssertionExpression,\r\n        /** 括号表达式 */\r\n        ParenthesizedExpression,\r\n        /** 函数表达式 */\r\n        FunctionExpression,\r\n        /** 箭头函数 */\r\n        ArrowFunction,\r\n        /** 删除表达式 */\r\n        DeleteExpression,\r\n        /** 类型为 表达式 */\r\n        TypeOfExpression,\r\n        /** 无值 表达式 */\r\n        VoidExpression,\r\n        /** 等待 表达式 */\r\n        AwaitExpression,\r\n        /** 前缀一元表达式  */\r\n        PrefixUnaryExpression,\r\n        /** 后缀一元表达式， */\r\n        PostfixUnaryExpression,\r\n        /** 二元表达式  */\r\n        BinaryExpression,\r\n        /** 条件表达式 */\r\n        ConditionalExpression,\r\n        /** 模板的表达 `${}` */\r\n        TemplateExpression,\r\n        /** 获取 表达式 */\r\n        YieldExpression,\r\n        /** 传播表达式 */\r\n        SpreadElement,\r\n        /** 类表达式 */\r\n        ClassExpression,\r\n        /** 略的表达 ...  */\r\n        OmittedExpression,\r\n        /** 类型参数表达式， */\r\n        ExpressionWithTypeArguments,\r\n        /** 转为表达式 */\r\n        AsExpression,\r\n        /** 非空表达式 */\r\n        NonNullExpression,\r\n        /** 元属性表达式  */\r\n        MetaProperty,\r\n\r\n        // Misc 杂项\r\n        /** 模板跨度 */\r\n        TemplateSpan,\r\n        /** 分号类元素 */\r\n        SemicolonClassElement,\r\n        // Element\r\n        /** 块 */\r\n        Block,\r\n        /** 变量语句 */\r\n        VariableStatement,\r\n        /** 空语句 */\r\n        EmptyStatement,\r\n        /** 表达式语句 */\r\n        ExpressionStatement,\r\n        /** 如果 语句 */\r\n        IfStatement,\r\n        /** 点语句 */\r\n        DoStatement,\r\n        /** 判断循环语句  */\r\n        WhileStatement,\r\n        /** 循环语句 */\r\n        ForStatement,\r\n        /** 循环在语句 */\r\n        ForInStatement,\r\n        /** 循环属于 语句 */\r\n        ForOfStatement,\r\n        /** 继续语句 */\r\n        ContinueStatement,\r\n        /** 跳出语句 */\r\n        BreakStatement,\r\n        /** 返回语句 */\r\n        ReturnStatement,\r\n        /** 外扩语句 */\r\n        WithStatement,\r\n        /** 假如语句 */\r\n        SwitchStatement,\r\n        /** 标签语句 */\r\n        LabeledStatement,\r\n        /** 抛出语句 */\r\n        ThrowStatement,\r\n        /** 尝试语句 */\r\n        TryStatement,\r\n        /** 调试语句 */\r\n        DebuggerStatement,\r\n        /** 变量的声明 */\r\n        VariableDeclaration,\r\n        /** 变量列表声明 */\r\n        VariableDeclarationList,\r\n        /** 函数声明 */\r\n        FunctionDeclaration,\r\n        /** 类声明 */\r\n        ClassDeclaration,\r\n        /** 接口声明 */\r\n        InterfaceDeclaration,\r\n        /** 类型别名声明 */\r\n        TypeAliasDeclaration,\r\n        /** 枚举声明 */\r\n        EnumDeclaration,\r\n        /** 模块声明 */\r\n        ModuleDeclaration,\r\n        /** 模块块 */\r\n        ModuleBlock,\r\n        /** 为 块 */\r\n        CaseBlock,\r\n        /** 名称空间导出声明 */\r\n        NamespaceExportDeclaration,\r\n        /** 引入等于声明 */\r\n        ImportEqualsDeclaration,\r\n        /** 引入声明 */\r\n        ImportDeclaration,\r\n        /**  引入规范 */\r\n        ImportClause,\r\n        /** 名称空间引入 */\r\n        NamespaceImport,\r\n        /** 名子引入 */\r\n        NamedImports,\r\n        /** 引入说明符 */\r\n        ImportSpecifier,\r\n        /** 出口赋值 */\r\n        ExportAssignment,\r\n        /** 出口声明 */\r\n        ExportDeclaration,\r\n        /** 名子导出 */\r\n        NamedExports,\r\n        /** 出口符号 */\r\n        ExportSpecifier,\r\n        /** 失踪声明 */\r\n        MissingDeclaration,\r\n\r\n        // Module references.\r\n        /** 外部模块的参考 */\r\n        ExternalModuleReference,\r\n\r\n        // JSX\r\n        /** jsx元素 */\r\n        JsxElement,\r\n        /** jsx自关闭元素 */\r\n        JsxSelfClosingElement,\r\n        /** jsx打开元素 */\r\n        JsxOpeningElement,\r\n        /** jsx关闭元素 */\r\n        JsxClosingElement,\r\n        /** jsx特性 */\r\n        JsxAttribute,\r\n        /** jsx特性集 */\r\n        JsxAttributes,\r\n        /** jsx传播特性 */\r\n        JsxSpreadAttribute,\r\n        /** jsx表达式 */\r\n        JsxExpression,\r\n\r\n        // Clauses\r\n        /** 为 子句 */\r\n        CaseClause,\r\n        /** 默认子句 */\r\n        DefaultClause,\r\n        /** 遗产子句 */\r\n        HeritageClause,\r\n        /** 捕获子句 */\r\n        CatchClause,\r\n\r\n        // Property assignments\r\n        /** 属性赋值 */\r\n        PropertyAssignment,\r\n        /** 速记属性赋值 */\r\n        ShorthandPropertyAssignment,\r\n        /** 传播赋值 */\r\n        SpreadAssignment,\r\n\r\n        // Enum\r\n        /** 枚举成员 */\r\n        EnumMember,\r\n        // Top-level nodes\r\n        /** 源码文件 */\r\n        SourceFile,\r\n        /** 程序集 */\r\n        Bundle,\r\n\r\n        // JSDoc nodes\r\n        /** JSD类型表达式 */\r\n        JSDocTypeExpression,\r\n        // The * type\r\n        /** JSD * 类型 */\r\n        JSDocAllType,\r\n        // The ? type\r\n        /** JSD ?类型 */\r\n        JSDocUnknownType,\r\n        /** JSD空标签类型 */\r\n        JSDocNullableType,\r\n        /** JSD非空标签类型 */\r\n        JSDocNonNullableType,\r\n        /** JSD可选类型 */\r\n        JSDocOptionalType,\r\n        /** JSD函数类型 */\r\n        JSDocFunctionType,\r\n        /** JSD变量 */\r\n        JSDocVariadicType,\r\n        /** JSD注释类型 */\r\n        JSDocComment,\r\n        /** JSD标签 */\r\n        JSDocTag,\r\n        /** JSD增强标签 */\r\n        JSDocAugmentsTag,\r\n        /** JSD类标签 */\r\n        JSDocClassTag,\r\n        /** JSD参数标签 */\r\n        JSDocParameterTag,\r\n        /** JSD返回值标签 */\r\n        JSDocReturnTag,\r\n        /** JSD类型标签 */\r\n        JSDocTypeTag,\r\n        /** JSD模板标签 */\r\n        JSDocTemplateTag,\r\n        /** JSD定义标签 */\r\n        JSDocTypedefTag,\r\n        /** JSD属性标签 */\r\n        JSDocPropertyTag,\r\n        /** JSD类型字面量 */\r\n        JSDocTypeLiteral,\r\n\r\n        全局词典语句,\r\n        局部词典语句,\r\n        词典键,\r\n        词典值,\r\n        词典表达式,\r\n        // Synthesized list\r\n        /** 语法表 */\r\n        SyntaxList,\r\n        // Transformation nodes 转换节点\r\n        /** 不发射语句 */\r\n        NotEmittedStatement,\r\n        /** 部分发出表达式 */\r\n        PartiallyEmittedExpression,\r\n        /** 逗号表达式列表 */\r\n        CommaListExpression,\r\n        /** 合并申报的标记  */\r\n        MergeDeclarationMarker,\r\n        /** 声明结束标记 */\r\n        EndOfDeclarationMarker,\r\n\r\n        // Enum value count\r\n        /** 常量 */\r\n        Count,\r\n        // Markers\r\n        /** 第一个赋值 = 等于令牌 */\r\n        FirstAssignment = EqualsToken,\r\n        /** 最后一个赋值 = ^=令牌 */\r\n        LastAssignment = CaretEqualsToken,\r\n        /** 第一个复合赋值 = +=令牌 */\r\n        FirstCompoundAssignment = PlusEqualsToken,\r\n        /** 最后一个复合赋值= ^=令牌  */\r\n        LastCompoundAssignment = CaretEqualsToken,\r\n        /** 第一个保留关键字 = 跳出令牌 */\r\n        FirstReservedWord = BreakKeyword,\r\n        /** 最后一个保留关键字 = 外扩令牌 */\r\n        LastReservedWord = WithKeyword,\r\n        /** 第一个关键字 = 跳出令牌 */\r\n        FirstKeyword = BreakKeyword,\r\n        /** 最后一个关键字 = 属于令牌 */\r\n        LastKeyword = OfKeyword,\r\n        /** 第一个未来保证字 = 实现令牌 */\r\n        FirstFutureReservedWord = ImplementsKeyword,\r\n        /** 最后一个未来保留字 = 获取令牌 */\r\n        LastFutureReservedWord = YieldKeyword,\r\n        /** 第一个类型节点 = 类型谓词 */\r\n        FirstTypeNode = TypePredicate,\r\n        /** 最后一个类型接 = 字面量类型 */\r\n        LastTypeNode = LiteralType,\r\n        /** 第一个标点符号 = { 开大括号令牌 */\r\n        FirstPunctuation = OpenBraceToken,\r\n        /** 最后一个标点符号 = ^=令牌 */\r\n        LastPunctuation = CaretEqualsToken,\r\n        /** 第一个令牌 = 未知 */\r\n        FirstToken = Unknown,\r\n        /** 最后一个令牌 = 最后一个关键字 */\r\n        LastToken = LastKeyword,\r\n        /** 第一个杂项令牌 = //单行注释 */\r\n        FirstTriviaToken = SingleLineCommentTrivia,\r\n        /** 最后一个杂项令牌 =git冲突标记 */\r\n        LastTriviaToken = ConflictMarkerTrivia,\r\n        /** 第一个字面量令牌 = 数字字面量 */\r\n        FirstLiteralToken = NumericLiteral,\r\n        /** 最后一个字面量令牌 =无替换模板字面量 */\r\n        LastLiteralToken = NoSubstitutionTemplateLiteral,\r\n        /** 第一个模板标记 = 无替换模板文字 */\r\n        FirstTemplateToken = NoSubstitutionTemplateLiteral,\r\n        /** 最后一个模板标记 = 伪文字 模板的尾 */\r\n        LastTemplateToken = TemplateTail,\r\n        /** 第一个二元运算符 = < 令牌 */\r\n        FirstBinaryOperator = LessThanToken,\r\n        /** 最后一个二元运算符 = ^=令牌 */\r\n        LastBinaryOperator = CaretEqualsToken,\r\n        /** 第一个节点 = 限定名 */\r\n        FirstNode = QualifiedName,\r\n        /** 第一个JSD节点 = JSD类型表达式 */\r\n        FirstJSDocNode = JSDocTypeExpression,\r\n        /** 最后一个JSD节点 = JSD类型字面量 */\r\n        LastJSDocNode = JSDocTypeLiteral,\r\n        /** 第一个JSD标签节点 = JSD标签 */\r\n        FirstJSDocTagNode = JSDocTag,\r\n        /** 最后一个JSD标签节点 = JSD字类型面量 */\r\n        LastJSDocTagNode = JSDocTypeLiteral\r\n    }\r\n\r\n    export const enum NodeFlags {\r\n        None = 0,\r\n        Let = 1 << 0,  // Variable declaration\r\n        Const = 1 << 1,  // Variable declaration\r\n        NestedNamespace = 1 << 2,  // Namespace declaration\r\n        Synthesized = 1 << 3,  // Node was synthesized during transformation\r\n        Namespace = 1 << 4,  // Namespace declaration\r\n        ExportContext = 1 << 5,  // Export context (initialized by binding)\r\n        ContainsThis = 1 << 6,  // Interface contains references to \"this\"\r\n        HasImplicitReturn = 1 << 7,  // If function implicitly returns on one of codepaths (initialized by binding)\r\n        HasExplicitReturn = 1 << 8,  // If function has explicit reachable return on one of codepaths (initialized by binding)\r\n        GlobalAugmentation = 1 << 9,  // Set if module declaration is an augmentation for the global scope\r\n        HasAsyncFunctions = 1 << 10, // If the file has async functions (initialized by binding)\r\n        DisallowInContext = 1 << 11, // If node was parsed in a context where 'in-expressions' are not allowed\r\n        YieldContext = 1 << 12, // If node was parsed in the 'yield' context created when parsing a generator\r\n        DecoratorContext = 1 << 13, // If node was parsed as part of a decorator\r\n        AwaitContext = 1 << 14, // If node was parsed in the 'await' context created when parsing an async function\r\n        ThisNodeHasError = 1 << 15, // If the parser encountered an error when parsing the code that created this node\r\n        JavaScriptFile = 1 << 16, // If node was parsed in a JavaScript\r\n        ThisNodeOrAnySubNodesHasError = 1 << 17, // If this node or any of its children had an error\r\n        HasAggregatedChildData = 1 << 18, // If we've computed data from children and cached it in this node\r\n\r\n        // This flag will be set when the parser encounters a dynamic import expression so that module resolution\r\n        // will not have to walk the tree if the flag is not set. However, this flag is just a approximation because\r\n        // once it is set, the flag never gets cleared (hence why it's named \"PossiblyContainsDynamicImport\").\r\n        // During editing, if dynamic import is removed, incremental parsing will *NOT* update this flag. This means that the tree will always be traversed\r\n        // during module resolution. However, the removal operation should not occur often and in the case of the\r\n        // removal, it is likely that users will add the import anyway.\r\n        // The advantage of this approach is its simplicity. For the case of batch compilation,\r\n        // we guarantee that users won't have to pay the price of walking the tree if a dynamic import isn't used.\r\n        /* @internal */\r\n        PossiblyContainsDynamicImport = 1 << 19,\r\n        JSDoc = 1 << 20, // If node was parsed inside jsdoc\r\n        词典标签 = 1 << 21,\r\n        BlockScoped = Let | Const,\r\n\r\n        ReachabilityCheckFlags = HasImplicitReturn | HasExplicitReturn,\r\n        ReachabilityAndEmitFlags = ReachabilityCheckFlags | HasAsyncFunctions,\r\n\r\n        // Parsing context flags\r\n        ContextFlags = DisallowInContext | YieldContext | DecoratorContext | AwaitContext | JavaScriptFile,\r\n\r\n        // Exclude these flags when parsing a Type\r\n        TypeExcludesFlags = YieldContext | AwaitContext,\r\n    }\r\n\r\n    export const enum ModifierFlags {\r\n        None = 0,\r\n        Export = 1 << 0,  // Declarations\r\n        Ambient = 1 << 1,  // Declarations\r\n        Public = 1 << 2,  // Property/Method\r\n        Private = 1 << 3,  // Property/Method\r\n        Protected = 1 << 4,  // Property/Method\r\n        Static = 1 << 5,  // Property/Method\r\n        Readonly = 1 << 6,  // Property/Method\r\n        Abstract = 1 << 7,  // Class/Method/ConstructSignature\r\n        Async = 1 << 8,  // Property/Method/Function\r\n        Default = 1 << 9,  // Function/Class (export default declaration)\r\n        Const = 1 << 11, // Variable declaration\r\n        HasComputedFlags = 1 << 29, // Modifier flags have been computed\r\n\r\n        AccessibilityModifier = Public | Private | Protected,\r\n        // Accessibility modifiers and 'readonly' can be attached to a parameter in a constructor to make it a property.\r\n        ParameterPropertyModifier = AccessibilityModifier | Readonly,\r\n        NonPublicAccessibilityModifier = Private | Protected,\r\n\r\n        TypeScriptModifier = Ambient | Public | Private | Protected | Readonly | Abstract | Const,\r\n        ExportDefault = Export | Default,\r\n    }\r\n\r\n    export const enum JsxFlags {\r\n        None = 0,\r\n        /** An element from a named property of the JSX.IntrinsicElements interface */\r\n        IntrinsicNamedElement = 1 << 0,\r\n        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */\r\n        IntrinsicIndexedElement = 1 << 1,\r\n\r\n        IntrinsicElement = IntrinsicNamedElement | IntrinsicIndexedElement,\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum RelationComparisonResult {\r\n        Succeeded = 1, // Should be truthy\r\n        Failed = 2,\r\n        FailedAndReported = 3\r\n    }\r\n\r\n    export interface Node extends TextRange {\r\n        kind: SyntaxKind;\r\n        flags: NodeFlags;\r\n        局部词典语句?: 局部词典语句[];\r\n        别名?: 别名;\r\n        别名id?: number;\r\n        /* @internal */ modifierFlagsCache?: ModifierFlags;\r\n        /* @internal */ transformFlags?: TransformFlags;\r\n        decorators?: NodeArray<Decorator>;                    // Array of decorators (in document order)\r\n        modifiers?: ModifiersArray;                           // Array of modifiers\r\n        /* @internal */ id?: number;                          // Unique id (used to look up NodeLinks)\r\n        parent?: Node;                                        // Parent node (initialized by binding)\r\n        /* @internal */ original?: Node;                      // The original node if this is an updated node.\r\n        /* @internal */ startsOnNewLine?: boolean;            // Whether a synthesized node should start on a new line (used by transforms).\r\n        /* @internal */ symbol?: Symbol;                      // Symbol declared by node (initialized by binding)\r\n        /* @internal */ locals?: SymbolTable;                 // Locals associated with node (initialized by binding)\r\n        /* @internal */ nextContainer?: Node;                 // Next container in declaration order (initialized by binding)\r\n        /* @internal */ localSymbol?: Symbol;                 // Local symbol declared by node (initialized by binding only for exported nodes)\r\n        /* @internal */ flowNode?: FlowNode;                  // Associated FlowNode (initialized by binding)\r\n        /* @internal */ emitNode?: EmitNode;                  // Associated EmitNode (initialized by transforms)\r\n        /* @internal */ contextualType?: Type;                // Used to temporarily assign a contextual type during overload resolution\r\n        /* @internal */ contextualMapper?: TypeMapper;        // Mapper for contextual type\r\n    }\r\n\r\n    export interface JSDocContainer {\r\n        /* @internal */ jsDoc?: JSDoc[];                      // JSDoc that directly precedes this node\r\n        /* @internal */ jsDocCache?: ReadonlyArray<JSDocTag>; // Cache for getJSDocTags\r\n    }\r\n\r\n\r\n    export type HasJSDoc =\r\n        | ParameterDeclaration\r\n        | CallSignatureDeclaration\r\n        | ConstructSignatureDeclaration\r\n        | MethodSignature\r\n        | PropertySignature\r\n        | ArrowFunction\r\n        | ParenthesizedExpression\r\n        | SpreadAssignment\r\n        | ShorthandPropertyAssignment\r\n        | PropertyAssignment\r\n        | FunctionExpression\r\n        | LabeledStatement\r\n        | ExpressionStatement\r\n        | VariableStatement\r\n        | FunctionDeclaration\r\n        | ConstructorDeclaration\r\n        | MethodDeclaration\r\n        | PropertyDeclaration\r\n        | AccessorDeclaration\r\n        | ClassLikeDeclaration\r\n        | InterfaceDeclaration\r\n        | TypeAliasDeclaration\r\n        | EnumMember\r\n        | EnumDeclaration\r\n        | ModuleDeclaration\r\n        | ImportEqualsDeclaration\r\n        | IndexSignatureDeclaration\r\n        | FunctionTypeNode\r\n        | ConstructorTypeNode\r\n        | JSDocFunctionType\r\n        | EndOfFileToken;\r\n\r\n    /* @internal */\r\n    export type MutableNodeArray<T extends Node> = NodeArray<T> & T[];\r\n\r\n    export interface NodeArray<T extends Node> extends ReadonlyArray<T>, TextRange {\r\n        hasTrailingComma?: boolean;\r\n        /* @internal */ transformFlags?: TransformFlags;\r\n    }\r\n\r\n    export interface Token<TKind extends SyntaxKind> extends Node {\r\n        kind: TKind;\r\n    }\r\n\r\n    export type DotDotDotToken = Token<SyntaxKind.DotDotDotToken>;\r\n    export type QuestionToken = Token<SyntaxKind.QuestionToken>;\r\n    export type ColonToken = Token<SyntaxKind.ColonToken>;\r\n    export type EqualsToken = Token<SyntaxKind.EqualsToken>;\r\n    export type AsteriskToken = Token<SyntaxKind.AsteriskToken>;\r\n    export type EqualsGreaterThanToken = Token<SyntaxKind.EqualsGreaterThanToken>;\r\n    export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;\r\n    export type AtToken = Token<SyntaxKind.AtToken>;\r\n    export type ReadonlyToken = Token<SyntaxKind.ReadonlyKeyword>;\r\n    export type AwaitKeywordToken = Token<SyntaxKind.AwaitKeyword>;\r\n\r\n    export type Modifier\r\n        = Token<SyntaxKind.AbstractKeyword>\r\n        | Token<SyntaxKind.AsyncKeyword>\r\n        | Token<SyntaxKind.ConstKeyword>\r\n        | Token<SyntaxKind.DeclareKeyword>\r\n        | Token<SyntaxKind.DefaultKeyword>\r\n        | Token<SyntaxKind.ExportKeyword>\r\n        | Token<SyntaxKind.PublicKeyword>\r\n        | Token<SyntaxKind.PrivateKeyword>\r\n        | Token<SyntaxKind.ProtectedKeyword>\r\n        | Token<SyntaxKind.ReadonlyKeyword>\r\n        | Token<SyntaxKind.StaticKeyword>\r\n        ;\r\n\r\n    export type ModifiersArray = NodeArray<Modifier>;\r\n\r\n    /*@internal*/\r\n    export const enum GeneratedIdentifierKind {\r\n        None,   // Not automatically generated.\r\n        Auto,   // Automatically generated identifier.\r\n        Loop,   // Automatically generated identifier with a preference for '_i'.\r\n        Unique, // Unique name based on the 'text' property.\r\n        Node,   // Unique name based on the node in the 'original' property.\r\n    }\r\n\r\n    export interface Identifier extends PrimaryExpression {\r\n        kind: SyntaxKind.Identifier;\r\n        /**\r\n         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)\r\n         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.\r\n         */\r\n        escapedText: __String;\r\n        originalKeywordKind?: SyntaxKind;                         // Original syntaxKind which get set so that we can report an error later\r\n        /*@internal*/ autoGenerateKind?: GeneratedIdentifierKind; // Specifies whether to auto-generate the text for an identifier.\r\n        /*@internal*/ autoGenerateId?: number;                    // Ensures unique generated identifiers get unique names, but clones get the same name.\r\n        isInJSDocNamespace?: boolean;                             // if the node is a member in a JSDoc namespace\r\n        /*@internal*/ typeArguments?: NodeArray<TypeNode>;        // Only defined on synthesized nodes. Though not syntactically valid, used in emitting diagnostics.\r\n        /*@internal*/ jsdocDotPos?: number;                       // Identifier occurs in JSDoc-style generic: Id.<T>\r\n    }\r\n\r\n    // Transient identifier node (marked by id === -1)\r\n    export interface TransientIdentifier extends Identifier {\r\n        resolvedSymbol: Symbol;\r\n    }\r\n\r\n    /*@internal*/\r\n    export interface GeneratedIdentifier extends Identifier {\r\n        autoGenerateKind: GeneratedIdentifierKind.Auto\r\n        | GeneratedIdentifierKind.Loop\r\n        | GeneratedIdentifierKind.Unique\r\n        | GeneratedIdentifierKind.Node;\r\n    }\r\n\r\n    export interface QualifiedName extends Node {\r\n        kind: SyntaxKind.QualifiedName;\r\n        left: EntityName;\r\n        right: Identifier;\r\n        /*@internal*/ jsdocDotPos?: number;                      // QualifiedName occurs in JSDoc-style generic: Id1.Id2.<T>\r\n    }\r\n\r\n    export type EntityName = Identifier | QualifiedName;\r\n\r\n    export type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName;\r\n\r\n    export type DeclarationName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | BindingPattern;\r\n\r\n\r\n    export interface Declaration extends Node {\r\n        _declarationBrand: any;\r\n    }\r\n\r\n    export interface NamedDeclaration extends Declaration {\r\n        name?: DeclarationName;\r\n    }\r\n\r\n    export interface DeclarationStatement extends NamedDeclaration, Statement {\r\n        name?: Identifier | StringLiteral | NumericLiteral;\r\n    }\r\n\r\n    export interface ComputedPropertyName extends Node {\r\n        kind: SyntaxKind.ComputedPropertyName;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface Decorator extends Node {\r\n        kind: SyntaxKind.Decorator;\r\n        parent?: NamedDeclaration;\r\n        expression: LeftHandSideExpression;\r\n    }\r\n\r\n    export interface TypeParameterDeclaration extends NamedDeclaration {\r\n        kind: SyntaxKind.TypeParameter;\r\n        parent?: DeclarationWithTypeParameters;\r\n        name: Identifier;\r\n        constraint?: TypeNode;\r\n        default?: TypeNode;\r\n\r\n        // For error recovery purposes.\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {\r\n        kind: SignatureDeclaration[\"kind\"];\r\n        name?: PropertyName;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        parameters: NodeArray<ParameterDeclaration>;\r\n        type: TypeNode | undefined;\r\n    }\r\n\r\n    export type SignatureDeclaration =\r\n        | CallSignatureDeclaration\r\n        | ConstructSignatureDeclaration\r\n        | MethodSignature\r\n        | IndexSignatureDeclaration\r\n        | FunctionTypeNode\r\n        | ConstructorTypeNode\r\n        | JSDocFunctionType\r\n        | FunctionDeclaration\r\n        | MethodDeclaration\r\n        | ConstructorDeclaration\r\n        | AccessorDeclaration\r\n        | FunctionExpression\r\n        | ArrowFunction;\r\n\r\n    export interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.CallSignature;\r\n    }\r\n\r\n    export interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.ConstructSignature;\r\n    }\r\n\r\n    export type BindingName = Identifier | BindingPattern;\r\n\r\n    export interface VariableDeclaration extends NamedDeclaration {\r\n        kind: SyntaxKind.VariableDeclaration;\r\n        parent?: VariableDeclarationList | CatchClause;\r\n        name: BindingName;                  // Declared variable name\r\n        type?: TypeNode;                    // Optional type annotation\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface VariableDeclarationList extends Node {\r\n        kind: SyntaxKind.VariableDeclarationList;\r\n        parent?: VariableStatement | ForStatement | ForOfStatement | ForInStatement;\r\n        declarations: NodeArray<VariableDeclaration>;\r\n    }\r\n\r\n    export interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.Parameter;\r\n        parent?: SignatureDeclaration;\r\n        dotDotDotToken?: DotDotDotToken;    // Present on rest parameter\r\n        name: BindingName;                  // Declared parameter name.\r\n        questionToken?: QuestionToken;      // Present on optional parameter\r\n        type?: TypeNode;                    // Optional type annotation\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface BindingElement extends NamedDeclaration {\r\n        kind: SyntaxKind.BindingElement;\r\n        parent?: BindingPattern;\r\n        propertyName?: PropertyName;        // Binding property name (in object binding pattern)\r\n        dotDotDotToken?: DotDotDotToken;    // Present on rest element (in object binding pattern)\r\n        name: BindingName;                  // Declared binding element name\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface PropertySignature extends TypeElement, JSDocContainer {\r\n        kind: SyntaxKind.PropertySignature;\r\n        name: PropertyName;                 // Declared property name\r\n        questionToken?: QuestionToken;      // Present on optional property\r\n        type?: TypeNode;                    // Optional type annotation\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface PropertyDeclaration extends ClassElement, JSDocContainer {\r\n        kind: SyntaxKind.PropertyDeclaration;\r\n        questionToken?: QuestionToken;      // Present for use with reporting a grammar error\r\n        name: PropertyName;\r\n        type?: TypeNode;\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface ObjectLiteralElement extends NamedDeclaration {\r\n        _objectLiteralBrandBrand: any;\r\n        name?: PropertyName;\r\n    }\r\n\r\n    export type ObjectLiteralElementLike\r\n        = PropertyAssignment\r\n        | ShorthandPropertyAssignment\r\n        | SpreadAssignment\r\n        | MethodDeclaration\r\n        | AccessorDeclaration\r\n        ;\r\n\r\n    export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.PropertyAssignment;\r\n        name: PropertyName;\r\n        questionToken?: QuestionToken;\r\n        initializer: Expression;\r\n    }\r\n\r\n    export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.ShorthandPropertyAssignment;\r\n        name: Identifier;\r\n        questionToken?: QuestionToken;\r\n        // used when ObjectLiteralExpression is used in ObjectAssignmentPattern\r\n        // it is grammar error to appear in actual object initializer\r\n        equalsToken?: Token<SyntaxKind.EqualsToken>;\r\n        objectAssignmentInitializer?: Expression;\r\n    }\r\n\r\n    export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.SpreadAssignment;\r\n        expression: Expression;\r\n    }\r\n\r\n    // SyntaxKind.VariableDeclaration\r\n    // SyntaxKind.Parameter\r\n    // SyntaxKind.BindingElement\r\n    // SyntaxKind.Property\r\n    // SyntaxKind.PropertyAssignment\r\n    // SyntaxKind.JsxAttribute\r\n    // SyntaxKind.ShorthandPropertyAssignment\r\n    // SyntaxKind.EnumMember\r\n    // SyntaxKind.JSDocPropertyTag\r\n    // SyntaxKind.JSDocParameterTag\r\n    export interface VariableLikeDeclaration extends NamedDeclaration {\r\n        propertyName?: PropertyName;\r\n        dotDotDotToken?: DotDotDotToken;\r\n        name: DeclarationName;\r\n        questionToken?: QuestionToken;\r\n        type?: TypeNode;\r\n        initializer?: Expression;\r\n    }\r\n\r\n    export interface PropertyLikeDeclaration extends NamedDeclaration {\r\n        name: PropertyName;\r\n    }\r\n\r\n    export interface ObjectBindingPattern extends Node {\r\n        kind: SyntaxKind.ObjectBindingPattern;\r\n        parent?: VariableDeclaration | ParameterDeclaration | BindingElement;\r\n        elements: NodeArray<BindingElement>;\r\n    }\r\n\r\n    export interface ArrayBindingPattern extends Node {\r\n        kind: SyntaxKind.ArrayBindingPattern;\r\n        parent?: VariableDeclaration | ParameterDeclaration | BindingElement;\r\n        elements: NodeArray<ArrayBindingElement>;\r\n    }\r\n\r\n    export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\r\n\r\n    export type ArrayBindingElement = BindingElement | OmittedExpression;\r\n\r\n    /**\r\n     * Several node kinds share function-like features such as a signature,\r\n     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.\r\n     * Examples:\r\n     * - FunctionDeclaration\r\n     * - MethodDeclaration\r\n     * - AccessorDeclaration\r\n     */\r\n    export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {\r\n        _functionLikeDeclarationBrand: any;\r\n\r\n        asteriskToken?: AsteriskToken;\r\n        questionToken?: QuestionToken;\r\n        body?: Block | Expression;\r\n    }\r\n\r\n    export type FunctionLikeDeclaration =\r\n        | FunctionDeclaration\r\n        | MethodDeclaration\r\n        | ConstructorDeclaration\r\n        | GetAccessorDeclaration\r\n        | SetAccessorDeclaration\r\n        | FunctionExpression\r\n        | ArrowFunction;\r\n    export type FunctionLike =\r\n        | FunctionLikeDeclaration\r\n        | FunctionTypeNode\r\n        | ConstructorTypeNode\r\n        | IndexSignatureDeclaration\r\n        | MethodSignature\r\n        | ConstructSignatureDeclaration\r\n        | CallSignatureDeclaration;\r\n\r\n    export interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement {\r\n        kind: SyntaxKind.FunctionDeclaration;\r\n        name?: Identifier;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    export interface MethodSignature extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.MethodSignature;\r\n        name: PropertyName;\r\n    }\r\n\r\n    // Note that a MethodDeclaration is considered both a ClassElement and an ObjectLiteralElement.\r\n    // Both the grammars for ClassDeclaration and ObjectLiteralExpression allow for MethodDeclarations\r\n    // as child elements, and so a MethodDeclaration satisfies both interfaces.  This avoids the\r\n    // alternative where we would need separate kinds/types for ClassMethodDeclaration and\r\n    // ObjectLiteralMethodDeclaration, which would look identical.\r\n    //\r\n    // Because of this, it may be necessary to determine what sort of MethodDeclaration you have\r\n    // at later stages of the compiler pipeline.  In that case, you can either check the parent kind\r\n    // of the method, or use helpers like isObjectLiteralMethodDeclaration\r\n    export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.MethodDeclaration;\r\n        name: PropertyName;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {\r\n        kind: SyntaxKind.Constructor;\r\n        parent?: ClassDeclaration | ClassExpression;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */\r\n    export interface SemicolonClassElement extends ClassElement {\r\n        kind: SyntaxKind.SemicolonClassElement;\r\n        parent?: ClassDeclaration | ClassExpression;\r\n    }\r\n\r\n    // See the comment on MethodDeclaration for the intuition behind GetAccessorDeclaration being a\r\n    // ClassElement and an ObjectLiteralElement.\r\n    export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.GetAccessor;\r\n        parent?: ClassDeclaration | ClassExpression | ObjectLiteralExpression;\r\n        name: PropertyName;\r\n        body: FunctionBody;\r\n    }\r\n\r\n    // See the comment on MethodDeclaration for the intuition behind SetAccessorDeclaration being a\r\n    // ClassElement and an ObjectLiteralElement.\r\n    export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.SetAccessor;\r\n        parent?: ClassDeclaration | ClassExpression | ObjectLiteralExpression;\r\n        name: PropertyName;\r\n        body: FunctionBody;\r\n    }\r\n\r\n    export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\r\n\r\n    export interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement {\r\n        kind: SyntaxKind.IndexSignature;\r\n        parent?: ClassDeclaration | ClassExpression | InterfaceDeclaration | TypeLiteralNode;\r\n    }\r\n\r\n    export interface TypeNode extends Node {\r\n        _typeNodeBrand: any;\r\n    }\r\n\r\n    export interface KeywordTypeNode extends TypeNode {\r\n        kind: SyntaxKind.AnyKeyword\r\n        | SyntaxKind.NumberKeyword\r\n        | SyntaxKind.ObjectKeyword\r\n        | SyntaxKind.BooleanKeyword\r\n        | SyntaxKind.StringKeyword\r\n        | SyntaxKind.SymbolKeyword\r\n        | SyntaxKind.ThisKeyword\r\n        | SyntaxKind.VoidKeyword\r\n        | SyntaxKind.UndefinedKeyword\r\n        | SyntaxKind.NullKeyword\r\n        | SyntaxKind.NeverKeyword;\r\n    }\r\n\r\n    export interface ThisTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ThisType;\r\n    }\r\n\r\n    export type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;\r\n\r\n    export interface FunctionTypeNode extends TypeNode, SignatureDeclarationBase {\r\n        kind: SyntaxKind.FunctionType;\r\n    }\r\n\r\n    export interface ConstructorTypeNode extends TypeNode, SignatureDeclarationBase {\r\n        kind: SyntaxKind.ConstructorType;\r\n    }\r\n\r\n    export type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;\r\n\r\n    export interface TypeReferenceNode extends TypeNode {\r\n        kind: SyntaxKind.TypeReference;\r\n        typeName: EntityName;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface TypePredicateNode extends TypeNode {\r\n        kind: SyntaxKind.TypePredicate;\r\n        parent?: SignatureDeclaration;\r\n        parameterName: Identifier | ThisTypeNode;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface TypeQueryNode extends TypeNode {\r\n        kind: SyntaxKind.TypeQuery;\r\n        exprName: EntityName;\r\n    }\r\n\r\n    // A TypeLiteral is the declaration node for an anonymous symbol.\r\n    export interface TypeLiteralNode extends TypeNode, Declaration {\r\n        kind: SyntaxKind.TypeLiteral;\r\n        members: NodeArray<TypeElement>;\r\n    }\r\n\r\n    export interface ArrayTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ArrayType;\r\n        elementType: TypeNode;\r\n    }\r\n\r\n    export interface TupleTypeNode extends TypeNode {\r\n        kind: SyntaxKind.TupleType;\r\n        elementTypes: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;\r\n\r\n    export interface UnionTypeNode extends TypeNode {\r\n        kind: SyntaxKind.UnionType;\r\n        types: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface IntersectionTypeNode extends TypeNode {\r\n        kind: SyntaxKind.IntersectionType;\r\n        types: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface ParenthesizedTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ParenthesizedType;\r\n        type: TypeNode;\r\n    }\r\n    export interface TypeOperatorNode extends TypeNode {\r\n        kind: SyntaxKind.TypeOperator;\r\n        operator: SyntaxKind.KeyOfKeyword;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface IndexedAccessTypeNode extends TypeNode {\r\n        kind: SyntaxKind.IndexedAccessType;\r\n        objectType: TypeNode;\r\n        indexType: TypeNode;\r\n    }\r\n\r\n    export interface MappedTypeNode extends TypeNode, Declaration {\r\n        kind: SyntaxKind.MappedType;\r\n        readonlyToken?: ReadonlyToken;\r\n        typeParameter: TypeParameterDeclaration;\r\n        questionToken?: QuestionToken;\r\n        type?: TypeNode;\r\n    }\r\n\r\n    export interface LiteralTypeNode extends TypeNode {\r\n        kind: SyntaxKind.LiteralType;\r\n        literal: BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\r\n    }\r\n\r\n    export interface StringLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.StringLiteral;\r\n        别名?: 别名;\r\n        别名id?: number;\r\n        /* @internal */ textSourceNode?: Identifier | StringLiteral | NumericLiteral; // Allows a StringLiteral to get its text from another node (used by transforms).\r\n        /** Note: this is only set when synthesizing a node, not during parsing. */\r\n        /* @internal */ singleQuote?: boolean;\r\n    }\r\n\r\n    // Note: 'brands' in our syntax nodes serve to give us a small amount of nominal typing.\r\n    // Consider 'Expression'.  Without the brand, 'Expression' is actually no different\r\n    // (structurally) than 'Node'.  Because of this you can pass any Node to a function that\r\n    // takes an Expression without any error.  By using the 'brands' we ensure that the type\r\n    // checker actually thinks you have something of the right type.  Note: the brands are\r\n    // never actually given values.  At runtime they have zero cost.\r\n\r\n    export interface Expression extends Node {\r\n        _expressionBrand: any;\r\n    }\r\n\r\n    export interface OmittedExpression extends Expression {\r\n        kind: SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n    // Represents an expression that is elided as part of a transformation to emit comments on a\r\n    // not-emitted node. The 'expression' property of a PartiallyEmittedExpression should be emitted.\r\n    export interface PartiallyEmittedExpression extends LeftHandSideExpression {\r\n        kind: SyntaxKind.PartiallyEmittedExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface UnaryExpression extends Expression {\r\n        _unaryExpressionBrand: any;\r\n    }\r\n\r\n    /** Deprecated, please use UpdateExpression */\r\n    export type IncrementExpression = UpdateExpression;\r\n    export interface UpdateExpression extends UnaryExpression {\r\n        _updateExpressionBrand: any;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-UpdateExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-UnaryExpression\r\n    export type PrefixUnaryOperator\r\n        = SyntaxKind.PlusPlusToken\r\n        | SyntaxKind.MinusMinusToken\r\n        | SyntaxKind.PlusToken\r\n        | SyntaxKind.MinusToken\r\n        | SyntaxKind.TildeToken\r\n        | SyntaxKind.ExclamationToken;\r\n\r\n    export interface PrefixUnaryExpression extends UpdateExpression {\r\n        kind: SyntaxKind.PrefixUnaryExpression;\r\n        operator: PrefixUnaryOperator;\r\n        operand: UnaryExpression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-UpdateExpression\r\n    export type PostfixUnaryOperator\r\n        = SyntaxKind.PlusPlusToken\r\n        | SyntaxKind.MinusMinusToken\r\n        ;\r\n\r\n    export interface PostfixUnaryExpression extends UpdateExpression {\r\n        kind: SyntaxKind.PostfixUnaryExpression;\r\n        operand: LeftHandSideExpression;\r\n        operator: PostfixUnaryOperator;\r\n    }\r\n\r\n    export interface LeftHandSideExpression extends UpdateExpression {\r\n        _leftHandSideExpressionBrand: any;\r\n    }\r\n\r\n    export interface MemberExpression extends LeftHandSideExpression {\r\n        _memberExpressionBrand: any;\r\n    }\r\n\r\n    export interface PrimaryExpression extends MemberExpression {\r\n        _primaryExpressionBrand: any;\r\n    }\r\n\r\n    export interface NullLiteral extends PrimaryExpression, TypeNode {\r\n        kind: SyntaxKind.NullKeyword;\r\n    }\r\n\r\n    export interface BooleanLiteral extends PrimaryExpression, TypeNode {\r\n        kind: SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword;\r\n    }\r\n\r\n    export interface ThisExpression extends PrimaryExpression, KeywordTypeNode {\r\n        kind: SyntaxKind.ThisKeyword;\r\n    }\r\n\r\n    export interface SuperExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    export interface ImportExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.ImportKeyword;\r\n    }\r\n\r\n    export interface DeleteExpression extends UnaryExpression {\r\n        kind: SyntaxKind.DeleteExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface TypeOfExpression extends UnaryExpression {\r\n        kind: SyntaxKind.TypeOfExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface VoidExpression extends UnaryExpression {\r\n        kind: SyntaxKind.VoidExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface AwaitExpression extends UnaryExpression {\r\n        kind: SyntaxKind.AwaitExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface YieldExpression extends Expression {\r\n        kind: SyntaxKind.YieldExpression;\r\n        asteriskToken?: AsteriskToken;\r\n        expression?: Expression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ExponentiationExpression\r\n    export type ExponentiationOperator\r\n        = SyntaxKind.AsteriskAsteriskToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-MultiplicativeOperator\r\n    export type MultiplicativeOperator\r\n        = SyntaxKind.AsteriskToken\r\n        | SyntaxKind.SlashToken\r\n        | SyntaxKind.PercentToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-MultiplicativeExpression\r\n    export type MultiplicativeOperatorOrHigher\r\n        = ExponentiationOperator\r\n        | MultiplicativeOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AdditiveExpression\r\n    export type AdditiveOperator\r\n        = SyntaxKind.PlusToken\r\n        | SyntaxKind.MinusToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AdditiveExpression\r\n    export type AdditiveOperatorOrHigher\r\n        = MultiplicativeOperatorOrHigher\r\n        | AdditiveOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ShiftExpression\r\n    export type ShiftOperator\r\n        = SyntaxKind.LessThanLessThanToken\r\n        | SyntaxKind.GreaterThanGreaterThanToken\r\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ShiftExpression\r\n    export type ShiftOperatorOrHigher\r\n        = AdditiveOperatorOrHigher\r\n        | ShiftOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-RelationalExpression\r\n    export type RelationalOperator\r\n        = SyntaxKind.LessThanToken\r\n        | SyntaxKind.LessThanEqualsToken\r\n        | SyntaxKind.GreaterThanToken\r\n        | SyntaxKind.GreaterThanEqualsToken\r\n        | SyntaxKind.InstanceOfKeyword\r\n        | SyntaxKind.InKeyword\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-RelationalExpression\r\n    export type RelationalOperatorOrHigher\r\n        = ShiftOperatorOrHigher\r\n        | RelationalOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-EqualityExpression\r\n    export type EqualityOperator\r\n        = SyntaxKind.EqualsEqualsToken\r\n        | SyntaxKind.EqualsEqualsEqualsToken\r\n        | SyntaxKind.ExclamationEqualsEqualsToken\r\n        | SyntaxKind.ExclamationEqualsToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-EqualityExpression\r\n    export type EqualityOperatorOrHigher\r\n        = RelationalOperatorOrHigher\r\n        | EqualityOperator;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseXORExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseORExpression\r\n    export type BitwiseOperator\r\n        = SyntaxKind.AmpersandToken\r\n        | SyntaxKind.BarToken\r\n        | SyntaxKind.CaretToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseXORExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseORExpression\r\n    export type BitwiseOperatorOrHigher\r\n        = EqualityOperatorOrHigher\r\n        | BitwiseOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalORExpression\r\n    export type LogicalOperator\r\n        = SyntaxKind.AmpersandAmpersandToken\r\n        | SyntaxKind.BarBarToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalORExpression\r\n    export type LogicalOperatorOrHigher\r\n        = BitwiseOperatorOrHigher\r\n        | LogicalOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentOperator\r\n    export type CompoundAssignmentOperator\r\n        = SyntaxKind.PlusEqualsToken\r\n        | SyntaxKind.MinusEqualsToken\r\n        | SyntaxKind.AsteriskAsteriskEqualsToken\r\n        | SyntaxKind.AsteriskEqualsToken\r\n        | SyntaxKind.SlashEqualsToken\r\n        | SyntaxKind.PercentEqualsToken\r\n        | SyntaxKind.AmpersandEqualsToken\r\n        | SyntaxKind.BarEqualsToken\r\n        | SyntaxKind.CaretEqualsToken\r\n        | SyntaxKind.LessThanLessThanEqualsToken\r\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken\r\n        | SyntaxKind.GreaterThanGreaterThanEqualsToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentExpression\r\n    export type AssignmentOperator\r\n        = SyntaxKind.EqualsToken\r\n        | CompoundAssignmentOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentExpression\r\n    export type AssignmentOperatorOrHigher\r\n        = LogicalOperatorOrHigher\r\n        | AssignmentOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-Expression\r\n    export type BinaryOperator\r\n        = AssignmentOperatorOrHigher\r\n        | SyntaxKind.CommaToken\r\n        ;\r\n\r\n    export type BinaryOperatorToken = Token<BinaryOperator>;\r\n\r\n    export interface BinaryExpression extends Expression, Declaration {\r\n        kind: SyntaxKind.BinaryExpression;\r\n        left: Expression;\r\n        operatorToken: BinaryOperatorToken;\r\n        right: Expression;\r\n    }\r\n\r\n    export type AssignmentOperatorToken = Token<AssignmentOperator>;\r\n\r\n    export interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {\r\n        left: LeftHandSideExpression;\r\n        operatorToken: TOperator;\r\n    }\r\n\r\n    export interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {\r\n        left: ObjectLiteralExpression;\r\n    }\r\n\r\n    export interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {\r\n        left: ArrayLiteralExpression;\r\n    }\r\n\r\n    export type DestructuringAssignment\r\n        = ObjectDestructuringAssignment\r\n        | ArrayDestructuringAssignment\r\n        ;\r\n\r\n    export type BindingOrAssignmentElement\r\n        = VariableDeclaration\r\n        | ParameterDeclaration\r\n        | BindingElement\r\n        | PropertyAssignment // AssignmentProperty\r\n        | ShorthandPropertyAssignment // AssignmentProperty\r\n        | SpreadAssignment // AssignmentRestProperty\r\n        | OmittedExpression // Elision\r\n        | SpreadElement // AssignmentRestElement\r\n        | ArrayLiteralExpression // ArrayAssignmentPattern\r\n        | ObjectLiteralExpression // ObjectAssignmentPattern\r\n        | AssignmentExpression<EqualsToken> // AssignmentElement\r\n        | Identifier // DestructuringAssignmentTarget\r\n        | PropertyAccessExpression // DestructuringAssignmentTarget\r\n        | ElementAccessExpression // DestructuringAssignmentTarget\r\n        ;\r\n\r\n    export type BindingOrAssignmentElementRestIndicator\r\n        = DotDotDotToken // from BindingElement\r\n        | SpreadElement // AssignmentRestElement\r\n        | SpreadAssignment // AssignmentRestProperty\r\n        ;\r\n\r\n    export type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Expression;\r\n\r\n    export type ObjectBindingOrAssignmentPattern\r\n        = ObjectBindingPattern\r\n        | ObjectLiteralExpression // ObjectAssignmentPattern\r\n        ;\r\n\r\n    export type ArrayBindingOrAssignmentPattern\r\n        = ArrayBindingPattern\r\n        | ArrayLiteralExpression // ArrayAssignmentPattern\r\n        ;\r\n\r\n    export type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;\r\n\r\n    export type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;\r\n\r\n    export interface ConditionalExpression extends Expression {\r\n        kind: SyntaxKind.ConditionalExpression;\r\n        condition: Expression;\r\n        questionToken: QuestionToken;\r\n        whenTrue: Expression;\r\n        colonToken: ColonToken;\r\n        whenFalse: Expression;\r\n    }\r\n\r\n    export type FunctionBody = Block;\r\n    export type ConciseBody = FunctionBody | Expression;\r\n\r\n    export interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer {\r\n        kind: SyntaxKind.FunctionExpression;\r\n        name?: Identifier;\r\n        body: FunctionBody;  // Required, whereas the member inherited from FunctionDeclaration is optional\r\n    }\r\n\r\n    export interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer {\r\n        kind: SyntaxKind.ArrowFunction;\r\n        equalsGreaterThanToken: EqualsGreaterThanToken;\r\n        body: ConciseBody;\r\n    }\r\n\r\n    // The text property of a LiteralExpression stores the interpreted value of the literal in text form. For a StringLiteral,\r\n    // or any literal of a template, this means quotes have been removed and escapes have been converted to actual characters.\r\n    // For a NumericLiteral, the stored value is the toString() representation of the number. For example 1, 1.00, and 1e0 are all stored as just \"1\".\r\n    export interface LiteralLikeNode extends Node {\r\n        text: string;\r\n        isUnterminated?: boolean;\r\n        hasExtendedUnicodeEscape?: boolean;\r\n    }\r\n\r\n    // The text property of a LiteralExpression stores the interpreted value of the literal in text form. For a StringLiteral,\r\n    // or any literal of a template, this means quotes have been removed and escapes have been converted to actual characters.\r\n    // For a NumericLiteral, the stored value is the toString() representation of the number. For example 1, 1.00, and 1e0 are all stored as just \"1\".\r\n    export interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {\r\n        _literalExpressionBrand: any;\r\n    }\r\n\r\n    export interface RegularExpressionLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.RegularExpressionLiteral;\r\n    }\r\n\r\n    export interface NoSubstitutionTemplateLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.NoSubstitutionTemplateLiteral;\r\n        别名?: 别名;\r\n        别名id?: number;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum NumericLiteralFlags {\r\n        None = 0,\r\n        Scientific = 1 << 1,        // e.g. `10e2`\r\n        Octal = 1 << 2,             // e.g. `0777`\r\n        HexSpecifier = 1 << 3,      // e.g. `0x00000000`\r\n        BinarySpecifier = 1 << 4,   // e.g. `0b0110010000000000`\r\n        OctalSpecifier = 1 << 5,    // e.g. `0o777`\r\n        BinaryOrOctalSpecifier = BinarySpecifier | OctalSpecifier,\r\n    }\r\n\r\n    export interface NumericLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.NumericLiteral;\r\n        /* @internal */\r\n        numericLiteralFlags?: NumericLiteralFlags;\r\n    }\r\n\r\n    export interface TemplateHead extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateHead;\r\n        parent?: TemplateExpression;\r\n    }\r\n\r\n    export interface TemplateMiddle extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateMiddle;\r\n        parent?: TemplateSpan;\r\n    }\r\n\r\n    export interface TemplateTail extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateTail;\r\n        parent?: TemplateSpan;\r\n    }\r\n\r\n    export type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\r\n\r\n    export interface TemplateExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.TemplateExpression;\r\n        head: TemplateHead;\r\n        templateSpans: NodeArray<TemplateSpan>;\r\n    }\r\n\r\n    // Each of these corresponds to a substitution expression and a template literal, in that order.\r\n    // The template literal must have kind TemplateMiddleLiteral or TemplateTailLiteral.\r\n    export interface TemplateSpan extends Node {\r\n        kind: SyntaxKind.TemplateSpan;\r\n        parent?: TemplateExpression;\r\n        expression: Expression;\r\n        literal: TemplateMiddle | TemplateTail;\r\n    }\r\n\r\n    export interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {\r\n        kind: SyntaxKind.ParenthesizedExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ArrayLiteralExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.ArrayLiteralExpression;\r\n        elements: NodeArray<Expression>;\r\n        /* @internal */\r\n        multiLine?: boolean;\r\n    }\r\n\r\n    export interface SpreadElement extends Expression {\r\n        kind: SyntaxKind.SpreadElement;\r\n        parent?: ArrayLiteralExpression | CallExpression | NewExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    /**\r\n     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to\r\n     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be\r\n     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type\r\n     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)\r\n     */\r\n    export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {\r\n        properties: NodeArray<T>;\r\n    }\r\n\r\n    // An ObjectLiteralExpression is the declaration node for an anonymous symbol.\r\n    export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {\r\n        kind: SyntaxKind.ObjectLiteralExpression;\r\n        /* @internal */\r\n        multiLine?: boolean;\r\n    }\r\n\r\n    export type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression | ParenthesizedExpression;\r\n    export type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;\r\n\r\n    export interface PropertyAccessExpression extends MemberExpression, NamedDeclaration {\r\n        kind: SyntaxKind.PropertyAccessExpression;\r\n        expression: LeftHandSideExpression;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface SuperPropertyAccessExpression extends PropertyAccessExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */\r\n    export interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {\r\n        _propertyAccessExpressionLikeQualifiedNameBrand?: any;\r\n        expression: EntityNameExpression;\r\n    }\r\n\r\n    export interface ElementAccessExpression extends MemberExpression {\r\n        kind: SyntaxKind.ElementAccessExpression;\r\n        expression: LeftHandSideExpression;\r\n        argumentExpression?: Expression;\r\n    }\r\n\r\n    export interface SuperElementAccessExpression extends ElementAccessExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-SuperProperty\r\n    export type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;\r\n\r\n    export interface CallExpression extends LeftHandSideExpression, Declaration {\r\n        kind: SyntaxKind.CallExpression;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments: NodeArray<Expression>;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-SuperCall\r\n    export interface SuperCall extends CallExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    export interface ImportCall extends CallExpression {\r\n        expression: ImportExpression;\r\n    }\r\n\r\n    export interface ExpressionWithTypeArguments extends TypeNode {\r\n        kind: SyntaxKind.ExpressionWithTypeArguments;\r\n        parent?: HeritageClause;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface NewExpression extends PrimaryExpression, Declaration {\r\n        kind: SyntaxKind.NewExpression;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments?: NodeArray<Expression>;\r\n    }\r\n\r\n    export interface TaggedTemplateExpression extends MemberExpression {\r\n        kind: SyntaxKind.TaggedTemplateExpression;\r\n        tag: LeftHandSideExpression;\r\n        template: TemplateLiteral;\r\n    }\r\n\r\n    export type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;\r\n\r\n    export interface AsExpression extends Expression {\r\n        kind: SyntaxKind.AsExpression;\r\n        expression: Expression;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface TypeAssertion extends UnaryExpression {\r\n        kind: SyntaxKind.TypeAssertionExpression;\r\n        type: TypeNode;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export type AssertionExpression = TypeAssertion | AsExpression;\r\n\r\n    export interface NonNullExpression extends LeftHandSideExpression {\r\n        kind: SyntaxKind.NonNullExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    // NOTE: MetaProperty is really a MemberExpression, but we consider it a PrimaryExpression\r\n    //       for the same reasons we treat NewExpression as a PrimaryExpression.\r\n    export interface MetaProperty extends PrimaryExpression {\r\n        kind: SyntaxKind.MetaProperty;\r\n        keywordToken: SyntaxKind.NewKeyword;\r\n        name: Identifier;\r\n    }\r\n\r\n    /// A JSX expression of the form <TagName attrs>...</TagName>\r\n    export interface JsxElement extends PrimaryExpression {\r\n        kind: SyntaxKind.JsxElement;\r\n        openingElement: JsxOpeningElement;\r\n        children: NodeArray<JsxChild>;\r\n        closingElement: JsxClosingElement;\r\n    }\r\n\r\n    /// Either the opening tag in a <Tag>...</Tag> pair, or the lone <Tag /> in a self-closing form\r\n    export type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\r\n\r\n    export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\r\n\r\n    export type JsxTagNameExpression = PrimaryExpression | PropertyAccessExpression;\r\n\r\n    export interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {\r\n        parent?: JsxOpeningLikeElement;\r\n    }\r\n\r\n    /// The opening element of a <Tag>...</Tag> JsxElement\r\n    export interface JsxOpeningElement extends Expression {\r\n        kind: SyntaxKind.JsxOpeningElement;\r\n        parent?: JsxElement;\r\n        tagName: JsxTagNameExpression;\r\n        attributes: JsxAttributes;\r\n    }\r\n\r\n    /// A JSX expression of the form <TagName attrs />\r\n    export interface JsxSelfClosingElement extends PrimaryExpression {\r\n        kind: SyntaxKind.JsxSelfClosingElement;\r\n        tagName: JsxTagNameExpression;\r\n        attributes: JsxAttributes;\r\n    }\r\n\r\n    export interface JsxAttribute extends ObjectLiteralElement {\r\n        kind: SyntaxKind.JsxAttribute;\r\n        parent?: JsxAttributes;\r\n        name: Identifier;\r\n        /// JSX attribute initializers are optional; <X y /> is sugar for <X y={true} />\r\n        initializer?: StringLiteral | JsxExpression;\r\n    }\r\n\r\n    export interface JsxSpreadAttribute extends ObjectLiteralElement {\r\n        kind: SyntaxKind.JsxSpreadAttribute;\r\n        parent?: JsxAttributes;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface JsxClosingElement extends Node {\r\n        kind: SyntaxKind.JsxClosingElement;\r\n        parent?: JsxElement;\r\n        tagName: JsxTagNameExpression;\r\n    }\r\n\r\n    export interface JsxExpression extends Expression {\r\n        kind: SyntaxKind.JsxExpression;\r\n        parent?: JsxElement | JsxAttributeLike;\r\n        dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface JsxText extends Node {\r\n        kind: SyntaxKind.JsxText;\r\n        containsOnlyWhiteSpaces: boolean;\r\n        parent?: JsxElement;\r\n    }\r\n\r\n    export type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement;\r\n\r\n    export interface Statement extends Node {\r\n        _statementBrand: any;\r\n    }\r\n\r\n    // Represents a statement that is elided as part of a transformation to emit comments on a\r\n    // not-emitted node.\r\n    export interface NotEmittedStatement extends Statement {\r\n        kind: SyntaxKind.NotEmittedStatement;\r\n    }\r\n\r\n    /**\r\n     * Marks the end of transformed declaration to properly emit exports.\r\n     */\r\n    /* @internal */\r\n    export interface EndOfDeclarationMarker extends Statement {\r\n        kind: SyntaxKind.EndOfDeclarationMarker;\r\n    }\r\n\r\n    /**\r\n     * A list of comma-seperated expressions. This node is only created by transformations.\r\n     */\r\n    export interface CommaListExpression extends Expression {\r\n        kind: SyntaxKind.CommaListExpression;\r\n        elements: NodeArray<Expression>;\r\n    }\r\n\r\n    /**\r\n     * Marks the beginning of a merged transformed declaration.\r\n     */\r\n    /* @internal */\r\n    export interface MergeDeclarationMarker extends Statement {\r\n        kind: SyntaxKind.MergeDeclarationMarker;\r\n    }\r\n\r\n    export interface EmptyStatement extends Statement {\r\n        kind: SyntaxKind.EmptyStatement;\r\n    }\r\n\r\n    export interface DebuggerStatement extends Statement {\r\n        kind: SyntaxKind.DebuggerStatement;\r\n    }\r\n\r\n    export interface MissingDeclaration extends DeclarationStatement, ClassElement, ObjectLiteralElement, TypeElement {\r\n        kind: SyntaxKind.MissingDeclaration;\r\n        name?: Identifier;\r\n    }\r\n\r\n    export type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;\r\n\r\n    export interface Block extends Statement {\r\n        kind: SyntaxKind.Block;\r\n        statements: NodeArray<Statement>;\r\n        /*@internal*/ multiLine?: boolean;\r\n    }\r\n\r\n    export interface VariableStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.VariableStatement;\r\n        declarationList: VariableDeclarationList;\r\n    }\r\n\r\n    export interface ExpressionStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.ExpressionStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface PrologueDirective extends ExpressionStatement {\r\n        expression: StringLiteral;\r\n    }\r\n\r\n    export interface IfStatement extends Statement {\r\n        kind: SyntaxKind.IfStatement;\r\n        expression: Expression;\r\n        thenStatement: Statement;\r\n        elseStatement?: Statement;\r\n    }\r\n\r\n    export interface IterationStatement extends Statement {\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface DoStatement extends IterationStatement {\r\n        kind: SyntaxKind.DoStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface WhileStatement extends IterationStatement {\r\n        kind: SyntaxKind.WhileStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export type ForInitializer = VariableDeclarationList | Expression;\r\n\r\n    export interface ForStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForStatement;\r\n        initializer?: ForInitializer;\r\n        condition?: Expression;\r\n        incrementor?: Expression;\r\n    }\r\n\r\n    export type ForInOrOfStatement = ForInStatement | ForOfStatement;\r\n\r\n    export interface ForInStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForInStatement;\r\n        initializer: ForInitializer;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ForOfStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForOfStatement;\r\n        awaitModifier?: AwaitKeywordToken;\r\n        initializer: ForInitializer;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface BreakStatement extends Statement {\r\n        kind: SyntaxKind.BreakStatement;\r\n        label?: Identifier;\r\n    }\r\n\r\n    export interface ContinueStatement extends Statement {\r\n        kind: SyntaxKind.ContinueStatement;\r\n        label?: Identifier;\r\n    }\r\n\r\n    export type BreakOrContinueStatement = BreakStatement | ContinueStatement;\r\n\r\n    export interface ReturnStatement extends Statement {\r\n        kind: SyntaxKind.ReturnStatement;\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface WithStatement extends Statement {\r\n        kind: SyntaxKind.WithStatement;\r\n        expression: Expression;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface SwitchStatement extends Statement {\r\n        kind: SyntaxKind.SwitchStatement;\r\n        expression: Expression;\r\n        caseBlock: CaseBlock;\r\n        possiblyExhaustive?: boolean;\r\n    }\r\n\r\n    export interface CaseBlock extends Node {\r\n        kind: SyntaxKind.CaseBlock;\r\n        parent?: SwitchStatement;\r\n        clauses: NodeArray<CaseOrDefaultClause>;\r\n    }\r\n\r\n    export interface CaseClause extends Node {\r\n        kind: SyntaxKind.CaseClause;\r\n        parent?: CaseBlock;\r\n        expression: Expression;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export interface DefaultClause extends Node {\r\n        kind: SyntaxKind.DefaultClause;\r\n        parent?: CaseBlock;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export type CaseOrDefaultClause = CaseClause | DefaultClause;\r\n\r\n    export interface LabeledStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.LabeledStatement;\r\n        label: Identifier;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface ThrowStatement extends Statement {\r\n        kind: SyntaxKind.ThrowStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface TryStatement extends Statement {\r\n        kind: SyntaxKind.TryStatement;\r\n        tryBlock: Block;\r\n        catchClause?: CatchClause;\r\n        finallyBlock?: Block;\r\n    }\r\n\r\n    export interface CatchClause extends Node {\r\n        kind: SyntaxKind.CatchClause;\r\n        parent?: TryStatement;\r\n        variableDeclaration?: VariableDeclaration;\r\n        block: Block;\r\n    }\r\n\r\n    export type DeclarationWithTypeParameters = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;\r\n\r\n    export interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;\r\n        name?: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        heritageClauses?: NodeArray<HeritageClause>;\r\n        members: NodeArray<ClassElement>;\r\n    }\r\n\r\n    export interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {\r\n        kind: SyntaxKind.ClassDeclaration;\r\n        name?: Identifier;\r\n    }\r\n\r\n    export interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {\r\n        kind: SyntaxKind.ClassExpression;\r\n    }\r\n\r\n    export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;\r\n\r\n    export interface ClassElement extends NamedDeclaration {\r\n        _classElementBrand: any;\r\n        name?: PropertyName;\r\n    }\r\n\r\n    export interface TypeElement extends NamedDeclaration {\r\n        _typeElementBrand: any;\r\n        name?: PropertyName;\r\n        questionToken?: QuestionToken;\r\n    }\r\n\r\n    export interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.InterfaceDeclaration;\r\n        name: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        heritageClauses?: NodeArray<HeritageClause>;\r\n        members: NodeArray<TypeElement>;\r\n    }\r\n\r\n    export interface HeritageClause extends Node {\r\n        kind: SyntaxKind.HeritageClause;\r\n        parent?: InterfaceDeclaration | ClassDeclaration | ClassExpression;\r\n        token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\r\n        types: NodeArray<ExpressionWithTypeArguments>;\r\n    }\r\n\r\n    export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.TypeAliasDeclaration;\r\n        name: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface EnumMember extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.EnumMember;\r\n        parent?: EnumDeclaration;\r\n        // This does include ComputedPropertyName, but the parser will give an error\r\n        // if it parses a ComputedPropertyName in an EnumMember\r\n        name: PropertyName;\r\n        initializer?: Expression;\r\n    }\r\n\r\n    export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.EnumDeclaration;\r\n        name: Identifier;\r\n        members: NodeArray<EnumMember>;\r\n    }\r\n\r\n    export type ModuleName = Identifier | StringLiteral;\r\n\r\n    export type ModuleBody = NamespaceBody | JSDocNamespaceBody;\r\n\r\n    export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.ModuleDeclaration;\r\n        parent?: ModuleBody | SourceFile;\r\n        name: ModuleName;\r\n        body?: ModuleBody | JSDocNamespaceDeclaration;\r\n    }\r\n\r\n    export type NamespaceBody = ModuleBlock | NamespaceDeclaration;\r\n\r\n    export interface NamespaceDeclaration extends ModuleDeclaration {\r\n        name: Identifier;\r\n        body: NamespaceBody;\r\n    }\r\n\r\n    export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;\r\n\r\n    export interface JSDocNamespaceDeclaration extends ModuleDeclaration {\r\n        name: Identifier;\r\n        body: JSDocNamespaceBody;\r\n    }\r\n\r\n    export interface ModuleBlock extends Node, Statement {\r\n        kind: SyntaxKind.ModuleBlock;\r\n        parent?: ModuleDeclaration;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export type ModuleReference = EntityName | ExternalModuleReference;\r\n\r\n    /**\r\n     * One of:\r\n     * - import x = require(\"mod\");\r\n     * - import x = M.x;\r\n     */\r\n    export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.ImportEqualsDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        name: Identifier;\r\n\r\n        // 'EntityName' for an internal module reference, 'ExternalModuleReference' for an external\r\n        // module reference.\r\n        moduleReference: ModuleReference;\r\n    }\r\n\r\n    export interface ExternalModuleReference extends Node {\r\n        kind: SyntaxKind.ExternalModuleReference;\r\n        parent?: ImportEqualsDeclaration;\r\n        expression?: Expression;\r\n    }\r\n\r\n    // In case of:\r\n    // import \"mod\"  => importClause = undefined, moduleSpecifier = \"mod\"\r\n    // In rest of the cases, module specifier is string literal corresponding to module\r\n    // ImportClause information is shown at its declaration below.\r\n    export interface ImportDeclaration extends Statement {\r\n        kind: SyntaxKind.ImportDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        importClause?: ImportClause;\r\n        /** If this is not a StringLiteral it will be a grammar error. */\r\n        moduleSpecifier: Expression;\r\n    }\r\n\r\n    export type NamedImportBindings = NamespaceImport | NamedImports;\r\n\r\n    // In case of:\r\n    // import d from \"mod\" => name = d, namedBinding = undefined\r\n    // import * as ns from \"mod\" => name = undefined, namedBinding: NamespaceImport = { name: ns }\r\n    // import d, * as ns from \"mod\" => name = d, namedBinding: NamespaceImport = { name: ns }\r\n    // import { a, b as x } from \"mod\" => name = undefined, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\r\n    // import d, { a, b as x } from \"mod\" => name = d, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\r\n    export interface ImportClause extends NamedDeclaration {\r\n        kind: SyntaxKind.ImportClause;\r\n        parent?: ImportDeclaration;\r\n        name?: Identifier; // Default binding\r\n        namedBindings?: NamedImportBindings;\r\n    }\r\n\r\n    export interface NamespaceImport extends NamedDeclaration {\r\n        kind: SyntaxKind.NamespaceImport;\r\n        parent?: ImportClause;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface NamespaceExportDeclaration extends DeclarationStatement {\r\n        kind: SyntaxKind.NamespaceExportDeclaration;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface ExportDeclaration extends DeclarationStatement {\r\n        kind: SyntaxKind.ExportDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        exportClause?: NamedExports;\r\n        /** If this is not a StringLiteral it will be a grammar error. */\r\n        moduleSpecifier?: Expression;\r\n    }\r\n\r\n    export interface NamedImports extends Node {\r\n        kind: SyntaxKind.NamedImports;\r\n        parent?: ImportClause;\r\n        elements: NodeArray<ImportSpecifier>;\r\n    }\r\n\r\n    export interface NamedExports extends Node {\r\n        kind: SyntaxKind.NamedExports;\r\n        parent?: ExportDeclaration;\r\n        elements: NodeArray<ExportSpecifier>;\r\n    }\r\n\r\n    export type NamedImportsOrExports = NamedImports | NamedExports;\r\n\r\n    export interface ImportSpecifier extends NamedDeclaration {\r\n        kind: SyntaxKind.ImportSpecifier;\r\n        parent?: NamedImports;\r\n        propertyName?: Identifier;  // Name preceding \"as\" keyword (or undefined when \"as\" is absent)\r\n        name: Identifier;           // Declared name\r\n    }\r\n\r\n    export interface ExportSpecifier extends NamedDeclaration {\r\n        kind: SyntaxKind.ExportSpecifier;\r\n        parent?: NamedExports;\r\n        propertyName?: Identifier;  // Name preceding \"as\" keyword (or undefined when \"as\" is absent)\r\n        name: Identifier;           // Declared name\r\n    }\r\n\r\n    export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;\r\n\r\n    export interface ExportAssignment extends DeclarationStatement {\r\n        kind: SyntaxKind.ExportAssignment;\r\n        parent?: SourceFile;\r\n        isExportEquals?: boolean;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface FileReference extends TextRange {\r\n        fileName: string;\r\n    }\r\n\r\n    export interface CheckJsDirective extends TextRange {\r\n        enabled: boolean;\r\n    }\r\n\r\n    export type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;\r\n\r\n    export interface CommentRange extends TextRange {\r\n        hasTrailingNewLine?: boolean;\r\n        kind: CommentKind;\r\n    }\r\n\r\n    export interface SynthesizedComment extends CommentRange {\r\n        text: string;\r\n        pos: -1;\r\n        end: -1;\r\n    }\r\n\r\n    // represents a top level: { type } expression in a JSDoc comment.\r\n    export interface JSDocTypeExpression extends TypeNode {\r\n        kind: SyntaxKind.JSDocTypeExpression;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocType extends TypeNode {\r\n        _jsDocTypeBrand: any;\r\n    }\r\n\r\n    export interface JSDocAllType extends JSDocType {\r\n        kind: SyntaxKind.JSDocAllType;\r\n    }\r\n\r\n    export interface JSDocUnknownType extends JSDocType {\r\n        kind: SyntaxKind.JSDocUnknownType;\r\n    }\r\n\r\n    export interface JSDocNonNullableType extends JSDocType {\r\n        kind: SyntaxKind.JSDocNonNullableType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocNullableType extends JSDocType {\r\n        kind: SyntaxKind.JSDocNullableType;\r\n        type: TypeNode;\r\n    }\r\n    export interface JSDocOptionalType extends JSDocType {\r\n        kind: SyntaxKind.JSDocOptionalType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase {\r\n        kind: SyntaxKind.JSDocFunctionType;\r\n    }\r\n\r\n    export interface JSDocVariadicType extends JSDocType {\r\n        kind: SyntaxKind.JSDocVariadicType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;\r\n\r\n    export interface JSDoc extends Node {\r\n        kind: SyntaxKind.JSDocComment;\r\n        parent?: HasJSDoc;\r\n        tags: NodeArray<JSDocTag> | undefined;\r\n        comment: string | undefined;\r\n    }\r\n\r\n    export interface JSDocTag extends Node {\r\n        parent: JSDoc;\r\n        atToken: AtToken;\r\n        tagName: Identifier;\r\n        comment: string | undefined;\r\n    }\r\n\r\n    export interface JSDocUnknownTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTag;\r\n    }\r\n\r\n    /**\r\n     * Note that `@extends` is a synonym of `@augments`.\r\n     * Both tags are represented by this interface.\r\n     */\r\n    export interface JSDocAugmentsTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocAugmentsTag;\r\n        class: ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression };\r\n    }\r\n\r\n    export interface JSDocClassTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocClassTag;\r\n    }\r\n\r\n    export interface JSDocTemplateTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTemplateTag;\r\n        typeParameters: NodeArray<TypeParameterDeclaration>;\r\n    }\r\n\r\n    export interface JSDocReturnTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocReturnTag;\r\n        typeExpression: JSDocTypeExpression;\r\n    }\r\n\r\n    export interface JSDocTypeTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTypeTag;\r\n        typeExpression: JSDocTypeExpression;\r\n    }\r\n\r\n    export interface JSDocTypedefTag extends JSDocTag, NamedDeclaration {\r\n        parent: JSDoc;\r\n        kind: SyntaxKind.JSDocTypedefTag;\r\n        fullName?: JSDocNamespaceDeclaration | Identifier;\r\n        name?: Identifier;\r\n        typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;\r\n    }\r\n\r\n    export interface JSDocPropertyLikeTag extends JSDocTag, Declaration {\r\n        parent: JSDoc;\r\n        name: EntityName;\r\n        typeExpression?: JSDocTypeExpression;\r\n        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */\r\n        isNameFirst: boolean;\r\n        isBracketed: boolean;\r\n    }\r\n\r\n    export interface JSDocPropertyTag extends JSDocPropertyLikeTag {\r\n        kind: SyntaxKind.JSDocPropertyTag;\r\n    }\r\n\r\n    export interface JSDocParameterTag extends JSDocPropertyLikeTag {\r\n        kind: SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export interface JSDocTypeLiteral extends JSDocType {\r\n        kind: SyntaxKind.JSDocTypeLiteral;\r\n        jsDocPropertyTags?: ReadonlyArray<JSDocPropertyLikeTag>;\r\n        /** If true, then this type literal represents an *array* of its type. */\r\n        isArrayType?: boolean;\r\n    }\r\n\r\n    export const enum FlowFlags {\r\n        Unreachable = 1 << 0,  // Unreachable code //执行不到的代码\r\n        Start = 1 << 1,  // Start of flow graph //流图开始\r\n        BranchLabel = 1 << 2,  // Non-looping junction // 分支标签\r\n        LoopLabel = 1 << 3,  // Looping junction // 循环标签\r\n        Assignment = 1 << 4,  // Assignment // 赋值\r\n        TrueCondition = 1 << 5,  // Condition known to be true 真条件\r\n        FalseCondition = 1 << 6,  // Condition known to be false 假条件\r\n        SwitchClause = 1 << 7,  // Switch statement clause  假如分支\r\n        ArrayMutation = 1 << 8,  // Potential array mutation  潜在的阵列突变\r\n        Referenced = 1 << 9,  // Referenced as antecedent once 先行引用一次\r\n        Shared = 1 << 10, // Referenced as antecedent more than once 作为先行引用不止一次\r\n        PreFinally = 1 << 11, // Injected edge that links pre-finally label and pre-try flow 注入边缘链接前最后标签和预试流\r\n        AfterFinally = 1 << 12, // Injected edge that links post-finally flow with the rest of the graph 注入的边缘，连接最后与图的其余部分流动。\r\n        Label = BranchLabel | LoopLabel,\r\n        Condition = TrueCondition | FalseCondition\r\n    }\r\n\r\n    export interface FlowLock {\r\n        locked?: boolean;\r\n    }\r\n\r\n    export interface AfterFinallyFlow extends FlowNodeBase, FlowLock {\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export interface PreFinallyFlow extends FlowNodeBase {\r\n        antecedent: FlowNode;\r\n        lock: FlowLock;\r\n    }\r\n\r\n    export type FlowNode =\r\n        | AfterFinallyFlow | PreFinallyFlow | FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation;\r\n    export interface FlowNodeBase {\r\n        flags: FlowFlags;\r\n        id?: number;     // Node id used by flow type cache in checker\r\n    }\r\n\r\n    // FlowStart represents the start of a control flow. For a function expression or arrow\r\n    // function, the container property references the function (which in turn has a flowNode\r\n    // property for the containing control flow).\r\n    export interface FlowStart extends FlowNodeBase {\r\n        container?: FunctionExpression | ArrowFunction | MethodDeclaration;\r\n    }\r\n\r\n    // FlowLabel represents a junction with multiple possible preceding control flows.\r\n    export interface FlowLabel extends FlowNodeBase {\r\n        antecedents: FlowNode[];\r\n    }\r\n\r\n    // FlowAssignment represents a node that assigns a value to a narrowable reference,\r\n    // i.e. an identifier or a dotted name that starts with an identifier or 'this'.\r\n    export interface FlowAssignment extends FlowNodeBase {\r\n        node: Expression | VariableDeclaration | BindingElement;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    // FlowCondition represents a condition that is known to be true or false at the\r\n    // node's location in the control flow.\r\n    export interface FlowCondition extends FlowNodeBase {\r\n        expression: Expression;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export interface FlowSwitchClause extends FlowNodeBase {\r\n        switchStatement: SwitchStatement;\r\n        clauseStart: number;   // Start index of case/default clause range\r\n        clauseEnd: number;     // End index of case/default clause range\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    // FlowArrayMutation represents a node potentially mutates an array, i.e. an\r\n    // operation of the form 'x.push(value)', 'x.unshift(value)' or 'x[n] = value'.\r\n    export interface FlowArrayMutation extends FlowNodeBase {\r\n        node: CallExpression | BinaryExpression;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export type FlowType = Type | IncompleteType;\r\n\r\n    // Incomplete types occur during control flow analysis of loops. An IncompleteType\r\n    // is distinguished from a regular type by a flags value of zero. Incomplete type\r\n    // objects are internal to the getFlowTypeOfRefecence function and never escape it.\r\n    export interface IncompleteType {\r\n        flags: TypeFlags;  // No flags set\r\n        type: Type;        // The type marked incomplete\r\n    }\r\n\r\n    export interface AmdDependency {\r\n        path: string;\r\n        name: string;\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * Subset of properties from SourceFile that are used in multiple utility functions\r\n     */\r\n    export interface SourceFileLike {\r\n        readonly text: string;\r\n        lineMap: ReadonlyArray<number>;\r\n    }\r\n\r\n\r\n    /* @internal */\r\n    export interface RedirectInfo {\r\n        /** Source file this redirects to. */\r\n        readonly redirectTarget: SourceFile;\r\n        /**\r\n         * Source file for the duplicate package. This will not be used by the Program,\r\n         * but we need to keep this around so we can watch for changes in underlying.\r\n         */\r\n        readonly unredirected: SourceFile;\r\n    }\r\n\r\n    // Source files are declarations when they are external modules.\r\n    export interface SourceFile extends Declaration {\r\n        kind: SyntaxKind.SourceFile;\r\n        statements: NodeArray<Statement>;\r\n        endOfFileToken: Token<SyntaxKind.EndOfFileToken>;\r\n\r\n        fileName: string;\r\n        /* @internal */ path: Path;\r\n        text: string;\r\n        词典语句?: Map<全局词典语句>;\r\n        全局词典?:Map<词典>\r\n\r\n        /**\r\n         * If two source files are for the same version of the same package, one will redirect to the other.\r\n         * (See `createRedirectSourceFile` in program.ts.)\r\n         * The redirect will have this set. The other will not have anything set, but see Program#sourceFileIsRedirectedTo.\r\n         */\r\n        /* @internal */ redirectInfo?: RedirectInfo | undefined;\r\n\r\n        amdDependencies: ReadonlyArray<AmdDependency>;\r\n        moduleName: string;\r\n        referencedFiles: ReadonlyArray<FileReference>;\r\n        typeReferenceDirectives: ReadonlyArray<FileReference>;\r\n        languageVariant: LanguageVariant;\r\n        isDeclarationFile: boolean;\r\n\r\n        // this map is used by transpiler to supply alternative names for dependencies (i.e. in case of bundling)\r\n        /* @internal */\r\n        renamedDependencies?: ReadonlyMap<string>;\r\n\r\n        /**\r\n         * lib.d.ts should have a reference comment like\r\n         *\r\n         *  /// <reference no-default-lib=\"true\"/>\r\n         *\r\n         * If any other file has this comment, it signals not to include lib.d.ts\r\n         * because this containing file is intended to act as a default library.\r\n         */\r\n        hasNoDefaultLib: boolean;\r\n\r\n        languageVersion: ScriptTarget;\r\n        /* @internal */ scriptKind: ScriptKind;\r\n\r\n        // The first node that causes this file to be an external module\r\n        /* @internal */ externalModuleIndicator: Node;\r\n        // The first node that causes this file to be a CommonJS module\r\n        /* @internal */ commonJsModuleIndicator: Node;\r\n\r\n        /* @internal */ identifiers: Map<string>; // Map from a string to an interned string\r\n        /* @internal */ nodeCount: number;\r\n        /* @internal */ identifierCount: number;\r\n        /* @internal */ symbolCount: number;\r\n\r\n        // File-level diagnostics reported by the parser (includes diagnostics about /// references\r\n        // as well as code diagnostics).\r\n        /* @internal */ parseDiagnostics: Diagnostic[];\r\n\r\n        // File-level diagnostics reported by the binder.\r\n        /* @internal */ bindDiagnostics: Diagnostic[];\r\n\r\n        // File-level JSDoc diagnostics reported by the JSDoc parser\r\n        /* @internal */ jsDocDiagnostics?: Diagnostic[];\r\n\r\n        // Stores additional file-level diagnostics reported by the program\r\n        /* @internal */ additionalSyntacticDiagnostics?: ReadonlyArray<Diagnostic>;\r\n\r\n        // Stores a line map for the file.\r\n        // This field should never be used directly to obtain line map, use getLineMap function instead.\r\n        /* @internal */ lineMap: ReadonlyArray<number>;\r\n        /* @internal */ classifiableNames?: ReadonlyUnderscoreEscapedMap<true>;\r\n        // Stores a mapping 'external module reference text' -> 'resolved file name' | undefined\r\n        // It is used to resolve module names in the checker.\r\n        // Content of this field should never be used directly - use getResolvedModuleFileName/setResolvedModuleFileName functions instead\r\n        /* @internal */ resolvedModules: Map<ResolvedModuleFull>;\r\n        /* @internal */ resolvedTypeReferenceDirectiveNames: Map<ResolvedTypeReferenceDirective>;\r\n        /* @internal */ imports: ReadonlyArray<StringLiteral>;\r\n        // Identifier only if `declare global`\r\n        /* @internal */ moduleAugmentations: ReadonlyArray<StringLiteral | Identifier>;\r\n        /* @internal */ patternAmbientModules?: PatternAmbientModule[];\r\n        /* @internal */ ambientModuleNames: ReadonlyArray<string>;\r\n        /* @internal */ checkJsDirective: CheckJsDirective | undefined;\r\n        /* @internal */ version: string;\r\n    }\r\n\r\n    export interface Bundle extends Node {\r\n        kind: SyntaxKind.Bundle;\r\n        sourceFiles: ReadonlyArray<SourceFile>;\r\n    }\r\n\r\n    export interface JsonSourceFile extends SourceFile {\r\n        jsonObject?: ObjectLiteralExpression;\r\n        extendedSourceFiles?: string[];\r\n    }\r\n\r\n    export interface ScriptReferenceHost {\r\n        getCompilerOptions(): CompilerOptions;\r\n        getSourceFile(fileName: string): SourceFile;\r\n        getSourceFileByPath(path: Path): SourceFile;\r\n        getCurrentDirectory(): string;\r\n    }\r\n\r\n    export interface ParseConfigHost {\r\n        useCaseSensitiveFileNames: boolean;\r\n\r\n        readDirectory(rootDir: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, depth: number): string[];\r\n\r\n        /**\r\n         * Gets a value indicating whether the specified path exists and is a file.\r\n         * @param path The path to test.\r\n         */\r\n        fileExists(path: string): boolean;\r\n\r\n        readFile(path: string): string | undefined;\r\n    }\r\n\r\n    export interface WriteFileCallback {\r\n        (fileName: string, data: string, writeByteOrderMark: boolean, onError: ((message: string) => void) | undefined, sourceFiles: ReadonlyArray<SourceFile>): void;\r\n    }\r\n\r\n    export class OperationCanceledException { }\r\n\r\n    export interface CancellationToken {\r\n        isCancellationRequested(): boolean;\r\n\r\n        /** @throws OperationCanceledException if isCancellationRequested is true */\r\n        throwIfCancellationRequested(): void;\r\n    }\r\n\r\n    export interface Program extends ScriptReferenceHost {\r\n\r\n        /**\r\n         * Get a list of root file names that were passed to a 'createProgram'\r\n         */\r\n        getRootFileNames(): ReadonlyArray<string>;\r\n\r\n        /**\r\n         * Get a list of files in the program\r\n         */\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n\r\n        /**\r\n         * Get a list of file names that were passed to 'createProgram' or referenced in a\r\n         * program source file but could not be located.\r\n         */\r\n        /* @internal */\r\n        getMissingFilePaths(): ReadonlyArray<Path>;\r\n\r\n        /**\r\n         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then\r\n         * the JavaScript and declaration files will be produced for all the files in this program.\r\n         * If targetSourceFile is specified, then only the JavaScript and declaration for that\r\n         * specific file will be generated.\r\n         *\r\n         * If writeFile is not specified then the writeFile callback from the compiler host will be\r\n         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter\r\n         * will be invoked when writing the JavaScript and declaration files.\r\n         */\r\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\r\n\r\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n\r\n        /**\r\n         * Gets a type checker that can be used to semantically analyze source files in the program.\r\n         */\r\n        getTypeChecker(): TypeChecker;\r\n\r\n        /* @internal */ getCommonSourceDirectory(): string;\r\n\r\n        // For testing purposes only.  Should not be used by any other consumers (including the\r\n        // language service).\r\n        /* @internal */ getDiagnosticsProducingTypeChecker(): TypeChecker;\r\n        /* @internal */ dropDiagnosticsProducingTypeChecker(): void;\r\n\r\n        /* @internal */ getClassifiableNames(): UnderscoreEscapedMap<true>;\r\n\r\n        /* @internal */ getNodeCount(): number;\r\n        /* @internal */ getIdentifierCount(): number;\r\n        /* @internal */ getSymbolCount(): number;\r\n        /* @internal */ getTypeCount(): number;\r\n\r\n        /* @internal */ getFileProcessingDiagnostics(): DiagnosticCollection;\r\n        /* @internal */ getResolvedTypeReferenceDirectives(): Map<ResolvedTypeReferenceDirective>;\r\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\r\n        /* @internal */ isSourceFileDefaultLibrary(file: SourceFile): boolean;\r\n\r\n        // For testing purposes only.\r\n        /* @internal */ structureIsReused?: StructureIsReused;\r\n\r\n        /* @internal */ getSourceFileFromReference(referencingFile: SourceFile, ref: FileReference): SourceFile | undefined;\r\n\r\n        /** Given a source file, get the name of the package it was imported from. */\r\n        /* @internal */ sourceFileToPackageName: Map<string>;\r\n        /** Set of all source files that some other source file redirects to. */\r\n        /* @internal */ redirectTargetsSet: Map<true>;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum StructureIsReused {\r\n        Not = 0,\r\n        SafeModules = 1 << 0,\r\n        Completely = 1 << 1,\r\n    }\r\n\r\n    export interface CustomTransformers {\r\n        /** Custom transformers to evaluate before built-in transformations. */\r\n        before?: TransformerFactory<SourceFile>[];\r\n        /** Custom transformers to evaluate after built-in transformations. */\r\n        after?: TransformerFactory<SourceFile>[];\r\n    }\r\n\r\n    export interface SourceMapSpan {\r\n        /** Line number in the .js file. */\r\n        emittedLine: number;\r\n        /** Column number in the .js file. */\r\n        emittedColumn: number;\r\n        /** Line number in the .ts file. */\r\n        sourceLine: number;\r\n        /** Column number in the .ts file. */\r\n        sourceColumn: number;\r\n        /** Optional name (index into names array) associated with this span. */\r\n        nameIndex?: number;\r\n        /** .ts file (index into sources array) associated with this span */\r\n        sourceIndex: number;\r\n    }\r\n\r\n    export interface SourceMapData {\r\n        sourceMapFilePath: string;           // Where the sourcemap file is written\r\n        jsSourceMappingURL: string;          // source map URL written in the .js file\r\n        sourceMapFile: string;               // Source map's file field - .js file name\r\n        sourceMapSourceRoot: string;         // Source map's sourceRoot field - location where the sources will be present if not \"\"\r\n        sourceMapSources: string[];          // Source map's sources field - list of sources that can be indexed in this source map\r\n        sourceMapSourcesContent?: string[];  // Source map's sourcesContent field - list of the sources' text to be embedded in the source map\r\n        inputSourceFileNames: string[];      // Input source file (which one can use on program to get the file), 1:1 mapping with the sourceMapSources list\r\n        sourceMapNames?: string[];           // Source map's names field - list of names that can be indexed in this source map\r\n        sourceMapMappings: string;           // Source map's mapping field - encoded source map spans\r\n        sourceMapDecodedMappings: SourceMapSpan[];  // Raw source map spans that were encoded into the sourceMapMappings\r\n    }\r\n\r\n    /** Return code used by getEmitOutput function to indicate status of the function */\r\n    export enum ExitStatus {\r\n        // Compiler ran successfully.  Either this was a simple do-nothing compilation (for example,\r\n        // when -version or -help was provided, or this was a normal compilation, no diagnostics\r\n        // were produced, and all outputs were generated successfully.\r\n        Success = 0,\r\n\r\n        // Diagnostics were produced and because of them no code was generated.\r\n        DiagnosticsPresent_OutputsSkipped = 1,\r\n\r\n        // Diagnostics were produced and outputs were generated in spite of them.\r\n        DiagnosticsPresent_OutputsGenerated = 2,\r\n    }\r\n\r\n    export interface EmitResult {\r\n        emitSkipped: boolean;\r\n        /** Contains declaration emit diagnostics */\r\n        diagnostics: ReadonlyArray<Diagnostic>;\r\n        emittedFiles: string[]; // Array of files the compiler wrote to disk\r\n        /* @internal */ sourceMaps: SourceMapData[];  // Array of sourceMapData if compiler emitted sourcemaps\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TypeCheckerHost {\r\n        getCompilerOptions(): CompilerOptions;\r\n\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n        getSourceFile(fileName: string): SourceFile;\r\n        getResolvedTypeReferenceDirectives(): ReadonlyMap<ResolvedTypeReferenceDirective>;\r\n    }\r\n\r\n    export interface TypeChecker {\r\n        /** 取类型按符号位置 */\r\n        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\r\n        /** 取声明类型从符号 */\r\n        getDeclaredTypeOfSymbol(symbol: Symbol): Type;\r\n        /** 取类型的属性集 */\r\n        getPropertiesOfType(type: Type): Symbol[];\r\n        /** 取类型的属性 */\r\n        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;\r\n        /** 取类型的索引信息 */\r\n        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;\r\n        /** 取类型的签名 */\r\n        getSignaturesOfType(type: Type, kind: SignatureKind): Signature[];\r\n        /** 取类型的索引类型 */\r\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;\r\n        /** 取基类型 */\r\n        getBaseTypes(type: InterfaceType): BaseType[];\r\n        /** 取字面量类型的基类型 */\r\n        getBaseTypeOfLiteralType(type: Type): Type;\r\n        /** 取加宽类型 */\r\n        getWidenedType(type: Type): Type;\r\n        /** 取签名的返回类型 */\r\n        getReturnTypeOfSignature(signature: Signature): Type;\r\n        /**\r\n         * Gets the type of a parameter at a given position in a signature.\r\n         * Returns `any` if the index is not valid.\r\n         */             /** 取参数类型 */\r\n        /* @internal */ getParameterType(signature: Signature, parameterIndex: number): Type;\r\n        getNullableType(type: Type, flags: TypeFlags): Type;\r\n        /** 取非可空类型 */\r\n        getNonNullableType(type: Type): Type;\r\n\r\n        /** 请注意，导致节点不能被检查。 */\r\n        /** 类型转为类型节点 */\r\n        typeToTypeNode(type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): TypeNode;\r\n        /** 请注意，导致节点不能被检查。 */\r\n        /** 签名转为签名声明 */\r\n        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): SignatureDeclaration;\r\n        /** 请注意，导致节点不能被检查。 */\r\n        /** 索引信息转为索引签名声明 */\r\n        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, kind: IndexKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): IndexSignatureDeclaration;\r\n        /** 取范围内的符号 */\r\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\r\n        /** 取符号按位置 */\r\n        getSymbolAtLocation(node: Node): Symbol | undefined;\r\n        /** 取参数属性声明的符号 */\r\n        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];\r\n        /** 取速记值赋值符号 */\r\n        getShorthandAssignmentValueSymbol(location: Node): Symbol | undefined;\r\n        /** 取出口说明符局部目标符号 */\r\n        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier): Symbol | undefined;\r\n        /**\r\n         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.\r\n         * Otherwise returns its input.\r\n         * For example, at `export type T = number;`:\r\n         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.\r\n         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.\r\n         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.\r\n         */\r\n        getExportSymbolOfSymbol(symbol: Symbol): Symbol;\r\n        /** 取解构分配财产的特征 */\r\n        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;\r\n        /** 取位置按位置 */\r\n        getTypeAtLocation(node: Node): Type;\r\n        /** 取类型从类型节点 */\r\n        getTypeFromTypeNode(node: TypeNode): Type;\r\n        /** 签名转为文字 */\r\n        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;\r\n        /** 类型转为文字 */\r\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\r\n        /** 符号转为文字 */\r\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): string;\r\n        /**\r\n         * @deprecated Use the createX factory functions or XToY typechecker methods and `createPrinter` or the `xToString` methods instead\r\n         * This will be removed in a future version.\r\n         */\r\n        /** 取符号显示构建 */\r\n        getSymbolDisplayBuilder(): SymbolDisplayBuilder;\r\n        /** 取完全限定名 */\r\n        getFullyQualifiedName(symbol: Symbol): string;\r\n        /** 取类型的增强属性类型 */\r\n        getAugmentedPropertiesOfType(type: Type): Symbol[];\r\n        /** 取根符号集 */\r\n        getRootSymbols(symbol: Symbol): Symbol[];\r\n        /** 取语境类型 */\r\n        getContextualType(node: Expression): Type | undefined;\r\n        /**\r\n         * returns unknownSignature in the case of an error. Don't know when it returns undefined.\r\n         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.\r\n         */\r\n        /** 取解决的签名 */\r\n        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;\r\n        /** 取签名从声明 */\r\n        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;\r\n        /** 是重载的实现 */\r\n        isImplementationOfOverload(node: FunctionLike): boolean | undefined;\r\n        /** 是未定义符号 */\r\n        isUndefinedSymbol(symbol: Symbol): boolean;\r\n        /** 是增强参数符号 */\r\n        isArgumentsSymbol(symbol: Symbol): boolean;\r\n        /** 是未知符号 */\r\n        isUnknownSymbol(symbol: Symbol): boolean;\r\n        /** 取合并符号 */\r\n        /* @internal */ getMergedSymbol(symbol: Symbol): Symbol;\r\n        /** 取常量值 */\r\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\r\n        /** 是有效的属性访问 */\r\n        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName, propertyName: string): boolean;\r\n        /** Follow all aliases to get the original symbol. */\r\n        /** 取别名符号 */\r\n        getAliasedSymbol(symbol: Symbol): Symbol;\r\n        /** Follow a *single* alias to get the immediately aliased symbol. */\r\n        /** 取直接的别名符号 */\r\n        /* @internal */ getImmediateAliasedSymbol(symbol: Symbol): Symbol;\r\n        /** 取模块的出口 */\r\n        getExportsOfModule(moduleSymbol: Symbol): Symbol[];\r\n        /** Unlike `getExportsOfModule`, this includes properties of an `export =` value. */\r\n        /** 取模块的出口集属性 */\r\n        /* @internal */ getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];\r\n        /** 取所有的属性类型从JSX开放像元素 */\r\n        getAllAttributesTypeFromJsxOpeningLikeElement(elementNode: JsxOpeningLikeElement): Type | undefined;\r\n        /** 取JSX内在标签名称 */\r\n        getJsxIntrinsicTagNames(): Symbol[];\r\n        /** 是可选参数 */\r\n        isOptionalParameter(node: ParameterDeclaration): boolean;\r\n        /** 取AMB模块集 */\r\n        getAmbientModules(): Symbol[];\r\n        /** 尝试取模块出口的成员 */\r\n\r\n        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\r\n        /** Unlike `tryGetMemberInModuleExports`, this includes properties of an `export =` value. */\r\n        /* @internal */ tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\r\n        /** 取明显类型 */\r\n        getApparentType(type: Type): Type;\r\n        /** 取不存在的属性建议 */\r\n        getSuggestionForNonexistentProperty(node: Identifier, containingType: Type): string | undefined;\r\n        /** 取不存在的符号建议 */\r\n        getSuggestionForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): string | undefined;\r\n        /** 获取类型的基约束 */\r\n        /* @internal */ getBaseConstraintOfType(type: Type): Type | undefined;\r\n        /** 尝试找到环境模块没有增强参数 */\r\n\r\n        /* @internal */ getAnyType(): Type;\r\n        /* @internal */ getStringType(): Type;\r\n        /* @internal */ getNumberType(): Type;\r\n        /* @internal */ getBooleanType(): Type;\r\n        /* @internal */ getVoidType(): Type;\r\n        /* @internal */ getUndefinedType(): Type;\r\n        /* @internal */ getNullType(): Type;\r\n        /* @internal */ getESSymbolType(): Type;\r\n        /* @internal */ getNeverType(): Type;\r\n        /* @internal */ getUnionType(types: Type[], subtypeReduction?: boolean): Type;\r\n        /* @internal */ createArrayType(elementType: Type): Type;\r\n        /* @internal */ createPromiseType(type: Type): Type;\r\n\r\n        /* @internal */ createAnonymousType(symbol: Symbol, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], stringIndexInfo: IndexInfo, numberIndexInfo: IndexInfo): Type;\r\n        /* @internal */ createSignature(declaration: SignatureDeclaration, typeParameters: TypeParameter[], thisParameter: Symbol | undefined, parameters: Symbol[], resolvedReturnType: Type, typePredicate: TypePredicate, minArgumentCount: number, hasRestParameter: boolean, hasLiteralTypes: boolean): Signature;\r\n        /* @internal */ createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;\r\n        /* @internal */ createIndexInfo(type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;\r\n        /* @internal */ isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;\r\n        /* @internal */ tryFindAmbientModuleWithoutAugmentations(moduleName: string): Symbol | undefined;\r\n\r\n        /* @internal */ getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;\r\n\r\n        // Should not be called directly.  Should only be accessed through the Program instance.\r\n        /* @internal */ getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[];\r\n        /* @internal */ getGlobalDiagnostics(): Diagnostic[];\r\n        /* @internal */ getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken): EmitResolver;\r\n\r\n        /* @internal */ getNodeCount(): number;\r\n        /* @internal */ getIdentifierCount(): number;\r\n        /* @internal */ getSymbolCount(): number;\r\n        /* @internal */ getTypeCount(): number;\r\n\r\n        /**\r\n         * For a union, will include a property if it's defined in *any* of the member types.\r\n         * So for `{ a } | { b }`, this will include both `a` and `b`.\r\n         * Does not include properties of primitive types.\r\n         */\r\n        /* @internal */ isArrayLikeType(type: Type): boolean;\r\n        /* @internal */ getAllPossiblePropertiesOfTypes(type: ReadonlyArray<Type>): Symbol[];\r\n        /* @internal */ resolveName(name: string, location: Node, meaning: SymbolFlags): Symbol | undefined;\r\n        /* @internal */ getJsxNamespace(): string;\r\n    }\r\n\r\n    export enum NodeBuilderFlags {\r\n        None = 0,\r\n        // Options\r\n        NoTruncation = 1 << 0,   // Don't truncate result\r\n        WriteArrayAsGenericType = 1 << 1,   // Write Array<T> instead T[]\r\n        WriteTypeArgumentsOfSignature = 1 << 5,   // Write the type arguments instead of type parameters of the signature\r\n        UseFullyQualifiedType = 1 << 6,   // Write out the fully qualified type name (eg. Module.Type, instead of Type)\r\n        SuppressAnyReturnType = 1 << 8,   // If the return type is any-like, don't offer a return type.\r\n        WriteTypeParametersInQualifiedName = 1 << 9,\r\n\r\n        // Error handling\r\n        AllowThisInObjectLiteral = 1 << 10,\r\n        AllowQualifedNameInPlaceOfIdentifier = 1 << 11,\r\n        AllowAnonymousIdentifier = 1 << 13,\r\n        AllowEmptyUnionOrIntersection = 1 << 14,\r\n        AllowEmptyTuple = 1 << 15,\r\n\r\n        IgnoreErrors = AllowThisInObjectLiteral | AllowQualifedNameInPlaceOfIdentifier | AllowAnonymousIdentifier | AllowEmptyUnionOrIntersection | AllowEmptyTuple,\r\n\r\n        // State\r\n        InObjectTypeLiteral = 1 << 20,\r\n        InTypeAlias = 1 << 23,    // Writing type in type alias declaration\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolWalker {\r\n        /** Note: Return values are not ordered. */\r\n        walkType(root: Type): { visitedTypes: ReadonlyArray<Type>, visitedSymbols: ReadonlyArray<Symbol> };\r\n        /** Note: Return values are not ordered. */\r\n        walkSymbol(root: Symbol): { visitedTypes: ReadonlyArray<Type>, visitedSymbols: ReadonlyArray<Symbol> };\r\n    }\r\n\r\n    export interface SymbolDisplayBuilder {\r\n        buildTypeDisplay(type: Type, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildSymbolDisplay(symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): void;\r\n        buildSignatureDisplay(signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): void;\r\n        buildIndexSignatureDisplay(info: IndexInfo, writer: SymbolWriter, kind: IndexKind, enclosingDeclaration?: Node, globalFlags?: TypeFormatFlags, symbolStack?: Symbol[]): void;\r\n        buildParameterDisplay(parameter: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildTypeParameterDisplay(tp: TypeParameter, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildTypePredicateDisplay(predicate: TypePredicate, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildTypeParameterDisplayFromSymbol(symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildDisplayForParametersAndDelimiters(thisParameter: Symbol, parameters: Symbol[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildDisplayForTypeParametersAndDelimiters(typeParameters: TypeParameter[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        buildReturnTypeDisplay(signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n    }\r\n\r\n    export interface SymbolWriter {\r\n        writeKeyword(text: string): void;\r\n        writeOperator(text: string): void;\r\n        writePunctuation(text: string): void;\r\n        writeSpace(text: string): void;\r\n        writeStringLiteral(text: string): void;\r\n        writeParameter(text: string): void;\r\n        writeProperty(text: string): void;\r\n        writeSymbol(text: string, symbol: Symbol): void;\r\n        writeLine(): void;\r\n        increaseIndent(): void;\r\n        decreaseIndent(): void;\r\n        clear(): void;\r\n\r\n        // Called when the symbol writer encounters a symbol to write.  Currently only used by the\r\n        // declaration emitter to help determine if it should patch up the final declaration file\r\n        // with import statements it previously saw (but chose not to emit).\r\n        trackSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): void;\r\n        reportInaccessibleThisError(): void;\r\n        reportPrivateInBaseOfClassExpression(propertyName: string): void;\r\n    }\r\n\r\n    export const enum TypeFormatFlags {\r\n        None = 0,\r\n        WriteArrayAsGenericType = 1 << 0,  // Write Array<T> instead T[]\r\n        UseTypeOfFunction = 1 << 2,  // Write typeof instead of function type literal\r\n        NoTruncation = 1 << 3,  // Don't truncate typeToString result\r\n        WriteArrowStyleSignature = 1 << 4,  // Write arrow style signature\r\n        WriteOwnNameForAnyLike = 1 << 5,  // Write symbol's own name instead of 'any' for any like types (eg. unknown, __resolving__ etc)\r\n        WriteTypeArgumentsOfSignature = 1 << 6,  // Write the type arguments instead of type parameters of the signature\r\n        InElementType = 1 << 7,  // Writing an array or union element type\r\n        UseFullyQualifiedType = 1 << 8,  // Write out the fully qualified type name (eg. Module.Type, instead of Type)\r\n        InFirstTypeArgument = 1 << 9,  // Writing first type argument of the instantiated type\r\n        InTypeAlias = 1 << 10,  // Writing type in type alias declaration\r\n        SuppressAnyReturnType = 1 << 12,  // If the return type is any-like, don't offer a return type.\r\n        AddUndefined = 1 << 13,  // Add undefined to types of initialized, non-optional parameters\r\n        WriteClassExpressionAsTypeLiteral = 1 << 14, // Write a type literal instead of (Anonymous class)\r\n        InArrayType = 1 << 15,  // Writing an array element type\r\n        UseAliasDefinedOutsideCurrentScope = 1 << 16, // For a `type T = ... ` defined in a different file, write `T` instead of its value,\r\n        // even though `T` can't be accessed in the current scope.\r\n    }\r\n\r\n    export const enum SymbolFormatFlags {\r\n        None = 0x00000000,\r\n\r\n        // Write symbols's type argument if it is instantiated symbol\r\n        // eg. class C<T> { p: T }   <-- Show p as C<T>.p here\r\n        //     var a: C<number>;\r\n        //     var p = a.p;  <--- Here p is property of C<number> so show it as C<number>.p instead of just C.p\r\n        WriteTypeParametersOrArguments = 0x00000001,\r\n\r\n        // Use only external alias information to get the symbol name in the given context\r\n        // eg.  module m { export class c { } } import x = m.c;\r\n        // When this flag is specified m.c will be used to refer to the class instead of alias symbol x\r\n        UseOnlyExternalAliasing = 0x00000002,\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SymbolAccessibility {\r\n        Accessible,\r\n        NotAccessible,\r\n        CannotBeNamed\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SyntheticSymbolKind {\r\n        UnionOrIntersection,\r\n        Spread\r\n    }\r\n\r\n    export const enum TypePredicateKind {\r\n        This,\r\n        Identifier\r\n    }\r\n\r\n    export interface TypePredicateBase {\r\n        kind: TypePredicateKind;\r\n        type: Type;\r\n    }\r\n\r\n    export interface ThisTypePredicate extends TypePredicateBase {\r\n        kind: TypePredicateKind.This;\r\n    }\r\n\r\n    export interface IdentifierTypePredicate extends TypePredicateBase {\r\n        kind: TypePredicateKind.Identifier;\r\n        parameterName: string;\r\n        parameterIndex: number;\r\n    }\r\n\r\n    export type TypePredicate = IdentifierTypePredicate | ThisTypePredicate;\r\n\r\n    /* @internal */\r\n    export type AnyImportSyntax = ImportDeclaration | ImportEqualsDeclaration;\r\n\r\n    /* @internal */\r\n    export interface SymbolVisibilityResult {\r\n        accessibility: SymbolAccessibility;\r\n        aliasesToMakeVisible?: AnyImportSyntax[]; // aliases that need to have this symbol visible\r\n        errorSymbolName?: string; // Optional symbol name that results in error\r\n        errorNode?: Node; // optional node that results in error\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolAccessibilityResult extends SymbolVisibilityResult {\r\n        errorModuleName?: string; // If the symbol is not visible from module, module's name\r\n    }\r\n\r\n    /** Indicates how to serialize the name for a TypeReferenceNode when emitting decorator metadata */\r\n    /* @internal */\r\n    export enum TypeReferenceSerializationKind {\r\n        Unknown,                            // The TypeReferenceNode could not be resolved. The type name\r\n        // should be emitted using a safe fallback.\r\n        TypeWithConstructSignatureAndValue, // The TypeReferenceNode resolves to a type with a constructor\r\n        // function that can be reached at runtime (e.g. a `class`\r\n        // declaration or a `var` declaration for the static side\r\n        // of a type, such as the global `Promise` type in lib.d.ts).\r\n        VoidNullableOrNeverType,            // The TypeReferenceNode resolves to a Void-like, Nullable, or Never type.\r\n        NumberLikeType,                     // The TypeReferenceNode resolves to a Number-like type.\r\n        StringLikeType,                     // The TypeReferenceNode resolves to a String-like type.\r\n        BooleanType,                        // The TypeReferenceNode resolves to a Boolean-like type.\r\n        ArrayLikeType,                      // The TypeReferenceNode resolves to an Array-like type.\r\n        ESSymbolType,                       // The TypeReferenceNode resolves to the ESSymbol type.\r\n        Promise,                            // The TypeReferenceNode resolved to the global Promise constructor symbol.\r\n        TypeWithCallSignature,              // The TypeReferenceNode resolves to a Function type or a type\r\n        // with call signatures.\r\n        ObjectType,                         // The TypeReferenceNode resolves to any other type.\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitResolver {\r\n        /** 有全局名称 */\r\n        hasGlobalName(name: string): boolean;\r\n        /** 取引用的出口容器 */\r\n        getReferencedExportContainer(node: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration;\r\n        /** 取引用的引用声明 */\r\n        getReferencedImportDeclaration(node: Identifier): Declaration;\r\n        /** 取碰撞的名字被引用的声明 */\r\n        getReferencedDeclarationWithCollidingName(node: Identifier): Declaration;\r\n        /** 是碰撞的名字的声明 */\r\n        isDeclarationWithCollidingName(node: Declaration): boolean;\r\n        /** 是值别名声明 */\r\n        isValueAliasDeclaration(node: Node): boolean;\r\n        /** 是引用别名声明。 */\r\n        isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean;\r\n        /** 是顶级进口等于值的实体名称 */\r\n        isTopLevelValueImportEqualsWithEntityName(node: ImportEqualsDeclaration): boolean;\r\n        /** 取节点检查旗帜 */\r\n        getNodeCheckFlags(node: Node): NodeCheckFlags;\r\n        /** 是可见的声明 */\r\n        isDeclarationVisible(node: Declaration): boolean;\r\n        /** 收集相关的别名 */\r\n        collectLinkedAliases(node: Identifier): Node[];\r\n        /** 是重载的实现 */\r\n        isImplementationOfOverload(node: FunctionLikeDeclaration): boolean | undefined;\r\n        /** 初始化参数是必需的 */\r\n        isRequiredInitializedParameter(node: ParameterDeclaration): boolean;\r\n        /** 是可选的初始化参数 */\r\n        isOptionalUninitializedParameterProperty(node: ParameterDeclaration): boolean;\r\n        /** 写声明的类型 */\r\n        writeTypeOfDeclaration(declaration: AccessorDeclaration | VariableLikeDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter): void;\r\n        /** 写签名声明的返回类型 */\r\n        writeReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter): void;\r\n        /** 写表达式的类型 */\r\n        writeTypeOfExpression(expr: Expression, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter): void;\r\n        /** 是可访问的符号 */\r\n        isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;\r\n        /** 是可访问的实体名称 */\r\n        isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node): SymbolVisibilityResult;\r\n        // Returns the constant value this property access resolves to, or 'undefined' for a non-constant\r\n        /** 取常量值 */\r\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number;\r\n        /** 取引用值的声明 */\r\n        getReferencedValueDeclaration(reference: Identifier): Declaration;\r\n        /** 取类型引用系列化旗帜 */\r\n        getTypeReferenceSerializationKind(typeName: EntityName, location?: Node): TypeReferenceSerializationKind;\r\n        /** 是可选参数 */\r\n        isOptionalParameter(node: ParameterDeclaration): boolean;\r\n        /** 模块导出的一些值 */\r\n        moduleExportsSomeValue(moduleReferenceExpression: Expression): boolean;\r\n        /** 参数是局部绑定的 */\r\n        isArgumentsLocalBinding(node: Identifier): boolean;\r\n        /** 取外部模块文件从申报到 */\r\n        getExternalModuleFileFromDeclaration(declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration): SourceFile;\r\n        /** 取类型引用指令从实体名称 */\r\n        getTypeReferenceDirectivesForEntityName(name: EntityNameOrEntityNameExpression): string[];\r\n        /** 取类型引用的指令从符号 */\r\n        getTypeReferenceDirectivesForSymbol(symbol: Symbol, meaning?: SymbolFlags): string[];\r\n        /** 是字面量常量声明 */\r\n        isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean;\r\n        /** 写入文字常量值 */\r\n        writeLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration, writer: SymbolWriter): void;\r\n        /** 让JSX厂实体 */\r\n        getJsxFactoryEntity(): EntityName;\r\n        取别名助手数据?(): string[];\r\n    }\r\n\r\n    export const enum SymbolFlags {\r\n        None = 0,\r\n        FunctionScopedVariable = 1 << 0,   // Variable (var) or parameter\r\n        BlockScopedVariable = 1 << 1,   // A block-scoped variable (let or const)\r\n        Property = 1 << 2,   // Property or enum member\r\n        EnumMember = 1 << 3,   // Enum member\r\n        Function = 1 << 4,   // Function\r\n        Class = 1 << 5,   // Class\r\n        Interface = 1 << 6,   // Interface\r\n        ConstEnum = 1 << 7,   // Const enum\r\n        RegularEnum = 1 << 8,   // Enum\r\n        ValueModule = 1 << 9,   // Instantiated module\r\n        NamespaceModule = 1 << 10,  // Uninstantiated module\r\n        TypeLiteral = 1 << 11,  // Type Literal or mapped type\r\n        ObjectLiteral = 1 << 12,  // Object Literal\r\n        Method = 1 << 13,  // Method\r\n        Constructor = 1 << 14,  // Constructor\r\n        GetAccessor = 1 << 15,  // Get accessor\r\n        SetAccessor = 1 << 16,  // Set accessor\r\n        Signature = 1 << 17,  // Call, construct, or index signature\r\n        TypeParameter = 1 << 18,  // Type parameter\r\n        TypeAlias = 1 << 19,  // Type alias\r\n        ExportValue = 1 << 20,  // Exported value marker (see comment in declareModuleMember in binder)\r\n        Alias = 1 << 21,  // An alias for another symbol (see comment in isAliasSymbolDeclaration in checker)\r\n        Prototype = 1 << 22,  // Prototype property (no source representation)\r\n        ExportStar = 1 << 23,  // Export * declaration\r\n        Optional = 1 << 24,  // Optional property\r\n        Transient = 1 << 25,  // Transient symbol (created during type check)\r\n\r\n        Enum = RegularEnum | ConstEnum,\r\n        Variable = FunctionScopedVariable | BlockScopedVariable,\r\n        Value = Variable | Property | EnumMember | Function | Class | Enum | ValueModule | Method | GetAccessor | SetAccessor,\r\n        Type = Class | Interface | Enum | EnumMember | TypeLiteral | ObjectLiteral | TypeParameter | TypeAlias,\r\n        Namespace = ValueModule | NamespaceModule | Enum,\r\n        Module = ValueModule | NamespaceModule,\r\n        Accessor = GetAccessor | SetAccessor,\r\n\r\n        // Variables can be redeclared, but can not redeclare a block-scoped declaration with the\r\n        // same name, or any other value that is not a variable, e.g. ValueModule or Class\r\n        FunctionScopedVariableExcludes = Value & ~FunctionScopedVariable,\r\n\r\n        // Block-scoped declarations are not allowed to be re-declared\r\n        // they can not merge with anything in the value space\r\n        BlockScopedVariableExcludes = Value,\r\n\r\n        ParameterExcludes = Value,\r\n        PropertyExcludes = None,\r\n        EnumMemberExcludes = Value | Type,\r\n        FunctionExcludes = Value & ~(Function | ValueModule),\r\n        ClassExcludes = (Value | Type) & ~(ValueModule | Interface), // class-interface mergability done in checker.ts\r\n        InterfaceExcludes = Type & ~(Interface | Class),\r\n        RegularEnumExcludes = (Value | Type) & ~(RegularEnum | ValueModule), // regular enums merge only with regular enums and modules\r\n        ConstEnumExcludes = (Value | Type) & ~ConstEnum, // const enums merge only with const enums\r\n        ValueModuleExcludes = Value & ~(Function | Class | RegularEnum | ValueModule),\r\n        NamespaceModuleExcludes = 0,\r\n        MethodExcludes = Value & ~Method,\r\n        GetAccessorExcludes = Value & ~SetAccessor,\r\n        SetAccessorExcludes = Value & ~GetAccessor,\r\n        TypeParameterExcludes = Type & ~TypeParameter,\r\n        TypeAliasExcludes = Type,\r\n        AliasExcludes = Alias,\r\n\r\n        ModuleMember = Variable | Function | Class | Interface | Enum | Module | TypeAlias | Alias,\r\n\r\n        ExportHasLocal = Function | Class | Enum | ValueModule,\r\n\r\n        HasExports = Class | Enum | Module,\r\n        HasMembers = Class | Interface | TypeLiteral | ObjectLiteral,\r\n\r\n        BlockScoped = BlockScopedVariable | Class | Enum,\r\n\r\n        PropertyOrAccessor = Property | Accessor,\r\n\r\n        ClassMember = Method | Accessor | Property,\r\n\r\n        /* @internal */\r\n        // The set of things we consider semantically classifiable.  Used to speed up the LS during\r\n        // classification.\r\n        Classifiable = Class | Enum | TypeAlias | Interface | TypeParameter | Module,\r\n    }\r\n\r\n    export interface Symbol {\r\n        flags: SymbolFlags;                     // Symbol flags\r\n        escapedName: __String;                  // Name of symbol\r\n        别名?: 别名;\r\n        别名id?: number;\r\n        declarations?: Declaration[];           // Declarations associated with this symbol\r\n        valueDeclaration?: Declaration;         // First value declaration of the symbol\r\n        members?: SymbolTable;                  // Class, interface or literal instance members\r\n        exports?: SymbolTable;                  // Module exports\r\n        globalExports?: SymbolTable;            // Conditional global UMD exports\r\n        /* @internal */ id?: number;            // Unique id (used to look up SymbolLinks)\r\n        /* @internal */ mergeId?: number;       // Merge id (used to look up merged symbol)\r\n        /* @internal */ parent?: Symbol;        // Parent symbol\r\n        /* @internal */ exportSymbol?: Symbol;  // Exported symbol associated with this symbol\r\n        /* @internal */ constEnumOnlyModule?: boolean; // True if module contains only const enums or other modules with only const enums\r\n        /* @internal */ isReferenced?: boolean; // True if the symbol is referenced elsewhere\r\n        /* @internal */ isReplaceableByMethod?: boolean; // Can this Javascript class property be replaced by a method symbol?\r\n        /* @internal */ isAssigned?: boolean;   // True if the symbol is a parameter with assignments\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolLinks {\r\n        immediateTarget?: Symbol;           // Immediate target of an alias. May be another alias. Do not access directly, use `checker.getImmediateAliasedSymbol` instead.\r\n        target?: Symbol;                    // Resolved (non-alias) target of an alias\r\n        type?: Type;                        // Type of value symbol\r\n        declaredType?: Type;                // Type of class, interface, enum, type alias, or type parameter\r\n        typeParameters?: TypeParameter[];   // Type parameters of type alias (undefined if non-generic)\r\n        inferredClassType?: Type;           // Type of an inferred ES5 class\r\n        instantiations?: Map<Type>;         // Instantiations of generic type alias (undefined if non-generic)\r\n        mapper?: TypeMapper;                // Type mapper for instantiation alias\r\n        referenced?: boolean;               // True if alias symbol has been referenced as a value\r\n        containingType?: UnionOrIntersectionType;  // Containing union or intersection type for synthetic property\r\n        leftSpread?: Symbol;                // Left source for synthetic spread property\r\n        rightSpread?: Symbol;               // Right source for synthetic spread property\r\n        syntheticOrigin?: Symbol;           // For a property on a mapped or spread type, points back to the original property\r\n        syntheticLiteralTypeOrigin?: StringLiteralType; // For a property on a mapped type, indicates the type whose text to use as the declaration name, instead of the symbol name\r\n        isDiscriminantProperty?: boolean;   // True if discriminant synthetic property\r\n        resolvedExports?: SymbolTable;      // Resolved exports of module\r\n        exportsChecked?: boolean;           // True if exports of external module have been checked\r\n        typeParametersChecked?: boolean;    // True if type parameters of merged class and interface declarations have been checked.\r\n        isDeclarationWithCollidingName?: boolean;    // True if symbol is block scoped redeclaration\r\n        bindingElement?: BindingElement;    // Binding element associated with property symbol\r\n        exportsSomeValue?: boolean;         // True if module exports some value (not just types)\r\n        enumKind?: EnumKind;                // Enum declaration classification\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum EnumKind {\r\n        Numeric,                            // Numeric enum (each member has a TypeFlags.Enum type)\r\n        Literal                             // Literal enum (each member has a TypeFlags.EnumLiteral type)\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum CheckFlags {\r\n        Instantiated = 1 << 0,         // Instantiated symbol\r\n        SyntheticProperty = 1 << 1,         // Property in union or intersection type\r\n        SyntheticMethod = 1 << 2,         // Method in union or intersection type\r\n        Readonly = 1 << 3,         // Readonly transient symbol\r\n        Partial = 1 << 4,         // Synthetic property present in some but not all constituents\r\n        HasNonUniformType = 1 << 5,         // Synthetic property with non-uniform type in constituents\r\n        ContainsPublic = 1 << 6,         // Synthetic property with public constituent(s)\r\n        ContainsProtected = 1 << 7,         // Synthetic property with protected constituent(s)\r\n        ContainsPrivate = 1 << 8,         // Synthetic property with private constituent(s)\r\n        ContainsStatic = 1 << 9,         // Synthetic property with static constituent(s)\r\n        Synthetic = SyntheticProperty | SyntheticMethod\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TransientSymbol extends Symbol, SymbolLinks {\r\n        checkFlags: CheckFlags;\r\n        isRestParameter?: boolean;\r\n    }\r\n\r\n    export const enum InternalSymbolName {\r\n        Call = \"__call\", // Call signatures\r\n        Constructor = \"__constructor\", // Constructor implementations\r\n        New = \"__new\", // Constructor signatures\r\n        Index = \"__index\", // Index signatures\r\n        ExportStar = \"__export\", // Module export * declarations\r\n        Global = \"__global\", // Global self-reference\r\n        Missing = \"__missing\", // Indicates missing symbol\r\n        Type = \"__type\", // Anonymous type literal symbol\r\n        Object = \"__object\", // Anonymous object literal declaration\r\n        JSXAttributes = \"__jsxAttributes\", // Anonymous JSX attributes object literal declaration\r\n        Class = \"__class\", // Unnamed class expression\r\n        Function = \"__function\", // Unnamed function expression\r\n        Computed = \"__computed\", // Computed property name declaration with dynamic name\r\n        Resolving = \"__resolving__\", // Indicator symbol used to mark partially resolved type aliases\r\n        ExportEquals = \"export=\", // Export assignment symbol\r\n        Default = \"default\", // Default export symbol (technically not wholly internal, but included here for usability)\r\n    }\r\n\r\n    /**\r\n     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.\r\n     * The shape of this brand is rather unique compared to others we've used.\r\n     * Instead of just an intersection of a string and an object, it is that union-ed\r\n     * with an intersection of void and an object. This makes it wholly incompatible\r\n     * with a normal string (which is good, it cannot be misused on assignment or on usage),\r\n     * while still being comparable with a normal string via === (also good) and castable from a string.\r\n     */\r\n    export type __String = (string & { __escapedIdentifier: void }) | (void & { __escapedIdentifier: void }) | InternalSymbolName;\r\n\r\n    /** ReadonlyMap where keys are `__String`s. */\r\n    export interface ReadonlyUnderscoreEscapedMap<T> {\r\n        get(key: __String): T | undefined;\r\n        has(key: __String): boolean;\r\n        forEach(action: (value: T, key: __String) => void): void;\r\n        readonly size: number;\r\n        keys(): Iterator<__String>;\r\n        values(): Iterator<T>;\r\n        entries(): Iterator<[__String, T]>;\r\n    }\r\n\r\n    /** Map where keys are `__String`s. */\r\n    export interface UnderscoreEscapedMap<T> extends ReadonlyUnderscoreEscapedMap<T> {\r\n        set(key: __String, value: T): this;\r\n        delete(key: __String): boolean;\r\n        clear(): void;\r\n    }\r\n\r\n    /** SymbolTable based on ES6 Map interface. */\r\n    export type SymbolTable = UnderscoreEscapedMap<Symbol>;\r\n\r\n    /** Represents a \"prefix*suffix\" pattern. */\r\n    /* @internal */\r\n    export interface Pattern {\r\n        prefix: string;\r\n        suffix: string;\r\n    }\r\n\r\n    /** Used to track a `declare module \"foo*\"`-like declaration. */\r\n    /* @internal */\r\n    export interface PatternAmbientModule {\r\n        pattern: Pattern;\r\n        symbol: Symbol;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum NodeCheckFlags {\r\n        /** 节点已被类型检查。 */\r\n        TypeChecked = 0x00000001,  // Node has been type checked\r\n        /** 字面量 \"本对象\" 引用 */\r\n        LexicalThis = 0x00000002,  // Lexical 'this' reference\r\n        /** 字面量 \"本对象\" 在体内使用 */\r\n        CaptureThis = 0x00000004,  // Lexical 'this' used in body\r\n        /** 字面量 \"新.目标\" 在体内使用  */\r\n        CaptureNewTarget = 0x00000008,  // Lexical 'new.target' used in body\r\n        /** 实例 \"父对象\" 引用 */\r\n        SuperInstance = 0x00000100,  // Instance 'super' reference\r\n        /** 静态 \"父对象\" 引用  */\r\n        SuperStatic = 0x00000200,  // Static 'super' reference\r\n        /** 语境类型被分配 */\r\n        ContextChecked = 0x00000400,  // Contextual types have been assigned\r\n        /** 一个异步方法，读取一个成员的\"父对象\"值。 */\r\n        AsyncMethodWithSuper = 0x00000800,  // An async method that reads a value from a member of 'super'.\r\n        /** 一个异步方法，指定一个值给一个成员的\"父对象\"。 */\r\n        AsyncMethodWithSuperBinding = 0x00001000,  // An async method that assigns a value to a member of 'super'.\r\n        /** 字面量 增强参数 在体内使用 */\r\n        CaptureArguments = 0x00002000,  // Lexical 'arguments' used in body\r\n        /** 枚举成员的值已被计算 */\r\n        EnumValuesComputed = 0x00004000,  // Values for enum members have been computed, and any errors have been reported for them.\r\n        /** 词汇模块实例化声明与先前的类声明合并 */\r\n        LexicalModuleMergesWithClass = 0x00008000,  // Instantiated lexical module declaration is merged with a previous class declaration.\r\n        /** 循环，包含块限定了作用域的变量被关闭 */\r\n        LoopWithCapturedBlockScopedBinding = 0x00010000,  // Loop that contains block scoped variable captured in closure\r\n        /** 块作用域的结合，在一些功能捕获 */\r\n        CapturedBlockScopedBinding = 0x00020000,  // Block-scoped binding that is captured in some function\r\n        /** 块作用域嵌套迭代语句结合申报 */\r\n        BlockScopedBindingInLoop = 0x00040000,  // Block-scoped binding with declaration nested inside iteration statement\r\n        /** 装饰类，包含结合本身在类体。 */\r\n        ClassWithBodyScopedClassBinding = 0x00080000,  // Decorated class that contains a binding to itself inside of the class body.\r\n        /** 结合装饰类里面的类的身体。 */\r\n        BodyScopedClassBinding = 0x00100000,  // Binding to a decorated class inside of the class's body.\r\n        /** 块作用域绑定的值应明确复制转换环外 */\r\n        NeedsLoopOutParameter = 0x00200000,  // Block scoped binding whose value should be explicitly copied outside of the converted loop\r\n        /** 参数分配已标记 */\r\n        AssignmentsMarked = 0x00400000,  // Parameter assignments have been marked\r\n        /** 类包含一个绑定到它的构造函数在类体。 */\r\n        ClassWithConstructorReference = 0x00800000,  // Class that contains a binding to its constructor inside of the class body.\r\n        /** 绑定到类的构造函数里面的类的身体。 */\r\n        ConstructorReferenceInClass = 0x01000000,  // Binding to a class constructor inside of the class's body.\r\n    }\r\n\r\n    /* @internal */\r\n    export interface NodeLinks {\r\n        flags?: NodeCheckFlags;           // Set of flags specific to Node\r\n        resolvedType?: Type;              // Cached type of type node\r\n        resolvedSignature?: Signature;    // Cached signature of signature node or call expression\r\n        resolvedSymbol?: Symbol;          // Cached name resolution result\r\n        别名解析缓存符号?: Symbol;\r\n        字面量类型约束缓存?:Type;\r\n        resolvedIndexInfo?: IndexInfo;    // Cached indexing info resolution result\r\n        maybeTypePredicate?: boolean;     // Cached check whether call expression might reference a type predicate\r\n        enumMemberValue?: string | number;  // Constant value of enum member\r\n        isVisible?: boolean;              // Is this node visible\r\n        containsArgumentsReference?: boolean; // Whether a function-like declaration contains an 'arguments' reference\r\n        hasReportedStatementInAmbientContext?: boolean;  // Cache boolean if we report statements in ambient context\r\n        jsxFlags?: JsxFlags;              // flags for knowing what kind of element/attributes we're dealing with\r\n        resolvedJsxElementAttributesType?: Type;  // resolved element attributes type of a JSX openinglike element\r\n        resolvedJsxElementAllAttributesType?: Type;  // resolved all element attributes type of a JSX openinglike element\r\n        hasSuperCall?: boolean;           // recorded result when we try to find super-call. We only try to find one if this flag is undefined, indicating that we haven't made an attempt.\r\n        superCall?: ExpressionStatement;  // Cached first super-call found in the constructor. Used in checking whether super is called before this-accessing\r\n        switchTypes?: Type[];             // Cached array of switch case expression types\r\n    }\r\n\r\n    export const enum TypeFlags {\r\n        Any = 1 << 0,\r\n        String = 1 << 1,\r\n        Number = 1 << 2,\r\n        Boolean = 1 << 3,\r\n        Enum = 1 << 4,\r\n        StringLiteral = 1 << 5,\r\n        NumberLiteral = 1 << 6,\r\n        BooleanLiteral = 1 << 7,\r\n        EnumLiteral = 1 << 8,   // Always combined with StringLiteral, NumberLiteral, or Union\r\n        ESSymbol = 1 << 9,   // Type of symbol primitive introduced in ES6\r\n        Void = 1 << 10,\r\n        Undefined = 1 << 11,\r\n        Null = 1 << 12,\r\n        Never = 1 << 13,  // Never type\r\n        TypeParameter = 1 << 14,  // Type parameter\r\n        Object = 1 << 15,  // Object type\r\n        Union = 1 << 16,  // Union (T | U)\r\n        Intersection = 1 << 17,  // Intersection (T & U)\r\n        Index = 1 << 18,  // keyof T\r\n        IndexedAccess = 1 << 19,  // T[K]\r\n        /* @internal */\r\n        FreshLiteral = 1 << 20,  // Fresh literal type\r\n        /* @internal */\r\n        ContainsWideningType = 1 << 21,  // Type is or contains undefined or null widening type\r\n        /* @internal */\r\n        ContainsObjectLiteral = 1 << 22,  // Type is or contains object literal type\r\n        /* @internal */\r\n        ContainsAnyFunctionType = 1 << 23,  // Type is or contains the anyFunctionType\r\n        NonPrimitive = 1 << 24,  // intrinsic object type\r\n        /* @internal */\r\n        JsxAttributes = 1 << 25,  // Jsx attributes type\r\n        MarkerType = 1 << 26,  // Marker type used for variance probing\r\n\r\n        /* @internal */\r\n        Nullable = Undefined | Null,\r\n        Literal = StringLiteral | NumberLiteral | BooleanLiteral,\r\n        Unit = Literal | Nullable,\r\n        StringOrNumberLiteral = StringLiteral | NumberLiteral,\r\n        /* @internal */\r\n        DefinitelyFalsy = StringLiteral | NumberLiteral | BooleanLiteral | Void | Undefined | Null,\r\n        PossiblyFalsy = DefinitelyFalsy | String | Number | Boolean,\r\n        /* @internal */\r\n        Intrinsic = Any | String | Number | Boolean | BooleanLiteral | ESSymbol | Void | Undefined | Null | Never | NonPrimitive,\r\n        /* @internal */\r\n        Primitive = String | Number | Boolean | Enum | EnumLiteral | ESSymbol | Void | Undefined | Null | Literal,\r\n        StringLike = String | StringLiteral | Index,\r\n        NumberLike = Number | NumberLiteral | Enum,\r\n        BooleanLike = Boolean | BooleanLiteral,\r\n        EnumLike = Enum | EnumLiteral,\r\n        UnionOrIntersection = Union | Intersection,\r\n        StructuredType = Object | Union | Intersection,\r\n        StructuredOrTypeVariable = StructuredType | TypeParameter | Index | IndexedAccess,\r\n        TypeVariable = TypeParameter | IndexedAccess,\r\n\r\n        // 'Narrowable' types are types where narrowing actually narrows.\r\n        // This *should* be every type other than null, undefined, void, and never\r\n        Narrowable = Any | StructuredType | TypeParameter | Index | IndexedAccess | StringLike | NumberLike | BooleanLike | ESSymbol | NonPrimitive,\r\n        NotUnionOrUnit = Any | ESSymbol | Object | NonPrimitive,\r\n        /* @internal */\r\n        RequiresWidening = ContainsWideningType | ContainsObjectLiteral,\r\n        /* @internal */\r\n        PropagatingFlags = ContainsWideningType | ContainsObjectLiteral | ContainsAnyFunctionType,\r\n        Cts类型转换 = String | StringLiteral | EnumLiteral | Object | Union | Index,\r\n    }\r\n\r\n    export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;\r\n\r\n    // Properties common to all types\r\n    export interface Type {\r\n        flags: TypeFlags;                // Flags\r\n        /* @internal */ id: number;      // Unique ID\r\n        /* @internal */ checker: TypeChecker;\r\n        symbol?: Symbol;                 // Symbol associated with type (if any)\r\n        pattern?: DestructuringPattern;  // Destructuring pattern represented by type (if any)\r\n        aliasSymbol?: Symbol;            // Alias associated with type\r\n        aliasTypeArguments?: Type[];     // Alias type arguments (if any)\r\n    }\r\n\r\n    /* @internal */\r\n    // Intrinsic types (TypeFlags.Intrinsic)\r\n    export interface IntrinsicType extends Type {\r\n        intrinsicName: string;        // Name of intrinsic type\r\n        别名?: 别名;\r\n        别名id?: number;\r\n    }\r\n\r\n    // String literal types (TypeFlags.StringLiteral)\r\n    // Numeric literal types (TypeFlags.NumberLiteral)\r\n    export interface LiteralType extends Type {\r\n        value: string | number;     // Value of literal\r\n        freshType?: LiteralType;    // Fresh version of type\r\n        regularType?: LiteralType;  // Regular version of type\r\n    }\r\n\r\n    export interface StringLiteralType extends LiteralType {\r\n        value: string;\r\n        别名?: 别名;\r\n        别名id?: number;\r\n    }\r\n\r\n    export interface NumberLiteralType extends LiteralType {\r\n        value: number;\r\n    }\r\n\r\n    // Enum types (TypeFlags.Enum)\r\n    export interface EnumType extends Type {\r\n        别名?: 别名;\r\n        别名id?: number;\r\n    }\r\n\r\n    export const enum ObjectFlags {\r\n        Class = 1 << 0,  // Class\r\n        Interface = 1 << 1,  // Interface\r\n        Reference = 1 << 2,  // Generic type reference\r\n        Tuple = 1 << 3,  // Synthesized generic tuple type\r\n        Anonymous = 1 << 4,  // Anonymous\r\n        Mapped = 1 << 5,  // Mapped\r\n        Instantiated = 1 << 6,  // Instantiated anonymous or mapped type\r\n        ObjectLiteral = 1 << 7,  // Originates in an object literal\r\n        EvolvingArray = 1 << 8,  // Evolving array type\r\n        ObjectLiteralPatternWithComputedProperties = 1 << 9,  // Object literal pattern with computed properties\r\n        ClassOrInterface = Class | Interface\r\n    }\r\n\r\n    // Object types (TypeFlags.ObjectType)\r\n    export interface ObjectType extends Type {\r\n        objectFlags: ObjectFlags;\r\n        别名?: 别名;\r\n        别名id?: number;\r\n    }\r\n\r\n    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */\r\n    export interface InterfaceType extends ObjectType {\r\n        typeParameters: TypeParameter[];           // Type parameters (undefined if non-generic)\r\n        outerTypeParameters: TypeParameter[];      // Outer type parameters (undefined if none)\r\n        localTypeParameters: TypeParameter[];      // Local type parameters (undefined if none)\r\n        thisType: TypeParameter;                   // The \"this\" type (undefined if none)\r\n        /* @internal */\r\n        resolvedBaseConstructorType?: Type;        // Resolved base constructor type of class\r\n        /* @internal */\r\n        resolvedBaseTypes: BaseType[];             // Resolved base types\r\n    }\r\n\r\n    // Object type or intersection of object types\r\n    export type BaseType = ObjectType | IntersectionType;\r\n\r\n    export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {\r\n        declaredProperties: Symbol[];              // Declared members\r\n        declaredCallSignatures: Signature[];       // Declared call signatures\r\n        declaredConstructSignatures: Signature[];  // Declared construct signatures\r\n        declaredStringIndexInfo: IndexInfo;        // Declared string indexing info\r\n        declaredNumberIndexInfo: IndexInfo;        // Declared numeric indexing info\r\n    }\r\n\r\n    /**\r\n     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or\r\n     * a \"this\" type, references to the class or interface are made using type references. The\r\n     * typeArguments property specifies the types to substitute for the type parameters of the\r\n     * class or interface and optionally includes an extra element that specifies the type to\r\n     * substitute for \"this\" in the resulting instantiation. When no extra argument is present,\r\n     * the type reference itself is substituted for \"this\". The typeArguments property is undefined\r\n     * if the class or interface has no type parameters and the reference isn't specifying an\r\n     * explicit \"this\" argument.\r\n     */\r\n    export interface TypeReference extends ObjectType {\r\n        target: GenericType;    // Type reference target\r\n        typeArguments?: Type[];  // Type reference type arguments (undefined if none)\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum Variance {\r\n        Invariant = 0,  // Neither covariant nor contravariant\r\n        Covariant = 1,  // Covariant\r\n        Contravariant = 2,  // Contravariant\r\n        Bivariant = 3,  // Both covariant and contravariant\r\n        Independent = 4,  // Unwitnessed type parameter\r\n    }\r\n\r\n    // Generic class and interface types\r\n    export interface GenericType extends InterfaceType, TypeReference {\r\n        /* @internal */\r\n        instantiations: Map<TypeReference>;  // Generic instantiation cache\r\n        /* @internal */\r\n        variances?: Variance[];  // Variance of each type parameter\r\n    }\r\n\r\n    export interface UnionOrIntersectionType extends Type {\r\n        types: Type[];                    // Constituent types\r\n        /* @internal */\r\n        propertyCache: SymbolTable;       // Cache of resolved properties\r\n        /* @internal */\r\n        resolvedProperties: Symbol[];\r\n        /* @internal */\r\n        resolvedIndexType: IndexType;\r\n        /* @internal */\r\n        resolvedBaseConstraint: Type;\r\n        /* @internal */\r\n        couldContainTypeVariables: boolean;\r\n    }\r\n\r\n    export interface UnionType extends UnionOrIntersectionType { }\r\n\r\n    export interface IntersectionType extends UnionOrIntersectionType {\r\n        /* @internal */\r\n        resolvedApparentType: Type;\r\n    }\r\n\r\n    export type StructuredType = ObjectType | UnionType | IntersectionType;\r\n\r\n    /* @internal */\r\n    // An instantiated anonymous type has a target and a mapper\r\n    export interface AnonymousType extends ObjectType {\r\n        target?: AnonymousType;  // Instantiation target\r\n        mapper?: TypeMapper;     // Instantiation mapper\r\n    }\r\n\r\n    /* @internal */\r\n    export interface MappedType extends AnonymousType {\r\n        declaration: MappedTypeNode;\r\n        typeParameter?: TypeParameter;\r\n        constraintType?: Type;\r\n        templateType?: Type;\r\n        modifiersType?: Type;\r\n    }\r\n\r\n    export interface EvolvingArrayType extends ObjectType {\r\n        elementType: Type;      // Element expressions of evolving array type\r\n        finalArrayType?: Type;  // Final array type of evolving array type\r\n    }\r\n\r\n    /* @internal */\r\n    // Resolved object, union, or intersection type\r\n    export interface ResolvedType extends ObjectType, UnionOrIntersectionType {\r\n        members: SymbolTable;              // Properties by name\r\n        properties: Symbol[];              // Properties\r\n        callSignatures: Signature[];       // Call signatures of type\r\n        constructSignatures: Signature[];  // Construct signatures of type\r\n        stringIndexInfo?: IndexInfo;       // String indexing info\r\n        numberIndexInfo?: IndexInfo;       // Numeric indexing info\r\n    }\r\n\r\n    /* @internal */\r\n    // Object literals are initially marked fresh. Freshness disappears following an assignment,\r\n    // before a type assertion, or when  an object literal's type is widened. The regular\r\n    // version of a fresh type is identical except for the TypeFlags.FreshObjectLiteral flag.\r\n    export interface FreshObjectLiteralType extends ResolvedType {\r\n        regularType: ResolvedType;  // Regular version of fresh type 普通版的清新型\r\n    }\r\n\r\n    // Just a place to cache element types of iterables and iterators\r\n    /* @internal */\r\n    export interface IterableOrIteratorType extends ObjectType, UnionType {\r\n        iteratedTypeOfIterable?: Type;\r\n        iteratedTypeOfIterator?: Type;\r\n        iteratedTypeOfAsyncIterable?: Type;\r\n        iteratedTypeOfAsyncIterator?: Type;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface PromiseOrAwaitableType extends ObjectType, UnionType {\r\n        promiseTypeOfPromiseConstructor?: Type;\r\n        promisedTypeOfPromise?: Type;\r\n        awaitedTypeOfType?: Type;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SyntheticDefaultModuleType extends Type {\r\n        syntheticType?: Type;\r\n    }\r\n\r\n    export interface TypeVariable extends Type {\r\n        /* @internal */\r\n        resolvedBaseConstraint: Type;\r\n        /* @internal */\r\n        resolvedIndexType: IndexType;\r\n    }\r\n\r\n    // Type parameters (TypeFlags.TypeParameter)\r\n    export interface TypeParameter extends TypeVariable {\r\n        /** Retrieve using getConstraintFromTypeParameter */\r\n        constraint: Type;        // Constraint\r\n        default?: Type;\r\n        /* @internal */\r\n        target?: TypeParameter;  // Instantiation target\r\n        /* @internal */\r\n        mapper?: TypeMapper;     // Instantiation mapper\r\n        /* @internal */\r\n        isThisType?: boolean;\r\n        /* @internal */\r\n        resolvedDefaultType?: Type;\r\n    }\r\n\r\n    // Indexed access types (TypeFlags.IndexedAccess)\r\n    // Possible forms are T[xxx], xxx[T], or xxx[keyof T], where T is a type variable\r\n    export interface IndexedAccessType extends TypeVariable {\r\n        objectType: Type;\r\n        indexType: Type;\r\n        constraint?: Type;\r\n    }\r\n\r\n    // keyof T types (TypeFlags.Index)\r\n    export interface IndexType extends Type {\r\n        type: TypeVariable | UnionOrIntersectionType;\r\n    }\r\n\r\n    export const enum SignatureKind {\r\n        Call,\r\n        Construct,\r\n    }\r\n\r\n    export interface Signature {\r\n        declaration: SignatureDeclaration;  // Originating declaration\r\n        typeParameters?: TypeParameter[];   // Type parameters (undefined if non-generic)\r\n        parameters: Symbol[];               // Parameters\r\n        /* @internal */\r\n        thisParameter?: Symbol;             // symbol of this-type parameter\r\n        /* @internal */\r\n        resolvedReturnType: Type;           // Resolved return type\r\n        /* @internal */\r\n        minArgumentCount: number;           // Number of non-optional parameters\r\n        /* @internal */\r\n        hasRestParameter: boolean;          // True if last parameter is rest parameter\r\n        /* @internal */\r\n        hasLiteralTypes: boolean;           // True if specialized\r\n        /* @internal */\r\n        target?: Signature;                 // Instantiation target\r\n        /* @internal */\r\n        mapper?: TypeMapper;                // Instantiation mapper\r\n        /* @internal */\r\n        unionSignatures?: Signature[];      // Underlying signatures of a union signature\r\n        /* @internal */\r\n        erasedSignatureCache?: Signature;   // Erased version of signature (deferred)\r\n        /* @internal */\r\n        canonicalSignatureCache?: Signature; // Canonical version of signature (deferred)\r\n        /* @internal */\r\n        isolatedSignatureType?: ObjectType; // A manufactured type that just contains the signature for purposes of signature comparison\r\n        /* @internal */\r\n        typePredicate?: TypePredicate;\r\n        /* @internal */\r\n        instantiations?: Map<Signature>;    // Generic signature instantiation cache\r\n    }\r\n\r\n    export const enum IndexKind {\r\n        String,\r\n        Number,\r\n    }\r\n\r\n    export interface IndexInfo {\r\n        type: Type;\r\n        isReadonly: boolean;\r\n        declaration?: SignatureDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TypeMapper {\r\n        (t: TypeParameter): Type;\r\n    }\r\n\r\n    export const enum InferencePriority {\r\n        Contravariant = 1 << 0,  // Inference from contravariant position\r\n        NakedTypeVariable = 1 << 1,  // Naked type variable in union or intersection type\r\n        MappedType = 1 << 2,  // Reverse inference for mapped type\r\n        ReturnType = 1 << 3,  // Inference made from return type of generic function\r\n    }\r\n\r\n    export interface InferenceInfo {\r\n        typeParameter: TypeParameter;\r\n        candidates: Type[];\r\n        inferredType: Type;\r\n        priority: InferencePriority;\r\n        topLevel: boolean;\r\n        isFixed: boolean;\r\n    }\r\n\r\n    export const enum InferenceFlags {\r\n        InferUnionTypes = 1 << 0,  // Infer union types for disjoint candidates (otherwise unknownType)\r\n        NoDefault = 1 << 1,  // Infer unknownType for no inferences (otherwise anyType or emptyObjectType)\r\n        AnyDefault = 1 << 2,  // Infer anyType for no inferences (otherwise emptyObjectType)\r\n    }\r\n\r\n    /**\r\n     * Ternary values are defined such that\r\n     * x & y is False if either x or y is False.\r\n     * x & y is Maybe if either x or y is Maybe, but neither x or y is False.\r\n     * x & y is True if both x and y are True.\r\n     * x | y is False if both x and y are False.\r\n     * x | y is Maybe if either x or y is Maybe, but neither x or y is True.\r\n     * x | y is True if either x or y is True.\r\n     */\r\n    export const enum Ternary {\r\n        False = 0,\r\n        Maybe = 1,\r\n        True = -1\r\n    }\r\n\r\n    export type TypeComparer = (s: Type, t: Type, reportErrors?: boolean) => Ternary;\r\n\r\n    /* @internal */\r\n    export interface InferenceContext extends TypeMapper {\r\n        signature: Signature;               // Generic signature for which inferences are made\r\n        inferences: InferenceInfo[];        // Inferences made for each type parameter\r\n        flags: InferenceFlags;              // Inference flags\r\n        compareTypes: TypeComparer;         // Type comparer function\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SpecialPropertyAssignmentKind {\r\n        None,\r\n        /// exports.name = expr\r\n        ExportsProperty,\r\n        /// module.exports = expr\r\n        ModuleExports,\r\n        /// className.prototype.name = expr\r\n        PrototypeProperty,\r\n        /// this.name = expr\r\n        ThisProperty,\r\n        // F.name = expr\r\n        Property\r\n    }\r\n\r\n    export interface JsFileExtensionInfo {\r\n        extension: string;\r\n        isMixedContent: boolean;\r\n        scriptKind?: ScriptKind;\r\n    }\r\n\r\n    export interface DiagnosticMessage {\r\n        key: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        message: string;\r\n    }\r\n\r\n    /**\r\n     * A linked list of formatted diagnostic messages to be used as part of a multiline message.\r\n     * It is built from the bottom up, leaving the head to be the \"main\" diagnostic.\r\n     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\r\n     * the difference is that messages are all preformatted in DMC.\r\n     */\r\n    export interface DiagnosticMessageChain {\r\n        messageText: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        next?: DiagnosticMessageChain;\r\n    }\r\n\r\n    export interface Diagnostic {\r\n        file: SourceFile | undefined;\r\n        start: number | undefined;\r\n        length: number | undefined;\r\n        messageText: string | DiagnosticMessageChain;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        source?: string;\r\n    }\r\n\r\n    export enum DiagnosticCategory {\r\n        Warning,\r\n        Error,\r\n        Message\r\n    }\r\n\r\n    export enum ModuleResolutionKind {\r\n        Classic = 1,\r\n        NodeJs = 2\r\n    }\r\n\r\n    export interface PluginImport {\r\n        name: string;\r\n    }\r\n\r\n    export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | null | undefined;\r\n\r\n    export interface CompilerOptions {\r\n        /*@internal*/ all?: boolean;\r\n        allowJs?: boolean;\r\n        /*@internal*/ allowNonTsExtensions?: boolean;\r\n        allowSyntheticDefaultImports?: boolean;\r\n        allowUnreachableCode?: boolean;\r\n        allowUnusedLabels?: boolean;\r\n        alwaysStrict?: boolean;  // Always combine with strict property\r\n        baseUrl?: string;\r\n        charset?: string;\r\n        checkJs?: boolean;\r\n        /* @internal */ configFilePath?: string;\r\n        /** configFile is set as non enumerable property so as to avoid checking of json source files */\r\n        /* @internal */ readonly configFile?: JsonSourceFile;\r\n        declaration?: boolean;\r\n        declarationDir?: string;\r\n        /* @internal */ diagnostics?: boolean;\r\n        /* @internal */ extendedDiagnostics?: boolean;\r\n        disableSizeLimit?: boolean;\r\n        downlevelIteration?: boolean;\r\n        emitBOM?: boolean;\r\n        emitDecoratorMetadata?: boolean;\r\n        experimentalDecorators?: boolean;\r\n        forceConsistentCasingInFileNames?: boolean;\r\n        /*@internal*/help?: boolean;\r\n        importHelpers?: boolean;\r\n        /*@internal*/init?: boolean;\r\n        inlineSourceMap?: boolean;\r\n        inlineSources?: boolean;\r\n        isolatedModules?: boolean;\r\n        jsx?: JsxEmit;\r\n        lib?: string[];\r\n        /*@internal*/listEmittedFiles?: boolean;\r\n        /*@internal*/listFiles?: boolean;\r\n        locale?: string;\r\n        mapRoot?: string;\r\n        maxNodeModuleJsDepth?: number;\r\n        module?: ModuleKind;\r\n        moduleResolution?: ModuleResolutionKind;\r\n        newLine?: NewLineKind;\r\n        noEmit?: boolean;\r\n        /*@internal*/noEmitForJsFiles?: boolean;\r\n        noEmitHelpers?: boolean;\r\n        noEmitOnError?: boolean;\r\n        noErrorTruncation?: boolean;\r\n        noFallthroughCasesInSwitch?: boolean;\r\n        noImplicitAny?: boolean;  // Always combine with strict property\r\n        noImplicitReturns?: boolean;\r\n        noImplicitThis?: boolean;  // Always combine with strict property\r\n        noStrictGenericChecks?: boolean;\r\n        noUnusedLocals?: boolean;\r\n        noUnusedParameters?: boolean;\r\n        noImplicitUseStrict?: boolean;\r\n        noLib?: boolean;\r\n        noResolve?: boolean;\r\n        out?: string;\r\n        outDir?: string;\r\n        outFile?: string;\r\n        paths?: MapLike<string[]>;\r\n        /*@internal*/ plugins?: PluginImport[];\r\n        preserveConstEnums?: boolean;\r\n        preserveSymlinks?: boolean;\r\n        project?: string;\r\n        /* @internal */ pretty?: DiagnosticStyle;\r\n        reactNamespace?: string;\r\n        jsxFactory?: string;\r\n        removeComments?: boolean;\r\n        rootDir?: string;\r\n        rootDirs?: string[];\r\n        skipLibCheck?: boolean;\r\n        skipDefaultLibCheck?: boolean;\r\n        sourceMap?: boolean;\r\n        sourceRoot?: string;\r\n        strict?: boolean;\r\n        strictFunctionTypes?: boolean;  // Always combine with strict property\r\n        strictNullChecks?: boolean;  // Always combine with strict property\r\n        /* @internal */ stripInternal?: boolean;\r\n        suppressExcessPropertyErrors?: boolean;\r\n        suppressImplicitAnyIndexErrors?: boolean;\r\n        /* @internal */ suppressOutputPathCheck?: boolean;\r\n        target?: ScriptTarget;\r\n        traceResolution?: boolean;\r\n        types?: string[];\r\n        /** Paths used to compute primary types search locations */\r\n        typeRoots?: string[];\r\n        /*@internal*/ version?: boolean;\r\n        /*@internal*/ watch?: boolean;\r\n        使用中文支持库?: boolean;\r\n        中文关键字?: boolean;\r\n        转译Ts?: boolean;\r\n        转译Cts?: boolean;\r\n        转译声明?: boolean;\r\n        输出无词典标识符?: boolean;\r\n        词典在文件尾?: boolean;\r\n        词典不重复输出?: boolean;\r\n        [option: string]: CompilerOptionsValue | JsonSourceFile | undefined;\r\n    }\r\n\r\n    export interface TypeAcquisition {\r\n        /* @deprecated typingOptions.enableAutoDiscovery\r\n         * Use typeAcquisition.enable instead.\r\n         */\r\n        enableAutoDiscovery?: boolean;\r\n        enable?: boolean;\r\n        include?: string[];\r\n        exclude?: string[];\r\n        [option: string]: string[] | boolean | undefined;\r\n    }\r\n\r\n    export interface DiscoverTypingsInfo {\r\n        fileNames: string[];                            // The file names that belong to the same project.\r\n        projectRootPath: string;                        // The path to the project root directory\r\n        safeListPath: string;                           // The path used to retrieve the safe list\r\n        packageNameToTypingLocation: Map<string>;       // The map of package names to their cached typing locations\r\n        typeAcquisition: TypeAcquisition;               // Used to customize the type acquisition process\r\n        compilerOptions: CompilerOptions;               // Used as a source for typing inference\r\n        unresolvedImports: ReadonlyArray<string>;       // List of unresolved module ids from imports\r\n    }\r\n\r\n\r\n    export enum ModuleKind {\r\n        None = 0,\r\n        CommonJS = 1,\r\n        AMD = 2,\r\n        UMD = 3,\r\n        System = 4,\r\n        ES2015 = 5,\r\n        ESNext = 6\r\n    }\r\n\r\n    export const enum JsxEmit {\r\n        None = 0,\r\n        Preserve = 1,\r\n        React = 2,\r\n        ReactNative = 3\r\n    }\r\n\r\n    export const enum NewLineKind {\r\n        CarriageReturnLineFeed = 0,\r\n        LineFeed = 1\r\n    }\r\n\r\n    export interface LineAndCharacter {\r\n        /** 0-based. */\r\n        line: number;\r\n        /*\r\n         * 0-based. This value denotes the character position in line and is different from the 'column' because of tab characters.\r\n         */\r\n        character: number;\r\n    }\r\n\r\n    export const enum ScriptKind {\r\n        Unknown = 0,\r\n        JS = 1,\r\n        JSX = 2,\r\n        TS = 3,\r\n        CTS = 4,\r\n        TSX = 5,\r\n        CTSX = 6,\r\n        External = 7,\r\n        JSON = 8\r\n    }\r\n\r\n    export const enum ScriptTarget {\r\n        ES3 = 0,\r\n        ES5 = 1,\r\n        ES2015 = 2,\r\n        ES2016 = 3,\r\n        ES2017 = 4,\r\n        ESNext = 5,\r\n        Latest = ESNext,\r\n    }\r\n\r\n    export const enum LanguageVariant {\r\n        Standard,\r\n        JSX,\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum DiagnosticStyle {\r\n        Simple,\r\n        Pretty,\r\n    }\r\n\r\n    /** Either a parsed command line or a parsed tsconfig.json */\r\n    export interface ParsedCommandLine {\r\n        options: CompilerOptions;\r\n        typeAcquisition?: TypeAcquisition;\r\n        fileNames: string[];\r\n        raw?: any;\r\n        errors: Diagnostic[];\r\n        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\r\n        compileOnSave?: boolean;\r\n        /* @internal */ configFileSpecs?: ConfigFileSpecs;\r\n    }\r\n\r\n    export const enum WatchDirectoryFlags {\r\n        None = 0,\r\n        Recursive = 1 << 0,\r\n    }\r\n\r\n    /* @internal */\r\n    export interface ConfigFileSpecs {\r\n        filesSpecs: ReadonlyArray<string>;\r\n        /**\r\n         * Present to report errors (user specified specs), validatedIncludeSpecs are used for file name matching\r\n         */\r\n        includeSpecs: ReadonlyArray<string>;\r\n        /**\r\n         * Present to report errors (user specified specs), validatedExcludeSpecs are used for file name matching\r\n         */\r\n        excludeSpecs: ReadonlyArray<string>;\r\n        validatedIncludeSpecs: ReadonlyArray<string>;\r\n        validatedExcludeSpecs: ReadonlyArray<string>;\r\n        wildcardDirectories: MapLike<WatchDirectoryFlags>;\r\n    }\r\n\r\n    export interface ExpandResult {\r\n        fileNames: string[];\r\n        wildcardDirectories: MapLike<WatchDirectoryFlags>;\r\n        /* @internal */ spec: ConfigFileSpecs;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionBase {\r\n        name: string;\r\n        别名?: string;\r\n        type: \"string\" | \"number\" | \"boolean\" | \"object\" | \"list\" | Map<number | string>;    // a value of a primitive type, or an object literal mapping named values to actual values\r\n        isFilePath?: boolean;                                   // True if option value is a path or fileName\r\n        shortName?: string;                                     // A short mnemonic for convenience - for instance, 'h' can be used in place of 'help'\r\n        description?: DiagnosticMessage;                        // The message describing what the command line switch does\r\n        paramType?: DiagnosticMessage;                          // The name to be used for a non-boolean option's parameter\r\n        isTSConfigOnly?: boolean;                               // True if option can only be specified via tsconfig.json file\r\n        isCommandLineOnly?: boolean;\r\n        showInSimplifiedHelpView?: boolean;\r\n        category?: DiagnosticMessage;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfPrimitiveType extends CommandLineOptionBase {\r\n        type: \"string\" | \"number\" | \"boolean\";\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfCustomType extends CommandLineOptionBase {\r\n        type: Map<number | string>;  // an object literal mapping named values to actual values\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TsConfigOnlyOption extends CommandLineOptionBase {\r\n        type: \"object\";\r\n        elementOptions?: Map<CommandLineOption>;\r\n        extraKeyDiagnosticMessage?: DiagnosticMessage;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfListType extends CommandLineOptionBase {\r\n        type: \"list\";\r\n        element: CommandLineOptionOfCustomType | CommandLineOptionOfPrimitiveType | TsConfigOnlyOption;\r\n    }\r\n\r\n    /* @internal */\r\n    export type CommandLineOption = CommandLineOptionOfCustomType | CommandLineOptionOfPrimitiveType | TsConfigOnlyOption | CommandLineOptionOfListType;\r\n\r\n    /* @internal */\r\n    export const enum CharacterCodes {\r\n        nullCharacter = 0,\r\n        maxAsciiCharacter = 0x7F,\r\n\r\n        lineFeed = 0x0A,              // \\n\r\n        carriageReturn = 0x0D,        // \\r\r\n        lineSeparator = 0x2028,\r\n        paragraphSeparator = 0x2029,\r\n        nextLine = 0x0085,\r\n\r\n        // Unicode 3.0 space characters\r\n        space = 0x0020,   // \" \"\r\n        nonBreakingSpace = 0x00A0,   //\r\n        enQuad = 0x2000,\r\n        emQuad = 0x2001,\r\n        enSpace = 0x2002,\r\n        emSpace = 0x2003,\r\n        threePerEmSpace = 0x2004,\r\n        fourPerEmSpace = 0x2005,\r\n        sixPerEmSpace = 0x2006,\r\n        figureSpace = 0x2007,\r\n        punctuationSpace = 0x2008,\r\n        thinSpace = 0x2009,\r\n        hairSpace = 0x200A,\r\n        zeroWidthSpace = 0x200B,\r\n        narrowNoBreakSpace = 0x202F,\r\n        ideographicSpace = 0x3000,\r\n        mathematicalSpace = 0x205F,\r\n        ogham = 0x1680,\r\n\r\n        _ = 0x5F,\r\n        $ = 0x24,\r\n\r\n        _0 = 0x30,\r\n        _1 = 0x31,\r\n        _2 = 0x32,\r\n        _3 = 0x33,\r\n        _4 = 0x34,\r\n        _5 = 0x35,\r\n        _6 = 0x36,\r\n        _7 = 0x37,\r\n        _8 = 0x38,\r\n        _9 = 0x39,\r\n\r\n        a = 0x61,\r\n        b = 0x62,\r\n        c = 0x63,\r\n        d = 0x64,\r\n        e = 0x65,\r\n        f = 0x66,\r\n        g = 0x67,\r\n        h = 0x68,\r\n        i = 0x69,\r\n        j = 0x6A,\r\n        k = 0x6B,\r\n        l = 0x6C,\r\n        m = 0x6D,\r\n        n = 0x6E,\r\n        o = 0x6F,\r\n        p = 0x70,\r\n        q = 0x71,\r\n        r = 0x72,\r\n        s = 0x73,\r\n        t = 0x74,\r\n        u = 0x75,\r\n        v = 0x76,\r\n        w = 0x77,\r\n        x = 0x78,\r\n        y = 0x79,\r\n        z = 0x7A,\r\n\r\n        A = 0x41,\r\n        B = 0x42,\r\n        C = 0x43,\r\n        D = 0x44,\r\n        E = 0x45,\r\n        F = 0x46,\r\n        G = 0x47,\r\n        H = 0x48,\r\n        I = 0x49,\r\n        J = 0x4A,\r\n        K = 0x4B,\r\n        L = 0x4C,\r\n        M = 0x4D,\r\n        N = 0x4E,\r\n        O = 0x4F,\r\n        P = 0x50,\r\n        Q = 0x51,\r\n        R = 0x52,\r\n        S = 0x53,\r\n        T = 0x54,\r\n        U = 0x55,\r\n        V = 0x56,\r\n        W = 0x57,\r\n        X = 0x58,\r\n        Y = 0x59,\r\n        Z = 0x5a,\r\n\r\n        ampersand = 0x26,             // &\r\n        asterisk = 0x2A,              // *\r\n        at = 0x40,                    // @\r\n        backslash = 0x5C,             // \\\r\n        backtick = 0x60,              // `\r\n        bar = 0x7C,                   // |\r\n        caret = 0x5E,                 // ^\r\n        closeBrace = 0x7D,            // }\r\n        closeBracket = 0x5D,          // ]\r\n        closeParen = 0x29,            // )\r\n        colon = 0x3A,                 // :\r\n        comma = 0x2C,                 // ,\r\n        dot = 0x2E,                   // .\r\n        doubleQuote = 0x22,           // \"\r\n        equals = 0x3D,                // =\r\n        exclamation = 0x21,           // !\r\n        greaterThan = 0x3E,           // >\r\n        hash = 0x23,                  // #\r\n        lessThan = 0x3C,              // <\r\n        minus = 0x2D,                 // -\r\n        openBrace = 0x7B,             // {\r\n        openBracket = 0x5B,           // [\r\n        openParen = 0x28,             // (\r\n        percent = 0x25,               // %\r\n        plus = 0x2B,                  // +\r\n        question = 0x3F,              // ?\r\n        semicolon = 0x3B,             // ;\r\n        singleQuote = 0x27,           // '\r\n        slash = 0x2F,                 // /\r\n        tilde = 0x7E,                 // ~\r\n\r\n        backspace = 0x08,             // \\b\r\n        formFeed = 0x0C,              // \\f\r\n        byteOrderMark = 0xFEFF,\r\n        tab = 0x09,                   // \\t\r\n        verticalTab = 0x0B,           // \\v\r\n    }\r\n\r\n    export interface ModuleResolutionHost {\r\n        fileExists(fileName: string): boolean;\r\n        // readFile function is used to read arbitrary text files on disk, i.e. when resolution procedure needs the content of 'package.json'\r\n        // to determine location of bundled typings for node module\r\n        readFile(fileName: string): string | undefined;\r\n        trace?(s: string): void;\r\n        directoryExists?(directoryName: string): boolean;\r\n        /**\r\n         * Resolve a symbolic link.\r\n         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options\r\n         */\r\n        realpath?(path: string): string;\r\n        getCurrentDirectory?(): string;\r\n        getDirectories?(path: string): string[];\r\n    }\r\n\r\n    /**\r\n     * Represents the result of module resolution.\r\n     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.\r\n     * The Program will then filter results based on these flags.\r\n     *\r\n     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.\r\n     */\r\n    export interface ResolvedModule {\r\n        /** Path of the file the module was resolved to. */\r\n        resolvedFileName: string;\r\n        /** True if `resolvedFileName` comes from `node_modules`. */\r\n        isExternalLibraryImport?: boolean;\r\n    }\r\n\r\n    /**\r\n     * ResolvedModule with an explicitly provided `extension` property.\r\n     * Prefer this over `ResolvedModule`.\r\n     * If changing this, remember to change `moduleResolutionIsEqualTo`.\r\n     */\r\n    export interface ResolvedModuleFull extends ResolvedModule {\r\n        /**\r\n         * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.\r\n         * This is optional for backwards-compatibility, but will be added if not provided.\r\n         */\r\n        extension: Extension;\r\n        packageId?: PackageId;\r\n    }\r\n\r\n    /**\r\n     * Unique identifier with a package name and version.\r\n     * If changing this, remember to change `packageIdIsEqual`.\r\n     */\r\n    export interface PackageId {\r\n        /**\r\n         * Name of the package.\r\n         * Should not include `@types`.\r\n         * If accessing a non-index file, this should include its name e.g. \"foo/bar\".\r\n         */\r\n        name: string;\r\n        /**\r\n         * Name of a submodule within this package.\r\n         * May be \"\".\r\n         */\r\n        subModuleName: string;\r\n        /** Version of the package, e.g. \"1.2.3\" */\r\n        version: string;\r\n    }\r\n\r\n    export const enum Extension {\r\n        Ts = \".ts\",\r\n        Tsx = \".tsx\",\r\n        CTs = \".cts\",\r\n        CTsx = \".ctsx\",\r\n        Dts = \".d.ts\",\r\n        DCts = \".d.cts\",\r\n        Js = \".js\",\r\n        Jsx = \".jsx\",\r\n        Json = \".json\"\r\n    }\r\n\r\n    export interface ResolvedModuleWithFailedLookupLocations {\r\n        readonly resolvedModule: ResolvedModuleFull | undefined;\r\n        /* @internal */\r\n        readonly failedLookupLocations: ReadonlyArray<string>;\r\n    }\r\n\r\n    export interface ResolvedTypeReferenceDirective {\r\n        // True if the type declaration file was found in a primary lookup location\r\n        primary: boolean;\r\n        // The location of the .d.ts file we located, or undefined if resolution failed\r\n        resolvedFileName: string | undefined;\r\n        packageId?: PackageId;\r\n    }\r\n\r\n    export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\r\n        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective;\r\n        readonly failedLookupLocations: ReadonlyArray<string>;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface HasInvalidatedResolution {\r\n        (sourceFile: Path): boolean;\r\n    }\r\n\r\n    export interface CompilerHost extends ModuleResolutionHost {\r\n        getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\r\n        getSourceFileByPath?(fileName: string, path: Path, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\r\n        getCancellationToken?(): CancellationToken;\r\n        getDefaultLibFileName(options: CompilerOptions): string;\r\n        getDefaultLibLocation?(): string;\r\n        writeFile: WriteFileCallback;\r\n        getCurrentDirectory(): string;\r\n        getDirectories(path: string): string[];\r\n        getCanonicalFileName(fileName: string): string;\r\n        useCaseSensitiveFileNames(): boolean;\r\n        getNewLine(): string;\r\n\r\n        /*\r\n         * CompilerHost must either implement resolveModuleNames (in case if it wants to be completely in charge of\r\n         * module name resolution) or provide implementation for methods from ModuleResolutionHost (in this case compiler\r\n         * will apply built-in module resolution logic and use members of ModuleResolutionHost to ask host specific questions).\r\n         * If resolveModuleNames is implemented then implementation for members from ModuleResolutionHost can be just\r\n         * 'throw new Error(\"NotImplemented\")'\r\n         */\r\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames?: string[]): ResolvedModule[];\r\n        /**\r\n         * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files\r\n         */\r\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string): ResolvedTypeReferenceDirective[];\r\n        getEnvironmentVariable?(name: string): string;\r\n        /* @internal */ onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions): void;\r\n        /* @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;\r\n        /* @internal */ hasChangedAutomaticTypeDirectiveNames?: boolean;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum TransformFlags {\r\n        None = 0,\r\n\r\n        // Facts\r\n        // - Flags used to indicate that a node or subtree contains syntax that requires transformation.\r\n        TypeScript = 1 << 0,\r\n        ContainsTypeScript = 1 << 1,\r\n        ContainsJsx = 1 << 2,\r\n        ContainsESNext = 1 << 3,\r\n        ContainsES2017 = 1 << 4,\r\n        ContainsES2016 = 1 << 5,\r\n        ES2015 = 1 << 6,\r\n        ContainsES2015 = 1 << 7,\r\n        Generator = 1 << 8,\r\n        ContainsGenerator = 1 << 9,\r\n        DestructuringAssignment = 1 << 10,\r\n        ContainsDestructuringAssignment = 1 << 11,\r\n\r\n        // Markers\r\n        // - Flags used to indicate that a subtree contains a specific transformation.\r\n        ContainsDecorators = 1 << 12,\r\n        ContainsPropertyInitializer = 1 << 13,\r\n        ContainsLexicalThis = 1 << 14,\r\n        ContainsCapturedLexicalThis = 1 << 15,\r\n        ContainsLexicalThisInComputedPropertyName = 1 << 16,\r\n        ContainsDefaultValueAssignments = 1 << 17,\r\n        ContainsParameterPropertyAssignments = 1 << 18,\r\n        ContainsSpread = 1 << 19,\r\n        ContainsObjectSpread = 1 << 20,\r\n        ContainsRest = ContainsSpread,\r\n        ContainsObjectRest = ContainsObjectSpread,\r\n        ContainsComputedPropertyName = 1 << 21,\r\n        ContainsBlockScopedBinding = 1 << 22,\r\n        ContainsBindingPattern = 1 << 23,\r\n        ContainsYield = 1 << 24,\r\n        ContainsHoistedDeclarationOrCompletion = 1 << 25,\r\n        ContainsDynamicImport = 1 << 26,\r\n\r\n        // Please leave this as 1 << 29.\r\n        // It is the maximum bit we can set before we outgrow the size of a v8 small integer (SMI) on an x86 system.\r\n        // It is a good reminder of how much room we have left\r\n        HasComputedFlags = 1 << 29, // Transform flags have been computed.\r\n\r\n        // Assertions\r\n        // - Bitmasks that are used to assert facts about the syntax of a node and its subtree.\r\n        AssertTypeScript = TypeScript | ContainsTypeScript,\r\n        AssertJsx = ContainsJsx,\r\n        AssertESNext = ContainsESNext,\r\n        AssertES2017 = ContainsES2017,\r\n        AssertES2016 = ContainsES2016,\r\n        AssertES2015 = ES2015 | ContainsES2015,\r\n        AssertGenerator = Generator | ContainsGenerator,\r\n        AssertDestructuringAssignment = DestructuringAssignment | ContainsDestructuringAssignment,\r\n\r\n        // Scope Exclusions\r\n        // - Bitmasks that exclude flags from propagating out of a specific context\r\n        //   into the subtree flags of their container.\r\n        NodeExcludes = TypeScript | ES2015 | DestructuringAssignment | Generator | HasComputedFlags,\r\n        ArrowFunctionExcludes = NodeExcludes | ContainsDecorators | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsParameterPropertyAssignments | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        FunctionExcludes = NodeExcludes | ContainsDecorators | ContainsDefaultValueAssignments | ContainsCapturedLexicalThis | ContainsLexicalThis | ContainsParameterPropertyAssignments | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        ConstructorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        MethodOrAccessorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        ClassExcludes = NodeExcludes | ContainsDecorators | ContainsPropertyInitializer | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsComputedPropertyName | ContainsParameterPropertyAssignments | ContainsLexicalThisInComputedPropertyName,\r\n        ModuleExcludes = NodeExcludes | ContainsDecorators | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsHoistedDeclarationOrCompletion,\r\n        TypeExcludes = ~ContainsTypeScript,\r\n        ObjectLiteralExcludes = NodeExcludes | ContainsDecorators | ContainsComputedPropertyName | ContainsLexicalThisInComputedPropertyName | ContainsObjectSpread,\r\n        ArrayLiteralOrCallOrNewExcludes = NodeExcludes | ContainsSpread,\r\n        VariableDeclarationListExcludes = NodeExcludes | ContainsBindingPattern | ContainsObjectRest,\r\n        ParameterExcludes = NodeExcludes,\r\n        CatchClauseExcludes = NodeExcludes | ContainsObjectRest,\r\n        BindingPatternExcludes = NodeExcludes | ContainsRest,\r\n\r\n        // Masks\r\n        // - Additional bitmasks\r\n        TypeScriptClassSyntaxMask = ContainsParameterPropertyAssignments | ContainsPropertyInitializer | ContainsDecorators,\r\n        ES2015FunctionSyntaxMask = ContainsCapturedLexicalThis | ContainsDefaultValueAssignments,\r\n    }\r\n\r\n    export interface SourceMapRange extends TextRange {\r\n        source?: SourceMapSource;\r\n    }\r\n\r\n    export interface SourceMapSource {\r\n        fileName: string;\r\n        text: string;\r\n        /* @internal */ lineMap: ReadonlyArray<number>;\r\n        skipTrivia?: (pos: number) => number;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitNode {\r\n        annotatedNodes?: Node[];                 // Tracks Parse-tree nodes with EmitNodes for eventual cleanup.\r\n        flags?: EmitFlags;                       // Flags that customize emit\r\n        leadingComments?: SynthesizedComment[];  // Synthesized leading comments\r\n        trailingComments?: SynthesizedComment[]; // Synthesized trailing comments\r\n        commentRange?: TextRange;                // The text range to use when emitting leading or trailing comments\r\n        sourceMapRange?: SourceMapRange;         // The text range to use when emitting leading or trailing source mappings\r\n        tokenSourceMapRanges?: SourceMapRange[]; // The text range to use when emitting source mappings for tokens\r\n        constantValue?: string | number;         // The constant value of an expression\r\n        externalHelpersModuleName?: Identifier;  // The local name for an imported helpers module\r\n        helpers?: EmitHelper[];                  // Emit helpers for the node\r\n    }\r\n\r\n    export const enum EmitFlags {\r\n        SingleLine = 1 << 0,                    // The contents of this node should be emitted on a single line.\r\n        AdviseOnEmitNode = 1 << 1,              // The printer should invoke the onEmitNode callback when printing this node.\r\n        NoSubstitution = 1 << 2,                // Disables further substitution of an expression.\r\n        CapturesThis = 1 << 3,                  // The function captures a lexical `this`\r\n        NoLeadingSourceMap = 1 << 4,            // Do not emit a leading source map location for this node.\r\n        NoTrailingSourceMap = 1 << 5,           // Do not emit a trailing source map location for this node.\r\n        NoSourceMap = NoLeadingSourceMap | NoTrailingSourceMap, // Do not emit a source map location for this node.\r\n        NoNestedSourceMaps = 1 << 6,            // Do not emit source map locations for children of this node.\r\n        NoTokenLeadingSourceMaps = 1 << 7,      // Do not emit leading source map location for token nodes.\r\n        NoTokenTrailingSourceMaps = 1 << 8,     // Do not emit trailing source map location for token nodes.\r\n        NoTokenSourceMaps = NoTokenLeadingSourceMaps | NoTokenTrailingSourceMaps, // Do not emit source map locations for tokens of this node.\r\n        NoLeadingComments = 1 << 9,             // Do not emit leading comments for this node.\r\n        NoTrailingComments = 1 << 10,           // Do not emit trailing comments for this node.\r\n        NoComments = NoLeadingComments | NoTrailingComments, // Do not emit comments for this node.\r\n        NoNestedComments = 1 << 11,\r\n        HelperName = 1 << 12,\r\n        ExportName = 1 << 13,                   // Ensure an export prefix is added for an identifier that points to an exported declaration with a local name (see SymbolFlags.ExportHasLocal).\r\n        LocalName = 1 << 14,                    // Ensure an export prefix is not added for an identifier that points to an exported declaration.\r\n        InternalName = 1 << 15,                 // The name is internal to an ES5 class body function.\r\n        Indented = 1 << 16,                     // Adds an explicit extra indentation level for class and function bodies when printing (used to match old emitter).\r\n        NoIndentation = 1 << 17,                // Do not indent the node.\r\n        AsyncFunctionBody = 1 << 18,\r\n        ReuseTempVariableScope = 1 << 19,       // Reuse the existing temp variable scope during emit.\r\n        CustomPrologue = 1 << 20,               // Treat the statement as if it were a prologue directive (NOTE: Prologue directives are *not* transformed).\r\n        NoHoisting = 1 << 21,                   // Do not hoist this declaration in --module system\r\n        HasEndOfDeclarationMarker = 1 << 22,    // Declaration has an associated NotEmittedStatement to mark the end of the declaration\r\n        Iterator = 1 << 23,                     // The expression to a `yield*` should be treated as an Iterator when down-leveling, not an Iterable.\r\n        NoAsciiEscaping = 1 << 24,              // When synthesizing nodes that lack an original node or textSourceNode, we want to write the text on the node with ASCII escaping substitutions.\r\n        /*@internal*/ TypeScriptClassWrapper = 1 << 25, // The node is an IIFE class wrapper created by the ts transform.\r\n    }\r\n\r\n    export interface EmitHelper {\r\n        readonly name: string;      // A unique name for this helper.\r\n        readonly scoped: boolean;   // Indicates whether the helper MUST be emitted in the current scope.\r\n        readonly text: string;      // ES3-compatible raw script text.\r\n        readonly priority?: number; // Helpers with a higher priority are emitted earlier than other helpers on the node.\r\n    }\r\n\r\n    /**\r\n     * Used by the checker, this enum keeps track of external emit helpers that should be type\r\n     * checked.\r\n     */\r\n    /* @internal */\r\n    export const enum ExternalEmitHelpers {\r\n        Extends = 1 << 0,               // __extends (used by the ES2015 class transformation)\r\n        Assign = 1 << 1,                // __assign (used by Jsx and ESNext object spread transformations)\r\n        Rest = 1 << 2,                  // __rest (used by ESNext object rest transformation)\r\n        Decorate = 1 << 3,              // __decorate (used by TypeScript decorators transformation)\r\n        Metadata = 1 << 4,              // __metadata (used by TypeScript decorators transformation)\r\n        Param = 1 << 5,                 // __param (used by TypeScript decorators transformation)\r\n        Awaiter = 1 << 6,               // __awaiter (used by ES2017 async functions transformation)\r\n        Generator = 1 << 7,             // __generator (used by ES2015 generator transformation)\r\n        Values = 1 << 8,                // __values (used by ES2015 for..of and yield* transformations)\r\n        Read = 1 << 9,                  // __read (used by ES2015 iterator destructuring transformation)\r\n        Spread = 1 << 10,               // __spread (used by ES2015 array spread and argument list spread transformations)\r\n        Await = 1 << 11,                // __await (used by ES2017 async generator transformation)\r\n        AsyncGenerator = 1 << 12,       // __asyncGenerator (used by ES2017 async generator transformation)\r\n        AsyncDelegator = 1 << 13,       // __asyncDelegator (used by ES2017 async generator yield* transformation)\r\n        AsyncValues = 1 << 14,          // __asyncValues (used by ES2017 for..await..of transformation)\r\n        ExportStar = 1 << 15,           // __exportStar (used by CommonJS/AMD/UMD module transformation)\r\n\r\n        MakeTemplateObject = 1 << 16,   // __makeTemplateObject (used for constructing template string array objects)\r\n        PropName = 1 << 17,                 // __propName (used by 转换CTS module transformation)\r\n\r\n        FirstEmitHelper = Extends,\r\n        LastEmitHelper = PropName,\r\n\r\n        // Helpers included by ES2015 for..of\r\n        ForOfIncludes = Values,\r\n\r\n        // Helpers included by ES2017 for..await..of\r\n        ForAwaitOfIncludes = AsyncValues,\r\n\r\n        // Helpers included by ES2017 async generators\r\n        AsyncGeneratorIncludes = Await | AsyncGenerator,\r\n\r\n        // Helpers included by yield* in ES2017 async generators\r\n        AsyncDelegatorIncludes = Await | AsyncDelegator | AsyncValues,\r\n\r\n        // Helpers included by ES2015 spread\r\n        SpreadIncludes = Read | Spread,\r\n\r\n    }\r\n\r\n    export const enum EmitHint {\r\n        SourceFile,          // Emitting a SourceFile\r\n        Expression,          // Emitting an Expression\r\n        IdentifierName,      // Emitting an IdentifierName\r\n        MappedTypeParameter, // Emitting a TypeParameterDeclaration inside of a MappedTypeNode\r\n        Unspecified,         // Emitting an otherwise unspecified node\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitHost extends ScriptReferenceHost {\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n\r\n        /* @internal */\r\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\r\n\r\n        getCommonSourceDirectory(): string;\r\n        getCanonicalFileName(fileName: string): string;\r\n        getNewLine(): string;\r\n\r\n        isEmitBlocked(emitFileName: string): boolean;\r\n\r\n        writeFile: WriteFileCallback;\r\n    }\r\n\r\n    export interface TransformationContext {\r\n        /*@internal*/ getEmitResolver(): EmitResolver;\r\n        /*@internal*/ getEmitHost(): EmitHost;\r\n\r\n        /** Gets the compiler options supplied to the transformer. */\r\n        getCompilerOptions(): CompilerOptions;\r\n\r\n        /** Starts a new lexical environment. */\r\n        startLexicalEnvironment(): void;\r\n\r\n        /** Suspends the current lexical environment, usually after visiting a parameter list. */\r\n        suspendLexicalEnvironment(): void;\r\n\r\n        /** Resumes a suspended lexical environment, usually before visiting a function body. */\r\n        resumeLexicalEnvironment(): void;\r\n\r\n        /** Ends a lexical environment, returning any declarations. */\r\n        endLexicalEnvironment(): Statement[];\r\n\r\n        /** Hoists a function declaration to the containing scope. */\r\n        hoistFunctionDeclaration(node: FunctionDeclaration): void;\r\n\r\n        /** Hoists a variable declaration to the containing scope. */\r\n        hoistVariableDeclaration(node: Identifier): void;\r\n\r\n        /** Records a request for a non-scoped emit helper in the current context. */\r\n        requestEmitHelper(helper: EmitHelper): void;\r\n\r\n        /** Gets and resets the requested non-scoped emit helpers. */\r\n        readEmitHelpers(): EmitHelper[] | undefined;\r\n\r\n        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */\r\n        enableSubstitution(kind: SyntaxKind): void;\r\n\r\n        /** Determines whether expression substitutions are enabled for the provided node. */\r\n        isSubstitutionEnabled(node: Node): boolean;\r\n\r\n        /**\r\n         * Hook used by transformers to substitute expressions just before they\r\n         * are emitted by the pretty printer.\r\n         *\r\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\r\n         * before returning the `NodeTransformer` callback.\r\n         */\r\n        onSubstituteNode: (hint: EmitHint, node: Node) => Node;\r\n\r\n        /**\r\n         * Enables before/after emit notifications in the pretty printer for the provided\r\n         * SyntaxKind.\r\n         */\r\n        enableEmitNotification(kind: SyntaxKind): void;\r\n\r\n        /**\r\n         * Determines whether before/after emit notifications should be raised in the pretty\r\n         * printer when it emits a node.\r\n         */\r\n        isEmitNotificationEnabled(node: Node): boolean;\r\n\r\n        /**\r\n         * Hook used to allow transformers to capture state before or after\r\n         * the printer emits a node.\r\n         *\r\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\r\n         * before returning the `NodeTransformer` callback.\r\n         */\r\n        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\r\n    }\r\n\r\n    export interface TransformationResult<T extends Node> {\r\n        /** Gets the transformed source files. */\r\n        transformed: T[];\r\n\r\n        /** Gets diagnostics for the transformation. */\r\n        diagnostics?: Diagnostic[];\r\n\r\n        /**\r\n         * Gets a substitute for a node, if one is available; otherwise, returns the original node.\r\n         *\r\n         * @param hint A hint as to the intended usage of the node.\r\n         * @param node The node to substitute.\r\n         */\r\n        substituteNode(hint: EmitHint, node: Node): Node;\r\n\r\n        /**\r\n         * Emits a node with possible notification.\r\n         *\r\n         * @param hint A hint as to the intended usage of the node.\r\n         * @param node The node to emit.\r\n         * @param emitCallback A callback used to emit the node.\r\n         */\r\n        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\r\n\r\n        /**\r\n         * Clean up EmitNode entries on any parse-tree nodes.\r\n         */\r\n        dispose(): void;\r\n    }\r\n\r\n    /**\r\n     * A function that is used to initialize and return a `Transformer` callback, which in turn\r\n     * will be used to transform one or more nodes.\r\n     */\r\n    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;\r\n\r\n    /**\r\n     * A function that transforms a node.\r\n     */\r\n    export type Transformer<T extends Node> = (node: T) => T;\r\n\r\n    /**\r\n     * A function that accepts and possibly transforms a node.\r\n     */\r\n    export type Visitor = (node: Node) => VisitResult<Node>;\r\n\r\n    export type VisitResult<T extends Node> = T | T[] | undefined;\r\n\r\n    export interface Printer {\r\n        /**\r\n         * Print a node and its subtree as-is, without any emit transformations.\r\n         * @param hint A value indicating the purpose of a node. This is primarily used to\r\n         * distinguish between an `Identifier` used in an expression position, versus an\r\n         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\r\n         * should just pass `Unspecified`.\r\n         * @param node The node to print. The node and its subtree are printed as-is, without any\r\n         * emit transformations.\r\n         * @param sourceFile A source file that provides context for the node. The source text of\r\n         * the file is used to emit the original source content for literals and identifiers, while\r\n         * the identifiers of the source file are used when generating unique names to avoid\r\n         * collisions.\r\n         */\r\n        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;\r\n        /**\r\n         * Prints a source file as-is, without any emit transformations.\r\n         */\r\n        printFile(sourceFile: SourceFile): string;\r\n        /**\r\n         * Prints a bundle of source files as-is, without any emit transformations.\r\n         */\r\n        printBundle(bundle: Bundle): string;\r\n        /*@internal*/ writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;\r\n        /*@internal*/ writeFile(sourceFile: SourceFile, writer: EmitTextWriter): void;\r\n        /*@internal*/ writeBundle(bundle: Bundle, writer: EmitTextWriter): void;\r\n    }\r\n\r\n    export interface PrintHandlers {\r\n        /**\r\n         * A hook used by the Printer when generating unique names to avoid collisions with\r\n         * globally defined names that exist outside of the current source file.\r\n         */\r\n        hasGlobalName?(name: string): boolean;\r\n        /**\r\n         * A hook used by the Printer to provide notifications prior to emitting a node. A\r\n         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and\r\n         * `node` values.\r\n         * @param hint A hint indicating the intended purpose of the node.\r\n         * @param node The node to emit.\r\n         * @param emitCallback A callback that, when invoked, will emit the node.\r\n         * @example\r\n         * ```ts\r\n         * var printer = createPrinter(printerOptions, {\r\n         *   onEmitNode(hint, node, emitCallback) {\r\n         *     // set up or track state prior to emitting the node...\r\n         *     emitCallback(hint, node);\r\n         *     // restore state after emitting the node...\r\n         *   }\r\n         * });\r\n         * ```\r\n         */\r\n        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\r\n        /**\r\n         * A hook used by the Printer to perform just-in-time substitution of a node. This is\r\n         * primarily used by node transformations that need to substitute one node for another,\r\n         * such as replacing `myExportedVar` with `exports.myExportedVar`.\r\n         * @param hint A hint indicating the intended purpose of the node.\r\n         * @param node The node to emit.\r\n         * @example\r\n         * ```ts\r\n         * var printer = createPrinter(printerOptions, {\r\n         *   substituteNode(hint, node) {\r\n         *     // perform substitution if necessary...\r\n         *     return node;\r\n         *   }\r\n         * });\r\n         * ```\r\n         */\r\n        substituteNode?(hint: EmitHint, node: Node): Node;\r\n        /*@internal*/ onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\r\n        /*@internal*/ onEmitSourceMapOfToken?: (node: Node, token: SyntaxKind, pos: number, emitCallback: (token: SyntaxKind, pos: number) => number) => number;\r\n        /*@internal*/ onEmitSourceMapOfPosition?: (pos: number) => void;\r\n        /*@internal*/ onEmitHelpers?: (node: Node, writeLines: (text: string) => void) => void;\r\n        /*@internal*/ onSetSourceFile?: (node: SourceFile) => void;\r\n        /*@internal*/ onBeforeEmitNodeArray?: (nodes: NodeArray<any>) => void;\r\n        /*@internal*/ onAfterEmitNodeArray?: (nodes: NodeArray<any>) => void;\r\n        /*@internal*/ onBeforeEmitToken?: (node: Node) => void;\r\n        /*@internal*/ onAfterEmitToken?: (node: Node) => void;\r\n    }\r\n\r\n    export interface PrinterOptions {\r\n        removeComments?: boolean;\r\n        newLine?: NewLineKind;\r\n        /*@internal*/ sourceMap?: boolean;\r\n        /*@internal*/ inlineSourceMap?: boolean;\r\n        /*@internal*/ extendedDiagnostics?: boolean;\r\n        /*@internal*/ 中文关键字?: boolean;\r\n    }\r\n\r\n    /*@internal*/\r\n    export interface EmitTextWriter {\r\n        write(s: string): void;\r\n        writeTextOfNode(text: string, node: Node): void;\r\n        writeLine(): void;\r\n        increaseIndent(): void;\r\n        decreaseIndent(): void;\r\n        getText(): string;\r\n        rawWrite(s: string): void;\r\n        writeLiteral(s: string): void;\r\n        getTextPos(): number;\r\n        getLine(): number;\r\n        getColumn(): number;\r\n        getIndent(): number;\r\n        isAtStartOfLine(): boolean;\r\n        reset(): void;\r\n    }\r\n\r\n    export interface TextSpan {\r\n        start: number;\r\n        length: number;\r\n    }\r\n\r\n    export interface TextChangeRange {\r\n        span: TextSpan;\r\n        newLength: number;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface DiagnosticCollection {\r\n        // Adds a diagnostic to this diagnostic collection.\r\n        add(diagnostic: Diagnostic): void;\r\n\r\n        // Gets all the diagnostics that aren't associated with a file.\r\n        getGlobalDiagnostics(): Diagnostic[];\r\n\r\n        // If fileName is provided, gets all the diagnostics associated with that file name.\r\n        // Otherwise, returns all the diagnostics (global and file associated) in this collection.\r\n        getDiagnostics(fileName?: string): Diagnostic[];\r\n\r\n        // Gets a count of how many times this collection has been modified.  This value changes\r\n        // each time 'add' is called (regardless of whether or not an equivalent diagnostic was\r\n        // already in the collection).  As such, it can be used as a simple way to tell if any\r\n        // operation caused diagnostics to be returned by storing and comparing the return value\r\n        // of this method before/after the operation is performed.\r\n        getModificationCount(): number;\r\n\r\n        /* @internal */ reattachFileDiagnostics(newFile: SourceFile): void;\r\n    }\r\n\r\n    // SyntaxKind.SyntaxList\r\n    export interface SyntaxList extends Node {\r\n        _children: Node[];\r\n    }\r\n}\r\n\r\nnamespace ts {\r\n\r\n    // 以下为CTS增加\r\n    export const enum 词典类别 {\r\n        汉英词典 = 1,\r\n        英汉词典 = 2,\r\n    }\r\n\r\n    export const enum 使用场景 {\r\n        输出 = 1,\r\n        类型检查 = 2,\r\n    }\r\n\r\n    export const enum 输出种类 {\r\n        输出源码 = 1,\r\n        输出中文 = 2,\r\n        输出英文 = 3\r\n    }\r\n\r\n    export const enum 文件种类 {\r\n        未知 = 0,\r\n        DCTS = 1,\r\n        DTS = 2,\r\n        CTS = 3,\r\n        TS = 4,\r\n        CTSX = 5,\r\n        TSX = 6,\r\n        JS = 7,\r\n        JSX = 8,\r\n        外部 = 9,\r\n        JSON = 10,\r\n    }\r\n    export interface 别名数据{\r\n        别名数据:string[],\r\n        添加:(数据:string)=>number\r\n        元素数量:number\r\n    }\r\n\r\n    export interface 文本名称 {\r\n        名称: __String | string;\r\n        别名: __String | string;\r\n    }\r\n\r\n    export type 索引 = {\r\n        键: string,\r\n        值: string\r\n    };\r\n\r\n    export type 别名索引 = {\r\n        键: __String | string,\r\n        值: 别名\r\n    };\r\n\r\n    export type 索引表 = Map<string>;\r\n\r\n\r\n    export type 可携带词典节点 = Identifier | StringLiteral\r\n\r\n    export interface 词典键 extends Node {\r\n        kind: SyntaxKind.词典键;\r\n        name: Identifier | StringLiteral;\r\n    }\r\n\r\n    export interface 词典值 extends Node {\r\n        kind: SyntaxKind.词典值;\r\n        name: Identifier | StringLiteral;\r\n    }\r\n\r\n    export interface 词典 extends Expression {\r\n        kind: SyntaxKind.词典表达式;\r\n        键: 词典键;\r\n        值: 词典值;\r\n        是局部词典?: 别名旗帜;\r\n        是全局词典?: 别名旗帜;\r\n        是单向词典?: 别名旗帜;\r\n        是内置词典?: 别名旗帜;\r\n        是文本字面量词典?: 别名旗帜;\r\n        词典类别?: 别名旗帜;\r\n        引用节点?: Map<可携带词典节点>;\r\n    }\r\n\r\n    export const enum 别名旗帜 {\r\n        空 = 0,\r\n        英汉 = 1,\r\n        汉英 = 1 << 1,\r\n        字面量 = 1 << 2,\r\n        局部词典 = 1 << 3,\r\n        全局词典 = 1 << 4,\r\n        单向词典 = 1 << 5,\r\n        内置词典 = 1 << 6,\r\n    }\r\n\r\n    export type 词典旗帜 = 别名旗帜\r\n\r\n    export interface 别名 {\r\n        旗帜: 别名旗帜;\r\n        名称: __String;\r\n    }\r\n\r\n    export type 别名组 = UnderscoreEscapedMap<别名[]>;\r\n\r\n    export interface 全局词典语句 extends Statement {\r\n        kind: SyntaxKind.全局词典语句;\r\n        表达式: NodeArray<词典>;\r\n    }\r\n\r\n    export interface 局部词典语句 extends Statement {\r\n        kind: SyntaxKind.局部词典语句;\r\n        表达式: NodeArray<词典>;\r\n    }\r\n    export type 词典语句 = 局部词典语句 | 全局词典语句\r\n\r\n    export interface 词典注释范围 {\r\n        词典旗帜: 词典旗帜\r\n        注释范围: CommentRange | undefined\r\n    }\r\n\r\n    export type 类型节点携带者 = Identifier | TypeParameterDeclaration | SignatureDeclaration | VariableDeclaration\r\n        | ParameterDeclaration | PropertySignature | PropertyDeclaration | VariableLikeDeclaration | TypeReferenceNode | TypePredicateNode\r\n        | ArrayTypeNode | TupleTypeNode | UnionOrIntersectionTypeNode | ParenthesizedTypeNode | TypeOperatorNode | IndexedAccessTypeNode\r\n        | MappedTypeNode | CallExpression | ExpressionWithTypeArguments | NewExpression | AssertionExpression | TypeAliasDeclaration\r\n        | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType\r\n\r\n    export type 单类型节点携带者 = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration\r\n        | VariableLikeDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration\r\n        | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType\r\n\r\n    export type 类型集节点携带者 = UnionOrIntersectionTypeNode\r\n\r\n    export type 类型参数节点携带者 = Identifier | TypeReferenceNode | CallExpression | ExpressionWithTypeArguments | NewExpression\r\n\r\n    export type 元素类型节点携带者 = ArrayTypeNode\r\n\r\n    export type 元素集类型节点携带者 = TupleTypeNode\r\n\r\n    export type 默认及约束类型节点携带者 = TypeParameterDeclaration\r\n\r\n    export type 对象及索引类型节点携带者 =  IndexedAccessTypeNode\r\n\r\n\r\n}\r\n","/*@internal*/\r\nnamespace ts {\r\n    declare const performance: { now?(): number } | undefined;\r\n    /** Gets a timestamp with (at least) ms resolution */\r\n    export const timestamp = typeof performance !== \"undefined\" && performance.now ? () => performance.now() : Date.now ? Date.now : () => +(new Date());\r\n}\r\n\r\n/*@internal*/\r\n/** Performance measurements for the compiler. */\r\nnamespace ts.performance {\r\n    declare const onProfilerEvent: { (markName: string): void; profiler: boolean; };\r\n\r\n    const profilerEvent = typeof onProfilerEvent === \"function\" && onProfilerEvent.profiler === true\r\n            ? onProfilerEvent\r\n            : (_markName: string) => { };\r\n\r\n    let enabled = false;\r\n    let profilerStart = 0;\r\n    let counts: Map<number>;\r\n    let marks: Map<number>;\r\n    let measures: Map<number>;\r\n\r\n    /**\r\n     * Marks a performance event.\r\n     *\r\n     * @param markName The name of the mark.\r\n     */\r\n    export function mark(markName: string) {\r\n        if (enabled) {\r\n            marks.set(markName, timestamp());\r\n            counts.set(markName, (counts.get(markName) || 0) + 1);\r\n            profilerEvent(markName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a performance measurement with the specified name.\r\n     *\r\n     * @param measureName The name of the performance measurement.\r\n     * @param startMarkName The name of the starting mark. If not supplied, the point at which the\r\n     *      profiler was enabled is used.\r\n     * @param endMarkName The name of the ending mark. If not supplied, the current timestamp is\r\n     *      used.\r\n     */\r\n    export function measure(measureName: string, startMarkName?: string, endMarkName?: string) {\r\n        if (enabled) {\r\n            const end = endMarkName && marks.get(endMarkName) || timestamp();\r\n            const start = startMarkName && marks.get(startMarkName) || profilerStart;\r\n            measures.set(measureName, (measures.get(measureName) || 0) + (end - start));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of times a marker was encountered.\r\n     *\r\n     * @param markName The name of the mark.\r\n     */\r\n    export function getCount(markName: string) {\r\n        return counts && counts.get(markName) || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the total duration of all measurements with the supplied name.\r\n     *\r\n     * @param measureName The name of the measure whose durations should be accumulated.\r\n     */\r\n    export function getDuration(measureName: string) {\r\n        return measures && measures.get(measureName) || 0;\r\n    }\r\n\r\n    /**\r\n     * Iterate over each measure, performing some action\r\n     *\r\n     * @param cb The action to perform for each measure\r\n     */\r\n    export function forEachMeasure(cb: (measureName: string, duration: number) => void) {\r\n        measures.forEach((measure, key) => {\r\n            cb(key, measure);\r\n        });\r\n    }\r\n\r\n    /** Enables (and resets) performance measurements for the compiler. */\r\n    export function enable() {\r\n        counts = createMap<number>();\r\n        marks = createMap<number>();\r\n        measures = createMap<number>();\r\n        enabled = true;\r\n        profilerStart = timestamp();\r\n    }\r\n\r\n    /** Disables performance measurements for the compiler. */\r\n    export function disable() {\r\n        enabled = false;\r\n    }\r\n}\r\n","/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"performance.ts\" />\r\n\r\nnamespace ts {\r\n    // WARNING: The script `configureNightly.ts` uses a regexp to parse out these values.\r\n    // If changing the text in this section, be sure to test `configureNightly` too.\r\n    export const versionMajorMinor = \"2.7\";\r\n    /** The version of the TypeScript compiler release */\r\n    export const version = `${versionMajorMinor}.0`;\r\n}\r\n\r\nnamespace ts {\r\n    export function isExternalModuleNameRelative(moduleName: string): boolean {\r\n        // TypeScript 1.0 spec (April 2014): 11.2.1\r\n        // An external module name is \"relative\" if the first term is \".\" or \"..\".\r\n        // Update: We also consider a path like `C:\\foo.ts` \"relative\" because we do not search for it in `node_modules` or treat it as an ambient module.\r\n        return pathIsRelative(moduleName) || isRootedDiskPath(moduleName);\r\n    }\r\n}\r\n\r\n/* @internal */\r\nnamespace ts {\r\n\r\n    // More efficient to create a collator once and use its `compare` than to call `a.localeCompare(b)` many times.\r\n    export const collator: { compare(a: string, b: string): number } = typeof Intl === \"object\" && typeof Intl.Collator === \"function\" ? new Intl.Collator(/*locales*/ undefined, { usage: \"sort\", sensitivity: \"accent\" }) : undefined;\r\n    // Intl is missing in Safari, and node 0.10 treats \"a\" as greater than \"B\".\r\n    export const localeCompareIsCorrect = ts.collator && ts.collator.compare(\"a\", \"B\") < 0;\r\n\r\n    /** Create a MapLike with good performance. */\r\n    function createDictionaryObject<T>(): MapLike<T> {\r\n        const map = Object.create(/*prototype*/ null); // tslint:disable-line:no-null-keyword\r\n\r\n        // Using 'delete' on an object causes V8 to put the object in dictionary mode.\r\n        // This disables creation of hidden classes, which are expensive when an object is\r\n        // constantly changing shape.\r\n        map.__ = undefined;\r\n        delete map.__;\r\n\r\n        return map;\r\n    }\r\n\r\n    /** Create a new map. If a template object is provided, the map will copy entries from it. */\r\n    export function createMap<T>(): Map<T> {\r\n        return new MapCtr<T>();\r\n    }\r\n\r\n    /** Create a new escaped identifier map. */\r\n    export function createUnderscoreEscapedMap<T>(): UnderscoreEscapedMap<T> {\r\n        return new MapCtr<T>() as UnderscoreEscapedMap<T>;\r\n    }\r\n\r\n    export function createSymbolTable(symbols?: ReadonlyArray<Symbol>): SymbolTable {\r\n        const result = createMap<Symbol>() as SymbolTable;\r\n        if (symbols) {\r\n            for (const symbol of symbols) {\r\n                result.set(symbol.escapedName, symbol);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function createMapFromTemplate<T>(template?: MapLike<T>): Map<T> {\r\n        const map: Map<T> = new MapCtr<T>();\r\n\r\n        // Copies keys/values from template. Note that for..in will not throw if\r\n        // template is undefined, and instead will just exit the loop.\r\n        for (const key in template) {\r\n            if (hasOwnProperty.call(template, key)) {\r\n                map.set(key, template[key]);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    // The global Map object. This may not be available, so we must test for it.\r\n    declare const Map: { new<T>(): Map<T> } | undefined;\r\n    // Internet Explorer's Map doesn't support iteration, so don't use it.\r\n    // tslint:disable-next-line:no-in-operator\r\n    const MapCtr = typeof Map !== \"undefined\" && \"entries\" in Map.prototype ? Map : shimMap();\r\n\r\n    // Keep the class inside a function so it doesn't get compiled if it's not used.\r\n    function shimMap(): { new<T>(): Map<T> } {\r\n\r\n        class MapIterator<T, U extends (string | T | [string, T])> {\r\n            private data: MapLike<T>;\r\n            private keys: ReadonlyArray<string>;\r\n            private index = 0;\r\n            private selector: (data: MapLike<T>, key: string) => U;\r\n            constructor(data: MapLike<T>, selector: (data: MapLike<T>, key: string) => U) {\r\n                this.data = data;\r\n                this.selector = selector;\r\n                this.keys = Object.keys(data);\r\n            }\r\n\r\n            public next(): { value: U, done: false } | { value: never, done: true } {\r\n                const index = this.index;\r\n                if (index < this.keys.length) {\r\n                    this.index++;\r\n                    return { value: this.selector(this.data, this.keys[index]), done: false };\r\n                }\r\n                return { value: undefined as never, done: true };\r\n            }\r\n        }\r\n\r\n        return class<T> implements Map<T> {\r\n            private data = createDictionaryObject<T>();\r\n            public size = 0;\r\n\r\n            get(key: string): T {\r\n                return this.data[key];\r\n            }\r\n\r\n            set(key: string, value: T): this {\r\n                if (!this.has(key)) {\r\n                    this.size++;\r\n                }\r\n                this.data[key] = value;\r\n                return this;\r\n            }\r\n\r\n            has(key: string): boolean {\r\n                // tslint:disable-next-line:no-in-operator\r\n                return key in this.data;\r\n            }\r\n\r\n            delete(key: string): boolean {\r\n                if (this.has(key)) {\r\n                    this.size--;\r\n                    delete this.data[key];\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            clear(): void {\r\n                this.data = createDictionaryObject<T>();\r\n                this.size = 0;\r\n            }\r\n\r\n            keys() {\r\n                return new MapIterator(this.data, (_data, key) => key);\r\n            }\r\n\r\n            values() {\r\n                return new MapIterator(this.data, (data, key) => data[key]);\r\n            }\r\n\r\n            entries() {\r\n                return new MapIterator(this.data, (data, key) => [key, data[key]] as [string, T]);\r\n            }\r\n\r\n            forEach(action: (value: T, key: string) => void): void {\r\n                for (const key in this.data) {\r\n                    action(this.data[key], key);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    export function toPath(fileName: string, basePath: string, getCanonicalFileName: (path: string) => string): Path {\r\n        const nonCanonicalizedPath = isRootedDiskPath(fileName)\r\n            ? normalizePath(fileName)\r\n            : getNormalizedAbsolutePath(fileName, basePath);\r\n        return <Path>getCanonicalFileName(nonCanonicalizedPath);\r\n    }\r\n\r\n    export const enum Comparison {\r\n        LessThan    = -1,\r\n        EqualTo     = 0,\r\n        GreaterThan = 1\r\n    }\r\n\r\n    export function length(array: ReadonlyArray<any>) {\r\n        return array ? array.length : 0;\r\n    }\r\n\r\n    /**\r\n     * Iterates through 'array' by index and performs the callback on each element of array until the callback\r\n     * returns a truthy value, then returns that value.\r\n     * If no such value is found, the callback is applied to each element of array and undefined is returned.\r\n     */\r\n    export function forEach<T, U>(array: ReadonlyArray<T> | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const result = callback(array[i], i);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Like `forEach`, but suitable for use with numbers and strings (which may be falsy). */\r\n    export function firstDefined<T, U>(array: ReadonlyArray<T> | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const result = callback(array[i], i);\r\n            if (result !== undefined) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Iterates through the parent chain of a node and performs the callback on each parent until the callback\r\n     * returns a truthy value, then returns that value.\r\n     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns \"quit\"\r\n     * At that point findAncestor returns undefined.\r\n     */\r\n    export function findAncestor<T extends Node>(node: Node, callback: (element: Node) => element is T): T | undefined;\r\n    export function findAncestor(node: Node, callback: (element: Node) => boolean | \"quit\"): Node | undefined;\r\n    export function findAncestor(node: Node, callback: (element: Node) => boolean | \"quit\"): Node {\r\n        while (node) {\r\n            const result = callback(node);\r\n            if (result === \"quit\") {\r\n                return undefined;\r\n            }\r\n            else if (result) {\r\n                return node;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function zipWith<T, U, V>(arrayA: ReadonlyArray<T>, arrayB: ReadonlyArray<U>, callback: (a: T, b: U, index: number) => V): V[] {\r\n        const result: V[] = [];\r\n        Debug.assert(arrayA.length === arrayB.length);\r\n        for (let i = 0; i < arrayA.length; i++) {\r\n            result.push(callback(arrayA[i], arrayB[i], i));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function zipToMap<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): Map<T> {\r\n        Debug.assert(keys.length === values.length);\r\n        const map = createMap<T>();\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            map.set(keys[i], values[i]);\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Iterates through `array` by index and performs the callback on each element of array until the callback\r\n     * returns a falsey value, then returns false.\r\n     * If no such value is found, the callback is applied to each element of array and `true` is returned.\r\n     */\r\n    export function every<T>(array: ReadonlyArray<T>, callback: (element: T, index: number) => boolean): boolean {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                if (!callback(array[i], i)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found. */\r\n    export function find<T, U extends T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => element is U): U | undefined;\r\n    export function find<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined;\r\n    export function find<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const value = array[i];\r\n            if (predicate(value, i)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function findLast<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined {\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const value = array[i];\r\n            if (predicate(value, i)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found. */\r\n    export function findIndex<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): number {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (predicate(array[i], i)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the first truthy result of `callback`, or else fails.\r\n     * This is like `forEach`, but never returns undefined.\r\n     */\r\n    export function findMap<T, U>(array: ReadonlyArray<T>, callback: (element: T, index: number) => U | undefined): U {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const result = callback(array[i], i);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        Debug.fail();\r\n    }\r\n\r\n    export function contains<T>(array: ReadonlyArray<T>, value: T): boolean {\r\n        if (array) {\r\n            for (const v of array) {\r\n                if (v === value) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function indexOf<T>(array: ReadonlyArray<T>, value: T): number {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                if (array[i] === value) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    export function indexOfAnyCharCode(text: string, charCodes: ReadonlyArray<number>, start?: number): number {\r\n        for (let i = start || 0; i < text.length; i++) {\r\n            if (contains(charCodes, text.charCodeAt(i))) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    export function countWhere<T>(array: ReadonlyArray<T>, predicate: (x: T, i: number) => boolean): number {\r\n        let count = 0;\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = array[i];\r\n                if (predicate(v, i)) {\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Filters an array by a predicate function. Returns the same array instance if the predicate is\r\n     * true for all elements, otherwise returns a new array instance containing the filtered subset.\r\n     */\r\n    export function filter<T, U extends T>(array: T[], f: (x: T) => x is U): U[];\r\n    export function filter<T>(array: T[], f: (x: T) => boolean): T[];\r\n    export function filter<T, U extends T>(array: ReadonlyArray<T>, f: (x: T) => x is U): ReadonlyArray<U>;\r\n    export function filter<T, U extends T>(array: ReadonlyArray<T>, f: (x: T) => boolean): ReadonlyArray<T>;\r\n    export function filter<T>(array: T[], f: (x: T) => boolean): T[] {\r\n        if (array) {\r\n            const len = array.length;\r\n            let i = 0;\r\n            while (i < len && f(array[i])) i++;\r\n            if (i < len) {\r\n                const result = array.slice(0, i);\r\n                i++;\r\n                while (i < len) {\r\n                    const item = array[i];\r\n                    if (f(item)) {\r\n                        result.push(item);\r\n                    }\r\n                    i++;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n    export function filterMutate<T>(array: T[], f: (x: T, i: number, array: T[]) => boolean): void {\r\n        let outIndex = 0;\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (f(array[i], i, array)) {\r\n                array[outIndex] = array[i];\r\n                outIndex++;\r\n            }\r\n        }\r\n        array.length = outIndex;\r\n    }\r\n\r\n    export function clear(array: {}[]): void {\r\n        array.length = 0;\r\n    }\r\n\r\n    export function map<T, U>(array: ReadonlyArray<T>, f: (x: T, i: number) => U): U[] {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            for (let i = 0; i < array.length; i++) {\r\n                result.push(f(array[i], i));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Maps from T to T and avoids allocation if all elements map to themselves\r\n    export function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[];\r\n    export function sameMap<T>(array: ReadonlyArray<T>, f: (x: T, i: number) => T): ReadonlyArray<T>;\r\n    export function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                if (result) {\r\n                    result.push(f(array[i], i));\r\n                }\r\n                else {\r\n                    const item = array[i];\r\n                    const mapped = f(item, i);\r\n                    if (item !== mapped) {\r\n                        result = array.slice(0, i);\r\n                        result.push(mapped);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result || array;\r\n    }\r\n\r\n    /**\r\n     * Flattens an array containing a mix of array or non-array elements.\r\n     *\r\n     * @param array The array to flatten.\r\n     */\r\n    export function flatten<T>(array: ReadonlyArray<T | ReadonlyArray<T>>): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            result = [];\r\n            for (const v of array) {\r\n                if (v) {\r\n                    if (isArray(v)) {\r\n                        addRange(result, v);\r\n                    }\r\n                    else {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Maps an array. If the mapped value is an array, it is spread into the result.\r\n     *\r\n     * @param array The array to map.\r\n     * @param mapfn The callback used to map the result into one or more values.\r\n     */\r\n    export function flatMap<T, U>(array: ReadonlyArray<T> | undefined, mapfn: (x: T, i: number) => U | ReadonlyArray<U> | undefined): U[] | undefined {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = mapfn(array[i], i);\r\n                if (v) {\r\n                    if (isArray(v)) {\r\n                        addRange(result, v);\r\n                    }\r\n                    else {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function flatMapIter<T, U>(iter: Iterator<T>, mapfn: (x: T) => U | U[] | undefined): U[] {\r\n        const result: U[] = [];\r\n        while (true) {\r\n            const { value, done } = iter.next();\r\n            if (done) break;\r\n            const res = mapfn(value);\r\n            if (res) {\r\n                if (isArray(res)) {\r\n                    result.push(...res);\r\n                }\r\n                else {\r\n                    result.push(res);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Maps an array. If the mapped value is an array, it is spread into the result.\r\n     * Avoids allocation if all elements map to themselves.\r\n     *\r\n     * @param array The array to map.\r\n     * @param mapfn The callback used to map the result into one or more values.\r\n     */\r\n    export function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | ReadonlyArray<T>): T[];\r\n    export function sameFlatMap<T>(array: ReadonlyArray<T>, mapfn: (x: T, i: number) => T | ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | T[]): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                const mapped = mapfn(item, i);\r\n                if (result || item !== mapped || isArray(mapped)) {\r\n                    if (!result) {\r\n                        result = array.slice(0, i);\r\n                    }\r\n                    if (isArray(mapped)) {\r\n                        addRange(result, mapped);\r\n                    }\r\n                    else {\r\n                        result.push(mapped);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result || array;\r\n    }\r\n\r\n    export function mapDefined<T, U>(array: ReadonlyArray<T> | undefined, mapFn: (x: T, i: number) => U | undefined): U[] {\r\n        const result: U[] = [];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                const mapped = mapFn(item, i);\r\n                if (mapped !== undefined) {\r\n                    result.push(mapped);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function mapDefinedIter<T, U>(iter: Iterator<T>, mapFn: (x: T) => U | undefined): U[] {\r\n        const result: U[] = [];\r\n        while (true) {\r\n            const { value, done } = iter.next();\r\n            if (done) break;\r\n            const res = mapFn(value);\r\n            if (res !== undefined) {\r\n                result.push(res);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Computes the first matching span of elements and returns a tuple of the first span\r\n     * and the remaining elements.\r\n     */\r\n    export function span<T>(array: ReadonlyArray<T>, f: (x: T, i: number) => boolean): [T[], T[]] {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                if (!f(array[i], i)) {\r\n                    return [array.slice(0, i), array.slice(i)];\r\n                }\r\n            }\r\n            return [array.slice(0), []];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Maps contiguous spans of values with the same key.\r\n     *\r\n     * @param array The array to map.\r\n     * @param keyfn A callback used to select the key for an element.\r\n     * @param mapfn A callback used to map a contiguous chunk of values to a single value.\r\n     */\r\n    export function spanMap<T, K, U>(array: ReadonlyArray<T>, keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[] {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            const len = array.length;\r\n            let previousKey: K;\r\n            let key: K;\r\n            let start = 0;\r\n            let pos = 0;\r\n            while (start < len) {\r\n                while (pos < len) {\r\n                    const value = array[pos];\r\n                    key = keyfn(value, pos);\r\n                    if (pos === 0) {\r\n                        previousKey = key;\r\n                    }\r\n                    else if (key !== previousKey) {\r\n                        break;\r\n                    }\r\n\r\n                    pos++;\r\n                }\r\n\r\n                if (start < pos) {\r\n                    const v = mapfn(array.slice(start, pos), previousKey, start, pos);\r\n                    if (v) {\r\n                        result.push(v);\r\n                    }\r\n\r\n                    start = pos;\r\n                }\r\n\r\n                previousKey = key;\r\n                pos++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    export function mapEntries<T, U>(map: ReadonlyMap<T>, f: (key: string, value: T) => [string, U]): Map<U> {\r\n        if (!map) {\r\n            return undefined;\r\n        }\r\n\r\n        const result = createMap<U>();\r\n        map.forEach((value, key) => {\r\n            const [newKey, newValue] = f(key, value);\r\n            result.set(newKey, newValue);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    export function some<T>(array: ReadonlyArray<T>, predicate?: (value: T) => boolean): boolean {\r\n        if (array) {\r\n            if (predicate) {\r\n                for (const v of array) {\r\n                    if (predicate(v)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return array.length > 0;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function concatenate<T>(array1: T[], array2: T[]): T[];\r\n    export function concatenate<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function concatenate<T>(array1: T[], array2: T[]): T[] {\r\n        if (!some(array2)) return array1;\r\n        if (!some(array1)) return array2;\r\n        return [...array1, ...array2];\r\n    }\r\n\r\n    // TODO: fixme (N^2) - add optional comparer so collection can be sorted before deduplication.\r\n    export function deduplicate<T>(array: ReadonlyArray<T>, areEqual?: (a: T, b: T) => boolean): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            result = [];\r\n            loop: for (const item of array) {\r\n                for (const res of result) {\r\n                    if (areEqual ? areEqual(res, item) : res === item) {\r\n                        continue loop;\r\n                    }\r\n                }\r\n                result.push(item);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function arrayIsEqualTo<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>, equaler?: (a: T, b: T) => boolean): boolean {\r\n        if (!array1 || !array2) {\r\n            return array1 === array2;\r\n        }\r\n\r\n        if (array1.length !== array2.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < array1.length; i++) {\r\n            const equals = equaler ? equaler(array1[i], array2[i]) : array1[i] === array2[i];\r\n            if (!equals) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    export function changesAffectModuleResolution(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean {\r\n        return !oldOptions ||\r\n            (oldOptions.module !== newOptions.module) ||\r\n            (oldOptions.moduleResolution !== newOptions.moduleResolution) ||\r\n            (oldOptions.noResolve !== newOptions.noResolve) ||\r\n            (oldOptions.target !== newOptions.target) ||\r\n            (oldOptions.noLib !== newOptions.noLib) ||\r\n            (oldOptions.jsx !== newOptions.jsx) ||\r\n            (oldOptions.allowJs !== newOptions.allowJs) ||\r\n            (oldOptions.rootDir !== newOptions.rootDir) ||\r\n            (oldOptions.configFilePath !== newOptions.configFilePath) ||\r\n            (oldOptions.baseUrl !== newOptions.baseUrl) ||\r\n            (oldOptions.maxNodeModuleJsDepth !== newOptions.maxNodeModuleJsDepth) ||\r\n            !arrayIsEqualTo(oldOptions.lib, newOptions.lib) ||\r\n            !arrayIsEqualTo(oldOptions.typeRoots, newOptions.typeRoots) ||\r\n            !arrayIsEqualTo(oldOptions.rootDirs, newOptions.rootDirs) ||\r\n            !equalOwnProperties(oldOptions.paths, newOptions.paths);\r\n    }\r\n\r\n    /**\r\n     * Compacts an array, removing any falsey elements.\r\n     */\r\n    export function compact<T>(array: T[]): T[];\r\n    export function compact<T>(array: ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function compact<T>(array: T[]): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = array[i];\r\n                if (result || !v) {\r\n                    if (!result) {\r\n                        result = array.slice(0, i);\r\n                    }\r\n                    if (v) {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result || array;\r\n    }\r\n\r\n    /**\r\n     * Gets the relative complement of `arrayA` with respect to `b`, returning the elements that\r\n     * are not present in `arrayA` but are present in `arrayB`. Assumes both arrays are sorted\r\n     * based on the provided comparer.\r\n     */\r\n    export function relativeComplement<T>(arrayA: T[] | undefined, arrayB: T[] | undefined, comparer: Comparer<T> = compareValues, offsetA = 0, offsetB = 0): T[] | undefined {\r\n        if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0) return arrayB;\r\n        const result: T[] = [];\r\n        outer: for (; offsetB < arrayB.length; offsetB++) {\r\n            inner: for (; offsetA < arrayA.length; offsetA++) {\r\n                switch (comparer(arrayB[offsetB], arrayA[offsetA])) {\r\n                    case Comparison.LessThan: break inner;\r\n                    case Comparison.EqualTo: continue outer;\r\n                    case Comparison.GreaterThan: continue inner;\r\n                }\r\n            }\r\n            result.push(arrayB[offsetB]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function sum<T extends Record<K, number>, K extends string>(array: ReadonlyArray<T>, prop: K): number {\r\n        let result = 0;\r\n        for (const v of array) {\r\n            // Note: we need the following type assertion because of GH #17069\r\n            result += v[prop] as number;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Appends a value to an array, returning the array.\r\n     *\r\n     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\r\n     * is created if `value` was appended.\r\n     * @param value The value to append to the array. If `value` is `undefined`, nothing is\r\n     * appended.\r\n     */\r\n    export function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined {\r\n        if (value === undefined) return to;\r\n        if (to === undefined) return [value];\r\n        to.push(value);\r\n        return to;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual offset into an array for a relative offset. Negative offsets indicate a\r\n     * position offset from the end of the array.\r\n     */\r\n    function toOffset(array: ReadonlyArray<any>, offset: number) {\r\n        return offset < 0 ? array.length + offset : offset;\r\n    }\r\n\r\n    /**\r\n     * Appends a range of value to an array, returning the array.\r\n     *\r\n     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\r\n     * is created if `value` was appended.\r\n     * @param from The values to append to the array. If `from` is `undefined`, nothing is\r\n     * appended. If an element of `from` is `undefined`, that element is not appended.\r\n     * @param start The offset in `from` at which to start copying values.\r\n     * @param end The offset in `from` at which to stop copying values (non-inclusive).\r\n     */\r\n    export function addRange<T>(to: T[] | undefined, from: ReadonlyArray<T> | undefined, start?: number, end?: number): T[] | undefined {\r\n        if (from === undefined || from.length === 0) return to;\r\n        if (to === undefined) return from.slice(start, end);\r\n        start = start === undefined ? 0 : toOffset(from, start);\r\n        end = end === undefined ? from.length : toOffset(from, end);\r\n        for (let i = start; i < end && i < from.length; i++) {\r\n            const v = from[i];\r\n            if (v !== undefined) {\r\n                to.push(from[i]);\r\n            }\r\n        }\r\n        return to;\r\n    }\r\n\r\n    /**\r\n     * @return Whether the value was added.\r\n     */\r\n    export function pushIfUnique<T>(array: T[], toAdd: T): boolean {\r\n        if (contains(array, toAdd)) {\r\n            return false;\r\n        }\r\n        else {\r\n            array.push(toAdd);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unlike `pushIfUnique`, this can take `undefined` as an input, and returns a new array.\r\n     */\r\n    export function appendIfUnique<T>(array: T[] | undefined, toAdd: T): T[] {\r\n        if (array) {\r\n            pushIfUnique(array, toAdd);\r\n            return array;\r\n        }\r\n        else {\r\n            return [toAdd];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stable sort of an array. Elements equal to each other maintain their relative position in the array.\r\n     */\r\n    export function stableSort<T>(array: ReadonlyArray<T>, comparer: Comparer<T> = compareValues) {\r\n        return array\r\n            .map((_, i) => i) // create array of indices\r\n            .sort((x, y) => comparer(array[x], array[y]) || compareValues(x, y)) // sort indices by value then position\r\n            .map(i => array[i]); // get sorted array\r\n    }\r\n\r\n    export function rangeEquals<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>, pos: number, end: number) {\r\n        while (pos < end) {\r\n            if (array1[pos] !== array2[pos]) {\r\n                return false;\r\n            }\r\n            pos++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the element at a specific offset in an array if non-empty, `undefined` otherwise.\r\n     * A negative offset indicates the element should be retrieved from the end of the array.\r\n     */\r\n    export function elementAt<T>(array: ReadonlyArray<T> | undefined, offset: number): T | undefined {\r\n        if (array) {\r\n            offset = toOffset(array, offset);\r\n            if (offset < array.length) {\r\n                return array[offset];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the first element of an array if non-empty, `undefined` otherwise.\r\n     */\r\n    export function firstOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return elementAt(array, 0);\r\n    }\r\n\r\n    export function first<T>(array: ReadonlyArray<T>): T {\r\n        Debug.assert(array.length !== 0);\r\n        return array[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the last element of an array if non-empty, `undefined` otherwise.\r\n     */\r\n    export function lastOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return elementAt(array, -1);\r\n    }\r\n\r\n    export function last<T>(array: ReadonlyArray<T>): T {\r\n        Debug.assert(array.length !== 0);\r\n        return array[array.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns the only element of an array if it contains only one element, `undefined` otherwise.\r\n     */\r\n    export function singleOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return array && array.length === 1\r\n            ? array[0]\r\n            : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the only element of an array if it contains only one element; otheriwse, returns the\r\n     * array.\r\n     */\r\n    export function singleOrMany<T>(array: T[]): T | T[];\r\n    export function singleOrMany<T>(array: ReadonlyArray<T>): T | ReadonlyArray<T>;\r\n    export function singleOrMany<T>(array: T[]): T | T[] {\r\n        return array && array.length === 1\r\n            ? array[0]\r\n            : array;\r\n    }\r\n\r\n    export function replaceElement<T>(array: ReadonlyArray<T>, index: number, value: T): T[] {\r\n        const result = array.slice(0);\r\n        result[index] = value;\r\n        return result;\r\n    }\r\n\r\n    export type Comparer<T> = (a: T, b: T) => Comparison;\r\n\r\n    /**\r\n     * Performs a binary search, finding the index at which 'value' occurs in 'array'.\r\n     * If no such index is found, returns the 2's-complement of first index at which\r\n     * number[index] exceeds number.\r\n     * @param array A sorted array whose first element must be no larger than number\r\n     * @param number The value to be searched for in the array.\r\n     */\r\n    export function binarySearch<T>(array: ReadonlyArray<T>, value: T, comparer?: Comparer<T>, offset?: number): number {\r\n        if (!array || array.length === 0) {\r\n            return -1;\r\n        }\r\n\r\n        let low = offset || 0;\r\n        let high = array.length - 1;\r\n        comparer = comparer !== undefined\r\n            ? comparer\r\n            : (v1, v2) => (v1 < v2 ? -1 : (v1 > v2 ? 1 : 0));\r\n\r\n        while (low <= high) {\r\n            const middle = low + ((high - low) >> 1);\r\n            const midValue = array[middle];\r\n\r\n            if (comparer(midValue, value) === 0) {\r\n                return middle;\r\n            }\r\n            else if (comparer(midValue, value) > 0) {\r\n                high = middle - 1;\r\n            }\r\n            else {\r\n                low = middle + 1;\r\n            }\r\n        }\r\n\r\n        return ~low;\r\n    }\r\n\r\n    export function reduceLeft<T, U>(array: ReadonlyArray<T>, f: (memo: U, value: T, i: number) => U, initial: U, start?: number, count?: number): U;\r\n    export function reduceLeft<T>(array: ReadonlyArray<T>, f: (memo: T, value: T, i: number) => T): T;\r\n    export function reduceLeft<T>(array: T[], f: (memo: T, value: T, i: number) => T, initial?: T, start?: number, count?: number): T {\r\n        if (array && array.length > 0) {\r\n            const size = array.length;\r\n            if (size > 0) {\r\n                let pos = start === undefined || start < 0 ? 0 : start;\r\n                const end = count === undefined || pos + count > size - 1 ? size - 1 : pos + count;\r\n                let result: T;\r\n                if (arguments.length <= 2) {\r\n                    result = array[pos];\r\n                    pos++;\r\n                }\r\n                else {\r\n                    result = initial;\r\n                }\r\n                while (pos <= end) {\r\n                    result = f(result, array[pos], pos);\r\n                    pos++;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return initial;\r\n    }\r\n\r\n    export function reduceRight<T, U>(array: ReadonlyArray<T>, f: (memo: U, value: T, i: number) => U, initial: U, start?: number, count?: number): U;\r\n    export function reduceRight<T>(array: ReadonlyArray<T>, f: (memo: T, value: T, i: number) => T): T;\r\n    export function reduceRight<T>(array: T[], f: (memo: T, value: T, i: number) => T, initial?: T, start?: number, count?: number): T {\r\n        if (array) {\r\n            const size = array.length;\r\n            if (size > 0) {\r\n                let pos = start === undefined || start > size - 1 ? size - 1 : start;\r\n                const end = count === undefined || pos - count < 0 ? 0 : pos - count;\r\n                let result: T;\r\n                if (arguments.length <= 2) {\r\n                    result = array[pos];\r\n                    pos--;\r\n                }\r\n                else {\r\n                    result = initial;\r\n                }\r\n                while (pos >= end) {\r\n                    result = f(result, array[pos], pos);\r\n                    pos--;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return initial;\r\n    }\r\n\r\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    /**\r\n     * Indicates whether a map-like contains an own property with the specified key.\r\n     *\r\n     * @param map A map-like.\r\n     * @param key A property key.\r\n     */\r\n    export function hasProperty(map: MapLike<any>, key: string): boolean {\r\n        return hasOwnProperty.call(map, key);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of an owned property in a map-like.\r\n     *\r\n     * @param map A map-like.\r\n     * @param key A property key.\r\n     */\r\n    export function getProperty<T>(map: MapLike<T>, key: string): T | undefined {\r\n        return hasOwnProperty.call(map, key) ? map[key] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the owned, enumerable property keys of a map-like.\r\n     */\r\n    export function getOwnKeys<T>(map: MapLike<T>): string[] {\r\n        const keys: string[] = [];\r\n        for (const key in map) {\r\n            if (hasOwnProperty.call(map, key)) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    }\r\n\r\n    export function getOwnValues<T>(sparseArray: T[]): T[] {\r\n        const values: T[] = [];\r\n        for (const key in sparseArray) {\r\n            if (hasOwnProperty.call(sparseArray, key)) {\r\n                values.push(sparseArray[key]);\r\n            }\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    /** Shims `Array.from`. */\r\n    export function arrayFrom<T, U>(iterator: Iterator<T>, map: (t: T) => U): U[];\r\n    export function arrayFrom<T>(iterator: Iterator<T>): T[];\r\n    export function arrayFrom(iterator: Iterator<any>, map?: (t: any) => any): any[] {\r\n        const result: any[] = [];\r\n        for (let { value, done } = iterator.next(); !done; { value, done } = iterator.next()) {\r\n            result.push(map ? map(value) : value);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calls `callback` for each entry in the map, returning the first truthy result.\r\n     * Use `map.forEach` instead for normal iteration.\r\n     */\r\n    export function forEachEntry<T, U>(map: ReadonlyUnderscoreEscapedMap<T>, callback: (value: T, key: __String) => U | undefined): U | undefined;\r\n    export function forEachEntry<T, U>(map: ReadonlyMap<T>, callback: (value: T, key: string) => U | undefined): U | undefined;\r\n    export function forEachEntry<T, U>(map: ReadonlyUnderscoreEscapedMap<T> | ReadonlyMap<T>, callback: (value: T, key: (string & __String)) => U | undefined): U | undefined {\r\n        const iterator = map.entries();\r\n        for (let { value: pair, done } = iterator.next(); !done; { value: pair, done } = iterator.next()) {\r\n            const [key, value] = pair;\r\n            const result = callback(value, key as (string & __String));\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** `forEachEntry` for just keys. */\r\n    export function forEachKey<T>(map: ReadonlyUnderscoreEscapedMap<{}>, callback: (key: __String) => T | undefined): T | undefined;\r\n    export function forEachKey<T>(map: ReadonlyMap<{}>, callback: (key: string) => T | undefined): T | undefined;\r\n    export function forEachKey<T>(map: ReadonlyUnderscoreEscapedMap<{}> | ReadonlyMap<{}>, callback: (key: string & __String) => T | undefined): T | undefined {\r\n        const iterator = map.keys();\r\n        for (let { value: key, done } = iterator.next(); !done; { value: key, done } = iterator.next()) {\r\n            const result = callback(key as string & __String);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Copy entries from `source` to `target`. */\r\n    export function copyEntries<T>(source: ReadonlyUnderscoreEscapedMap<T>, target: UnderscoreEscapedMap<T>): void;\r\n    export function copyEntries<T>(source: ReadonlyMap<T>, target: Map<T>): void;\r\n    export function copyEntries<T, U extends UnderscoreEscapedMap<T> | Map<T>>(source: U, target: U): void {\r\n        (source as Map<T>).forEach((value, key) => {\r\n            (target as Map<T>).set(key, value);\r\n        });\r\n    }\r\n\r\n    export function assign<T1 extends MapLike<{}>, T2, T3>(t: T1, arg1: T2, arg2: T3): T1 & T2 & T3;\r\n    export function assign<T1 extends MapLike<{}>, T2>(t: T1, arg1: T2): T1 & T2;\r\n    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]): any;\r\n    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]) {\r\n        for (const arg of args) {\r\n            for (const p in arg) {\r\n                if (hasProperty(arg, p)) {\r\n                    t[p] = arg[p];\r\n                }\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Performs a shallow equality comparison of the contents of two map-likes.\r\n     *\r\n     * @param left A map-like whose properties should be compared.\r\n     * @param right A map-like whose properties should be compared.\r\n     */\r\n    export function equalOwnProperties<T>(left: MapLike<T>, right: MapLike<T>, equalityComparer?: (left: T, right: T) => boolean) {\r\n        if (left === right) return true;\r\n        if (!left || !right) return false;\r\n        for (const key in left) {\r\n            if (hasOwnProperty.call(left, key)) {\r\n                if (!hasOwnProperty.call(right, key) === undefined) return false;\r\n                if (equalityComparer ? !equalityComparer(left[key], right[key]) : left[key] !== right[key]) return false;\r\n            }\r\n        }\r\n\r\n        for (const key in right) {\r\n            if (hasOwnProperty.call(right, key)) {\r\n                if (!hasOwnProperty.call(left, key)) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a map from the elements of an array.\r\n     *\r\n     * @param array the array of input elements.\r\n     * @param makeKey a function that produces a key for a given element.\r\n     *\r\n     * This function makes no effort to avoid collisions; if any two elements produce\r\n     * the same key with the given 'makeKey' function, then the element with the higher\r\n     * index in the array will be the one associated with the produced key.\r\n     */\r\n    export function arrayToMap<T>(array: ReadonlyArray<T>, makeKey: (value: T) => string): Map<T>;\r\n    export function arrayToMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => string, makeValue: (value: T) => U): Map<U>;\r\n    export function arrayToMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => string, makeValue?: (value: T) => U): Map<T | U> {\r\n        const result = createMap<T | U>();\r\n        for (const value of array) {\r\n            result.set(makeKey(value), makeValue ? makeValue(value) : value);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function arrayToNumericMap<T>(array: ReadonlyArray<T>, makeKey: (value: T) => number): T[] {\r\n        const result: T[] = [];\r\n        for (const value of array) {\r\n            result[makeKey(value)] = value;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a set from the elements of an array.\r\n     *\r\n     * @param array the array of input elements.\r\n     */\r\n    export function arrayToSet(array: ReadonlyArray<string>): Map<true>;\r\n    export function arrayToSet<T>(array: ReadonlyArray<T>, makeKey: (value: T) => string): Map<true>;\r\n    export function arrayToSet(array: ReadonlyArray<any>, makeKey?: (value: any) => string): Map<true> {\r\n        return arrayToMap<any, true>(array, makeKey || (s => s), () => true);\r\n    }\r\n\r\n    export function cloneMap(map: SymbolTable): SymbolTable;\r\n    export function cloneMap<T>(map: ReadonlyMap<T>): Map<T>;\r\n    export function cloneMap<T>(map: ReadonlyMap<T> | SymbolTable): Map<T> | SymbolTable {\r\n        const clone = createMap<T>();\r\n        copyEntries(map as Map<T>, clone);\r\n        return clone;\r\n    }\r\n\r\n    export function clone<T>(object: T): T {\r\n        const result: any = {};\r\n        for (const id in object) {\r\n            if (hasOwnProperty.call(object, id)) {\r\n                result[id] = (<any>object)[id];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function extend<T1, T2>(first: T1, second: T2): T1 & T2 {\r\n        const result: T1 & T2 = <any>{};\r\n        for (const id in second) {\r\n            if (hasOwnProperty.call(second, id)) {\r\n                (result as any)[id] = (second as any)[id];\r\n            }\r\n        }\r\n\r\n        for (const id in first) {\r\n            if (hasOwnProperty.call(first, id)) {\r\n                (result as any)[id] = (first as any)[id];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    export interface MultiMap<T> extends Map<T[]> {\r\n        /**\r\n         * Adds the value to an array of values associated with the key, and returns the array.\r\n         * Creates the array if it does not already exist.\r\n         */\r\n        add(key: string, value: T): T[];\r\n        /**\r\n         * Removes a value from an array of values associated with the key.\r\n         * Does not preserve the order of those values.\r\n         * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.\r\n         */\r\n        remove(key: string, value: T): void;\r\n    }\r\n\r\n    export function createMultiMap<T>(): MultiMap<T> {\r\n        const map = createMap<T[]>() as MultiMap<T>;\r\n        map.add = multiMapAdd;\r\n        map.remove = multiMapRemove;\r\n        return map;\r\n    }\r\n    function multiMapAdd<T>(this: MultiMap<T>, key: string, value: T) {\r\n        let values = this.get(key);\r\n        if (values) {\r\n            values.push(value);\r\n        }\r\n        else {\r\n            this.set(key, values = [value]);\r\n        }\r\n        return values;\r\n\r\n    }\r\n    function multiMapRemove<T>(this: MultiMap<T>, key: string, value: T) {\r\n        const values = this.get(key);\r\n        if (values) {\r\n            unorderedRemoveItem(values, value);\r\n            if (!values.length) {\r\n                this.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests whether a value is an array.\r\n     */\r\n    export function isArray(value: any): value is ReadonlyArray<any> {\r\n        return Array.isArray ? Array.isArray(value) : value instanceof Array;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a value is string\r\n     */\r\n    export function isString(text: any): text is string {\r\n        return typeof text === \"string\";\r\n    }\r\n\r\n    export function tryCast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut | undefined {\r\n        return value !== undefined && test(value) ? value : undefined;\r\n    }\r\n\r\n    export function cast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut {\r\n        if (value !== undefined && test(value)) return value;\r\n        Debug.fail(`Invalid cast. The supplied value did not pass the test '${Debug.getFunctionName(test)}'.`);\r\n    }\r\n\r\n    /** Does nothing. */\r\n    export function noop(): void { }\r\n\r\n    /** Do nothing and return false */\r\n    export function returnFalse(): false { return false; }\r\n\r\n    /** Do nothing and return true */\r\n    export function returnTrue(): true { return true; }\r\n\r\n    /** Returns its argument. */\r\n    export function identity<T>(x: T) { return x; }\r\n\r\n    /** Throws an error because a function is not implemented. */\r\n    export function notImplemented(): never {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    export function memoize<T>(callback: () => T): () => T {\r\n        let value: T;\r\n        return () => {\r\n            if (callback) {\r\n                value = callback();\r\n                callback = undefined;\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * High-order function, creates a function that executes a function composition.\r\n     * For example, `chain(a, b)` is the equivalent of `x => ((a', b') => y => b'(a'(y)))(a(x), b(x))`\r\n     *\r\n     * @param args The functions to chain.\r\n     */\r\n    export function chain<T, U>(...args: ((t: T) => (u: U) => U)[]): (t: T) => (u: U) => U;\r\n    export function chain<T, U>(a: (t: T) => (u: U) => U, b: (t: T) => (u: U) => U, c: (t: T) => (u: U) => U, d: (t: T) => (u: U) => U, e: (t: T) => (u: U) => U): (t: T) => (u: U) => U {\r\n        if (e) {\r\n            const args: ((t: T) => (u: U) => U)[] = [];\r\n            for (let i = 0; i < arguments.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n\r\n            return t => compose(...map(args, f => f(t)));\r\n        }\r\n        else if (d) {\r\n            return t => compose(a(t), b(t), c(t), d(t));\r\n        }\r\n        else if (c) {\r\n            return t => compose(a(t), b(t), c(t));\r\n        }\r\n        else if (b) {\r\n            return t => compose(a(t), b(t));\r\n        }\r\n        else if (a) {\r\n            return t => compose(a(t));\r\n        }\r\n        else {\r\n            return _ => u => u;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * High-order function, composes functions. Note that functions are composed inside-out;\r\n     * for example, `compose(a, b)` is the equivalent of `x => b(a(x))`.\r\n     *\r\n     * @param args The functions to compose.\r\n     */\r\n    export function compose<T>(...args: ((t: T) => T)[]): (t: T) => T;\r\n    export function compose<T>(a: (t: T) => T, b: (t: T) => T, c: (t: T) => T, d: (t: T) => T, e: (t: T) => T): (t: T) => T {\r\n        if (e) {\r\n            const args: ((t: T) => T)[] = [];\r\n            for (let i = 0; i < arguments.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n\r\n            return t => reduceLeft(args, (u, f) => f(u), t);\r\n        }\r\n        else if (d) {\r\n            return t => d(c(b(a(t))));\r\n        }\r\n        else if (c) {\r\n            return t => c(b(a(t)));\r\n        }\r\n        else if (b) {\r\n            return t => b(a(t));\r\n        }\r\n        else if (a) {\r\n            return t => a(t);\r\n        }\r\n        else {\r\n            return t => t;\r\n        }\r\n    }\r\n\r\n    export function formatStringFromArgs(text: string, args: { [index: number]: string; }, baseIndex?: number): string {\r\n        baseIndex = baseIndex || 0;\r\n\r\n        return text.replace(/{(\\d+)}/g, (_match, index?) => args[+index + baseIndex]);\r\n    }\r\n\r\n    export let localizedDiagnosticMessages: MapLike<string> = undefined;\r\n\r\n    export function getLocaleSpecificMessage(message: DiagnosticMessage) {\r\n        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;\r\n    }\r\n\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: (string | number)[]): Diagnostic;\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage): Diagnostic {\r\n        Debug.assertGreaterThanOrEqual(start, 0);\r\n        Debug.assertGreaterThanOrEqual(length, 0);\r\n\r\n        if (file) {\r\n            Debug.assertLessThanOrEqual(start, file.text.length);\r\n            Debug.assertLessThanOrEqual(start + length, file.text.length);\r\n        }\r\n\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 4) {\r\n            text = formatStringFromArgs(text, arguments, 4);\r\n        }\r\n\r\n        return {\r\n            file,\r\n            start,\r\n            length,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n        };\r\n    }\r\n\r\n    /* internal */\r\n    export function formatMessage(_dummy: any, message: DiagnosticMessage): string {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 2) {\r\n            text = formatStringFromArgs(text, arguments, 2);\r\n        }\r\n\r\n        return text;\r\n    }\r\n\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage, ...args: (string | number)[]): Diagnostic;\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage): Diagnostic {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 1) {\r\n            text = formatStringFromArgs(text, arguments, 1);\r\n        }\r\n\r\n        return {\r\n            file: undefined,\r\n            start: undefined,\r\n            length: undefined,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code\r\n        };\r\n    }\r\n\r\n    export function createCompilerDiagnosticFromMessageChain(chain: DiagnosticMessageChain): Diagnostic {\r\n        return {\r\n            file: undefined,\r\n            start: undefined,\r\n            length: undefined,\r\n\r\n            code: chain.code,\r\n            category: chain.category,\r\n            messageText: chain.next ? chain : chain.messageText\r\n        };\r\n    }\r\n\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage, ...args: string[]): DiagnosticMessageChain;\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage): DiagnosticMessageChain {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 2) {\r\n            text = formatStringFromArgs(text, arguments, 2);\r\n        }\r\n\r\n        return {\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n\r\n            next: details\r\n        };\r\n    }\r\n\r\n    export function concatenateDiagnosticMessageChains(headChain: DiagnosticMessageChain, tailChain: DiagnosticMessageChain): DiagnosticMessageChain {\r\n        let lastChain = headChain;\r\n        while (lastChain.next) {\r\n            lastChain = lastChain.next;\r\n        }\r\n\r\n        lastChain.next = tailChain;\r\n        return headChain;\r\n    }\r\n\r\n    export function compareValues<T>(a: T, b: T): Comparison {\r\n        if (a === b) return Comparison.EqualTo;\r\n        if (a === undefined) return Comparison.LessThan;\r\n        if (b === undefined) return Comparison.GreaterThan;\r\n        return a < b ? Comparison.LessThan : Comparison.GreaterThan;\r\n    }\r\n\r\n    export function compareStrings(a: string, b: string, ignoreCase?: boolean): Comparison {\r\n        if (a === b) return Comparison.EqualTo;\r\n        if (a === undefined) return Comparison.LessThan;\r\n        if (b === undefined) return Comparison.GreaterThan;\r\n        if (ignoreCase) {\r\n            // Checking if \"collator exists indicates that Intl is available.\r\n            // We still have to check if \"collator.compare\" is correct. If it is not, use \"String.localeComapre\"\r\n            if (collator) {\r\n                const result = localeCompareIsCorrect ?\r\n                    collator.compare(a, b) :\r\n                    a.localeCompare(b, /*locales*/ undefined, { usage: \"sort\", sensitivity: \"accent\" });  // accent means a ≠ b, a ≠ á, a = A\r\n                return result < 0 ? Comparison.LessThan : result > 0 ? Comparison.GreaterThan : Comparison.EqualTo;\r\n            }\r\n\r\n            a = a.toUpperCase();\r\n            b = b.toUpperCase();\r\n            if (a === b) return Comparison.EqualTo;\r\n        }\r\n\r\n        return a < b ? Comparison.LessThan : Comparison.GreaterThan;\r\n    }\r\n\r\n    export function compareStringsCaseInsensitive(a: string, b: string) {\r\n        return compareStrings(a, b, /*ignoreCase*/ true);\r\n    }\r\n\r\n    function getDiagnosticFileName(diagnostic: Diagnostic): string {\r\n        return diagnostic.file ? diagnostic.file.fileName : undefined;\r\n    }\r\n\r\n    export function compareDiagnostics(d1: Diagnostic, d2: Diagnostic): Comparison {\r\n        return compareValues(getDiagnosticFileName(d1), getDiagnosticFileName(d2)) ||\r\n            compareValues(d1.start, d2.start) ||\r\n            compareValues(d1.length, d2.length) ||\r\n            compareValues(d1.code, d2.code) ||\r\n            compareMessageText(d1.messageText, d2.messageText) ||\r\n            Comparison.EqualTo;\r\n    }\r\n\r\n    function compareMessageText(text1: string | DiagnosticMessageChain, text2: string | DiagnosticMessageChain): Comparison {\r\n        while (text1 && text2) {\r\n            // We still have both chains.\r\n            const string1 = isString(text1) ? text1 : text1.messageText;\r\n            const string2 = isString(text2) ? text2 : text2.messageText;\r\n\r\n            const res = compareValues(string1, string2);\r\n            if (res) {\r\n                return res;\r\n            }\r\n\r\n            text1 = isString(text1) ? undefined : text1.next;\r\n            text2 = isString(text2) ? undefined : text2.next;\r\n        }\r\n\r\n        if (!text1 && !text2) {\r\n            // if the chains are done, then these messages are the same.\r\n            return Comparison.EqualTo;\r\n        }\r\n\r\n        // We still have one chain remaining.  The shorter chain should come first.\r\n        return text1 ? Comparison.GreaterThan : Comparison.LessThan;\r\n    }\r\n\r\n    export function sortAndDeduplicateDiagnostics(diagnostics: Diagnostic[]): Diagnostic[] {\r\n        return deduplicateSortedDiagnostics(diagnostics.sort(compareDiagnostics));\r\n    }\r\n\r\n    export function deduplicateSortedDiagnostics(diagnostics: Diagnostic[]): Diagnostic[] {\r\n        if (diagnostics.length < 2) {\r\n            return diagnostics;\r\n        }\r\n\r\n        const newDiagnostics = [diagnostics[0]];\r\n        let previousDiagnostic = diagnostics[0];\r\n        for (let i = 1; i < diagnostics.length; i++) {\r\n            const currentDiagnostic = diagnostics[i];\r\n            const isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === Comparison.EqualTo;\r\n            if (!isDupe) {\r\n                newDiagnostics.push(currentDiagnostic);\r\n                previousDiagnostic = currentDiagnostic;\r\n            }\r\n        }\r\n\r\n        return newDiagnostics;\r\n    }\r\n\r\n    export function normalizeSlashes(path: string): string {\r\n        return path.replace(/\\\\/g, \"/\");\r\n    }\r\n\r\n    /**\r\n     * Returns length of path root (i.e. length of \"/\", \"x:/\", \"//server/share/, file:///user/files\")\r\n     */\r\n    export function getRootLength(path: string): number {\r\n        if (path.charCodeAt(0) === CharacterCodes.slash) {\r\n            if (path.charCodeAt(1) !== CharacterCodes.slash) return 1;\r\n            const p1 = path.indexOf(\"/\", 2);\r\n            if (p1 < 0) return 2;\r\n            const p2 = path.indexOf(\"/\", p1 + 1);\r\n            if (p2 < 0) return p1 + 1;\r\n            return p2 + 1;\r\n        }\r\n        if (path.charCodeAt(1) === CharacterCodes.colon) {\r\n            if (path.charCodeAt(2) === CharacterCodes.slash) return 3;\r\n            return 2;\r\n        }\r\n        // Per RFC 1738 'file' URI schema has the shape file://<host>/<path>\r\n        // if <host> is omitted then it is assumed that host value is 'localhost',\r\n        // however slash after the omitted <host> is not removed.\r\n        // file:///folder1/file1 - this is a correct URI\r\n        // file://folder2/file2 - this is an incorrect URI\r\n        if (path.lastIndexOf(\"file:///\", 0) === 0) {\r\n            return \"file:///\".length;\r\n        }\r\n        const idx = path.indexOf(\"://\");\r\n        if (idx !== -1) {\r\n            return idx + \"://\".length;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Internally, we represent paths as strings with '/' as the directory separator.\r\n     * When we make system calls (eg: LanguageServiceHost.getDirectory()),\r\n     * we expect the host to correctly handle paths in our specified format.\r\n     */\r\n    export const directorySeparator = \"/\";\r\n    const directorySeparatorCharCode = CharacterCodes.slash;\r\n    function getNormalizedParts(normalizedSlashedPath: string, rootLength: number): string[] {\r\n        const parts = normalizedSlashedPath.substr(rootLength).split(directorySeparator);\r\n        const normalized: string[] = [];\r\n        for (const part of parts) {\r\n            if (part !== \".\") {\r\n                if (part === \"..\" && normalized.length > 0 && lastOrUndefined(normalized) !== \"..\") {\r\n                    normalized.pop();\r\n                }\r\n                else {\r\n                    // A part may be an empty string (which is 'falsy') if the path had consecutive slashes,\r\n                    // e.g. \"path//file.ts\".  Drop these before re-joining the parts.\r\n                    if (part) {\r\n                        normalized.push(part);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return normalized;\r\n    }\r\n\r\n    export function normalizePath(path: string): string {\r\n        return normalizePathAndParts(path).path;\r\n    }\r\n\r\n    export function normalizePathAndParts(path: string): { path: string, parts: string[] } {\r\n        path = normalizeSlashes(path);\r\n        const rootLength = getRootLength(path);\r\n        const root = path.substr(0, rootLength);\r\n        const parts = getNormalizedParts(path, rootLength);\r\n        if (parts.length) {\r\n            const joinedParts = root + parts.join(directorySeparator);\r\n            return { path: pathEndsWithDirectorySeparator(path) ? joinedParts + directorySeparator : joinedParts, parts };\r\n        }\r\n        else {\r\n            return { path: root, parts };\r\n        }\r\n    }\r\n\r\n    /** A path ending with '/' refers to a directory only, never a file. */\r\n    export function pathEndsWithDirectorySeparator(path: string): boolean {\r\n        return path.charCodeAt(path.length - 1) === directorySeparatorCharCode;\r\n    }\r\n\r\n    /**\r\n     * Returns the path except for its basename. Eg:\r\n     *\r\n     * /path/to/file.ext -> /path/to\r\n     */\r\n    export function getDirectoryPath(path: Path): Path;\r\n    export function getDirectoryPath(path: string): string;\r\n    export function getDirectoryPath(path: string): string {\r\n        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(directorySeparator)));\r\n    }\r\n\r\n    export function isUrl(path: string) {\r\n        return path && !isRootedDiskPath(path) && stringContains(path, \"://\");\r\n    }\r\n\r\n    export function pathIsRelative(path: string): boolean {\r\n        return /^\\.\\.?($|[\\\\/])/.test(path);\r\n    }\r\n\r\n    /** @deprecated Use `!isExternalModuleNameRelative(moduleName)` instead. */\r\n    export function moduleHasNonRelativeName(moduleName: string): boolean {\r\n        return !isExternalModuleNameRelative(moduleName);\r\n    }\r\n\r\n    export function getEmitScriptTarget(compilerOptions: CompilerOptions) {\r\n        return compilerOptions.target || ScriptTarget.ES3;\r\n    }\r\n\r\n    export function getEmitModuleKind(compilerOptions: CompilerOptions) {\r\n        return typeof compilerOptions.module === \"number\" ?\r\n            compilerOptions.module :\r\n            getEmitScriptTarget(compilerOptions) >= ScriptTarget.ES2015 ? ModuleKind.ES2015 : ModuleKind.CommonJS;\r\n    }\r\n\r\n    export function getEmitModuleResolutionKind(compilerOptions: CompilerOptions) {\r\n        let moduleResolution = compilerOptions.moduleResolution;\r\n        if (moduleResolution === undefined) {\r\n            moduleResolution = getEmitModuleKind(compilerOptions) === ModuleKind.CommonJS ? ModuleResolutionKind.NodeJs : ModuleResolutionKind.Classic;\r\n        }\r\n        return moduleResolution;\r\n    }\r\n\r\n    export function hasZeroOrOneAsteriskCharacter(str: string): boolean {\r\n        let seenAsterisk = false;\r\n        for (let i = 0; i < str.length; i++) {\r\n            if (str.charCodeAt(i) === CharacterCodes.asterisk) {\r\n                if (!seenAsterisk) {\r\n                    seenAsterisk = true;\r\n                }\r\n                else {\r\n                    // have already seen asterisk\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    export function isRootedDiskPath(path: string) {\r\n        return path && getRootLength(path) !== 0;\r\n    }\r\n\r\n    export function convertToRelativePath(absoluteOrRelativePath: string, basePath: string, getCanonicalFileName: (path: string) => string): string {\r\n        return !isRootedDiskPath(absoluteOrRelativePath)\r\n            ? absoluteOrRelativePath\r\n            : getRelativePathToDirectoryOrUrl(basePath, absoluteOrRelativePath, basePath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);\r\n    }\r\n\r\n    function normalizedPathComponents(path: string, rootLength: number) {\r\n        const normalizedParts = getNormalizedParts(path, rootLength);\r\n        return [path.substr(0, rootLength)].concat(normalizedParts);\r\n    }\r\n\r\n    export function getNormalizedPathComponents(path: string, currentDirectory: string) {\r\n        path = normalizeSlashes(path);\r\n        let rootLength = getRootLength(path);\r\n        if (rootLength === 0) {\r\n            // If the path is not rooted it is relative to current directory\r\n            path = combinePaths(normalizeSlashes(currentDirectory), path);\r\n            rootLength = getRootLength(path);\r\n        }\r\n\r\n        return normalizedPathComponents(path, rootLength);\r\n    }\r\n\r\n    export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string) {\r\n        return getNormalizedPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n    }\r\n\r\n    export function getNormalizedPathFromPathComponents(pathComponents: ReadonlyArray<string>) {\r\n        if (pathComponents && pathComponents.length) {\r\n            return pathComponents[0] + pathComponents.slice(1).join(directorySeparator);\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathComponentsOfUrl(url: string) {\r\n        // Get root length of http://www.website.com/folder1/folder2/\r\n        // In this example the root is:  http://www.website.com/\r\n        // normalized path components should be [\"http://www.website.com/\", \"folder1\", \"folder2\"]\r\n\r\n        const urlLength = url.length;\r\n        // Initial root length is http:// part\r\n        let rootLength = url.indexOf(\"://\") + \"://\".length;\r\n        while (rootLength < urlLength) {\r\n            // Consume all immediate slashes in the protocol\r\n            // eg.initial rootlength is just file:// but it needs to consume another \"/\" in file:///\r\n            if (url.charCodeAt(rootLength) === CharacterCodes.slash) {\r\n                rootLength++;\r\n            }\r\n            else {\r\n                // non slash character means we continue proceeding to next component of root search\r\n                break;\r\n            }\r\n        }\r\n\r\n        // there are no parts after http:// just return current string as the pathComponent\r\n        if (rootLength === urlLength) {\r\n            return [url];\r\n        }\r\n\r\n        // Find the index of \"/\" after website.com so the root can be http://www.website.com/ (from existing http://)\r\n        const indexOfNextSlash = url.indexOf(directorySeparator, rootLength);\r\n        if (indexOfNextSlash !== -1) {\r\n            // Found the \"/\" after the website.com so the root is length of http://www.website.com/\r\n            // and get components after the root normally like any other folder components\r\n            rootLength = indexOfNextSlash + 1;\r\n            return normalizedPathComponents(url, rootLength);\r\n        }\r\n        else {\r\n            // Can't find the host assume the rest of the string as component\r\n            // but make sure we append \"/\"  to it as root is not joined using \"/\"\r\n            // eg. if url passed in was http://website.com we want to use root as [http://website.com/]\r\n            // so that other path manipulations will be correct and it can be merged with relative paths correctly\r\n            return [url + directorySeparator];\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathOrUrlComponents(pathOrUrl: string, currentDirectory: string) {\r\n        if (isUrl(pathOrUrl)) {\r\n            return getNormalizedPathComponentsOfUrl(pathOrUrl);\r\n        }\r\n        else {\r\n            return getNormalizedPathComponents(pathOrUrl, currentDirectory);\r\n        }\r\n    }\r\n\r\n    export function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, relativeOrAbsolutePath: string, currentDirectory: string, getCanonicalFileName: (fileName: string) => string, isAbsolutePathAnUrl: boolean) {\r\n        const pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);\r\n        const directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);\r\n        if (directoryComponents.length > 1 && lastOrUndefined(directoryComponents) === \"\") {\r\n            // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name\r\n            // that is  [\"test\", \"cases\", \"\"] needs to be actually [\"test\", \"cases\"]\r\n            directoryComponents.pop();\r\n        }\r\n\r\n        // Find the component that differs\r\n        let joinStartIndex: number;\r\n        for (joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n            if (getCanonicalFileName(directoryComponents[joinStartIndex]) !== getCanonicalFileName(pathComponents[joinStartIndex])) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the relative path\r\n        if (joinStartIndex) {\r\n            let relativePath = \"\";\r\n            const relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);\r\n            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n                if (directoryComponents[joinStartIndex] !== \"\") {\r\n                    relativePath = relativePath + \"..\" + directorySeparator;\r\n                }\r\n            }\r\n\r\n            return relativePath + relativePathComponents.join(directorySeparator);\r\n        }\r\n\r\n        // Cant find the relative path, get the absolute path\r\n        let absolutePath = getNormalizedPathFromPathComponents(pathComponents);\r\n        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {\r\n            absolutePath = \"file:///\" + absolutePath;\r\n        }\r\n\r\n        return absolutePath;\r\n    }\r\n\r\n    export function getBaseFileName(path: string) {\r\n        if (path === undefined) {\r\n            return undefined;\r\n        }\r\n        const i = path.lastIndexOf(directorySeparator);\r\n        return i < 0 ? path : path.substring(i + 1);\r\n    }\r\n\r\n    export function combinePaths(path1: string, path2: string): string {\r\n        if (!(path1 && path1.length)) return path2;\r\n        if (!(path2 && path2.length)) return path1;\r\n        if (getRootLength(path2) !== 0) return path2;\r\n        if (path1.charAt(path1.length - 1) === directorySeparator) return path1 + path2;\r\n        return path1 + directorySeparator + path2;\r\n    }\r\n\r\n    /**\r\n     * Removes a trailing directory separator from a path.\r\n     * @param path The path.\r\n     */\r\n    export function removeTrailingDirectorySeparator(path: Path): Path;\r\n    export function removeTrailingDirectorySeparator(path: string): string;\r\n    export function removeTrailingDirectorySeparator(path: string) {\r\n        if (path.charAt(path.length - 1) === directorySeparator) {\r\n            return path.substr(0, path.length - 1);\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Adds a trailing directory separator to a path, if it does not already have one.\r\n     * @param path The path.\r\n     */\r\n    export function ensureTrailingDirectorySeparator(path: string) {\r\n        if (path.charAt(path.length - 1) !== directorySeparator) {\r\n            return path + directorySeparator;\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    export function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean) {\r\n        if (a === b) return Comparison.EqualTo;\r\n        if (a === undefined) return Comparison.LessThan;\r\n        if (b === undefined) return Comparison.GreaterThan;\r\n        a = removeTrailingDirectorySeparator(a);\r\n        b = removeTrailingDirectorySeparator(b);\r\n        const aComponents = getNormalizedPathComponents(a, currentDirectory);\r\n        const bComponents = getNormalizedPathComponents(b, currentDirectory);\r\n        const sharedLength = Math.min(aComponents.length, bComponents.length);\r\n        for (let i = 0; i < sharedLength; i++) {\r\n            const result = compareStrings(aComponents[i], bComponents[i], ignoreCase);\r\n            if (result !== Comparison.EqualTo) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return compareValues(aComponents.length, bComponents.length);\r\n    }\r\n\r\n    export function containsPath(parent: string, child: string, currentDirectory: string, ignoreCase?: boolean) {\r\n        if (parent === undefined || child === undefined) return false;\r\n        if (parent === child) return true;\r\n        parent = removeTrailingDirectorySeparator(parent);\r\n        child = removeTrailingDirectorySeparator(child);\r\n        if (parent === child) return true;\r\n        const parentComponents = getNormalizedPathComponents(parent, currentDirectory);\r\n        const childComponents = getNormalizedPathComponents(child, currentDirectory);\r\n        if (childComponents.length < parentComponents.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < parentComponents.length; i++) {\r\n            const result = compareStrings(parentComponents[i], childComponents[i], ignoreCase);\r\n            if (result !== Comparison.EqualTo) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    export function startsWith(str: string, prefix: string): boolean {\r\n        return str.lastIndexOf(prefix, 0) === 0;\r\n    }\r\n\r\n    export function removePrefix(str: string, prefix: string): string {\r\n        return startsWith(str, prefix) ? str.substr(prefix.length) : str;\r\n    }\r\n\r\n    export function endsWith(str: string, suffix: string): boolean {\r\n        const expectedPos = str.length - suffix.length;\r\n        return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\r\n    }\r\n\r\n    export function stringContains(str: string, substring: string): boolean {\r\n        return str.indexOf(substring) !== -1;\r\n    }\r\n\r\n    export function hasExtension(fileName: string): boolean {\r\n        return stringContains(getBaseFileName(fileName), \".\");\r\n    }\r\n\r\n    export function fileExtensionIs(path: string, extension: string): boolean {\r\n        return path.length > extension.length && endsWith(path, extension);\r\n    }\r\n\r\n    export function fileExtensionIsOneOf(path: string, extensions: ReadonlyArray<string>): boolean {\r\n        for (const extension of extensions) {\r\n            if (fileExtensionIs(path, extension)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\r\n    // It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\r\n    // proof.\r\n    const reservedCharacterPattern = /[^\\w\\s\\/]/g;\r\n    const wildcardCharCodes = [CharacterCodes.asterisk, CharacterCodes.question];\r\n\r\n    export const commonPackageFolders: ReadonlyArray<string> = [\"node_modules\", \"bower_components\", \"jspm_packages\"];\r\n\r\n    const implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join(\"|\")})(/|$))`;\r\n\r\n    interface WildcardMatcher {\r\n        singleAsteriskRegexFragment: string;\r\n        doubleAsteriskRegexFragment: string;\r\n        replaceWildcardCharacter: (match: string) => string;\r\n    }\r\n\r\n    const filesMatcher: WildcardMatcher = {\r\n        /**\r\n         * Matches any single directory segment unless it is the last segment and a .min.js file\r\n         * Breakdown:\r\n         *  [^./]                   # matches everything up to the first . character (excluding directory seperators)\r\n         *  (\\\\.(?!min\\\\.js$))?     # matches . characters but not if they are part of the .min.js file extension\r\n         */\r\n        singleAsteriskRegexFragment: \"([^./]|(\\\\.(?!min\\\\.js$))?)*\",\r\n        /**\r\n         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including\r\n         * files or directories, does not match subdirectories that start with a . character\r\n         */\r\n        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const directoriesMatcher: WildcardMatcher = {\r\n        singleAsteriskRegexFragment: \"[^/]*\",\r\n        /**\r\n         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including\r\n         * files or directories, does not match subdirectories that start with a . character\r\n         */\r\n        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const excludeMatcher: WildcardMatcher = {\r\n        singleAsteriskRegexFragment: \"[^/]*\",\r\n        doubleAsteriskRegexFragment: \"(/.+?)?\",\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const wildcardMatchers = {\r\n        files: filesMatcher,\r\n        directories: directoriesMatcher,\r\n        exclude: excludeMatcher,\r\n        文件集: filesMatcher,\r\n        目录集: directoriesMatcher,\r\n        排除: filesMatcher\r\n    };\r\n\r\n    export function getRegularExpressionForWildcard(specs: ReadonlyArray<string>, basePath: string, usage: \"files\" | \"directories\" | \"exclude\" | \"文件集\" | \"目录集\" | \"排除\"): string | undefined {\r\n        const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);\r\n        if (!patterns || !patterns.length) {\r\n            return undefined;\r\n        }\r\n\r\n        const pattern = patterns.map(pattern => `(${pattern})`).join(\"|\");\r\n        // If excluding, match \"foo/bar/baz...\", but if including, only allow \"foo\".\r\n        const terminator = usage === \"exclude\" || usage === \"排除\"  ? \"($|/)\" : \"$\";\r\n        return `^(${pattern})${terminator}`;\r\n    }\r\n\r\n    function getRegularExpressionsForWildcards(specs: ReadonlyArray<string>, basePath: string, usage: \"files\" | \"directories\" | \"exclude\" | \"文件集\" | \"目录集\" | \"排除\"): string[] | undefined {\r\n        if (specs === undefined || specs.length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return flatMap(specs, spec =>\r\n            spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));\r\n    }\r\n\r\n    /**\r\n     * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\r\n     * and does not contain any glob characters itself.\r\n     */\r\n    export function isImplicitGlob(lastPathComponent: string): boolean {\r\n        return !/[.*?]/.test(lastPathComponent);\r\n    }\r\n\r\n    function getSubPatternFromSpec(spec: string, basePath: string, usage: \"files\" | \"directories\" | \"exclude\" | \"文件集\" | \"目录集\" | \"排除\", { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter }: WildcardMatcher): string | undefined {\r\n        let subpattern = \"\";\r\n        let hasRecursiveDirectoryWildcard = false;\r\n        let hasWrittenComponent = false;\r\n        const components = getNormalizedPathComponents(spec, basePath);\r\n        const lastComponent = lastOrUndefined(components);\r\n        if (usage !== \"exclude\"&& usage !== \"排除\"  && lastComponent === \"**\") {\r\n            return undefined;\r\n        }\r\n\r\n        // getNormalizedPathComponents includes the separator for the root component.\r\n        // We need to remove to create our regex correctly.\r\n        components[0] = removeTrailingDirectorySeparator(components[0]);\r\n\r\n        if (isImplicitGlob(lastComponent)) {\r\n            components.push(\"**\", \"*\");\r\n        }\r\n\r\n        let optionalCount = 0;\r\n        for (let component of components) {\r\n            if (component === \"**\") {\r\n                if (hasRecursiveDirectoryWildcard) {\r\n                    return undefined;\r\n                }\r\n\r\n                subpattern += doubleAsteriskRegexFragment;\r\n                hasRecursiveDirectoryWildcard = true;\r\n            }\r\n            else {\r\n                if (usage === \"directories\" || usage === \"目录集\") {\r\n                    subpattern += \"(\";\r\n                    optionalCount++;\r\n                }\r\n\r\n                if (hasWrittenComponent) {\r\n                    subpattern += directorySeparator;\r\n                }\r\n\r\n                if (usage !== \"exclude\"&& usage !== \"排除\") {\r\n                    let componentPattern = \"\";\r\n                    // The * and ? wildcards should not match directories or files that start with . if they\r\n                    // appear first in a component. Dotted directories and files can be included explicitly\r\n                    // like so: **/.*/.*\r\n                    if (component.charCodeAt(0) === CharacterCodes.asterisk) {\r\n                        componentPattern += \"([^./]\" + singleAsteriskRegexFragment + \")?\";\r\n                        component = component.substr(1);\r\n                    }\r\n                    else if (component.charCodeAt(0) === CharacterCodes.question) {\r\n                        componentPattern += \"[^./]\";\r\n                        component = component.substr(1);\r\n                    }\r\n\r\n                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\r\n\r\n                    // Patterns should not include subfolders like node_modules unless they are\r\n                    // explicitly included as part of the path.\r\n                    //\r\n                    // As an optimization, if the component pattern is the same as the component,\r\n                    // then there definitely were no wildcard characters and we do not need to\r\n                    // add the exclusion pattern.\r\n                    if (componentPattern !== component) {\r\n                        subpattern += implicitExcludePathRegexPattern;\r\n                    }\r\n\r\n                    subpattern += componentPattern;\r\n                }\r\n                else {\r\n                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\r\n                }\r\n            }\r\n\r\n            hasWrittenComponent = true;\r\n        }\r\n\r\n        while (optionalCount > 0) {\r\n            subpattern += \")?\";\r\n            optionalCount--;\r\n        }\r\n\r\n        return subpattern;\r\n    }\r\n\r\n    function replaceWildcardCharacter(match: string, singleAsteriskRegexFragment: string) {\r\n        return match === \"*\" ? singleAsteriskRegexFragment : match === \"?\" ? \"[^/]\" : \"\\\\\" + match;\r\n    }\r\n\r\n    export interface FileSystemEntries {\r\n        readonly files: ReadonlyArray<string>;\r\n        readonly directories: ReadonlyArray<string>;\r\n    }\r\n\r\n    export interface FileMatcherPatterns {\r\n        /** One pattern for each \"include\" spec. */\r\n        includeFilePatterns: ReadonlyArray<string>;\r\n        /** One pattern matching one of any of the \"include\" specs. */\r\n        includeFilePattern: string;\r\n        includeDirectoryPattern: string;\r\n        excludePattern: string;\r\n        basePaths: ReadonlyArray<string>;\r\n    }\r\n\r\n    export function getFileMatcherPatterns(path: string, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns {\r\n        path = normalizePath(path);\r\n        currentDirectory = normalizePath(currentDirectory);\r\n        const absolutePath = combinePaths(currentDirectory, path);\r\n\r\n        return {\r\n            includeFilePatterns: map(getRegularExpressionsForWildcards(includes, absolutePath, \"files\"), pattern => `^${pattern}$`),\r\n            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, \"files\") || getRegularExpressionForWildcard(includes, absolutePath, \"文件集\"),\r\n            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, \"directories\") || getRegularExpressionForWildcard(includes, absolutePath, \"目录集\"),\r\n            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, \"exclude\") || getRegularExpressionForWildcard(excludes, absolutePath, \"排除\"),\r\n            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)\r\n        };\r\n    }\r\n\r\n    export function matchFiles(path: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries): string[] {\r\n        path = normalizePath(path);\r\n        currentDirectory = normalizePath(currentDirectory);\r\n\r\n        const patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);\r\n\r\n        const regexFlag = useCaseSensitiveFileNames ? \"\" : \"i\";\r\n        const includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(pattern => new RegExp(pattern, regexFlag));\r\n        const includeDirectoryRegex = patterns.includeDirectoryPattern && new RegExp(patterns.includeDirectoryPattern, regexFlag);\r\n        const excludeRegex = patterns.excludePattern && new RegExp(patterns.excludePattern, regexFlag);\r\n\r\n        // Associate an array of results with each include regex. This keeps results in order of the \"include\" order.\r\n        // If there are no \"includes\", then just put everything in results[0].\r\n        const results: string[][] = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];\r\n\r\n        const comparer = useCaseSensitiveFileNames ? compareStrings : compareStringsCaseInsensitive;\r\n        for (const basePath of patterns.basePaths) {\r\n            visitDirectory(basePath, combinePaths(currentDirectory, basePath), depth);\r\n        }\r\n\r\n        return flatten<string>(results);\r\n\r\n        function visitDirectory(path: string, absolutePath: string, depth: number | undefined) {\r\n            let { files, directories } = getFileSystemEntries(path);\r\n            files = files.slice().sort(comparer);\r\n\r\n            for (const current of files) {\r\n                const name = combinePaths(path, current);\r\n                const absoluteName = combinePaths(absolutePath, current);\r\n                if (extensions && !fileExtensionIsOneOf(name, extensions)) continue;\r\n                if (excludeRegex && excludeRegex.test(absoluteName)) continue;\r\n                if (!includeFileRegexes) {\r\n                    results[0].push(name);\r\n                }\r\n                else {\r\n                    const includeIndex = findIndex(includeFileRegexes, re => re.test(absoluteName));\r\n                    if (includeIndex !== -1) {\r\n                        results[includeIndex].push(name);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (depth !== undefined) {\r\n                depth--;\r\n                if (depth === 0) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            directories = directories.slice().sort(comparer);\r\n            for (const current of directories) {\r\n                const name = combinePaths(path, current);\r\n                const absoluteName = combinePaths(absolutePath, current);\r\n                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&\r\n                    (!excludeRegex || !excludeRegex.test(absoluteName))) {\r\n                    visitDirectory(name, absoluteName, depth);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the unique non-wildcard base paths amongst the provided include patterns.\r\n     */\r\n    function getBasePaths(path: string, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean) {\r\n        // Storage for our results in the form of literal paths (e.g. the paths as written by the user).\r\n        const basePaths: string[] = [path];\r\n\r\n        if (includes) {\r\n            // Storage for literal base paths amongst the include patterns.\r\n            const includeBasePaths: string[] = [];\r\n            for (const include of includes) {\r\n                // We also need to check the relative paths by converting them to absolute and normalizing\r\n                // in case they escape the base path (e.g \"..\\somedirectory\")\r\n                const absolute: string = isRootedDiskPath(include) ? include : normalizePath(combinePaths(path, include));\r\n                // Append the literal and canonical candidate base paths.\r\n                includeBasePaths.push(getIncludeBasePath(absolute));\r\n            }\r\n\r\n            // Sort the offsets array using either the literal or canonical path representations.\r\n            includeBasePaths.sort(useCaseSensitiveFileNames ? compareStrings : compareStringsCaseInsensitive);\r\n\r\n            // Iterate over each include base path and include unique base paths that are not a\r\n            // subpath of an existing base path\r\n            for (const includeBasePath of includeBasePaths) {\r\n                if (ts.every(basePaths, basePath => !containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames))) {\r\n                    basePaths.push(includeBasePath);\r\n                }\r\n            }\r\n        }\r\n\r\n        return basePaths;\r\n    }\r\n\r\n    function getIncludeBasePath(absolute: string): string {\r\n        const wildcardOffset = indexOfAnyCharCode(absolute, wildcardCharCodes);\r\n        if (wildcardOffset < 0) {\r\n            // No \"*\" or \"?\" in the path\r\n            return !hasExtension(absolute)\r\n                ? absolute\r\n                : removeTrailingDirectorySeparator(getDirectoryPath(absolute));\r\n        }\r\n        return absolute.substring(0, absolute.lastIndexOf(directorySeparator, wildcardOffset));\r\n    }\r\n\r\n    export function ensureScriptKind(fileName: string, scriptKind: ScriptKind | undefined): ScriptKind {\r\n        // Using scriptKind as a condition handles both:\r\n        // - 'scriptKind' is unspecified and thus it is `undefined`\r\n        // - 'scriptKind' is set and it is `Unknown` (0)\r\n        // If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt\r\n        // to get the ScriptKind from the file name. If it cannot be resolved\r\n        // from the file name then the default 'TS' script kind is returned.\r\n        return scriptKind || getScriptKindFromFileName(fileName) || ScriptKind.TS;\r\n    }\r\n\r\n    export function getScriptKindFromFileName(fileName: string): ScriptKind {\r\n        const ext = fileName.substr(fileName.lastIndexOf(\".\"));\r\n        switch (ext.toLowerCase()) {\r\n            case Extension.Js:\r\n                return ScriptKind.JS;\r\n            case Extension.Jsx:\r\n                return ScriptKind.JSX;\r\n            case Extension.Ts:\r\n                return ScriptKind.TS;\r\n            case Extension.CTs:\r\n                return ScriptKind.CTS;\r\n            case Extension.Tsx:\r\n                return ScriptKind.TSX;\r\n            case Extension.CTsx:\r\n                return ScriptKind.CTSX;\r\n            case Extension.Json:\r\n                return ScriptKind.JSON;\r\n            default:\r\n                return ScriptKind.Unknown;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  List of supported extensions in order of file resolution precedence.\r\n     */\r\n    export const supportedTypeScriptExtensions: ReadonlyArray<Extension> = [Extension.Ts, Extension.CTs, Extension.Tsx, Extension.CTsx, Extension.Dts, Extension.DCts];\r\n    /** Must have \".d.ts\" first because if \".ts\" goes first, that will be detected as the extension instead of \".d.ts\". */\r\n    export const supportedTypescriptExtensionsForExtractExtension: ReadonlyArray<Extension> = [Extension.Dts, Extension.DCts, Extension.Ts, Extension.CTs, Extension.Tsx, Extension.CTsx];\r\n    export const supportedJavascriptExtensions: ReadonlyArray<Extension> = [Extension.Js, Extension.Jsx];\r\n    const allSupportedExtensions: ReadonlyArray<Extension> = [...supportedTypeScriptExtensions, ...supportedJavascriptExtensions];\r\n\r\n    export function getSupportedExtensions(options?: CompilerOptions, extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ReadonlyArray<string> {\r\n        const needAllExtensions = options && options.allowJs;\r\n        if (!extraFileExtensions || extraFileExtensions.length === 0 || !needAllExtensions) {\r\n            return needAllExtensions ? allSupportedExtensions : supportedTypeScriptExtensions;\r\n        }\r\n        return deduplicate([...allSupportedExtensions, ...extraFileExtensions.map(e => e.extension)]);\r\n    }\r\n\r\n    export function hasJavaScriptFileExtension(fileName: string) {\r\n        return forEach(supportedJavascriptExtensions, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n\r\n    export function hasTypeScriptFileExtension(fileName: string) {\r\n        return forEach(supportedTypeScriptExtensions, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n\r\n    export function isSupportedSourceFileName(fileName: string, compilerOptions?: CompilerOptions, extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>) {\r\n        if (!fileName) { return false; }\r\n\r\n        for (const extension of getSupportedExtensions(compilerOptions, extraFileExtensions)) {\r\n            if (fileExtensionIs(fileName, extension)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Extension boundaries by priority. Lower numbers indicate higher priorities, and are\r\n     * aligned to the offset of the highest priority extension in the\r\n     * allSupportedExtensions array.\r\n     */\r\n    export const enum ExtensionPriority {\r\n        TypeScriptFiles = 0,\r\n        DeclarationAndJavaScriptFiles = 4,\r\n\r\n        Highest = TypeScriptFiles,\r\n        Lowest = DeclarationAndJavaScriptFiles,\r\n    }\r\n\r\n    export function getExtensionPriority(path: string, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        for (let i = supportedExtensions.length - 1; i >= 0; i--) {\r\n            if (fileExtensionIs(path, supportedExtensions[i])) {\r\n                return adjustExtensionPriority(<ExtensionPriority>i, supportedExtensions);\r\n            }\r\n        }\r\n\r\n        // If its not in the list of supported extensions, this is likely a\r\n        // TypeScript file with a non-ts extension\r\n        return ExtensionPriority.Highest;\r\n    }\r\n\r\n    /**\r\n     * Adjusts an extension priority to be the highest priority within the same range.\r\n     */\r\n    export function adjustExtensionPriority(extensionPriority: ExtensionPriority, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        if (extensionPriority < ExtensionPriority.DeclarationAndJavaScriptFiles) {\r\n            return ExtensionPriority.TypeScriptFiles;\r\n        }\r\n        else if (extensionPriority < supportedExtensions.length) {\r\n            return ExtensionPriority.DeclarationAndJavaScriptFiles;\r\n        }\r\n        else {\r\n            return supportedExtensions.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the next lowest extension priority for a given priority.\r\n     */\r\n    export function getNextLowestExtensionPriority(extensionPriority: ExtensionPriority, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        if (extensionPriority < ExtensionPriority.DeclarationAndJavaScriptFiles) {\r\n            return ExtensionPriority.DeclarationAndJavaScriptFiles;\r\n        }\r\n        else {\r\n            return supportedExtensions.length;\r\n        }\r\n    }\r\n\r\n    const extensionsToRemove = [Extension.Dts,Extension.DCts, Extension.Ts,  Extension.CTs,Extension.Js, Extension.Tsx, Extension.CTsx, Extension.Jsx];\r\n    export function removeFileExtension(path: string): string {\r\n        for (const ext of extensionsToRemove) {\r\n            const extensionless = tryRemoveExtension(path, ext);\r\n            if (extensionless !== undefined) {\r\n                return extensionless;\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n\r\n    export function tryRemoveExtension(path: string, extension: string): string | undefined {\r\n        return fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;\r\n    }\r\n\r\n    export function removeExtension(path: string, extension: string): string {\r\n        return path.substring(0, path.length - extension.length);\r\n    }\r\n\r\n    export function changeExtension<T extends string | Path>(path: T, newExtension: string): T {\r\n        return <T>(removeFileExtension(path) + newExtension);\r\n    }\r\n\r\n    export interface ObjectAllocator {\r\n        getNodeConstructor(): new (kind: SyntaxKind, pos?: number, end?: number) => Node;\r\n        getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos?: number, end?: number) => Token<TKind>;\r\n        getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos?: number, end?: number) => Identifier;\r\n        getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos?: number, end?: number) => SourceFile;\r\n        getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol;\r\n        getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type;\r\n        getSignatureConstructor(): new (checker: TypeChecker) => Signature;\r\n        get别名构造函数(): new (旗帜: 别名旗帜, 名称: __String) => 别名;\r\n        getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource;\r\n    }\r\n\r\n    function Symbol(this: Symbol, flags: SymbolFlags, name: __String) {\r\n        this.flags = flags;\r\n        this.escapedName = name;\r\n        this.declarations = undefined;\r\n    }\r\n\r\n    function 别名(this: 别名, 旗帜: 别名旗帜, 名称: __String) {\r\n        this.旗帜 = 旗帜;\r\n        this.名称 = 名称;\r\n    }\r\n\r\n    function Type(this: Type, checker: TypeChecker, flags: TypeFlags) {\r\n        this.flags = flags;\r\n        if (Debug.isDebugging) {\r\n            this.checker = checker;\r\n        }\r\n    }\r\n\r\n    function Signature() {\r\n    }\r\n\r\n    function Node(this: Node, kind: SyntaxKind, pos: number, end: number) {\r\n        this.id = 0;\r\n        this.kind = kind;\r\n        this.pos = pos;\r\n        this.end = end;\r\n        this.flags = NodeFlags.None;\r\n        this.modifierFlagsCache = ModifierFlags.None;\r\n        this.transformFlags = TransformFlags.None;\r\n        this.parent = undefined;\r\n        this.original = undefined;\r\n    }\r\n\r\n    function SourceMapSource(this: SourceMapSource, fileName: string, text: string, skipTrivia?: (pos: number) => number) {\r\n        this.fileName = fileName;\r\n        this.text = text;\r\n        this.skipTrivia = skipTrivia || (pos => pos);\r\n    }\r\n\r\n    export let objectAllocator: ObjectAllocator = {\r\n        getNodeConstructor: () => <any>Node,\r\n        getTokenConstructor: () => <any>Node,\r\n        getIdentifierConstructor: () => <any>Node,\r\n        getSourceFileConstructor: () => <any>Node,\r\n        getSymbolConstructor: () => <any>Symbol,\r\n        getTypeConstructor: () => <any>Type,\r\n        getSignatureConstructor: () => <any>Signature,\r\n        get别名构造函数: () => <any>别名,\r\n        getSourceMapSourceConstructor: () => <any>SourceMapSource,\r\n    };\r\n\r\n    export const enum AssertionLevel {\r\n        None = 0,\r\n        Normal = 1,\r\n        Aggressive = 2,\r\n        VeryAggressive = 3,\r\n    }\r\n\r\n    export namespace Debug {\r\n        export let currentAssertionLevel = AssertionLevel.None;\r\n        export let isDebugging = false;\r\n\r\n        export function shouldAssert(level: AssertionLevel): boolean {\r\n            return currentAssertionLevel >= level;\r\n        }\r\n\r\n        export function assert(expression: boolean, message?: string, verboseDebugInfo?: string | (() => string), stackCrawlMark?: Function): void {\r\n            if (!expression) {\r\n                if (verboseDebugInfo) {\r\n                    message += \"\\r\\nVerbose Debug Information: \" + (typeof verboseDebugInfo === \"string\" ? verboseDebugInfo : verboseDebugInfo());\r\n                }\r\n                fail(message ? \"False expression: \" + message : \"False expression.\", stackCrawlMark || assert);\r\n            }\r\n        }\r\n\r\n        export function assertEqual<T>(a: T, b: T, msg?: string, msg2?: string): void {\r\n            if (a !== b) {\r\n                const message = msg ? msg2 ? `${msg} ${msg2}` : msg : \"\";\r\n                fail(`Expected ${a} === ${b}. ${message}`);\r\n            }\r\n        }\r\n\r\n        export function assertLessThan(a: number, b: number, msg?: string): void {\r\n            if (a >= b) {\r\n                fail(`Expected ${a} < ${b}. ${msg || \"\"}`);\r\n            }\r\n        }\r\n\r\n        export function assertLessThanOrEqual(a: number, b: number): void {\r\n            if (a > b) {\r\n                fail(`Expected ${a} <= ${b}`);\r\n            }\r\n        }\r\n\r\n        export function assertGreaterThanOrEqual(a: number, b: number): void {\r\n            if (a < b) {\r\n                fail(`Expected ${a} >= ${b}`);\r\n            }\r\n        }\r\n\r\n        export function fail(message?: string, stackCrawlMark?: Function): never {\r\n            debugger;\r\n            const e = new Error(message ? `Debug Failure. ${message}` : \"Debug Failure.\");\r\n            if ((<any>Error).captureStackTrace) {\r\n                (<any>Error).captureStackTrace(e, stackCrawlMark || fail);\r\n            }\r\n            throw e;\r\n        }\r\n\r\n        export function assertNever(member: never, message?: string, stackCrawlMark?: Function): never {\r\n            return fail(message || `Illegal value: ${member}`, stackCrawlMark || assertNever);\r\n        }\r\n\r\n        export function getFunctionName(func: Function) {\r\n            if (typeof func !== \"function\") {\r\n                return \"\";\r\n            }\r\n            else if (func.hasOwnProperty(\"name\")) {\r\n                return (<any>func).name;\r\n            }\r\n            else {\r\n                const text = Function.prototype.toString.call(func);\r\n                const match = /^function\\s+([\\w\\$]+)\\s*\\(/.exec(text);\r\n                return match ? match[1] : \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Remove an item from an array, moving everything to its right one space left. */\r\n    export function orderedRemoveItem<T>(array: T[], item: T): boolean {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (array[i] === item) {\r\n                orderedRemoveItemAt(array, i);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Remove an item by index from an array, moving everything to its right one space left. */\r\n    export function orderedRemoveItemAt<T>(array: T[], index: number): void {\r\n        // This seems to be faster than either `array.splice(i, 1)` or `array.copyWithin(i, i+ 1)`.\r\n        for (let i = index; i < array.length - 1; i++) {\r\n            array[i] = array[i + 1];\r\n        }\r\n        array.pop();\r\n    }\r\n\r\n    export function unorderedRemoveItemAt<T>(array: T[], index: number): void {\r\n        // Fill in the \"hole\" left at `index`.\r\n        array[index] = array[array.length - 1];\r\n        array.pop();\r\n    }\r\n\r\n    /** Remove the *first* occurrence of `item` from the array. */\r\n    export function unorderedRemoveItem<T>(array: T[], item: T): void {\r\n        unorderedRemoveFirstItemWhere(array, element => element === item);\r\n    }\r\n\r\n    /** Remove the *first* element satisfying `predicate`. */\r\n    function unorderedRemoveFirstItemWhere<T>(array: T[], predicate: (element: T) => boolean): void {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (predicate(array[i])) {\r\n                unorderedRemoveItemAt(array, i);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function createGetCanonicalFileName(useCaseSensitiveFileNames: boolean): (fileName: string) => string {\r\n        return useCaseSensitiveFileNames\r\n            ? ((fileName) => fileName)\r\n            : ((fileName) => fileName.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * patternStrings contains both pattern strings (containing \"*\") and regular strings.\r\n     * Return an exact match if possible, or a pattern match, or undefined.\r\n     * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\r\n     */\r\n    export function matchPatternOrExact(patternStrings: ReadonlyArray<string>, candidate: string): string | Pattern | undefined {\r\n        const patterns: Pattern[] = [];\r\n        for (const patternString of patternStrings) {\r\n            const pattern = tryParsePattern(patternString);\r\n            if (pattern) {\r\n                patterns.push(pattern);\r\n            }\r\n            else if (patternString === candidate) {\r\n                // pattern was matched as is - no need to search further\r\n                return patternString;\r\n            }\r\n        }\r\n\r\n        return findBestPatternMatch(patterns, _ => _, candidate);\r\n    }\r\n\r\n    export function patternText({prefix, suffix}: Pattern): string {\r\n        return `${prefix}*${suffix}`;\r\n    }\r\n\r\n    /**\r\n     * Given that candidate matches pattern, returns the text matching the '*'.\r\n     * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\r\n     */\r\n    export function matchedText(pattern: Pattern, candidate: string): string {\r\n        Debug.assert(isPatternMatch(pattern, candidate));\r\n        return candidate.substr(pattern.prefix.length, candidate.length - pattern.suffix.length);\r\n    }\r\n\r\n    /** Return the object corresponding to the best pattern to match `candidate`. */\r\n    export function findBestPatternMatch<T>(values: ReadonlyArray<T>, getPattern: (value: T) => Pattern, candidate: string): T | undefined {\r\n        let matchedValue: T | undefined = undefined;\r\n        // use length of prefix as betterness criteria\r\n        let longestMatchPrefixLength = -1;\r\n\r\n        for (const v of values) {\r\n            const pattern = getPattern(v);\r\n            if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\r\n                longestMatchPrefixLength = pattern.prefix.length;\r\n                matchedValue = v;\r\n            }\r\n        }\r\n\r\n        return matchedValue;\r\n    }\r\n\r\n    function isPatternMatch({prefix, suffix}: Pattern, candidate: string) {\r\n        return candidate.length >= prefix.length + suffix.length &&\r\n            startsWith(candidate, prefix) &&\r\n            endsWith(candidate, suffix);\r\n    }\r\n\r\n    export function tryParsePattern(pattern: string): Pattern | undefined {\r\n        // This should be verified outside of here and a proper error thrown.\r\n        Debug.assert(hasZeroOrOneAsteriskCharacter(pattern));\r\n        const indexOfStar = pattern.indexOf(\"*\");\r\n        return indexOfStar === -1 ? undefined : {\r\n            prefix: pattern.substr(0, indexOfStar),\r\n            suffix: pattern.substr(indexOfStar + 1)\r\n        };\r\n    }\r\n\r\n    export function positionIsSynthesized(pos: number): boolean {\r\n        // This is a fast way of testing the following conditions:\r\n        //  pos === undefined || pos === null || isNaN(pos) || pos < 0;\r\n        return !(pos >= 0);\r\n    }\r\n\r\n    /** True if an extension is one of the supported TypeScript extensions. */\r\n    export function extensionIsTypeScript(ext: Extension): boolean {\r\n        return ext === Extension.Ts || ext === Extension.CTs || ext === Extension.Tsx || ext === Extension.CTsx || ext === Extension.Dts|| ext === Extension.DCts;\r\n    }\r\n\r\n    /**\r\n     * Gets the extension from a path.\r\n     * Path must have a valid extension.\r\n     */\r\n    export function extensionFromPath(path: string): Extension {\r\n        const ext = tryGetExtensionFromPath(path);\r\n        if (ext !== undefined) {\r\n            return ext;\r\n        }\r\n        Debug.fail(`File ${path} has unknown extension.`);\r\n    }\r\n\r\n    export function isAnySupportedFileExtension(path: string): boolean {\r\n        return tryGetExtensionFromPath(path) !== undefined;\r\n    }\r\n\r\n    export function tryGetExtensionFromPath(path: string): Extension | undefined {\r\n        return find<Extension>(supportedTypescriptExtensionsForExtractExtension, e => fileExtensionIs(path, e)) || find(supportedJavascriptExtensions, e => fileExtensionIs(path, e));\r\n    }\r\n\r\n    // Retrieves any string from the final \".\" onwards from a base file name.\r\n    // Unlike extensionFromPath, which throws an exception on unrecognized extensions.\r\n    export function getAnyExtensionFromPath(path: string): string | undefined {\r\n        const baseFileName = getBaseFileName(path);\r\n        const extensionIndex = baseFileName.lastIndexOf(\".\");\r\n        if (extensionIndex >= 0) {\r\n            return baseFileName.substring(extensionIndex);\r\n        }\r\n    }\r\n\r\n    export function isCheckJsEnabledForFile(sourceFile: SourceFile, compilerOptions: CompilerOptions) {\r\n        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;\r\n    }\r\n\r\n    export function and<T>(f: (arg: T) => boolean, g: (arg: T) => boolean) {\r\n        return (arg: T) => f(arg) && g(arg);\r\n    }\r\n\r\n    export function assertTypeIsNever(_: never): void { }\r\n\r\n    export interface FileAndDirectoryExistence {\r\n        fileExists: boolean;\r\n        directoryExists: boolean;\r\n    }\r\n\r\n    export interface CachedDirectoryStructureHost extends DirectoryStructureHost {\r\n        /** Returns the queried result for the file exists and directory exists if at all it was done */\r\n        addOrDeleteFileOrDirectory(fileOrDirectory: string, fileOrDirectoryPath: Path): FileAndDirectoryExistence | undefined;\r\n        addOrDeleteFile(fileName: string, filePath: Path, eventKind: FileWatcherEventKind): void;\r\n        clearCache(): void;\r\n    }\r\n\r\n    interface MutableFileSystemEntries {\r\n        readonly files: string[];\r\n        readonly directories: string[];\r\n    }\r\n\r\n    export function createCachedDirectoryStructureHost(host: DirectoryStructureHost): CachedDirectoryStructureHost {\r\n        const cachedReadDirectoryResult = createMap<MutableFileSystemEntries>();\r\n        const getCurrentDirectory = memoize(() => host.getCurrentDirectory());\r\n        const getCanonicalFileName = createGetCanonicalFileName(host.useCaseSensitiveFileNames);\r\n        return {\r\n            useCaseSensitiveFileNames: host.useCaseSensitiveFileNames,\r\n            newLine: host.newLine,\r\n            readFile: (path, encoding) => host.readFile(path, encoding),\r\n            write: s => host.write(s),\r\n            writeFile,\r\n            fileExists,\r\n            directoryExists,\r\n            createDirectory,\r\n            getCurrentDirectory,\r\n            getDirectories,\r\n            readDirectory,\r\n            addOrDeleteFileOrDirectory,\r\n            addOrDeleteFile,\r\n            clearCache,\r\n            exit: code => host.exit(code)\r\n        };\r\n\r\n        function toPath(fileName: string) {\r\n            return ts.toPath(fileName, getCurrentDirectory(), getCanonicalFileName);\r\n        }\r\n\r\n        function getCachedFileSystemEntries(rootDirPath: Path): MutableFileSystemEntries | undefined {\r\n            return cachedReadDirectoryResult.get(rootDirPath);\r\n        }\r\n\r\n        function getCachedFileSystemEntriesForBaseDir(path: Path): MutableFileSystemEntries | undefined {\r\n            return getCachedFileSystemEntries(getDirectoryPath(path));\r\n        }\r\n\r\n        function getBaseNameOfFileName(fileName: string) {\r\n            return getBaseFileName(normalizePath(fileName));\r\n        }\r\n\r\n        function createCachedFileSystemEntries(rootDir: string, rootDirPath: Path) {\r\n            const resultFromHost: MutableFileSystemEntries = {\r\n                files: map(host.readDirectory(rootDir, /*extensions*/ undefined, /*exclude*/ undefined, /*include*/[\"*.*\"]), getBaseNameOfFileName) || [],\r\n                directories: host.getDirectories(rootDir) || []\r\n            };\r\n\r\n            cachedReadDirectoryResult.set(rootDirPath, resultFromHost);\r\n            return resultFromHost;\r\n        }\r\n\r\n        /**\r\n         * If the readDirectory result was already cached, it returns that\r\n         * Otherwise gets result from host and caches it.\r\n         * The host request is done under try catch block to avoid caching incorrect result\r\n         */\r\n        function tryReadDirectory(rootDir: string, rootDirPath: Path): MutableFileSystemEntries | undefined {\r\n            const cachedResult = getCachedFileSystemEntries(rootDirPath);\r\n            if (cachedResult) {\r\n                return cachedResult;\r\n            }\r\n\r\n            try {\r\n                return createCachedFileSystemEntries(rootDir, rootDirPath);\r\n            }\r\n            catch (_e) {\r\n                // If there is exception to read directories, dont cache the result and direct the calls to host\r\n                Debug.assert(!cachedReadDirectoryResult.has(rootDirPath));\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        function fileNameEqual(name1: string, name2: string) {\r\n            return getCanonicalFileName(name1) === getCanonicalFileName(name2);\r\n        }\r\n\r\n        function hasEntry(entries: ReadonlyArray<string>, name: string) {\r\n            return some(entries, file => fileNameEqual(file, name));\r\n        }\r\n\r\n        function updateFileSystemEntry(entries: string[], baseName: string, isValid: boolean) {\r\n            if (hasEntry(entries, baseName)) {\r\n                if (!isValid) {\r\n                    return filterMutate(entries, entry => !fileNameEqual(entry, baseName));\r\n                }\r\n            }\r\n            else if (isValid) {\r\n                return entries.push(baseName);\r\n            }\r\n        }\r\n\r\n        function writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void {\r\n            const path = toPath(fileName);\r\n            const result = getCachedFileSystemEntriesForBaseDir(path);\r\n            if (result) {\r\n                updateFilesOfFileSystemEntry(result, getBaseNameOfFileName(fileName), /*fileExists*/ true);\r\n            }\r\n            return host.writeFile(fileName, data, writeByteOrderMark);\r\n        }\r\n\r\n        function fileExists(fileName: string): boolean {\r\n            const path = toPath(fileName);\r\n            const result = getCachedFileSystemEntriesForBaseDir(path);\r\n            return result && hasEntry(result.files, getBaseNameOfFileName(fileName)) ||\r\n                host.fileExists(fileName);\r\n        }\r\n\r\n        function directoryExists(dirPath: string): boolean {\r\n            const path = toPath(dirPath);\r\n            return cachedReadDirectoryResult.has(path) || host.directoryExists(dirPath);\r\n        }\r\n\r\n        function createDirectory(dirPath: string) {\r\n            const path = toPath(dirPath);\r\n            const result = getCachedFileSystemEntriesForBaseDir(path);\r\n            const baseFileName = getBaseNameOfFileName(dirPath);\r\n            if (result) {\r\n                updateFileSystemEntry(result.directories, baseFileName, /*isValid*/ true);\r\n            }\r\n            host.createDirectory(dirPath);\r\n        }\r\n\r\n        function getDirectories(rootDir: string): string[] {\r\n            const rootDirPath = toPath(rootDir);\r\n            const result = tryReadDirectory(rootDir, rootDirPath);\r\n            if (result) {\r\n                return result.directories.slice();\r\n            }\r\n            return host.getDirectories(rootDir);\r\n        }\r\n\r\n        function readDirectory(rootDir: string, extensions?: ReadonlyArray<string>, excludes?: ReadonlyArray<string>, includes?: ReadonlyArray<string>, depth?: number): string[] {\r\n            const rootDirPath = toPath(rootDir);\r\n            const result = tryReadDirectory(rootDir, rootDirPath);\r\n            if (result) {\r\n                return matchFiles(rootDir, extensions, excludes, includes, host.useCaseSensitiveFileNames, getCurrentDirectory(), depth, getFileSystemEntries);\r\n            }\r\n            return host.readDirectory(rootDir, extensions, excludes, includes, depth);\r\n\r\n            function getFileSystemEntries(dir: string) {\r\n                const path = toPath(dir);\r\n                if (path === rootDirPath) {\r\n                    return result;\r\n                }\r\n                return getCachedFileSystemEntries(path) || createCachedFileSystemEntries(dir, path);\r\n            }\r\n        }\r\n\r\n        function addOrDeleteFileOrDirectory(fileOrDirectory: string, fileOrDirectoryPath: Path) {\r\n            const existingResult = getCachedFileSystemEntries(fileOrDirectoryPath);\r\n            if (existingResult) {\r\n                // This was a folder already present, remove it if this doesnt exist any more\r\n                if (!host.directoryExists(fileOrDirectory)) {\r\n                    cachedReadDirectoryResult.delete(fileOrDirectoryPath);\r\n                }\r\n            }\r\n            else {\r\n                // This was earlier a file (hence not in cached directory contents)\r\n                // or we never cached the directory containing it\r\n                const parentResult = getCachedFileSystemEntriesForBaseDir(fileOrDirectoryPath);\r\n                if (parentResult) {\r\n                    const baseName = getBaseNameOfFileName(fileOrDirectory);\r\n                    if (parentResult) {\r\n                        const fsQueryResult: FileAndDirectoryExistence = {\r\n                            fileExists: host.fileExists(fileOrDirectoryPath),\r\n                            directoryExists: host.directoryExists(fileOrDirectoryPath)\r\n                        };\r\n                        updateFilesOfFileSystemEntry(parentResult, baseName, fsQueryResult.fileExists);\r\n                        updateFileSystemEntry(parentResult.directories, baseName, fsQueryResult.directoryExists);\r\n                        return fsQueryResult;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function addOrDeleteFile(fileName: string, filePath: Path, eventKind: FileWatcherEventKind) {\r\n            if (eventKind === FileWatcherEventKind.Changed) {\r\n                return;\r\n            }\r\n\r\n            const parentResult = getCachedFileSystemEntriesForBaseDir(filePath);\r\n            if (parentResult) {\r\n                updateFilesOfFileSystemEntry(parentResult, getBaseNameOfFileName(fileName), eventKind === FileWatcherEventKind.Created);\r\n            }\r\n        }\r\n\r\n        function updateFilesOfFileSystemEntry(parentResult: MutableFileSystemEntries, baseName: string, fileExists: boolean) {\r\n            updateFileSystemEntry(parentResult.files, baseName, fileExists);\r\n        }\r\n\r\n        function clearCache() {\r\n            cachedReadDirectoryResult.clear();\r\n        }\r\n    }\r\n}\r\n","/// <reference path=\"core.ts\"/>\r\n/// <reference types=\"node\"/>\r\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;\r\ndeclare function clearTimeout(handle: any): void;\r\n\r\nnamespace ts {\r\n    /**\r\n     * Set a high stack trace limit to provide more information in case of an error.\r\n     * Called for command-line and server use cases.\r\n     * Not called if TypeScript is used as a library.\r\n     */\r\n    /* @internal */\r\n    export function setStackTraceLimit() {\r\n        if ((Error as any).stackTraceLimit < 100) { // Also tests that we won't set the property if it doesn't exist.\r\n            (Error as any).stackTraceLimit = 100;\r\n        }\r\n    }\r\n\r\n    export enum FileWatcherEventKind {\r\n        Created,\r\n        Changed,\r\n        Deleted\r\n    }\r\n\r\n    export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind) => void;\r\n    export type DirectoryWatcherCallback = (fileName: string) => void;\r\n    export interface WatchedFile {\r\n        fileName: string;\r\n        callback: FileWatcherCallback;\r\n        mtime?: Date;\r\n    }\r\n\r\n    /**\r\n     * Partial interface of the System thats needed to support the caching of directory structure\r\n     */\r\n    export interface DirectoryStructureHost {\r\n        newLine: string;\r\n        useCaseSensitiveFileNames: boolean;\r\n        write(s: string): void;\r\n        readFile(path: string, encoding?: string): string | undefined;\r\n        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;\r\n        fileExists(path: string): boolean;\r\n        directoryExists(path: string): boolean;\r\n        createDirectory(path: string): void;\r\n        getCurrentDirectory(): string;\r\n        getDirectories(path: string): string[];\r\n        readDirectory(path: string, extensions?: ReadonlyArray<string>, exclude?: ReadonlyArray<string>, include?: ReadonlyArray<string>, depth?: number): string[];\r\n        exit(exitCode?: number): void;\r\n    }\r\n\r\n    export interface System extends DirectoryStructureHost {\r\n        args: string[];\r\n        getFileSize?(path: string): number;\r\n        /**\r\n         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that\r\n         * use native OS file watching\r\n         */\r\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher;\r\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n        resolvePath(path: string): string;\r\n        getExecutingFilePath(): string;\r\n        getModifiedTime?(path: string): Date;\r\n        /**\r\n         * This should be cryptographically secure.\r\n         * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)\r\n         */\r\n        createHash?(data: string): string;\r\n        getMemoryUsage?(): number;\r\n        realpath?(path: string): string;\r\n        /*@internal*/ getEnvironmentVariable(name: string): string;\r\n        /*@internal*/ tryEnableSourceMapsForHost?(): void;\r\n        /*@internal*/ debugMode?: boolean;\r\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\r\n        clearTimeout?(timeoutId: any): void;\r\n    }\r\n\r\n    export interface FileWatcher {\r\n        close(): void;\r\n    }\r\n\r\n    interface DirectoryWatcher extends FileWatcher {\r\n        referenceCount: number;\r\n    }\r\n\r\n    declare const require: any;\r\n    declare const process: any;\r\n    declare const global: any;\r\n    declare const __filename: string;\r\n\r\n    export function getNodeMajorVersion() {\r\n        if (typeof process === \"undefined\") {\r\n            return undefined;\r\n        }\r\n        const version: string = process.version;\r\n        if (!version) {\r\n            return undefined;\r\n        }\r\n        const dot = version.indexOf(\".\");\r\n        if (dot === -1) {\r\n            return undefined;\r\n        }\r\n        return parseInt(version.substring(1, dot));\r\n    }\r\n\r\n    declare const ChakraHost: {\r\n        args: string[];\r\n        currentDirectory: string;\r\n        executingFile: string;\r\n        newLine?: string;\r\n        useCaseSensitiveFileNames?: boolean;\r\n        echo(s: string): void;\r\n        quit(exitCode?: number): void;\r\n        fileExists(path: string): boolean;\r\n        directoryExists(path: string): boolean;\r\n        createDirectory(path: string): void;\r\n        resolvePath(path: string): string;\r\n        readFile(path: string): string | undefined;\r\n        writeFile(path: string, contents: string): void;\r\n        getDirectories(path: string): string[];\r\n        readDirectory(path: string, extensions?: ReadonlyArray<string>, basePaths?: ReadonlyArray<string>, excludeEx?: string, includeFileEx?: string, includeDirEx?: string): string[];\r\n        watchFile?(path: string, callback: FileWatcherCallback): FileWatcher;\r\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n        realpath(path: string): string;\r\n        getEnvironmentVariable?(name: string): string;\r\n    };\r\n\r\n    export let sys: System = (function() {\r\n        function getNodeSystem(): System {\r\n            const _fs = require(\"fs\");\r\n            const _path = require(\"path\");\r\n            const _os = require(\"os\");\r\n            const _crypto = require(\"crypto\");\r\n\r\n            const useNonPollingWatchers = process.env.TSC_NONPOLLING_WATCHER;\r\n\r\n            function createWatchedFileSet() {\r\n                const dirWatchers = createMap<DirectoryWatcher>();\r\n                // One file can have multiple watchers\r\n                const fileWatcherCallbacks = createMultiMap<FileWatcherCallback>();\r\n                return { addFile, removeFile };\r\n\r\n                function reduceDirWatcherRefCountForFile(fileName: string) {\r\n                    const dirName = getDirectoryPath(fileName);\r\n                    const watcher = dirWatchers.get(dirName);\r\n                    if (watcher) {\r\n                        watcher.referenceCount -= 1;\r\n                        if (watcher.referenceCount <= 0) {\r\n                            watcher.close();\r\n                            dirWatchers.delete(dirName);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function addDirWatcher(dirPath: string): void {\r\n                    let watcher = dirWatchers.get(dirPath);\r\n                    if (watcher) {\r\n                        watcher.referenceCount += 1;\r\n                        return;\r\n                    }\r\n                    watcher = fsWatchDirectory(\r\n                        dirPath || \".\",\r\n                        (eventName: string, relativeFileName: string) => fileEventHandler(eventName, relativeFileName, dirPath)\r\n                    ) as DirectoryWatcher;\r\n                    watcher.referenceCount = 1;\r\n                    dirWatchers.set(dirPath, watcher);\r\n                    return;\r\n                }\r\n\r\n                function addFileWatcherCallback(filePath: string, callback: FileWatcherCallback): void {\r\n                    fileWatcherCallbacks.add(filePath, callback);\r\n                }\r\n\r\n                function addFile(fileName: string, callback: FileWatcherCallback): WatchedFile {\r\n                    addFileWatcherCallback(fileName, callback);\r\n                    addDirWatcher(getDirectoryPath(fileName));\r\n\r\n                    return { fileName, callback };\r\n                }\r\n\r\n                function removeFile(watchedFile: WatchedFile) {\r\n                    removeFileWatcherCallback(watchedFile.fileName, watchedFile.callback);\r\n                    reduceDirWatcherRefCountForFile(watchedFile.fileName);\r\n                }\r\n\r\n                function removeFileWatcherCallback(filePath: string, callback: FileWatcherCallback) {\r\n                    fileWatcherCallbacks.remove(filePath, callback);\r\n                }\r\n\r\n                function fileEventHandler(eventName: string, relativeFileName: string | undefined, baseDirPath: string) {\r\n                    // When files are deleted from disk, the triggered \"rename\" event would have a relativefileName of \"undefined\"\r\n                    const fileName = !isString(relativeFileName)\r\n                        ? undefined\r\n                        : ts.getNormalizedAbsolutePath(relativeFileName, baseDirPath);\r\n                    // Some applications save a working file via rename operations\r\n                    if ((eventName === \"change\" || eventName === \"rename\")) {\r\n                        const callbacks = fileWatcherCallbacks.get(fileName);\r\n                        if (callbacks) {\r\n                            for (const fileCallback of callbacks) {\r\n                                fileCallback(fileName, FileWatcherEventKind.Changed);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const watchedFileSet = createWatchedFileSet();\r\n\r\n            const nodeVersion = getNodeMajorVersion();\r\n            const isNode4OrLater = nodeVersion >= 4;\r\n\r\n            function isFileSystemCaseSensitive(): boolean {\r\n                // win32\\win64 are case insensitive platforms\r\n                if (platform === \"win32\" || platform === \"win64\") {\r\n                    return false;\r\n                }\r\n                // If this file exists under a different case, we must be case-insensitve.\r\n                return !fileExists(swapCase(__filename));\r\n            }\r\n\r\n            /** Convert all lowercase chars to uppercase, and vice-versa */\r\n            function swapCase(s: string): string {\r\n                return s.replace(/\\w/g, (ch) => {\r\n                    const up = ch.toUpperCase();\r\n                    return ch === up ? ch.toLowerCase() : up;\r\n                });\r\n            }\r\n\r\n            const platform: string = _os.platform();\r\n            const useCaseSensitiveFileNames = isFileSystemCaseSensitive();\r\n\r\n            function fsWatchFile(fileName: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher {\r\n                _fs.watchFile(fileName, { persistent: true, interval: pollingInterval || 250 }, fileChanged);\r\n                return {\r\n                    close: () => _fs.unwatchFile(fileName, fileChanged)\r\n                };\r\n\r\n                function fileChanged(curr: any, prev: any) {\r\n                    const isCurrZero = +curr.mtime === 0;\r\n                    const isPrevZero = +prev.mtime === 0;\r\n                    const created = !isCurrZero && isPrevZero;\r\n                    const deleted = isCurrZero && !isPrevZero;\r\n\r\n                    const eventKind = created\r\n                        ? FileWatcherEventKind.Created\r\n                        : deleted\r\n                            ? FileWatcherEventKind.Deleted\r\n                            : FileWatcherEventKind.Changed;\r\n\r\n                    if (eventKind === FileWatcherEventKind.Changed && +curr.mtime <= +prev.mtime) {\r\n                        return;\r\n                    }\r\n\r\n                    callback(fileName, eventKind);\r\n                }\r\n            }\r\n\r\n            function fsWatchDirectory(directoryName: string, callback: (eventName: string, relativeFileName: string) => void, recursive?: boolean): FileWatcher {\r\n                let options: any;\r\n                /** Watcher for the directory depending on whether it is missing or present */\r\n                let watcher = !directoryExists(directoryName) ?\r\n                    watchMissingDirectory() :\r\n                    watchPresentDirectory();\r\n                return {\r\n                    close: () => {\r\n                        // Close the watcher (either existing directory watcher or missing directory watcher)\r\n                        watcher.close();\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Watch the directory that is currently present\r\n                 * and when the watched directory is deleted, switch to missing directory watcher\r\n                 */\r\n                function watchPresentDirectory(): FileWatcher {\r\n                    // Node 4.0 `fs.watch` function supports the \"recursive\" option on both OSX and Windows\r\n                    // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)\r\n                    if (options === undefined) {\r\n                        if (isNode4OrLater && (process.platform === \"win32\" || process.platform === \"darwin\")) {\r\n                            options = { persistent: true, recursive: !!recursive };\r\n                        }\r\n                        else {\r\n                            options = { persistent: true };\r\n                        }\r\n                    }\r\n\r\n                    const dirWatcher = _fs.watch(\r\n                        directoryName,\r\n                        options,\r\n                        callback\r\n                    );\r\n                    dirWatcher.on(\"error\", () => {\r\n                        if (!directoryExists(directoryName)) {\r\n                            // Deleting directory\r\n                            watcher = watchMissingDirectory();\r\n                            // Call the callback for current directory\r\n                            callback(\"rename\", \"\");\r\n                        }\r\n                    });\r\n                    return dirWatcher;\r\n                }\r\n\r\n                /**\r\n                 * Watch the directory that is missing\r\n                 * and switch to existing directory when the directory is created\r\n                 */\r\n                function watchMissingDirectory(): FileWatcher {\r\n                    return fsWatchFile(directoryName, (_fileName, eventKind) => {\r\n                        if (eventKind === FileWatcherEventKind.Created && directoryExists(directoryName)) {\r\n                            watcher.close();\r\n                            watcher = watchPresentDirectory();\r\n                            // Call the callback for current directory\r\n                            // For now it could be callback for the inner directory creation,\r\n                            // but just return current directory, better than current no-op\r\n                            callback(\"rename\", \"\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            function readFile(fileName: string, _encoding?: string): string | undefined {\r\n                if (!fileExists(fileName)) {\r\n                    return undefined;\r\n                }\r\n                const buffer = _fs.readFileSync(fileName);\r\n                let len = buffer.length;\r\n                if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {\r\n                    // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,\r\n                    // flip all byte pairs and treat as little endian.\r\n                    len &= ~1; // Round down to a multiple of 2\r\n                    for (let i = 0; i < len; i += 2) {\r\n                        const temp = buffer[i];\r\n                        buffer[i] = buffer[i + 1];\r\n                        buffer[i + 1] = temp;\r\n                    }\r\n                    return buffer.toString(\"utf16le\", 2);\r\n                }\r\n                if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {\r\n                    // Little endian UTF-16 byte order mark detected\r\n                    return buffer.toString(\"utf16le\", 2);\r\n                }\r\n                if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\r\n                    // UTF-8 byte order mark detected\r\n                    return buffer.toString(\"utf8\", 3);\r\n                }\r\n                // Default is UTF-8 with no byte order mark\r\n                return buffer.toString(\"utf8\");\r\n            }\r\n\r\n            function writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void {\r\n                // If a BOM is required, emit one\r\n                if (writeByteOrderMark) {\r\n                    data = \"\\uFEFF\" + data;\r\n                }\r\n\r\n                let fd: number;\r\n\r\n                try {\r\n                    fd = _fs.openSync(fileName, \"w\");\r\n                    _fs.writeSync(fd, data, /*position*/ undefined, \"utf8\");\r\n                }\r\n                finally {\r\n                    if (fd !== undefined) {\r\n                        _fs.closeSync(fd);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getAccessibleFileSystemEntries(path: string): FileSystemEntries {\r\n                try {\r\n                    const entries = _fs.readdirSync(path || \".\").sort();\r\n                    const files: string[] = [];\r\n                    const directories: string[] = [];\r\n                    for (const entry of entries) {\r\n                        // This is necessary because on some file system node fails to exclude\r\n                        // \".\" and \"..\". See https://github.com/nodejs/node/issues/4002\r\n                        if (entry === \".\" || entry === \"..\") {\r\n                            continue;\r\n                        }\r\n                        const name = combinePaths(path, entry);\r\n\r\n                        let stat: any;\r\n                        try {\r\n                            stat = _fs.statSync(name);\r\n                        }\r\n                        catch (e) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (stat.isFile()) {\r\n                            files.push(entry);\r\n                        }\r\n                        else if (stat.isDirectory()) {\r\n                            directories.push(entry);\r\n                        }\r\n                    }\r\n                    return { files, directories };\r\n                }\r\n                catch (e) {\r\n                    return { files: [], directories: [] };\r\n                }\r\n            }\r\n\r\n            function readDirectory(path: string, extensions?: ReadonlyArray<string>, excludes?: ReadonlyArray<string>, includes?: ReadonlyArray<string>, depth?: number): string[] {\r\n                return matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, process.cwd(), depth, getAccessibleFileSystemEntries);\r\n            }\r\n\r\n            const enum FileSystemEntryKind {\r\n                File,\r\n                Directory\r\n            }\r\n\r\n            function fileSystemEntryExists(path: string, entryKind: FileSystemEntryKind): boolean {\r\n                try {\r\n                    const stat = _fs.statSync(path);\r\n                    switch (entryKind) {\r\n                        case FileSystemEntryKind.File: return stat.isFile();\r\n                        case FileSystemEntryKind.Directory: return stat.isDirectory();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            function fileExists(path: string): boolean {\r\n                return fileSystemEntryExists(path, FileSystemEntryKind.File);\r\n            }\r\n\r\n            function directoryExists(path: string): boolean {\r\n                return fileSystemEntryExists(path, FileSystemEntryKind.Directory);\r\n            }\r\n\r\n            function getDirectories(path: string): string[] {\r\n                return filter<string>(_fs.readdirSync(path), dir => fileSystemEntryExists(combinePaths(path, dir), FileSystemEntryKind.Directory));\r\n            }\r\n\r\n            const nodeSystem: System = {\r\n                args: process.argv.slice(2),\r\n                newLine: _os.EOL,\r\n                useCaseSensitiveFileNames,\r\n                write(s: string): void {\r\n                    process.stdout.write(s);\r\n                },\r\n                readFile,\r\n                writeFile,\r\n                watchFile: (fileName, callback, pollingInterval) => {\r\n                    if (useNonPollingWatchers) {\r\n                        const watchedFile = watchedFileSet.addFile(fileName, callback);\r\n                        return {\r\n                            close: () => watchedFileSet.removeFile(watchedFile)\r\n                        };\r\n                    }\r\n                    else {\r\n                        return fsWatchFile(fileName, callback, pollingInterval);\r\n                    }\r\n                },\r\n                watchDirectory: (directoryName, callback, recursive) => {\r\n                    // Node 4.0 `fs.watch` function supports the \"recursive\" option on both OSX and Windows\r\n                    // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)\r\n                    return fsWatchDirectory(directoryName, (eventName, relativeFileName) => {\r\n                        // In watchDirectory we only care about adding and removing files (when event name is\r\n                        // \"rename\"); changes made within files are handled by corresponding fileWatchers (when\r\n                        // event name is \"change\")\r\n                        if (eventName === \"rename\") {\r\n                            // When deleting a file, the passed baseFileName is null\r\n                            callback(!relativeFileName ? relativeFileName : normalizePath(combinePaths(directoryName, relativeFileName)));\r\n                        }\r\n                    }, recursive);\r\n                },\r\n                resolvePath: path => _path.resolve(path),\r\n                fileExists,\r\n                directoryExists,\r\n                createDirectory(directoryName: string) {\r\n                    if (!nodeSystem.directoryExists(directoryName)) {\r\n                        _fs.mkdirSync(directoryName);\r\n                    }\r\n                },\r\n                getExecutingFilePath() {\r\n                    return __filename;\r\n                },\r\n                getCurrentDirectory() {\r\n                    return process.cwd();\r\n                },\r\n                getDirectories,\r\n                getEnvironmentVariable(name: string) {\r\n                    return process.env[name] || \"\";\r\n                },\r\n                readDirectory,\r\n                getModifiedTime(path) {\r\n                    try {\r\n                        return _fs.statSync(path).mtime;\r\n                    }\r\n                    catch (e) {\r\n                        return undefined;\r\n                    }\r\n                },\r\n                createHash(data) {\r\n                    const hash = _crypto.createHash(\"md5\");\r\n                    hash.update(data);\r\n                    return hash.digest(\"hex\");\r\n                },\r\n                getMemoryUsage() {\r\n                    if (global.gc) {\r\n                        global.gc();\r\n                    }\r\n                    return process.memoryUsage().heapUsed;\r\n                },\r\n                getFileSize(path) {\r\n                    try {\r\n                        const stat = _fs.statSync(path);\r\n                        if (stat.isFile()) {\r\n                            return stat.size;\r\n                        }\r\n                    }\r\n                    catch (e) { }\r\n                    return 0;\r\n                },\r\n                exit(exitCode?: number): void {\r\n                    process.exit(exitCode);\r\n                },\r\n                realpath(path: string): string {\r\n                    return _fs.realpathSync(path);\r\n                },\r\n                debugMode: some(<string[]>process.execArgv, arg => /^--(inspect|debug)(-brk)?(=\\d+)?$/i.test(arg)),\r\n                tryEnableSourceMapsForHost() {\r\n                    try {\r\n                        require(\"source-map-support\").install();\r\n                    }\r\n                    catch (e) {\r\n                        // Could not enable source maps.\r\n                    }\r\n                },\r\n                setTimeout,\r\n                clearTimeout\r\n            };\r\n            return nodeSystem;\r\n        }\r\n\r\n        function getChakraSystem(): System {\r\n            const realpath = ChakraHost.realpath && ((path: string) => ChakraHost.realpath(path));\r\n            return {\r\n                newLine: ChakraHost.newLine || \"\\r\\n\",\r\n                args: ChakraHost.args,\r\n                useCaseSensitiveFileNames: !!ChakraHost.useCaseSensitiveFileNames,\r\n                write: ChakraHost.echo,\r\n                readFile(path: string, _encoding?: string) {\r\n                    // encoding is automatically handled by the implementation in ChakraHost\r\n                    return ChakraHost.readFile(path);\r\n                },\r\n                writeFile(path: string, data: string, writeByteOrderMark?: boolean) {\r\n                    // If a BOM is required, emit one\r\n                    if (writeByteOrderMark) {\r\n                        data = \"\\uFEFF\" + data;\r\n                    }\r\n\r\n                    ChakraHost.writeFile(path, data);\r\n                },\r\n                resolvePath: ChakraHost.resolvePath,\r\n                fileExists: ChakraHost.fileExists,\r\n                directoryExists: ChakraHost.directoryExists,\r\n                createDirectory: ChakraHost.createDirectory,\r\n                getExecutingFilePath: () => ChakraHost.executingFile,\r\n                getCurrentDirectory: () => ChakraHost.currentDirectory,\r\n                getDirectories: ChakraHost.getDirectories,\r\n                getEnvironmentVariable: ChakraHost.getEnvironmentVariable || (() => \"\"),\r\n                readDirectory(path, extensions, excludes, includes, _depth) {\r\n                    const pattern = getFileMatcherPatterns(path, excludes, includes, !!ChakraHost.useCaseSensitiveFileNames, ChakraHost.currentDirectory);\r\n                    return ChakraHost.readDirectory(path, extensions, pattern.basePaths, pattern.excludePattern, pattern.includeFilePattern, pattern.includeDirectoryPattern);\r\n                },\r\n                exit: ChakraHost.quit,\r\n                realpath\r\n            };\r\n        }\r\n\r\n        function recursiveCreateDirectory(directoryPath: string, sys: System) {\r\n            const basePath = getDirectoryPath(directoryPath);\r\n            const shouldCreateParent = basePath !== \"\" && directoryPath !== basePath && !sys.directoryExists(basePath);\r\n            if (shouldCreateParent) {\r\n                recursiveCreateDirectory(basePath, sys);\r\n            }\r\n            if (shouldCreateParent || !sys.directoryExists(directoryPath)) {\r\n                sys.createDirectory(directoryPath);\r\n            }\r\n        }\r\n\r\n        let sys: System;\r\n        if (typeof ChakraHost !== \"undefined\") {\r\n            sys = getChakraSystem();\r\n        }\r\n        else if (typeof process !== \"undefined\" && process.nextTick && !process.browser && typeof require !== \"undefined\") {\r\n            // process and process.nextTick checks if current environment is node-like\r\n            // process.browser check excludes webpack and browserify\r\n            sys = getNodeSystem();\r\n        }\r\n        if (sys) {\r\n            // patch writefile to create folder before writing the file\r\n            const originalWriteFile = sys.writeFile;\r\n            sys.writeFile = function(path, data, writeBom) {\r\n                const directoryPath = getDirectoryPath(normalizeSlashes(path));\r\n                if (directoryPath && !sys.directoryExists(directoryPath)) {\r\n                    recursiveCreateDirectory(directoryPath, sys);\r\n                }\r\n                originalWriteFile.call(sys, path, data, writeBom);\r\n            };\r\n        }\r\n        return sys;\r\n    })();\r\n\r\n    if (sys && sys.getEnvironmentVariable) {\r\n        Debug.currentAssertionLevel = /^development$/i.test(sys.getEnvironmentVariable(\"NODE_ENV\"))\r\n            ? AssertionLevel.Normal\r\n            : AssertionLevel.None;\r\n    }\r\n    if (sys && sys.debugMode) {\r\n        Debug.isDebugging = true;\r\n    }\r\n}\r\n","// <auto-generated />\r\n/// <reference path=\"types.ts\" />\r\n/* @internal */\r\nnamespace ts {\r\n    function diag(code: number, category: DiagnosticCategory, key: string, message: string): DiagnosticMessage {\r\n        return { code, category, key, message };\r\n    }\r\n    export const Diagnostics = {\r\n        Unterminated_string_literal: diag(1002, DiagnosticCategory.Error, \"Unterminated_string_literal_1002\", \"Unterminated string literal.\"),\r\n        Identifier_expected: diag(1003, DiagnosticCategory.Error, \"Identifier_expected_1003\", \"Identifier expected.\"),\r\n        _0_expected: diag(1005, DiagnosticCategory.Error, \"_0_expected_1005\", \"'{0}' expected.\"),\r\n        A_file_cannot_have_a_reference_to_itself: diag(1006, DiagnosticCategory.Error, \"A_file_cannot_have_a_reference_to_itself_1006\", \"A file cannot have a reference to itself.\"),\r\n        Trailing_comma_not_allowed: diag(1009, DiagnosticCategory.Error, \"Trailing_comma_not_allowed_1009\", \"Trailing comma not allowed.\"),\r\n        Asterisk_Slash_expected: diag(1010, DiagnosticCategory.Error, \"Asterisk_Slash_expected_1010\", \"'*/' expected.\"),\r\n        Unexpected_token: diag(1012, DiagnosticCategory.Error, \"Unexpected_token_1012\", \"Unexpected token.\"),\r\n        A_rest_parameter_must_be_last_in_a_parameter_list: diag(1014, DiagnosticCategory.Error, \"A_rest_parameter_must_be_last_in_a_parameter_list_1014\", \"A rest parameter must be last in a parameter list.\"),\r\n        Parameter_cannot_have_question_mark_and_initializer: diag(1015, DiagnosticCategory.Error, \"Parameter_cannot_have_question_mark_and_initializer_1015\", \"Parameter cannot have question mark and initializer.\"),\r\n        A_required_parameter_cannot_follow_an_optional_parameter: diag(1016, DiagnosticCategory.Error, \"A_required_parameter_cannot_follow_an_optional_parameter_1016\", \"A required parameter cannot follow an optional parameter.\"),\r\n        An_index_signature_cannot_have_a_rest_parameter: diag(1017, DiagnosticCategory.Error, \"An_index_signature_cannot_have_a_rest_parameter_1017\", \"An index signature cannot have a rest parameter.\"),\r\n        An_index_signature_parameter_cannot_have_an_accessibility_modifier: diag(1018, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018\", \"An index signature parameter cannot have an accessibility modifier.\"),\r\n        An_index_signature_parameter_cannot_have_a_question_mark: diag(1019, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_a_question_mark_1019\", \"An index signature parameter cannot have a question mark.\"),\r\n        An_index_signature_parameter_cannot_have_an_initializer: diag(1020, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_an_initializer_1020\", \"An index signature parameter cannot have an initializer.\"),\r\n        An_index_signature_must_have_a_type_annotation: diag(1021, DiagnosticCategory.Error, \"An_index_signature_must_have_a_type_annotation_1021\", \"An index signature must have a type annotation.\"),\r\n        An_index_signature_parameter_must_have_a_type_annotation: diag(1022, DiagnosticCategory.Error, \"An_index_signature_parameter_must_have_a_type_annotation_1022\", \"An index signature parameter must have a type annotation.\"),\r\n        An_index_signature_parameter_type_must_be_string_or_number: diag(1023, DiagnosticCategory.Error, \"An_index_signature_parameter_type_must_be_string_or_number_1023\", \"An index signature parameter type must be 'string' or 'number'.\"),\r\n        readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: diag(1024, DiagnosticCategory.Error, \"readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024\", \"'readonly' modifier can only appear on a property declaration or index signature.\"),\r\n        Accessibility_modifier_already_seen: diag(1028, DiagnosticCategory.Error, \"Accessibility_modifier_already_seen_1028\", \"Accessibility modifier already seen.\"),\r\n        _0_modifier_must_precede_1_modifier: diag(1029, DiagnosticCategory.Error, \"_0_modifier_must_precede_1_modifier_1029\", \"'{0}' modifier must precede '{1}' modifier.\"),\r\n        _0_modifier_already_seen: diag(1030, DiagnosticCategory.Error, \"_0_modifier_already_seen_1030\", \"'{0}' modifier already seen.\"),\r\n        _0_modifier_cannot_appear_on_a_class_element: diag(1031, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_class_element_1031\", \"'{0}' modifier cannot appear on a class element.\"),\r\n        super_must_be_followed_by_an_argument_list_or_member_access: diag(1034, DiagnosticCategory.Error, \"super_must_be_followed_by_an_argument_list_or_member_access_1034\", \"'super' must be followed by an argument list or member access.\"),\r\n        Only_ambient_modules_can_use_quoted_names: diag(1035, DiagnosticCategory.Error, \"Only_ambient_modules_can_use_quoted_names_1035\", \"Only ambient modules can use quoted names.\"),\r\n        Statements_are_not_allowed_in_ambient_contexts: diag(1036, DiagnosticCategory.Error, \"Statements_are_not_allowed_in_ambient_contexts_1036\", \"Statements are not allowed in ambient contexts.\"),\r\n        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: diag(1038, DiagnosticCategory.Error, \"A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038\", \"A 'declare' modifier cannot be used in an already ambient context.\"),\r\n        Initializers_are_not_allowed_in_ambient_contexts: diag(1039, DiagnosticCategory.Error, \"Initializers_are_not_allowed_in_ambient_contexts_1039\", \"Initializers are not allowed in ambient contexts.\"),\r\n        _0_modifier_cannot_be_used_in_an_ambient_context: diag(1040, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_in_an_ambient_context_1040\", \"'{0}' modifier cannot be used in an ambient context.\"),\r\n        _0_modifier_cannot_be_used_with_a_class_declaration: diag(1041, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_with_a_class_declaration_1041\", \"'{0}' modifier cannot be used with a class declaration.\"),\r\n        _0_modifier_cannot_be_used_here: diag(1042, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_here_1042\", \"'{0}' modifier cannot be used here.\"),\r\n        _0_modifier_cannot_appear_on_a_data_property: diag(1043, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_data_property_1043\", \"'{0}' modifier cannot appear on a data property.\"),\r\n        _0_modifier_cannot_appear_on_a_module_or_namespace_element: diag(1044, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044\", \"'{0}' modifier cannot appear on a module or namespace element.\"),\r\n        A_0_modifier_cannot_be_used_with_an_interface_declaration: diag(1045, DiagnosticCategory.Error, \"A_0_modifier_cannot_be_used_with_an_interface_declaration_1045\", \"A '{0}' modifier cannot be used with an interface declaration.\"),\r\n        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: diag(1046, DiagnosticCategory.Error, \"A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file_1046\", \"A 'declare' modifier is required for a top level declaration in a .d.ts file.\"),\r\n        A_rest_parameter_cannot_be_optional: diag(1047, DiagnosticCategory.Error, \"A_rest_parameter_cannot_be_optional_1047\", \"A rest parameter cannot be optional.\"),\r\n        A_rest_parameter_cannot_have_an_initializer: diag(1048, DiagnosticCategory.Error, \"A_rest_parameter_cannot_have_an_initializer_1048\", \"A rest parameter cannot have an initializer.\"),\r\n        A_set_accessor_must_have_exactly_one_parameter: diag(1049, DiagnosticCategory.Error, \"A_set_accessor_must_have_exactly_one_parameter_1049\", \"A 'set' accessor must have exactly one parameter.\"),\r\n        A_set_accessor_cannot_have_an_optional_parameter: diag(1051, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_an_optional_parameter_1051\", \"A 'set' accessor cannot have an optional parameter.\"),\r\n        A_set_accessor_parameter_cannot_have_an_initializer: diag(1052, DiagnosticCategory.Error, \"A_set_accessor_parameter_cannot_have_an_initializer_1052\", \"A 'set' accessor parameter cannot have an initializer.\"),\r\n        A_set_accessor_cannot_have_rest_parameter: diag(1053, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_rest_parameter_1053\", \"A 'set' accessor cannot have rest parameter.\"),\r\n        A_get_accessor_cannot_have_parameters: diag(1054, DiagnosticCategory.Error, \"A_get_accessor_cannot_have_parameters_1054\", \"A 'get' accessor cannot have parameters.\"),\r\n        Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: diag(1055, DiagnosticCategory.Error, \"Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055\", \"Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.\"),\r\n        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: diag(1056, DiagnosticCategory.Error, \"Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056\", \"Accessors are only available when targeting ECMAScript 5 and higher.\"),\r\n        An_async_function_or_method_must_have_a_valid_awaitable_return_type: diag(1057, DiagnosticCategory.Error, \"An_async_function_or_method_must_have_a_valid_awaitable_return_type_1057\", \"An async function or method must have a valid awaitable return type.\"),\r\n        The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1058, DiagnosticCategory.Error, \"The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058\", \"The return type of an async function must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        A_promise_must_have_a_then_method: diag(1059, DiagnosticCategory.Error, \"A_promise_must_have_a_then_method_1059\", \"A promise must have a 'then' method.\"),\r\n        The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: diag(1060, DiagnosticCategory.Error, \"The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060\", \"The first parameter of the 'then' method of a promise must be a callback.\"),\r\n        Enum_member_must_have_initializer: diag(1061, DiagnosticCategory.Error, \"Enum_member_must_have_initializer_1061\", \"Enum member must have initializer.\"),\r\n        Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: diag(1062, DiagnosticCategory.Error, \"Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062\", \"Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method.\"),\r\n        An_export_assignment_cannot_be_used_in_a_namespace: diag(1063, DiagnosticCategory.Error, \"An_export_assignment_cannot_be_used_in_a_namespace_1063\", \"An export assignment cannot be used in a namespace.\"),\r\n        The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type: diag(1064, DiagnosticCategory.Error, \"The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1064\", \"The return type of an async function or method must be the global Promise<T> type.\"),\r\n        In_ambient_enum_declarations_member_initializer_must_be_constant_expression: diag(1066, DiagnosticCategory.Error, \"In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066\", \"In ambient enum declarations member initializer must be constant expression.\"),\r\n        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: diag(1068, DiagnosticCategory.Error, \"Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068\", \"Unexpected token. A constructor, method, accessor, or property was expected.\"),\r\n        _0_modifier_cannot_appear_on_a_type_member: diag(1070, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_type_member_1070\", \"'{0}' modifier cannot appear on a type member.\"),\r\n        _0_modifier_cannot_appear_on_an_index_signature: diag(1071, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_an_index_signature_1071\", \"'{0}' modifier cannot appear on an index signature.\"),\r\n        A_0_modifier_cannot_be_used_with_an_import_declaration: diag(1079, DiagnosticCategory.Error, \"A_0_modifier_cannot_be_used_with_an_import_declaration_1079\", \"A '{0}' modifier cannot be used with an import declaration.\"),\r\n        Invalid_reference_directive_syntax: diag(1084, DiagnosticCategory.Error, \"Invalid_reference_directive_syntax_1084\", \"Invalid 'reference' directive syntax.\"),\r\n        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: diag(1085, DiagnosticCategory.Error, \"Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085\", \"Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'.\"),\r\n        An_accessor_cannot_be_declared_in_an_ambient_context: diag(1086, DiagnosticCategory.Error, \"An_accessor_cannot_be_declared_in_an_ambient_context_1086\", \"An accessor cannot be declared in an ambient context.\"),\r\n        _0_modifier_cannot_appear_on_a_constructor_declaration: diag(1089, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_constructor_declaration_1089\", \"'{0}' modifier cannot appear on a constructor declaration.\"),\r\n        _0_modifier_cannot_appear_on_a_parameter: diag(1090, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_parameter_1090\", \"'{0}' modifier cannot appear on a parameter.\"),\r\n        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: diag(1091, DiagnosticCategory.Error, \"Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091\", \"Only a single variable declaration is allowed in a 'for...in' statement.\"),\r\n        Type_parameters_cannot_appear_on_a_constructor_declaration: diag(1092, DiagnosticCategory.Error, \"Type_parameters_cannot_appear_on_a_constructor_declaration_1092\", \"Type parameters cannot appear on a constructor declaration.\"),\r\n        Type_annotation_cannot_appear_on_a_constructor_declaration: diag(1093, DiagnosticCategory.Error, \"Type_annotation_cannot_appear_on_a_constructor_declaration_1093\", \"Type annotation cannot appear on a constructor declaration.\"),\r\n        An_accessor_cannot_have_type_parameters: diag(1094, DiagnosticCategory.Error, \"An_accessor_cannot_have_type_parameters_1094\", \"An accessor cannot have type parameters.\"),\r\n        A_set_accessor_cannot_have_a_return_type_annotation: diag(1095, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_a_return_type_annotation_1095\", \"A 'set' accessor cannot have a return type annotation.\"),\r\n        An_index_signature_must_have_exactly_one_parameter: diag(1096, DiagnosticCategory.Error, \"An_index_signature_must_have_exactly_one_parameter_1096\", \"An index signature must have exactly one parameter.\"),\r\n        _0_list_cannot_be_empty: diag(1097, DiagnosticCategory.Error, \"_0_list_cannot_be_empty_1097\", \"'{0}' list cannot be empty.\"),\r\n        Type_parameter_list_cannot_be_empty: diag(1098, DiagnosticCategory.Error, \"Type_parameter_list_cannot_be_empty_1098\", \"Type parameter list cannot be empty.\"),\r\n        Type_argument_list_cannot_be_empty: diag(1099, DiagnosticCategory.Error, \"Type_argument_list_cannot_be_empty_1099\", \"Type argument list cannot be empty.\"),\r\n        Invalid_use_of_0_in_strict_mode: diag(1100, DiagnosticCategory.Error, \"Invalid_use_of_0_in_strict_mode_1100\", \"Invalid use of '{0}' in strict mode.\"),\r\n        with_statements_are_not_allowed_in_strict_mode: diag(1101, DiagnosticCategory.Error, \"with_statements_are_not_allowed_in_strict_mode_1101\", \"'with' statements are not allowed in strict mode.\"),\r\n        delete_cannot_be_called_on_an_identifier_in_strict_mode: diag(1102, DiagnosticCategory.Error, \"delete_cannot_be_called_on_an_identifier_in_strict_mode_1102\", \"'delete' cannot be called on an identifier in strict mode.\"),\r\n        A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator: diag(1103, DiagnosticCategory.Error, \"A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator_1103\", \"A 'for-await-of' statement is only allowed within an async function or async generator.\"),\r\n        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: diag(1104, DiagnosticCategory.Error, \"A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104\", \"A 'continue' statement can only be used within an enclosing iteration statement.\"),\r\n        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: diag(1105, DiagnosticCategory.Error, \"A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105\", \"A 'break' statement can only be used within an enclosing iteration or switch statement.\"),\r\n        Jump_target_cannot_cross_function_boundary: diag(1107, DiagnosticCategory.Error, \"Jump_target_cannot_cross_function_boundary_1107\", \"Jump target cannot cross function boundary.\"),\r\n        A_return_statement_can_only_be_used_within_a_function_body: diag(1108, DiagnosticCategory.Error, \"A_return_statement_can_only_be_used_within_a_function_body_1108\", \"A 'return' statement can only be used within a function body.\"),\r\n        Expression_expected: diag(1109, DiagnosticCategory.Error, \"Expression_expected_1109\", \"Expression expected.\"),\r\n        Type_expected: diag(1110, DiagnosticCategory.Error, \"Type_expected_1110\", \"Type expected.\"),\r\n        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: diag(1113, DiagnosticCategory.Error, \"A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113\", \"A 'default' clause cannot appear more than once in a 'switch' statement.\"),\r\n        Duplicate_label_0: diag(1114, DiagnosticCategory.Error, \"Duplicate_label_0_1114\", \"Duplicate label '{0}'.\"),\r\n        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: diag(1115, DiagnosticCategory.Error, \"A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115\", \"A 'continue' statement can only jump to a label of an enclosing iteration statement.\"),\r\n        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: diag(1116, DiagnosticCategory.Error, \"A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116\", \"A 'break' statement can only jump to a label of an enclosing statement.\"),\r\n        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: diag(1117, DiagnosticCategory.Error, \"An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode_1117\", \"An object literal cannot have multiple properties with the same name in strict mode.\"),\r\n        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: diag(1118, DiagnosticCategory.Error, \"An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118\", \"An object literal cannot have multiple get/set accessors with the same name.\"),\r\n        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: diag(1119, DiagnosticCategory.Error, \"An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119\", \"An object literal cannot have property and accessor with the same name.\"),\r\n        An_export_assignment_cannot_have_modifiers: diag(1120, DiagnosticCategory.Error, \"An_export_assignment_cannot_have_modifiers_1120\", \"An export assignment cannot have modifiers.\"),\r\n        Octal_literals_are_not_allowed_in_strict_mode: diag(1121, DiagnosticCategory.Error, \"Octal_literals_are_not_allowed_in_strict_mode_1121\", \"Octal literals are not allowed in strict mode.\"),\r\n        A_tuple_type_element_list_cannot_be_empty: diag(1122, DiagnosticCategory.Error, \"A_tuple_type_element_list_cannot_be_empty_1122\", \"A tuple type element list cannot be empty.\"),\r\n        Variable_declaration_list_cannot_be_empty: diag(1123, DiagnosticCategory.Error, \"Variable_declaration_list_cannot_be_empty_1123\", \"Variable declaration list cannot be empty.\"),\r\n        Digit_expected: diag(1124, DiagnosticCategory.Error, \"Digit_expected_1124\", \"Digit expected.\"),\r\n        Hexadecimal_digit_expected: diag(1125, DiagnosticCategory.Error, \"Hexadecimal_digit_expected_1125\", \"Hexadecimal digit expected.\"),\r\n        Unexpected_end_of_text: diag(1126, DiagnosticCategory.Error, \"Unexpected_end_of_text_1126\", \"Unexpected end of text.\"),\r\n        Invalid_character: diag(1127, DiagnosticCategory.Error, \"Invalid_character_1127\", \"Invalid character.\"),\r\n        Declaration_or_statement_expected: diag(1128, DiagnosticCategory.Error, \"Declaration_or_statement_expected_1128\", \"Declaration or statement expected.\"),\r\n        Statement_expected: diag(1129, DiagnosticCategory.Error, \"Statement_expected_1129\", \"Statement expected.\"),\r\n        case_or_default_expected: diag(1130, DiagnosticCategory.Error, \"case_or_default_expected_1130\", \"'case' or 'default' expected.\"),\r\n        Property_or_signature_expected: diag(1131, DiagnosticCategory.Error, \"Property_or_signature_expected_1131\", \"Property or signature expected.\"),\r\n        Enum_member_expected: diag(1132, DiagnosticCategory.Error, \"Enum_member_expected_1132\", \"Enum member expected.\"),\r\n        Variable_declaration_expected: diag(1134, DiagnosticCategory.Error, \"Variable_declaration_expected_1134\", \"Variable declaration expected.\"),\r\n        Argument_expression_expected: diag(1135, DiagnosticCategory.Error, \"Argument_expression_expected_1135\", \"Argument expression expected.\"),\r\n        Property_assignment_expected: diag(1136, DiagnosticCategory.Error, \"Property_assignment_expected_1136\", \"Property assignment expected.\"),\r\n        Expression_or_comma_expected: diag(1137, DiagnosticCategory.Error, \"Expression_or_comma_expected_1137\", \"Expression or comma expected.\"),\r\n        Parameter_declaration_expected: diag(1138, DiagnosticCategory.Error, \"Parameter_declaration_expected_1138\", \"Parameter declaration expected.\"),\r\n        Type_parameter_declaration_expected: diag(1139, DiagnosticCategory.Error, \"Type_parameter_declaration_expected_1139\", \"Type parameter declaration expected.\"),\r\n        Type_argument_expected: diag(1140, DiagnosticCategory.Error, \"Type_argument_expected_1140\", \"Type argument expected.\"),\r\n        String_literal_expected: diag(1141, DiagnosticCategory.Error, \"String_literal_expected_1141\", \"String literal expected.\"),\r\n        Line_break_not_permitted_here: diag(1142, DiagnosticCategory.Error, \"Line_break_not_permitted_here_1142\", \"Line break not permitted here.\"),\r\n        or_expected: diag(1144, DiagnosticCategory.Error, \"or_expected_1144\", \"'{' or ';' expected.\"),\r\n        Declaration_expected: diag(1146, DiagnosticCategory.Error, \"Declaration_expected_1146\", \"Declaration expected.\"),\r\n        Import_declarations_in_a_namespace_cannot_reference_a_module: diag(1147, DiagnosticCategory.Error, \"Import_declarations_in_a_namespace_cannot_reference_a_module_1147\", \"Import declarations in a namespace cannot reference a module.\"),\r\n        Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: diag(1148, DiagnosticCategory.Error, \"Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148\", \"Cannot use imports, exports, or module augmentations when '--module' is 'none'.\"),\r\n        File_name_0_differs_from_already_included_file_name_1_only_in_casing: diag(1149, DiagnosticCategory.Error, \"File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149\", \"File name '{0}' differs from already included file name '{1}' only in casing.\"),\r\n        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: diag(1150, DiagnosticCategory.Error, \"new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead_1150\", \"'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.\"),\r\n        const_declarations_must_be_initialized: diag(1155, DiagnosticCategory.Error, \"const_declarations_must_be_initialized_1155\", \"'const' declarations must be initialized.\"),\r\n        const_declarations_can_only_be_declared_inside_a_block: diag(1156, DiagnosticCategory.Error, \"const_declarations_can_only_be_declared_inside_a_block_1156\", \"'const' declarations can only be declared inside a block.\"),\r\n        let_declarations_can_only_be_declared_inside_a_block: diag(1157, DiagnosticCategory.Error, \"let_declarations_can_only_be_declared_inside_a_block_1157\", \"'let' declarations can only be declared inside a block.\"),\r\n        Unterminated_template_literal: diag(1160, DiagnosticCategory.Error, \"Unterminated_template_literal_1160\", \"Unterminated template literal.\"),\r\n        Unterminated_regular_expression_literal: diag(1161, DiagnosticCategory.Error, \"Unterminated_regular_expression_literal_1161\", \"Unterminated regular expression literal.\"),\r\n        An_object_member_cannot_be_declared_optional: diag(1162, DiagnosticCategory.Error, \"An_object_member_cannot_be_declared_optional_1162\", \"An object member cannot be declared optional.\"),\r\n        A_yield_expression_is_only_allowed_in_a_generator_body: diag(1163, DiagnosticCategory.Error, \"A_yield_expression_is_only_allowed_in_a_generator_body_1163\", \"A 'yield' expression is only allowed in a generator body.\"),\r\n        Computed_property_names_are_not_allowed_in_enums: diag(1164, DiagnosticCategory.Error, \"Computed_property_names_are_not_allowed_in_enums_1164\", \"Computed property names are not allowed in enums.\"),\r\n        A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol: diag(1165, DiagnosticCategory.Error, \"A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol_1165\", \"A computed property name in an ambient context must directly refer to a built-in symbol.\"),\r\n        A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol: diag(1166, DiagnosticCategory.Error, \"A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol_1166\", \"A computed property name in a class property declaration must directly refer to a built-in symbol.\"),\r\n        A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol: diag(1168, DiagnosticCategory.Error, \"A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol_1168\", \"A computed property name in a method overload must directly refer to a built-in symbol.\"),\r\n        A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol: diag(1169, DiagnosticCategory.Error, \"A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol_1169\", \"A computed property name in an interface must directly refer to a built-in symbol.\"),\r\n        A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol: diag(1170, DiagnosticCategory.Error, \"A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol_1170\", \"A computed property name in a type literal must directly refer to a built-in symbol.\"),\r\n        A_comma_expression_is_not_allowed_in_a_computed_property_name: diag(1171, DiagnosticCategory.Error, \"A_comma_expression_is_not_allowed_in_a_computed_property_name_1171\", \"A comma expression is not allowed in a computed property name.\"),\r\n        extends_clause_already_seen: diag(1172, DiagnosticCategory.Error, \"extends_clause_already_seen_1172\", \"'extends' clause already seen.\"),\r\n        extends_clause_must_precede_implements_clause: diag(1173, DiagnosticCategory.Error, \"extends_clause_must_precede_implements_clause_1173\", \"'extends' clause must precede 'implements' clause.\"),\r\n        Classes_can_only_extend_a_single_class: diag(1174, DiagnosticCategory.Error, \"Classes_can_only_extend_a_single_class_1174\", \"Classes can only extend a single class.\"),\r\n        implements_clause_already_seen: diag(1175, DiagnosticCategory.Error, \"implements_clause_already_seen_1175\", \"'implements' clause already seen.\"),\r\n        Interface_declaration_cannot_have_implements_clause: diag(1176, DiagnosticCategory.Error, \"Interface_declaration_cannot_have_implements_clause_1176\", \"Interface declaration cannot have 'implements' clause.\"),\r\n        Binary_digit_expected: diag(1177, DiagnosticCategory.Error, \"Binary_digit_expected_1177\", \"Binary digit expected.\"),\r\n        Octal_digit_expected: diag(1178, DiagnosticCategory.Error, \"Octal_digit_expected_1178\", \"Octal digit expected.\"),\r\n        Unexpected_token_expected: diag(1179, DiagnosticCategory.Error, \"Unexpected_token_expected_1179\", \"Unexpected token. '{' expected.\"),\r\n        Property_destructuring_pattern_expected: diag(1180, DiagnosticCategory.Error, \"Property_destructuring_pattern_expected_1180\", \"Property destructuring pattern expected.\"),\r\n        Array_element_destructuring_pattern_expected: diag(1181, DiagnosticCategory.Error, \"Array_element_destructuring_pattern_expected_1181\", \"Array element destructuring pattern expected.\"),\r\n        A_destructuring_declaration_must_have_an_initializer: diag(1182, DiagnosticCategory.Error, \"A_destructuring_declaration_must_have_an_initializer_1182\", \"A destructuring declaration must have an initializer.\"),\r\n        An_implementation_cannot_be_declared_in_ambient_contexts: diag(1183, DiagnosticCategory.Error, \"An_implementation_cannot_be_declared_in_ambient_contexts_1183\", \"An implementation cannot be declared in ambient contexts.\"),\r\n        Modifiers_cannot_appear_here: diag(1184, DiagnosticCategory.Error, \"Modifiers_cannot_appear_here_1184\", \"Modifiers cannot appear here.\"),\r\n        Merge_conflict_marker_encountered: diag(1185, DiagnosticCategory.Error, \"Merge_conflict_marker_encountered_1185\", \"Merge conflict marker encountered.\"),\r\n        A_rest_element_cannot_have_an_initializer: diag(1186, DiagnosticCategory.Error, \"A_rest_element_cannot_have_an_initializer_1186\", \"A rest element cannot have an initializer.\"),\r\n        A_parameter_property_may_not_be_declared_using_a_binding_pattern: diag(1187, DiagnosticCategory.Error, \"A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187\", \"A parameter property may not be declared using a binding pattern.\"),\r\n        Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: diag(1188, DiagnosticCategory.Error, \"Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188\", \"Only a single variable declaration is allowed in a 'for...of' statement.\"),\r\n        The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: diag(1189, DiagnosticCategory.Error, \"The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189\", \"The variable declaration of a 'for...in' statement cannot have an initializer.\"),\r\n        The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: diag(1190, DiagnosticCategory.Error, \"The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190\", \"The variable declaration of a 'for...of' statement cannot have an initializer.\"),\r\n        An_import_declaration_cannot_have_modifiers: diag(1191, DiagnosticCategory.Error, \"An_import_declaration_cannot_have_modifiers_1191\", \"An import declaration cannot have modifiers.\"),\r\n        Module_0_has_no_default_export: diag(1192, DiagnosticCategory.Error, \"Module_0_has_no_default_export_1192\", \"Module '{0}' has no default export.\"),\r\n        An_export_declaration_cannot_have_modifiers: diag(1193, DiagnosticCategory.Error, \"An_export_declaration_cannot_have_modifiers_1193\", \"An export declaration cannot have modifiers.\"),\r\n        Export_declarations_are_not_permitted_in_a_namespace: diag(1194, DiagnosticCategory.Error, \"Export_declarations_are_not_permitted_in_a_namespace_1194\", \"Export declarations are not permitted in a namespace.\"),\r\n        Catch_clause_variable_cannot_have_a_type_annotation: diag(1196, DiagnosticCategory.Error, \"Catch_clause_variable_cannot_have_a_type_annotation_1196\", \"Catch clause variable cannot have a type annotation.\"),\r\n        Catch_clause_variable_cannot_have_an_initializer: diag(1197, DiagnosticCategory.Error, \"Catch_clause_variable_cannot_have_an_initializer_1197\", \"Catch clause variable cannot have an initializer.\"),\r\n        An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: diag(1198, DiagnosticCategory.Error, \"An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198\", \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\"),\r\n        Unterminated_Unicode_escape_sequence: diag(1199, DiagnosticCategory.Error, \"Unterminated_Unicode_escape_sequence_1199\", \"Unterminated Unicode escape sequence.\"),\r\n        Line_terminator_not_permitted_before_arrow: diag(1200, DiagnosticCategory.Error, \"Line_terminator_not_permitted_before_arrow_1200\", \"Line terminator not permitted before arrow.\"),\r\n        Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: diag(1202, DiagnosticCategory.Error, \"Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202\", \"Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \\\"mod\\\"', 'import {a} from \\\"mod\\\"', 'import d from \\\"mod\\\"', or another module format instead.\"),\r\n        Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: diag(1203, DiagnosticCategory.Error, \"Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203\", \"Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead.\"),\r\n        Cannot_re_export_a_type_when_the_isolatedModules_flag_is_provided: diag(1205, DiagnosticCategory.Error, \"Cannot_re_export_a_type_when_the_isolatedModules_flag_is_provided_1205\", \"Cannot re-export a type when the '--isolatedModules' flag is provided.\"),\r\n        Decorators_are_not_valid_here: diag(1206, DiagnosticCategory.Error, \"Decorators_are_not_valid_here_1206\", \"Decorators are not valid here.\"),\r\n        Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: diag(1207, DiagnosticCategory.Error, \"Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207\", \"Decorators cannot be applied to multiple get/set accessors of the same name.\"),\r\n        Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided: diag(1208, DiagnosticCategory.Error, \"Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided_1208\", \"Cannot compile namespaces when the '--isolatedModules' flag is provided.\"),\r\n        Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided: diag(1209, DiagnosticCategory.Error, \"Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided_1209\", \"Ambient const enums are not allowed when the '--isolatedModules' flag is provided.\"),\r\n        Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode: diag(1210, DiagnosticCategory.Error, \"Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode_1210\", \"Invalid use of '{0}'. Class definitions are automatically in strict mode.\"),\r\n        A_class_declaration_without_the_default_modifier_must_have_a_name: diag(1211, DiagnosticCategory.Error, \"A_class_declaration_without_the_default_modifier_must_have_a_name_1211\", \"A class declaration without the 'default' modifier must have a name.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode: diag(1212, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212\", \"Identifier expected. '{0}' is a reserved word in strict mode.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: diag(1213, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213\", \"Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: diag(1214, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214\", \"Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.\"),\r\n        Invalid_use_of_0_Modules_are_automatically_in_strict_mode: diag(1215, DiagnosticCategory.Error, \"Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215\", \"Invalid use of '{0}'. Modules are automatically in strict mode.\"),\r\n        Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: diag(1216, DiagnosticCategory.Error, \"Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216\", \"Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules.\"),\r\n        Export_assignment_is_not_supported_when_module_flag_is_system: diag(1218, DiagnosticCategory.Error, \"Export_assignment_is_not_supported_when_module_flag_is_system_1218\", \"Export assignment is not supported when '--module' flag is 'system'.\"),\r\n        Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_to_remove_this_warning: diag(1219, DiagnosticCategory.Error, \"Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219\", \"Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.\"),\r\n        Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher: diag(1220, DiagnosticCategory.Error, \"Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher_1220\", \"Generators are only available when targeting ECMAScript 2015 or higher.\"),\r\n        Generators_are_not_allowed_in_an_ambient_context: diag(1221, DiagnosticCategory.Error, \"Generators_are_not_allowed_in_an_ambient_context_1221\", \"Generators are not allowed in an ambient context.\"),\r\n        An_overload_signature_cannot_be_declared_as_a_generator: diag(1222, DiagnosticCategory.Error, \"An_overload_signature_cannot_be_declared_as_a_generator_1222\", \"An overload signature cannot be declared as a generator.\"),\r\n        _0_tag_already_specified: diag(1223, DiagnosticCategory.Error, \"_0_tag_already_specified_1223\", \"'{0}' tag already specified.\"),\r\n        Signature_0_must_be_a_type_predicate: diag(1224, DiagnosticCategory.Error, \"Signature_0_must_be_a_type_predicate_1224\", \"Signature '{0}' must be a type predicate.\"),\r\n        Cannot_find_parameter_0: diag(1225, DiagnosticCategory.Error, \"Cannot_find_parameter_0_1225\", \"Cannot find parameter '{0}'.\"),\r\n        Type_predicate_0_is_not_assignable_to_1: diag(1226, DiagnosticCategory.Error, \"Type_predicate_0_is_not_assignable_to_1_1226\", \"Type predicate '{0}' is not assignable to '{1}'.\"),\r\n        Parameter_0_is_not_in_the_same_position_as_parameter_1: diag(1227, DiagnosticCategory.Error, \"Parameter_0_is_not_in_the_same_position_as_parameter_1_1227\", \"Parameter '{0}' is not in the same position as parameter '{1}'.\"),\r\n        A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: diag(1228, DiagnosticCategory.Error, \"A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228\", \"A type predicate is only allowed in return type position for functions and methods.\"),\r\n        A_type_predicate_cannot_reference_a_rest_parameter: diag(1229, DiagnosticCategory.Error, \"A_type_predicate_cannot_reference_a_rest_parameter_1229\", \"A type predicate cannot reference a rest parameter.\"),\r\n        A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: diag(1230, DiagnosticCategory.Error, \"A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230\", \"A type predicate cannot reference element '{0}' in a binding pattern.\"),\r\n        An_export_assignment_can_only_be_used_in_a_module: diag(1231, DiagnosticCategory.Error, \"An_export_assignment_can_only_be_used_in_a_module_1231\", \"An export assignment can only be used in a module.\"),\r\n        An_import_declaration_can_only_be_used_in_a_namespace_or_module: diag(1232, DiagnosticCategory.Error, \"An_import_declaration_can_only_be_used_in_a_namespace_or_module_1232\", \"An import declaration can only be used in a namespace or module.\"),\r\n        An_export_declaration_can_only_be_used_in_a_module: diag(1233, DiagnosticCategory.Error, \"An_export_declaration_can_only_be_used_in_a_module_1233\", \"An export declaration can only be used in a module.\"),\r\n        An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: diag(1234, DiagnosticCategory.Error, \"An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234\", \"An ambient module declaration is only allowed at the top level in a file.\"),\r\n        A_namespace_declaration_is_only_allowed_in_a_namespace_or_module: diag(1235, DiagnosticCategory.Error, \"A_namespace_declaration_is_only_allowed_in_a_namespace_or_module_1235\", \"A namespace declaration is only allowed in a namespace or module.\"),\r\n        The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: diag(1236, DiagnosticCategory.Error, \"The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236\", \"The return type of a property decorator function must be either 'void' or 'any'.\"),\r\n        The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: diag(1237, DiagnosticCategory.Error, \"The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237\", \"The return type of a parameter decorator function must be either 'void' or 'any'.\"),\r\n        Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: diag(1238, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238\", \"Unable to resolve signature of class decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: diag(1239, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239\", \"Unable to resolve signature of parameter decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: diag(1240, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240\", \"Unable to resolve signature of property decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: diag(1241, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241\", \"Unable to resolve signature of method decorator when called as an expression.\"),\r\n        abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: diag(1242, DiagnosticCategory.Error, \"abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242\", \"'abstract' modifier can only appear on a class, method, or property declaration.\"),\r\n        _0_modifier_cannot_be_used_with_1_modifier: diag(1243, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_with_1_modifier_1243\", \"'{0}' modifier cannot be used with '{1}' modifier.\"),\r\n        Abstract_methods_can_only_appear_within_an_abstract_class: diag(1244, DiagnosticCategory.Error, \"Abstract_methods_can_only_appear_within_an_abstract_class_1244\", \"Abstract methods can only appear within an abstract class.\"),\r\n        Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: diag(1245, DiagnosticCategory.Error, \"Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245\", \"Method '{0}' cannot have an implementation because it is marked abstract.\"),\r\n        An_interface_property_cannot_have_an_initializer: diag(1246, DiagnosticCategory.Error, \"An_interface_property_cannot_have_an_initializer_1246\", \"An interface property cannot have an initializer.\"),\r\n        A_type_literal_property_cannot_have_an_initializer: diag(1247, DiagnosticCategory.Error, \"A_type_literal_property_cannot_have_an_initializer_1247\", \"A type literal property cannot have an initializer.\"),\r\n        A_class_member_cannot_have_the_0_keyword: diag(1248, DiagnosticCategory.Error, \"A_class_member_cannot_have_the_0_keyword_1248\", \"A class member cannot have the '{0}' keyword.\"),\r\n        A_decorator_can_only_decorate_a_method_implementation_not_an_overload: diag(1249, DiagnosticCategory.Error, \"A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249\", \"A decorator can only decorate a method implementation, not an overload.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: diag(1250, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: diag(1251, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: diag(1252, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.\"),\r\n        _0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag: diag(1253, DiagnosticCategory.Error, \"_0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag_1253\", \"'{0}' tag cannot be used independently as a top level JSDoc tag.\"),\r\n        A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal: diag(1254, DiagnosticCategory.Error, \"A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_1254\", \"A 'const' initializer in an ambient context must be a string or numeric literal.\"),\r\n        with_statements_are_not_allowed_in_an_async_function_block: diag(1300, DiagnosticCategory.Error, \"with_statements_are_not_allowed_in_an_async_function_block_1300\", \"'with' statements are not allowed in an async function block.\"),\r\n        await_expression_is_only_allowed_within_an_async_function: diag(1308, DiagnosticCategory.Error, \"await_expression_is_only_allowed_within_an_async_function_1308\", \"'await' expression is only allowed within an async function.\"),\r\n        can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment: diag(1312, DiagnosticCategory.Error, \"can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment_1312\", \"'=' can only be used in an object literal property inside a destructuring assignment.\"),\r\n        The_body_of_an_if_statement_cannot_be_the_empty_statement: diag(1313, DiagnosticCategory.Error, \"The_body_of_an_if_statement_cannot_be_the_empty_statement_1313\", \"The body of an 'if' statement cannot be the empty statement.\"),\r\n        Global_module_exports_may_only_appear_in_module_files: diag(1314, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_in_module_files_1314\", \"Global module exports may only appear in module files.\"),\r\n        Global_module_exports_may_only_appear_in_declaration_files: diag(1315, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_in_declaration_files_1315\", \"Global module exports may only appear in declaration files.\"),\r\n        Global_module_exports_may_only_appear_at_top_level: diag(1316, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_at_top_level_1316\", \"Global module exports may only appear at top level.\"),\r\n        A_parameter_property_cannot_be_declared_using_a_rest_parameter: diag(1317, DiagnosticCategory.Error, \"A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317\", \"A parameter property cannot be declared using a rest parameter.\"),\r\n        An_abstract_accessor_cannot_have_an_implementation: diag(1318, DiagnosticCategory.Error, \"An_abstract_accessor_cannot_have_an_implementation_1318\", \"An abstract accessor cannot have an implementation.\"),\r\n        A_default_export_can_only_be_used_in_an_ECMAScript_style_module: diag(1319, DiagnosticCategory.Error, \"A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319\", \"A default export can only be used in an ECMAScript-style module.\"),\r\n        Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1320, DiagnosticCategory.Error, \"Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320\", \"Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1321, DiagnosticCategory.Error, \"Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321\", \"Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1322, DiagnosticCategory.Error, \"Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322\", \"Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Dynamic_import_cannot_be_used_when_targeting_ECMAScript_2015_modules: diag(1323, DiagnosticCategory.Error, \"Dynamic_import_cannot_be_used_when_targeting_ECMAScript_2015_modules_1323\", \"Dynamic import cannot be used when targeting ECMAScript 2015 modules.\"),\r\n        Dynamic_import_must_have_one_specifier_as_an_argument: diag(1324, DiagnosticCategory.Error, \"Dynamic_import_must_have_one_specifier_as_an_argument_1324\", \"Dynamic import must have one specifier as an argument.\"),\r\n        Specifier_of_dynamic_import_cannot_be_spread_element: diag(1325, DiagnosticCategory.Error, \"Specifier_of_dynamic_import_cannot_be_spread_element_1325\", \"Specifier of dynamic import cannot be spread element.\"),\r\n        Dynamic_import_cannot_have_type_arguments: diag(1326, DiagnosticCategory.Error, \"Dynamic_import_cannot_have_type_arguments_1326\", \"Dynamic import cannot have type arguments\"),\r\n        String_literal_with_double_quotes_expected: diag(1327, DiagnosticCategory.Error, \"String_literal_with_double_quotes_expected_1327\", \"String literal with double quotes expected.\"),\r\n        Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: diag(1328, DiagnosticCategory.Error, \"Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328\", \"Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal.\"),\r\n        _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: diag(1329, DiagnosticCategory.Error, \"_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329\", \"'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?\"),\r\n        Duplicate_identifier_0: diag(2300, DiagnosticCategory.Error, \"Duplicate_identifier_0_2300\", \"Duplicate identifier '{0}'.\"),\r\n        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: diag(2301, DiagnosticCategory.Error, \"Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301\", \"Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.\"),\r\n        Static_members_cannot_reference_class_type_parameters: diag(2302, DiagnosticCategory.Error, \"Static_members_cannot_reference_class_type_parameters_2302\", \"Static members cannot reference class type parameters.\"),\r\n        Circular_definition_of_import_alias_0: diag(2303, DiagnosticCategory.Error, \"Circular_definition_of_import_alias_0_2303\", \"Circular definition of import alias '{0}'.\"),\r\n        Cannot_find_name_0: diag(2304, DiagnosticCategory.Error, \"Cannot_find_name_0_2304\", \"Cannot find name '{0}'.\"),\r\n        Module_0_has_no_exported_member_1: diag(2305, DiagnosticCategory.Error, \"Module_0_has_no_exported_member_1_2305\", \"Module '{0}' has no exported member '{1}'.\"),\r\n        File_0_is_not_a_module: diag(2306, DiagnosticCategory.Error, \"File_0_is_not_a_module_2306\", \"File '{0}' is not a module.\"),\r\n        Cannot_find_module_0: diag(2307, DiagnosticCategory.Error, \"Cannot_find_module_0_2307\", \"Cannot find module '{0}'.\"),\r\n        Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: diag(2308, DiagnosticCategory.Error, \"Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308\", \"Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.\"),\r\n        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: diag(2309, DiagnosticCategory.Error, \"An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309\", \"An export assignment cannot be used in a module with other exported elements.\"),\r\n        Type_0_recursively_references_itself_as_a_base_type: diag(2310, DiagnosticCategory.Error, \"Type_0_recursively_references_itself_as_a_base_type_2310\", \"Type '{0}' recursively references itself as a base type.\"),\r\n        A_class_may_only_extend_another_class: diag(2311, DiagnosticCategory.Error, \"A_class_may_only_extend_another_class_2311\", \"A class may only extend another class.\"),\r\n        An_interface_may_only_extend_a_class_or_another_interface: diag(2312, DiagnosticCategory.Error, \"An_interface_may_only_extend_a_class_or_another_interface_2312\", \"An interface may only extend a class or another interface.\"),\r\n        Type_parameter_0_has_a_circular_constraint: diag(2313, DiagnosticCategory.Error, \"Type_parameter_0_has_a_circular_constraint_2313\", \"Type parameter '{0}' has a circular constraint.\"),\r\n        Generic_type_0_requires_1_type_argument_s: diag(2314, DiagnosticCategory.Error, \"Generic_type_0_requires_1_type_argument_s_2314\", \"Generic type '{0}' requires {1} type argument(s).\"),\r\n        Type_0_is_not_generic: diag(2315, DiagnosticCategory.Error, \"Type_0_is_not_generic_2315\", \"Type '{0}' is not generic.\"),\r\n        Global_type_0_must_be_a_class_or_interface_type: diag(2316, DiagnosticCategory.Error, \"Global_type_0_must_be_a_class_or_interface_type_2316\", \"Global type '{0}' must be a class or interface type.\"),\r\n        Global_type_0_must_have_1_type_parameter_s: diag(2317, DiagnosticCategory.Error, \"Global_type_0_must_have_1_type_parameter_s_2317\", \"Global type '{0}' must have {1} type parameter(s).\"),\r\n        Cannot_find_global_type_0: diag(2318, DiagnosticCategory.Error, \"Cannot_find_global_type_0_2318\", \"Cannot find global type '{0}'.\"),\r\n        Named_property_0_of_types_1_and_2_are_not_identical: diag(2319, DiagnosticCategory.Error, \"Named_property_0_of_types_1_and_2_are_not_identical_2319\", \"Named property '{0}' of types '{1}' and '{2}' are not identical.\"),\r\n        Interface_0_cannot_simultaneously_extend_types_1_and_2: diag(2320, DiagnosticCategory.Error, \"Interface_0_cannot_simultaneously_extend_types_1_and_2_2320\", \"Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.\"),\r\n        Excessive_stack_depth_comparing_types_0_and_1: diag(2321, DiagnosticCategory.Error, \"Excessive_stack_depth_comparing_types_0_and_1_2321\", \"Excessive stack depth comparing types '{0}' and '{1}'.\"),\r\n        Type_0_is_not_assignable_to_type_1: diag(2322, DiagnosticCategory.Error, \"Type_0_is_not_assignable_to_type_1_2322\", \"Type '{0}' is not assignable to type '{1}'.\"),\r\n        Cannot_redeclare_exported_variable_0: diag(2323, DiagnosticCategory.Error, \"Cannot_redeclare_exported_variable_0_2323\", \"Cannot redeclare exported variable '{0}'.\"),\r\n        Property_0_is_missing_in_type_1: diag(2324, DiagnosticCategory.Error, \"Property_0_is_missing_in_type_1_2324\", \"Property '{0}' is missing in type '{1}'.\"),\r\n        Property_0_is_private_in_type_1_but_not_in_type_2: diag(2325, DiagnosticCategory.Error, \"Property_0_is_private_in_type_1_but_not_in_type_2_2325\", \"Property '{0}' is private in type '{1}' but not in type '{2}'.\"),\r\n        Types_of_property_0_are_incompatible: diag(2326, DiagnosticCategory.Error, \"Types_of_property_0_are_incompatible_2326\", \"Types of property '{0}' are incompatible.\"),\r\n        Property_0_is_optional_in_type_1_but_required_in_type_2: diag(2327, DiagnosticCategory.Error, \"Property_0_is_optional_in_type_1_but_required_in_type_2_2327\", \"Property '{0}' is optional in type '{1}' but required in type '{2}'.\"),\r\n        Types_of_parameters_0_and_1_are_incompatible: diag(2328, DiagnosticCategory.Error, \"Types_of_parameters_0_and_1_are_incompatible_2328\", \"Types of parameters '{0}' and '{1}' are incompatible.\"),\r\n        Index_signature_is_missing_in_type_0: diag(2329, DiagnosticCategory.Error, \"Index_signature_is_missing_in_type_0_2329\", \"Index signature is missing in type '{0}'.\"),\r\n        Index_signatures_are_incompatible: diag(2330, DiagnosticCategory.Error, \"Index_signatures_are_incompatible_2330\", \"Index signatures are incompatible.\"),\r\n        this_cannot_be_referenced_in_a_module_or_namespace_body: diag(2331, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_module_or_namespace_body_2331\", \"'this' cannot be referenced in a module or namespace body.\"),\r\n        this_cannot_be_referenced_in_current_location: diag(2332, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_current_location_2332\", \"'this' cannot be referenced in current location.\"),\r\n        this_cannot_be_referenced_in_constructor_arguments: diag(2333, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_constructor_arguments_2333\", \"'this' cannot be referenced in constructor arguments.\"),\r\n        this_cannot_be_referenced_in_a_static_property_initializer: diag(2334, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_static_property_initializer_2334\", \"'this' cannot be referenced in a static property initializer.\"),\r\n        super_can_only_be_referenced_in_a_derived_class: diag(2335, DiagnosticCategory.Error, \"super_can_only_be_referenced_in_a_derived_class_2335\", \"'super' can only be referenced in a derived class.\"),\r\n        super_cannot_be_referenced_in_constructor_arguments: diag(2336, DiagnosticCategory.Error, \"super_cannot_be_referenced_in_constructor_arguments_2336\", \"'super' cannot be referenced in constructor arguments.\"),\r\n        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: diag(2337, DiagnosticCategory.Error, \"Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337\", \"Super calls are not permitted outside constructors or in nested functions inside constructors.\"),\r\n        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: diag(2338, DiagnosticCategory.Error, \"super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338\", \"'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.\"),\r\n        Property_0_does_not_exist_on_type_1: diag(2339, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_type_1_2339\", \"Property '{0}' does not exist on type '{1}'.\"),\r\n        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: diag(2340, DiagnosticCategory.Error, \"Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340\", \"Only public and protected methods of the base class are accessible via the 'super' keyword.\"),\r\n        Property_0_is_private_and_only_accessible_within_class_1: diag(2341, DiagnosticCategory.Error, \"Property_0_is_private_and_only_accessible_within_class_1_2341\", \"Property '{0}' is private and only accessible within class '{1}'.\"),\r\n        An_index_expression_argument_must_be_of_type_string_number_symbol_or_any: diag(2342, DiagnosticCategory.Error, \"An_index_expression_argument_must_be_of_type_string_number_symbol_or_any_2342\", \"An index expression argument must be of type 'string', 'number', 'symbol', or 'any'.\"),\r\n        This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1: diag(2343, DiagnosticCategory.Error, \"This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1_2343\", \"This syntax requires an imported helper named '{1}', but module '{0}' has no exported member '{1}'.\"),\r\n        Type_0_does_not_satisfy_the_constraint_1: diag(2344, DiagnosticCategory.Error, \"Type_0_does_not_satisfy_the_constraint_1_2344\", \"Type '{0}' does not satisfy the constraint '{1}'.\"),\r\n        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: diag(2345, DiagnosticCategory.Error, \"Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345\", \"Argument of type '{0}' is not assignable to parameter of type '{1}'.\"),\r\n        Call_target_does_not_contain_any_signatures: diag(2346, DiagnosticCategory.Error, \"Call_target_does_not_contain_any_signatures_2346\", \"Call target does not contain any signatures.\"),\r\n        Untyped_function_calls_may_not_accept_type_arguments: diag(2347, DiagnosticCategory.Error, \"Untyped_function_calls_may_not_accept_type_arguments_2347\", \"Untyped function calls may not accept type arguments.\"),\r\n        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: diag(2348, DiagnosticCategory.Error, \"Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348\", \"Value of type '{0}' is not callable. Did you mean to include 'new'?\"),\r\n        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures: diag(2349, DiagnosticCategory.Error, \"Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatur_2349\", \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\"),\r\n        Only_a_void_function_can_be_called_with_the_new_keyword: diag(2350, DiagnosticCategory.Error, \"Only_a_void_function_can_be_called_with_the_new_keyword_2350\", \"Only a void function can be called with the 'new' keyword.\"),\r\n        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: diag(2351, DiagnosticCategory.Error, \"Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature_2351\", \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"),\r\n        Type_0_cannot_be_converted_to_type_1: diag(2352, DiagnosticCategory.Error, \"Type_0_cannot_be_converted_to_type_1_2352\", \"Type '{0}' cannot be converted to type '{1}'.\"),\r\n        Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: diag(2353, DiagnosticCategory.Error, \"Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353\", \"Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.\"),\r\n        This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: diag(2354, DiagnosticCategory.Error, \"This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354\", \"This syntax requires an imported helper but module '{0}' cannot be found.\"),\r\n        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: diag(2355, DiagnosticCategory.Error, \"A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355\", \"A function whose declared type is neither 'void' nor 'any' must return a value.\"),\r\n        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: diag(2356, DiagnosticCategory.Error, \"An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type_2356\", \"An arithmetic operand must be of type 'any', 'number' or an enum type.\"),\r\n        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: diag(2357, DiagnosticCategory.Error, \"The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357\", \"The operand of an increment or decrement operator must be a variable or a property access.\"),\r\n        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2358, DiagnosticCategory.Error, \"The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358\", \"The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.\"),\r\n        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: diag(2359, DiagnosticCategory.Error, \"The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359\", \"The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.\"),\r\n        The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol: diag(2360, DiagnosticCategory.Error, \"The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol_2360\", \"The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.\"),\r\n        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2361, DiagnosticCategory.Error, \"The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter_2361\", \"The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.\"),\r\n        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: diag(2362, DiagnosticCategory.Error, \"The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2362\", \"The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\"),\r\n        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: diag(2363, DiagnosticCategory.Error, \"The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2363\", \"The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\"),\r\n        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: diag(2364, DiagnosticCategory.Error, \"The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364\", \"The left-hand side of an assignment expression must be a variable or a property access.\"),\r\n        Operator_0_cannot_be_applied_to_types_1_and_2: diag(2365, DiagnosticCategory.Error, \"Operator_0_cannot_be_applied_to_types_1_and_2_2365\", \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\"),\r\n        Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: diag(2366, DiagnosticCategory.Error, \"Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366\", \"Function lacks ending return statement and return type does not include 'undefined'.\"),\r\n        Type_parameter_name_cannot_be_0: diag(2368, DiagnosticCategory.Error, \"Type_parameter_name_cannot_be_0_2368\", \"Type parameter name cannot be '{0}'.\"),\r\n        A_parameter_property_is_only_allowed_in_a_constructor_implementation: diag(2369, DiagnosticCategory.Error, \"A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369\", \"A parameter property is only allowed in a constructor implementation.\"),\r\n        A_rest_parameter_must_be_of_an_array_type: diag(2370, DiagnosticCategory.Error, \"A_rest_parameter_must_be_of_an_array_type_2370\", \"A rest parameter must be of an array type.\"),\r\n        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: diag(2371, DiagnosticCategory.Error, \"A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371\", \"A parameter initializer is only allowed in a function or constructor implementation.\"),\r\n        Parameter_0_cannot_be_referenced_in_its_initializer: diag(2372, DiagnosticCategory.Error, \"Parameter_0_cannot_be_referenced_in_its_initializer_2372\", \"Parameter '{0}' cannot be referenced in its initializer.\"),\r\n        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: diag(2373, DiagnosticCategory.Error, \"Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it_2373\", \"Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.\"),\r\n        Duplicate_string_index_signature: diag(2374, DiagnosticCategory.Error, \"Duplicate_string_index_signature_2374\", \"Duplicate string index signature.\"),\r\n        Duplicate_number_index_signature: diag(2375, DiagnosticCategory.Error, \"Duplicate_number_index_signature_2375\", \"Duplicate number index signature.\"),\r\n        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: diag(2376, DiagnosticCategory.Error, \"A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_proper_2376\", \"A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.\"),\r\n        Constructors_for_derived_classes_must_contain_a_super_call: diag(2377, DiagnosticCategory.Error, \"Constructors_for_derived_classes_must_contain_a_super_call_2377\", \"Constructors for derived classes must contain a 'super' call.\"),\r\n        A_get_accessor_must_return_a_value: diag(2378, DiagnosticCategory.Error, \"A_get_accessor_must_return_a_value_2378\", \"A 'get' accessor must return a value.\"),\r\n        Getter_and_setter_accessors_do_not_agree_in_visibility: diag(2379, DiagnosticCategory.Error, \"Getter_and_setter_accessors_do_not_agree_in_visibility_2379\", \"Getter and setter accessors do not agree in visibility.\"),\r\n        get_and_set_accessor_must_have_the_same_type: diag(2380, DiagnosticCategory.Error, \"get_and_set_accessor_must_have_the_same_type_2380\", \"'get' and 'set' accessor must have the same type.\"),\r\n        A_signature_with_an_implementation_cannot_use_a_string_literal_type: diag(2381, DiagnosticCategory.Error, \"A_signature_with_an_implementation_cannot_use_a_string_literal_type_2381\", \"A signature with an implementation cannot use a string literal type.\"),\r\n        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: diag(2382, DiagnosticCategory.Error, \"Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature_2382\", \"Specialized overload signature is not assignable to any non-specialized signature.\"),\r\n        Overload_signatures_must_all_be_exported_or_non_exported: diag(2383, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_exported_or_non_exported_2383\", \"Overload signatures must all be exported or non-exported.\"),\r\n        Overload_signatures_must_all_be_ambient_or_non_ambient: diag(2384, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_ambient_or_non_ambient_2384\", \"Overload signatures must all be ambient or non-ambient.\"),\r\n        Overload_signatures_must_all_be_public_private_or_protected: diag(2385, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_public_private_or_protected_2385\", \"Overload signatures must all be public, private or protected.\"),\r\n        Overload_signatures_must_all_be_optional_or_required: diag(2386, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_optional_or_required_2386\", \"Overload signatures must all be optional or required.\"),\r\n        Function_overload_must_be_static: diag(2387, DiagnosticCategory.Error, \"Function_overload_must_be_static_2387\", \"Function overload must be static.\"),\r\n        Function_overload_must_not_be_static: diag(2388, DiagnosticCategory.Error, \"Function_overload_must_not_be_static_2388\", \"Function overload must not be static.\"),\r\n        Function_implementation_name_must_be_0: diag(2389, DiagnosticCategory.Error, \"Function_implementation_name_must_be_0_2389\", \"Function implementation name must be '{0}'.\"),\r\n        Constructor_implementation_is_missing: diag(2390, DiagnosticCategory.Error, \"Constructor_implementation_is_missing_2390\", \"Constructor implementation is missing.\"),\r\n        Function_implementation_is_missing_or_not_immediately_following_the_declaration: diag(2391, DiagnosticCategory.Error, \"Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391\", \"Function implementation is missing or not immediately following the declaration.\"),\r\n        Multiple_constructor_implementations_are_not_allowed: diag(2392, DiagnosticCategory.Error, \"Multiple_constructor_implementations_are_not_allowed_2392\", \"Multiple constructor implementations are not allowed.\"),\r\n        Duplicate_function_implementation: diag(2393, DiagnosticCategory.Error, \"Duplicate_function_implementation_2393\", \"Duplicate function implementation.\"),\r\n        Overload_signature_is_not_compatible_with_function_implementation: diag(2394, DiagnosticCategory.Error, \"Overload_signature_is_not_compatible_with_function_implementation_2394\", \"Overload signature is not compatible with function implementation.\"),\r\n        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: diag(2395, DiagnosticCategory.Error, \"Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395\", \"Individual declarations in merged declaration '{0}' must be all exported or all local.\"),\r\n        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: diag(2396, DiagnosticCategory.Error, \"Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396\", \"Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.\"),\r\n        Declaration_name_conflicts_with_built_in_global_identifier_0: diag(2397, DiagnosticCategory.Error, \"Declaration_name_conflicts_with_built_in_global_identifier_0_2397\", \"Declaration name conflicts with built-in global identifier '{0}'.\"),\r\n        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: diag(2399, DiagnosticCategory.Error, \"Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399\", \"Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.\"),\r\n        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: diag(2400, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400\", \"Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.\"),\r\n        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: diag(2401, DiagnosticCategory.Error, \"Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference_2401\", \"Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.\"),\r\n        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: diag(2402, DiagnosticCategory.Error, \"Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402\", \"Expression resolves to '_super' that compiler uses to capture base class reference.\"),\r\n        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: diag(2403, DiagnosticCategory.Error, \"Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403\", \"Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.\"),\r\n        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: diag(2404, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404\", \"The left-hand side of a 'for...in' statement cannot use a type annotation.\"),\r\n        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: diag(2405, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405\", \"The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.\"),\r\n        The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: diag(2406, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406\", \"The left-hand side of a 'for...in' statement must be a variable or a property access.\"),\r\n        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2407, DiagnosticCategory.Error, \"The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_2407\", \"The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.\"),\r\n        Setters_cannot_return_a_value: diag(2408, DiagnosticCategory.Error, \"Setters_cannot_return_a_value_2408\", \"Setters cannot return a value.\"),\r\n        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: diag(2409, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409\", \"Return type of constructor signature must be assignable to the instance type of the class.\"),\r\n        The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: diag(2410, DiagnosticCategory.Error, \"The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410\", \"The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.\"),\r\n        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: diag(2411, DiagnosticCategory.Error, \"Property_0_of_type_1_is_not_assignable_to_string_index_type_2_2411\", \"Property '{0}' of type '{1}' is not assignable to string index type '{2}'.\"),\r\n        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: diag(2412, DiagnosticCategory.Error, \"Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2_2412\", \"Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.\"),\r\n        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: diag(2413, DiagnosticCategory.Error, \"Numeric_index_type_0_is_not_assignable_to_string_index_type_1_2413\", \"Numeric index type '{0}' is not assignable to string index type '{1}'.\"),\r\n        Class_name_cannot_be_0: diag(2414, DiagnosticCategory.Error, \"Class_name_cannot_be_0_2414\", \"Class name cannot be '{0}'.\"),\r\n        Class_0_incorrectly_extends_base_class_1: diag(2415, DiagnosticCategory.Error, \"Class_0_incorrectly_extends_base_class_1_2415\", \"Class '{0}' incorrectly extends base class '{1}'.\"),\r\n        Class_static_side_0_incorrectly_extends_base_class_static_side_1: diag(2417, DiagnosticCategory.Error, \"Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417\", \"Class static side '{0}' incorrectly extends base class static side '{1}'.\"),\r\n        Class_0_incorrectly_implements_interface_1: diag(2420, DiagnosticCategory.Error, \"Class_0_incorrectly_implements_interface_1_2420\", \"Class '{0}' incorrectly implements interface '{1}'.\"),\r\n        A_class_may_only_implement_another_class_or_interface: diag(2422, DiagnosticCategory.Error, \"A_class_may_only_implement_another_class_or_interface_2422\", \"A class may only implement another class or interface.\"),\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: diag(2423, DiagnosticCategory.Error, \"Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423\", \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.\"),\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: diag(2424, DiagnosticCategory.Error, \"Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_proper_2424\", \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.\"),\r\n        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2425, DiagnosticCategory.Error, \"Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425\", \"Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.\"),\r\n        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2426, DiagnosticCategory.Error, \"Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426\", \"Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.\"),\r\n        Interface_name_cannot_be_0: diag(2427, DiagnosticCategory.Error, \"Interface_name_cannot_be_0_2427\", \"Interface name cannot be '{0}'.\"),\r\n        All_declarations_of_0_must_have_identical_type_parameters: diag(2428, DiagnosticCategory.Error, \"All_declarations_of_0_must_have_identical_type_parameters_2428\", \"All declarations of '{0}' must have identical type parameters.\"),\r\n        Interface_0_incorrectly_extends_interface_1: diag(2430, DiagnosticCategory.Error, \"Interface_0_incorrectly_extends_interface_1_2430\", \"Interface '{0}' incorrectly extends interface '{1}'.\"),\r\n        Enum_name_cannot_be_0: diag(2431, DiagnosticCategory.Error, \"Enum_name_cannot_be_0_2431\", \"Enum name cannot be '{0}'.\"),\r\n        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: diag(2432, DiagnosticCategory.Error, \"In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432\", \"In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.\"),\r\n        A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: diag(2433, DiagnosticCategory.Error, \"A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433\", \"A namespace declaration cannot be in a different file from a class or function with which it is merged.\"),\r\n        A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: diag(2434, DiagnosticCategory.Error, \"A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434\", \"A namespace declaration cannot be located prior to a class or function with which it is merged.\"),\r\n        Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: diag(2435, DiagnosticCategory.Error, \"Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435\", \"Ambient modules cannot be nested in other modules or namespaces.\"),\r\n        Ambient_module_declaration_cannot_specify_relative_module_name: diag(2436, DiagnosticCategory.Error, \"Ambient_module_declaration_cannot_specify_relative_module_name_2436\", \"Ambient module declaration cannot specify relative module name.\"),\r\n        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: diag(2437, DiagnosticCategory.Error, \"Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437\", \"Module '{0}' is hidden by a local declaration with the same name.\"),\r\n        Import_name_cannot_be_0: diag(2438, DiagnosticCategory.Error, \"Import_name_cannot_be_0_2438\", \"Import name cannot be '{0}'.\"),\r\n        Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: diag(2439, DiagnosticCategory.Error, \"Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439\", \"Import or export declaration in an ambient module declaration cannot reference module through relative module name.\"),\r\n        Import_declaration_conflicts_with_local_declaration_of_0: diag(2440, DiagnosticCategory.Error, \"Import_declaration_conflicts_with_local_declaration_of_0_2440\", \"Import declaration conflicts with local declaration of '{0}'.\"),\r\n        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: diag(2441, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441\", \"Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.\"),\r\n        Types_have_separate_declarations_of_a_private_property_0: diag(2442, DiagnosticCategory.Error, \"Types_have_separate_declarations_of_a_private_property_0_2442\", \"Types have separate declarations of a private property '{0}'.\"),\r\n        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: diag(2443, DiagnosticCategory.Error, \"Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443\", \"Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.\"),\r\n        Property_0_is_protected_in_type_1_but_public_in_type_2: diag(2444, DiagnosticCategory.Error, \"Property_0_is_protected_in_type_1_but_public_in_type_2_2444\", \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\"),\r\n        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: diag(2445, DiagnosticCategory.Error, \"Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445\", \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\"),\r\n        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1: diag(2446, DiagnosticCategory.Error, \"Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_2446\", \"Property '{0}' is protected and only accessible through an instance of class '{1}'.\"),\r\n        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: diag(2447, DiagnosticCategory.Error, \"The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447\", \"The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.\"),\r\n        Block_scoped_variable_0_used_before_its_declaration: diag(2448, DiagnosticCategory.Error, \"Block_scoped_variable_0_used_before_its_declaration_2448\", \"Block-scoped variable '{0}' used before its declaration.\"),\r\n        Class_0_used_before_its_declaration: diag(2449, DiagnosticCategory.Error, \"Class_0_used_before_its_declaration_2449\", \"Class '{0}' used before its declaration.\"),\r\n        Enum_0_used_before_its_declaration: diag(2450, DiagnosticCategory.Error, \"Enum_0_used_before_its_declaration_2450\", \"Enum '{0}' used before its declaration.\"),\r\n        Cannot_redeclare_block_scoped_variable_0: diag(2451, DiagnosticCategory.Error, \"Cannot_redeclare_block_scoped_variable_0_2451\", \"Cannot redeclare block-scoped variable '{0}'.\"),\r\n        An_enum_member_cannot_have_a_numeric_name: diag(2452, DiagnosticCategory.Error, \"An_enum_member_cannot_have_a_numeric_name_2452\", \"An enum member cannot have a numeric name.\"),\r\n        The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly: diag(2453, DiagnosticCategory.Error, \"The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_typ_2453\", \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\"),\r\n        Variable_0_is_used_before_being_assigned: diag(2454, DiagnosticCategory.Error, \"Variable_0_is_used_before_being_assigned_2454\", \"Variable '{0}' is used before being assigned.\"),\r\n        Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0: diag(2455, DiagnosticCategory.Error, \"Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0_2455\", \"Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.\"),\r\n        Type_alias_0_circularly_references_itself: diag(2456, DiagnosticCategory.Error, \"Type_alias_0_circularly_references_itself_2456\", \"Type alias '{0}' circularly references itself.\"),\r\n        Type_alias_name_cannot_be_0: diag(2457, DiagnosticCategory.Error, \"Type_alias_name_cannot_be_0_2457\", \"Type alias name cannot be '{0}'.\"),\r\n        An_AMD_module_cannot_have_multiple_name_assignments: diag(2458, DiagnosticCategory.Error, \"An_AMD_module_cannot_have_multiple_name_assignments_2458\", \"An AMD module cannot have multiple name assignments.\"),\r\n        Type_0_has_no_property_1_and_no_string_index_signature: diag(2459, DiagnosticCategory.Error, \"Type_0_has_no_property_1_and_no_string_index_signature_2459\", \"Type '{0}' has no property '{1}' and no string index signature.\"),\r\n        Type_0_has_no_property_1: diag(2460, DiagnosticCategory.Error, \"Type_0_has_no_property_1_2460\", \"Type '{0}' has no property '{1}'.\"),\r\n        Type_0_is_not_an_array_type: diag(2461, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_2461\", \"Type '{0}' is not an array type.\"),\r\n        A_rest_element_must_be_last_in_a_destructuring_pattern: diag(2462, DiagnosticCategory.Error, \"A_rest_element_must_be_last_in_a_destructuring_pattern_2462\", \"A rest element must be last in a destructuring pattern.\"),\r\n        A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: diag(2463, DiagnosticCategory.Error, \"A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463\", \"A binding pattern parameter cannot be optional in an implementation signature.\"),\r\n        A_computed_property_name_must_be_of_type_string_number_symbol_or_any: diag(2464, DiagnosticCategory.Error, \"A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464\", \"A computed property name must be of type 'string', 'number', 'symbol', or 'any'.\"),\r\n        this_cannot_be_referenced_in_a_computed_property_name: diag(2465, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_computed_property_name_2465\", \"'this' cannot be referenced in a computed property name.\"),\r\n        super_cannot_be_referenced_in_a_computed_property_name: diag(2466, DiagnosticCategory.Error, \"super_cannot_be_referenced_in_a_computed_property_name_2466\", \"'super' cannot be referenced in a computed property name.\"),\r\n        A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: diag(2467, DiagnosticCategory.Error, \"A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467\", \"A computed property name cannot reference a type parameter from its containing type.\"),\r\n        Cannot_find_global_value_0: diag(2468, DiagnosticCategory.Error, \"Cannot_find_global_value_0_2468\", \"Cannot find global value '{0}'.\"),\r\n        The_0_operator_cannot_be_applied_to_type_symbol: diag(2469, DiagnosticCategory.Error, \"The_0_operator_cannot_be_applied_to_type_symbol_2469\", \"The '{0}' operator cannot be applied to type 'symbol'.\"),\r\n        Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object: diag(2470, DiagnosticCategory.Error, \"Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object_2470\", \"'Symbol' reference does not refer to the global Symbol constructor object.\"),\r\n        A_computed_property_name_of_the_form_0_must_be_of_type_symbol: diag(2471, DiagnosticCategory.Error, \"A_computed_property_name_of_the_form_0_must_be_of_type_symbol_2471\", \"A computed property name of the form '{0}' must be of type 'symbol'.\"),\r\n        Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: diag(2472, DiagnosticCategory.Error, \"Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472\", \"Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.\"),\r\n        Enum_declarations_must_all_be_const_or_non_const: diag(2473, DiagnosticCategory.Error, \"Enum_declarations_must_all_be_const_or_non_const_2473\", \"Enum declarations must all be const or non-const.\"),\r\n        In_const_enum_declarations_member_initializer_must_be_constant_expression: diag(2474, DiagnosticCategory.Error, \"In_const_enum_declarations_member_initializer_must_be_constant_expression_2474\", \"In 'const' enum declarations member initializer must be constant expression.\"),\r\n        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment: diag(2475, DiagnosticCategory.Error, \"const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475\", \"'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.\"),\r\n        A_const_enum_member_can_only_be_accessed_using_a_string_literal: diag(2476, DiagnosticCategory.Error, \"A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476\", \"A const enum member can only be accessed using a string literal.\"),\r\n        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: diag(2477, DiagnosticCategory.Error, \"const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477\", \"'const' enum member initializer was evaluated to a non-finite value.\"),\r\n        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: diag(2478, DiagnosticCategory.Error, \"const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478\", \"'const' enum member initializer was evaluated to disallowed value 'NaN'.\"),\r\n        Property_0_does_not_exist_on_const_enum_1: diag(2479, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_const_enum_1_2479\", \"Property '{0}' does not exist on 'const' enum '{1}'.\"),\r\n        let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: diag(2480, DiagnosticCategory.Error, \"let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480\", \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\"),\r\n        Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: diag(2481, DiagnosticCategory.Error, \"Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481\", \"Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.\"),\r\n        The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: diag(2483, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483\", \"The left-hand side of a 'for...of' statement cannot use a type annotation.\"),\r\n        Export_declaration_conflicts_with_exported_declaration_of_0: diag(2484, DiagnosticCategory.Error, \"Export_declaration_conflicts_with_exported_declaration_of_0_2484\", \"Export declaration conflicts with exported declaration of '{0}'.\"),\r\n        The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: diag(2487, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487\", \"The left-hand side of a 'for...of' statement must be a variable or a property access.\"),\r\n        Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2488, DiagnosticCategory.Error, \"Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488\", \"Type must have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        An_iterator_must_have_a_next_method: diag(2489, DiagnosticCategory.Error, \"An_iterator_must_have_a_next_method_2489\", \"An iterator must have a 'next()' method.\"),\r\n        The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property: diag(2490, DiagnosticCategory.Error, \"The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property_2490\", \"The type returned by the 'next()' method of an iterator must have a 'value' property.\"),\r\n        The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: diag(2491, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491\", \"The left-hand side of a 'for...in' statement cannot be a destructuring pattern.\"),\r\n        Cannot_redeclare_identifier_0_in_catch_clause: diag(2492, DiagnosticCategory.Error, \"Cannot_redeclare_identifier_0_in_catch_clause_2492\", \"Cannot redeclare identifier '{0}' in catch clause.\"),\r\n        Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2: diag(2493, DiagnosticCategory.Error, \"Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2_2493\", \"Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.\"),\r\n        Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: diag(2494, DiagnosticCategory.Error, \"Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494\", \"Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.\"),\r\n        Type_0_is_not_an_array_type_or_a_string_type: diag(2495, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_a_string_type_2495\", \"Type '{0}' is not an array type or a string type.\"),\r\n        The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: diag(2496, DiagnosticCategory.Error, \"The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496\", \"The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.\"),\r\n        Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct: diag(2497, DiagnosticCategory.Error, \"Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct_2497\", \"Module '{0}' resolves to a non-module entity and cannot be imported using this construct.\"),\r\n        Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: diag(2498, DiagnosticCategory.Error, \"Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498\", \"Module '{0}' uses 'export =' and cannot be used with 'export *'.\"),\r\n        An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2499, DiagnosticCategory.Error, \"An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499\", \"An interface can only extend an identifier/qualified-name with optional type arguments.\"),\r\n        A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2500, DiagnosticCategory.Error, \"A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500\", \"A class can only implement an identifier/qualified-name with optional type arguments.\"),\r\n        A_rest_element_cannot_contain_a_binding_pattern: diag(2501, DiagnosticCategory.Error, \"A_rest_element_cannot_contain_a_binding_pattern_2501\", \"A rest element cannot contain a binding pattern.\"),\r\n        _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: diag(2502, DiagnosticCategory.Error, \"_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502\", \"'{0}' is referenced directly or indirectly in its own type annotation.\"),\r\n        Cannot_find_namespace_0: diag(2503, DiagnosticCategory.Error, \"Cannot_find_namespace_0_2503\", \"Cannot find namespace '{0}'.\"),\r\n        Type_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: diag(2504, DiagnosticCategory.Error, \"Type_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504\", \"Type must have a '[Symbol.asyncIterator]()' method that returns an async iterator.\"),\r\n        A_generator_cannot_have_a_void_type_annotation: diag(2505, DiagnosticCategory.Error, \"A_generator_cannot_have_a_void_type_annotation_2505\", \"A generator cannot have a 'void' type annotation.\"),\r\n        _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: diag(2506, DiagnosticCategory.Error, \"_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506\", \"'{0}' is referenced directly or indirectly in its own base expression.\"),\r\n        Type_0_is_not_a_constructor_function_type: diag(2507, DiagnosticCategory.Error, \"Type_0_is_not_a_constructor_function_type_2507\", \"Type '{0}' is not a constructor function type.\"),\r\n        No_base_constructor_has_the_specified_number_of_type_arguments: diag(2508, DiagnosticCategory.Error, \"No_base_constructor_has_the_specified_number_of_type_arguments_2508\", \"No base constructor has the specified number of type arguments.\"),\r\n        Base_constructor_return_type_0_is_not_a_class_or_interface_type: diag(2509, DiagnosticCategory.Error, \"Base_constructor_return_type_0_is_not_a_class_or_interface_type_2509\", \"Base constructor return type '{0}' is not a class or interface type.\"),\r\n        Base_constructors_must_all_have_the_same_return_type: diag(2510, DiagnosticCategory.Error, \"Base_constructors_must_all_have_the_same_return_type_2510\", \"Base constructors must all have the same return type.\"),\r\n        Cannot_create_an_instance_of_the_abstract_class_0: diag(2511, DiagnosticCategory.Error, \"Cannot_create_an_instance_of_the_abstract_class_0_2511\", \"Cannot create an instance of the abstract class '{0}'.\"),\r\n        Overload_signatures_must_all_be_abstract_or_non_abstract: diag(2512, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_abstract_or_non_abstract_2512\", \"Overload signatures must all be abstract or non-abstract.\"),\r\n        Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: diag(2513, DiagnosticCategory.Error, \"Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513\", \"Abstract method '{0}' in class '{1}' cannot be accessed via super expression.\"),\r\n        Classes_containing_abstract_methods_must_be_marked_abstract: diag(2514, DiagnosticCategory.Error, \"Classes_containing_abstract_methods_must_be_marked_abstract_2514\", \"Classes containing abstract methods must be marked abstract.\"),\r\n        Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: diag(2515, DiagnosticCategory.Error, \"Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515\", \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.\"),\r\n        All_declarations_of_an_abstract_method_must_be_consecutive: diag(2516, DiagnosticCategory.Error, \"All_declarations_of_an_abstract_method_must_be_consecutive_2516\", \"All declarations of an abstract method must be consecutive.\"),\r\n        Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: diag(2517, DiagnosticCategory.Error, \"Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517\", \"Cannot assign an abstract constructor type to a non-abstract constructor type.\"),\r\n        A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: diag(2518, DiagnosticCategory.Error, \"A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518\", \"A 'this'-based type guard is not compatible with a parameter-based type guard.\"),\r\n        An_async_iterator_must_have_a_next_method: diag(2519, DiagnosticCategory.Error, \"An_async_iterator_must_have_a_next_method_2519\", \"An async iterator must have a 'next()' method.\"),\r\n        Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: diag(2520, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520\", \"Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.\"),\r\n        Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions: diag(2521, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions_2521\", \"Expression resolves to variable declaration '{0}' that compiler uses to support async functions.\"),\r\n        The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: diag(2522, DiagnosticCategory.Error, \"The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522\", \"The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.\"),\r\n        yield_expressions_cannot_be_used_in_a_parameter_initializer: diag(2523, DiagnosticCategory.Error, \"yield_expressions_cannot_be_used_in_a_parameter_initializer_2523\", \"'yield' expressions cannot be used in a parameter initializer.\"),\r\n        await_expressions_cannot_be_used_in_a_parameter_initializer: diag(2524, DiagnosticCategory.Error, \"await_expressions_cannot_be_used_in_a_parameter_initializer_2524\", \"'await' expressions cannot be used in a parameter initializer.\"),\r\n        Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: diag(2525, DiagnosticCategory.Error, \"Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525\", \"Initializer provides no value for this binding element and the binding element has no default value.\"),\r\n        A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: diag(2526, DiagnosticCategory.Error, \"A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526\", \"A 'this' type is available only in a non-static member of a class or interface.\"),\r\n        The_inferred_type_of_0_references_an_inaccessible_this_type_A_type_annotation_is_necessary: diag(2527, DiagnosticCategory.Error, \"The_inferred_type_of_0_references_an_inaccessible_this_type_A_type_annotation_is_necessary_2527\", \"The inferred type of '{0}' references an inaccessible 'this' type. A type annotation is necessary.\"),\r\n        A_module_cannot_have_multiple_default_exports: diag(2528, DiagnosticCategory.Error, \"A_module_cannot_have_multiple_default_exports_2528\", \"A module cannot have multiple default exports.\"),\r\n        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: diag(2529, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529\", \"Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.\"),\r\n        Property_0_is_incompatible_with_index_signature: diag(2530, DiagnosticCategory.Error, \"Property_0_is_incompatible_with_index_signature_2530\", \"Property '{0}' is incompatible with index signature.\"),\r\n        Object_is_possibly_null: diag(2531, DiagnosticCategory.Error, \"Object_is_possibly_null_2531\", \"Object is possibly 'null'.\"),\r\n        Object_is_possibly_undefined: diag(2532, DiagnosticCategory.Error, \"Object_is_possibly_undefined_2532\", \"Object is possibly 'undefined'.\"),\r\n        Object_is_possibly_null_or_undefined: diag(2533, DiagnosticCategory.Error, \"Object_is_possibly_null_or_undefined_2533\", \"Object is possibly 'null' or 'undefined'.\"),\r\n        A_function_returning_never_cannot_have_a_reachable_end_point: diag(2534, DiagnosticCategory.Error, \"A_function_returning_never_cannot_have_a_reachable_end_point_2534\", \"A function returning 'never' cannot have a reachable end point.\"),\r\n        Enum_type_0_has_members_with_initializers_that_are_not_literals: diag(2535, DiagnosticCategory.Error, \"Enum_type_0_has_members_with_initializers_that_are_not_literals_2535\", \"Enum type '{0}' has members with initializers that are not literals.\"),\r\n        Type_0_cannot_be_used_to_index_type_1: diag(2536, DiagnosticCategory.Error, \"Type_0_cannot_be_used_to_index_type_1_2536\", \"Type '{0}' cannot be used to index type '{1}'.\"),\r\n        Type_0_has_no_matching_index_signature_for_type_1: diag(2537, DiagnosticCategory.Error, \"Type_0_has_no_matching_index_signature_for_type_1_2537\", \"Type '{0}' has no matching index signature for type '{1}'.\"),\r\n        Type_0_cannot_be_used_as_an_index_type: diag(2538, DiagnosticCategory.Error, \"Type_0_cannot_be_used_as_an_index_type_2538\", \"Type '{0}' cannot be used as an index type.\"),\r\n        Cannot_assign_to_0_because_it_is_not_a_variable: diag(2539, DiagnosticCategory.Error, \"Cannot_assign_to_0_because_it_is_not_a_variable_2539\", \"Cannot assign to '{0}' because it is not a variable.\"),\r\n        Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property: diag(2540, DiagnosticCategory.Error, \"Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property_2540\", \"Cannot assign to '{0}' because it is a constant or a read-only property.\"),\r\n        The_target_of_an_assignment_must_be_a_variable_or_a_property_access: diag(2541, DiagnosticCategory.Error, \"The_target_of_an_assignment_must_be_a_variable_or_a_property_access_2541\", \"The target of an assignment must be a variable or a property access.\"),\r\n        Index_signature_in_type_0_only_permits_reading: diag(2542, DiagnosticCategory.Error, \"Index_signature_in_type_0_only_permits_reading_2542\", \"Index signature in type '{0}' only permits reading.\"),\r\n        Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: diag(2543, DiagnosticCategory.Error, \"Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543\", \"Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.\"),\r\n        Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: diag(2544, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544\", \"Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.\"),\r\n        A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: diag(2545, DiagnosticCategory.Error, \"A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545\", \"A mixin class must have a constructor with a single rest parameter of type 'any[]'.\"),\r\n        Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1: diag(2546, DiagnosticCategory.Error, \"Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1_2546\", \"Property '{0}' has conflicting declarations and is inaccessible in type '{1}'.\"),\r\n        The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: diag(2547, DiagnosticCategory.Error, \"The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value__2547\", \"The type returned by the 'next()' method of an async iterator must be a promise for a type with a 'value' property.\"),\r\n        Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2548, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548\", \"Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2549, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549\", \"Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        Generic_type_instantiation_is_excessively_deep_and_possibly_infinite: diag(2550, DiagnosticCategory.Error, \"Generic_type_instantiation_is_excessively_deep_and_possibly_infinite_2550\", \"Generic type instantiation is excessively deep and possibly infinite.\"),\r\n        Property_0_does_not_exist_on_type_1_Did_you_mean_2: diag(2551, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551\", \"Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?\"),\r\n        Cannot_find_name_0_Did_you_mean_1: diag(2552, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_1_2552\", \"Cannot find name '{0}'. Did you mean '{1}'?\"),\r\n        Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: diag(2553, DiagnosticCategory.Error, \"Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553\", \"Computed values are not permitted in an enum with string valued members.\"),\r\n        Expected_0_arguments_but_got_1: diag(2554, DiagnosticCategory.Error, \"Expected_0_arguments_but_got_1_2554\", \"Expected {0} arguments, but got {1}.\"),\r\n        Expected_at_least_0_arguments_but_got_1: diag(2555, DiagnosticCategory.Error, \"Expected_at_least_0_arguments_but_got_1_2555\", \"Expected at least {0} arguments, but got {1}.\"),\r\n        Expected_0_arguments_but_got_a_minimum_of_1: diag(2556, DiagnosticCategory.Error, \"Expected_0_arguments_but_got_a_minimum_of_1_2556\", \"Expected {0} arguments, but got a minimum of {1}.\"),\r\n        Expected_at_least_0_arguments_but_got_a_minimum_of_1: diag(2557, DiagnosticCategory.Error, \"Expected_at_least_0_arguments_but_got_a_minimum_of_1_2557\", \"Expected at least {0} arguments, but got a minimum of {1}.\"),\r\n        Expected_0_type_arguments_but_got_1: diag(2558, DiagnosticCategory.Error, \"Expected_0_type_arguments_but_got_1_2558\", \"Expected {0} type arguments, but got {1}.\"),\r\n        Type_0_has_no_properties_in_common_with_type_1: diag(2559, DiagnosticCategory.Error, \"Type_0_has_no_properties_in_common_with_type_1_2559\", \"Type '{0}' has no properties in common with type '{1}'.\"),\r\n        Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: diag(2560, DiagnosticCategory.Error, \"Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560\", \"Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?\"),\r\n        Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: diag(2561, DiagnosticCategory.Error, \"Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561\", \"Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?\"),\r\n        Base_class_expressions_cannot_reference_class_type_parameters: diag(2562, DiagnosticCategory.Error, \"Base_class_expressions_cannot_reference_class_type_parameters_2562\", \"Base class expressions cannot reference class type parameters.\"),\r\n        The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: diag(2563, DiagnosticCategory.Error, \"The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563\", \"The containing function or module body is too large for control flow analysis.\"),\r\n        JSX_element_attributes_type_0_may_not_be_a_union_type: diag(2600, DiagnosticCategory.Error, \"JSX_element_attributes_type_0_may_not_be_a_union_type_2600\", \"JSX element attributes type '{0}' may not be a union type.\"),\r\n        The_return_type_of_a_JSX_element_constructor_must_return_an_object_type: diag(2601, DiagnosticCategory.Error, \"The_return_type_of_a_JSX_element_constructor_must_return_an_object_type_2601\", \"The return type of a JSX element constructor must return an object type.\"),\r\n        JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: diag(2602, DiagnosticCategory.Error, \"JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602\", \"JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.\"),\r\n        Property_0_in_type_1_is_not_assignable_to_type_2: diag(2603, DiagnosticCategory.Error, \"Property_0_in_type_1_is_not_assignable_to_type_2_2603\", \"Property '{0}' in type '{1}' is not assignable to type '{2}'.\"),\r\n        JSX_element_type_0_does_not_have_any_construct_or_call_signatures: diag(2604, DiagnosticCategory.Error, \"JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604\", \"JSX element type '{0}' does not have any construct or call signatures.\"),\r\n        JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements: diag(2605, DiagnosticCategory.Error, \"JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements_2605\", \"JSX element type '{0}' is not a constructor function for JSX elements.\"),\r\n        Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: diag(2606, DiagnosticCategory.Error, \"Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606\", \"Property '{0}' of JSX spread attribute is not assignable to target property.\"),\r\n        JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: diag(2607, DiagnosticCategory.Error, \"JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607\", \"JSX element class does not support attributes because it does not have a '{0}' property.\"),\r\n        The_global_type_JSX_0_may_not_have_more_than_one_property: diag(2608, DiagnosticCategory.Error, \"The_global_type_JSX_0_may_not_have_more_than_one_property_2608\", \"The global type 'JSX.{0}' may not have more than one property.\"),\r\n        JSX_spread_child_must_be_an_array_type: diag(2609, DiagnosticCategory.Error, \"JSX_spread_child_must_be_an_array_type_2609\", \"JSX spread child must be an array type.\"),\r\n        Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: diag(2649, DiagnosticCategory.Error, \"Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649\", \"Cannot augment module '{0}' with value exports because it resolves to a non-module entity.\"),\r\n        A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: diag(2651, DiagnosticCategory.Error, \"A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651\", \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\"),\r\n        Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: diag(2652, DiagnosticCategory.Error, \"Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652\", \"Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.\"),\r\n        Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: diag(2653, DiagnosticCategory.Error, \"Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653\", \"Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.\"),\r\n        Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_package_author_to_update_the_package_definition: diag(2654, DiagnosticCategory.Error, \"Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_pack_2654\", \"Exported external package typings file cannot contain tripleslash references. Please contact the package author to update the package definition.\"),\r\n        Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_the_package_definition: diag(2656, DiagnosticCategory.Error, \"Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_2656\", \"Exported external package typings file '{0}' is not a module. Please contact the package author to update the package definition.\"),\r\n        JSX_expressions_must_have_one_parent_element: diag(2657, DiagnosticCategory.Error, \"JSX_expressions_must_have_one_parent_element_2657\", \"JSX expressions must have one parent element.\"),\r\n        Type_0_provides_no_match_for_the_signature_1: diag(2658, DiagnosticCategory.Error, \"Type_0_provides_no_match_for_the_signature_1_2658\", \"Type '{0}' provides no match for the signature '{1}'.\"),\r\n        super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: diag(2659, DiagnosticCategory.Error, \"super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659\", \"'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.\"),\r\n        super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: diag(2660, DiagnosticCategory.Error, \"super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660\", \"'super' can only be referenced in members of derived classes or object literal expressions.\"),\r\n        Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: diag(2661, DiagnosticCategory.Error, \"Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661\", \"Cannot export '{0}'. Only local declarations can be exported from a module.\"),\r\n        Cannot_find_name_0_Did_you_mean_the_static_member_1_0: diag(2662, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662\", \"Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?\"),\r\n        Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: diag(2663, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663\", \"Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?\"),\r\n        Invalid_module_name_in_augmentation_module_0_cannot_be_found: diag(2664, DiagnosticCategory.Error, \"Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664\", \"Invalid module name in augmentation, module '{0}' cannot be found.\"),\r\n        Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: diag(2665, DiagnosticCategory.Error, \"Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665\", \"Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.\"),\r\n        Exports_and_export_assignments_are_not_permitted_in_module_augmentations: diag(2666, DiagnosticCategory.Error, \"Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666\", \"Exports and export assignments are not permitted in module augmentations.\"),\r\n        Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: diag(2667, DiagnosticCategory.Error, \"Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667\", \"Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.\"),\r\n        export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: diag(2668, DiagnosticCategory.Error, \"export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668\", \"'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.\"),\r\n        Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: diag(2669, DiagnosticCategory.Error, \"Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669\", \"Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.\"),\r\n        Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: diag(2670, DiagnosticCategory.Error, \"Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670\", \"Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.\"),\r\n        Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: diag(2671, DiagnosticCategory.Error, \"Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671\", \"Cannot augment module '{0}' because it resolves to a non-module entity.\"),\r\n        Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: diag(2672, DiagnosticCategory.Error, \"Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672\", \"Cannot assign a '{0}' constructor type to a '{1}' constructor type.\"),\r\n        Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: diag(2673, DiagnosticCategory.Error, \"Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673\", \"Constructor of class '{0}' is private and only accessible within the class declaration.\"),\r\n        Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: diag(2674, DiagnosticCategory.Error, \"Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674\", \"Constructor of class '{0}' is protected and only accessible within the class declaration.\"),\r\n        Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: diag(2675, DiagnosticCategory.Error, \"Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675\", \"Cannot extend a class '{0}'. Class constructor is marked as private.\"),\r\n        Accessors_must_both_be_abstract_or_non_abstract: diag(2676, DiagnosticCategory.Error, \"Accessors_must_both_be_abstract_or_non_abstract_2676\", \"Accessors must both be abstract or non-abstract.\"),\r\n        A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: diag(2677, DiagnosticCategory.Error, \"A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677\", \"A type predicate's type must be assignable to its parameter's type.\"),\r\n        Type_0_is_not_comparable_to_type_1: diag(2678, DiagnosticCategory.Error, \"Type_0_is_not_comparable_to_type_1_2678\", \"Type '{0}' is not comparable to type '{1}'.\"),\r\n        A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: diag(2679, DiagnosticCategory.Error, \"A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679\", \"A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.\"),\r\n        A_0_parameter_must_be_the_first_parameter: diag(2680, DiagnosticCategory.Error, \"A_0_parameter_must_be_the_first_parameter_2680\", \"A '{0}' parameter must be the first parameter.\"),\r\n        A_constructor_cannot_have_a_this_parameter: diag(2681, DiagnosticCategory.Error, \"A_constructor_cannot_have_a_this_parameter_2681\", \"A constructor cannot have a 'this' parameter.\"),\r\n        get_and_set_accessor_must_have_the_same_this_type: diag(2682, DiagnosticCategory.Error, \"get_and_set_accessor_must_have_the_same_this_type_2682\", \"'get' and 'set' accessor must have the same 'this' type.\"),\r\n        this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: diag(2683, DiagnosticCategory.Error, \"this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683\", \"'this' implicitly has type 'any' because it does not have a type annotation.\"),\r\n        The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: diag(2684, DiagnosticCategory.Error, \"The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684\", \"The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.\"),\r\n        The_this_types_of_each_signature_are_incompatible: diag(2685, DiagnosticCategory.Error, \"The_this_types_of_each_signature_are_incompatible_2685\", \"The 'this' types of each signature are incompatible.\"),\r\n        _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: diag(2686, DiagnosticCategory.Error, \"_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686\", \"'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.\"),\r\n        All_declarations_of_0_must_have_identical_modifiers: diag(2687, DiagnosticCategory.Error, \"All_declarations_of_0_must_have_identical_modifiers_2687\", \"All declarations of '{0}' must have identical modifiers.\"),\r\n        Cannot_find_type_definition_file_for_0: diag(2688, DiagnosticCategory.Error, \"Cannot_find_type_definition_file_for_0_2688\", \"Cannot find type definition file for '{0}'.\"),\r\n        Cannot_extend_an_interface_0_Did_you_mean_implements: diag(2689, DiagnosticCategory.Error, \"Cannot_extend_an_interface_0_Did_you_mean_implements_2689\", \"Cannot extend an interface '{0}'. Did you mean 'implements'?\"),\r\n        An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead: diag(2691, DiagnosticCategory.Error, \"An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691\", \"An import path cannot end with a '{0}' extension. Consider importing '{1}' instead.\"),\r\n        _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: diag(2692, DiagnosticCategory.Error, \"_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692\", \"'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.\"),\r\n        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: diag(2693, DiagnosticCategory.Error, \"_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693\", \"'{0}' only refers to a type, but is being used as a value here.\"),\r\n        Namespace_0_has_no_exported_member_1: diag(2694, DiagnosticCategory.Error, \"Namespace_0_has_no_exported_member_1_2694\", \"Namespace '{0}' has no exported member '{1}'.\"),\r\n        Left_side_of_comma_operator_is_unused_and_has_no_side_effects: diag(2695, DiagnosticCategory.Error, \"Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695\", \"Left side of comma operator is unused and has no side effects.\"),\r\n        The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: diag(2696, DiagnosticCategory.Error, \"The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696\", \"The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?\"),\r\n        An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2697, DiagnosticCategory.Error, \"An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697\", \"An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.\"),\r\n        Spread_types_may_only_be_created_from_object_types: diag(2698, DiagnosticCategory.Error, \"Spread_types_may_only_be_created_from_object_types_2698\", \"Spread types may only be created from object types.\"),\r\n        Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: diag(2699, DiagnosticCategory.Error, \"Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699\", \"Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'.\"),\r\n        Rest_types_may_only_be_created_from_object_types: diag(2700, DiagnosticCategory.Error, \"Rest_types_may_only_be_created_from_object_types_2700\", \"Rest types may only be created from object types.\"),\r\n        The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: diag(2701, DiagnosticCategory.Error, \"The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701\", \"The target of an object rest assignment must be a variable or a property access.\"),\r\n        _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: diag(2702, DiagnosticCategory.Error, \"_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702\", \"'{0}' only refers to a type, but is being used as a namespace here.\"),\r\n        The_operand_of_a_delete_operator_must_be_a_property_reference: diag(2703, DiagnosticCategory.Error, \"The_operand_of_a_delete_operator_must_be_a_property_reference_2703\", \"The operand of a delete operator must be a property reference.\"),\r\n        The_operand_of_a_delete_operator_cannot_be_a_read_only_property: diag(2704, DiagnosticCategory.Error, \"The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704\", \"The operand of a delete operator cannot be a read-only property.\"),\r\n        An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2705, DiagnosticCategory.Error, \"An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705\", \"An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.\"),\r\n        Required_type_parameters_may_not_follow_optional_type_parameters: diag(2706, DiagnosticCategory.Error, \"Required_type_parameters_may_not_follow_optional_type_parameters_2706\", \"Required type parameters may not follow optional type parameters.\"),\r\n        Generic_type_0_requires_between_1_and_2_type_arguments: diag(2707, DiagnosticCategory.Error, \"Generic_type_0_requires_between_1_and_2_type_arguments_2707\", \"Generic type '{0}' requires between {1} and {2} type arguments.\"),\r\n        Cannot_use_namespace_0_as_a_value: diag(2708, DiagnosticCategory.Error, \"Cannot_use_namespace_0_as_a_value_2708\", \"Cannot use namespace '{0}' as a value.\"),\r\n        Cannot_use_namespace_0_as_a_type: diag(2709, DiagnosticCategory.Error, \"Cannot_use_namespace_0_as_a_type_2709\", \"Cannot use namespace '{0}' as a type.\"),\r\n        _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: diag(2710, DiagnosticCategory.Error, \"_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710\", \"'{0}' are specified twice. The attribute named '{0}' will be overwritten.\"),\r\n        A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2711, DiagnosticCategory.Error, \"A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711\", \"A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.\"),\r\n        A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2712, DiagnosticCategory.Error, \"A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712\", \"A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.\"),\r\n        Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: diag(2713, DiagnosticCategory.Error, \"Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713\", \"Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\\\"{1}\\\"]'?\"),\r\n        The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: diag(2714, DiagnosticCategory.Error, \"The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714\", \"The expression of an export assignment must be an identifier or qualified name in an ambient context.\"),\r\n        Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: diag(2715, DiagnosticCategory.Error, \"Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715\", \"Abstract property '{0}' in class '{1}' cannot be accessed in the constructor.\"),\r\n        Type_parameter_0_has_a_circular_default: diag(2716, DiagnosticCategory.Error, \"Type_parameter_0_has_a_circular_default_2716\", \"Type parameter '{0}' has a circular default.\"),\r\n        Import_declaration_0_is_using_private_name_1: diag(4000, DiagnosticCategory.Error, \"Import_declaration_0_is_using_private_name_1_4000\", \"Import declaration '{0}' is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: diag(4002, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002\", \"Type parameter '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: diag(4004, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004\", \"Type parameter '{0}' of exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4006, DiagnosticCategory.Error, \"Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006\", \"Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4008, DiagnosticCategory.Error, \"Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008\", \"Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4010, DiagnosticCategory.Error, \"Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010\", \"Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4012, DiagnosticCategory.Error, \"Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012\", \"Type parameter '{0}' of public method from exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4014, DiagnosticCategory.Error, \"Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014\", \"Type parameter '{0}' of method from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4016, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016\", \"Type parameter '{0}' of exported function has or is using private name '{1}'.\"),\r\n        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4019, DiagnosticCategory.Error, \"Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019\", \"Implements clause of exported class '{0}' has or is using private name '{1}'.\"),\r\n        extends_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4020, DiagnosticCategory.Error, \"extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020\", \"'extends' clause of exported class '{0}' has or is using private name '{1}'.\"),\r\n        extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: diag(4022, DiagnosticCategory.Error, \"extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022\", \"'extends' clause of exported interface '{0}' has or is using private name '{1}'.\"),\r\n        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4023, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023\", \"Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: diag(4024, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024\", \"Exported variable '{0}' has or is using name '{1}' from private module '{2}'.\"),\r\n        Exported_variable_0_has_or_is_using_private_name_1: diag(4025, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_private_name_1_4025\", \"Exported variable '{0}' has or is using private name '{1}'.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4026, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026\", \"Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4027, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027\", \"Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4028, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028\", \"Public static property '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4029, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029\", \"Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4030, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030\", \"Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4031, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031\", \"Public property '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4032, DiagnosticCategory.Error, \"Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032\", \"Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Property_0_of_exported_interface_has_or_is_using_private_name_1: diag(4033, DiagnosticCategory.Error, \"Property_0_of_exported_interface_has_or_is_using_private_name_1_4033\", \"Property '{0}' of exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4034, DiagnosticCategory.Error, \"Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_4034\", \"Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: diag(4035, DiagnosticCategory.Error, \"Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1_4035\", \"Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4036, DiagnosticCategory.Error, \"Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_4036\", \"Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: diag(4037, DiagnosticCategory.Error, \"Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1_4037\", \"Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.\"),\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4038, DiagnosticCategory.Error, \"Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_externa_4038\", \"Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4039, DiagnosticCategory.Error, \"Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_4039\", \"Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: diag(4040, DiagnosticCategory.Error, \"Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0_4040\", \"Return type of public static property getter from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4041, DiagnosticCategory.Error, \"Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_modul_4041\", \"Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4042, DiagnosticCategory.Error, \"Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_4042\", \"Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: diag(4043, DiagnosticCategory.Error, \"Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0_4043\", \"Return type of public property getter from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4044, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044\", \"Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4045, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045\", \"Return type of constructor signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4046, DiagnosticCategory.Error, \"Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046\", \"Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4047, DiagnosticCategory.Error, \"Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047\", \"Return type of call signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4048, DiagnosticCategory.Error, \"Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048\", \"Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4049, DiagnosticCategory.Error, \"Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049\", \"Return type of index signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4050, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050\", \"Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4051, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051\", \"Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: diag(4052, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052\", \"Return type of public static method from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4053, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053\", \"Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4054, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054\", \"Return type of public method from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: diag(4055, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055\", \"Return type of public method from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4056, DiagnosticCategory.Error, \"Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056\", \"Return type of method from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: diag(4057, DiagnosticCategory.Error, \"Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057\", \"Return type of method from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4058, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058\", \"Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: diag(4059, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059\", \"Return type of exported function has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_exported_function_has_or_is_using_private_name_0: diag(4060, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_private_name_0_4060\", \"Return type of exported function has or is using private name '{0}'.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4061, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061\", \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4062, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062\", \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: diag(4063, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063\", \"Parameter '{0}' of constructor from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4064, DiagnosticCategory.Error, \"Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064\", \"Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4065, DiagnosticCategory.Error, \"Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065\", \"Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4066, DiagnosticCategory.Error, \"Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066\", \"Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4067, DiagnosticCategory.Error, \"Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067\", \"Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4068, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068\", \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4069, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069\", \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4070, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070\", \"Parameter '{0}' of public static method from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4071, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071\", \"Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4072, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072\", \"Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4073, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073\", \"Parameter '{0}' of public method from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4074, DiagnosticCategory.Error, \"Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074\", \"Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4075, DiagnosticCategory.Error, \"Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075\", \"Parameter '{0}' of method from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4076, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076\", \"Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: diag(4077, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077\", \"Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4078, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078\", \"Parameter '{0}' of exported function has or is using private name '{1}'.\"),\r\n        Exported_type_alias_0_has_or_is_using_private_name_1: diag(4081, DiagnosticCategory.Error, \"Exported_type_alias_0_has_or_is_using_private_name_1_4081\", \"Exported type alias '{0}' has or is using private name '{1}'.\"),\r\n        Default_export_of_the_module_has_or_is_using_private_name_0: diag(4082, DiagnosticCategory.Error, \"Default_export_of_the_module_has_or_is_using_private_name_0_4082\", \"Default export of the module has or is using private name '{0}'.\"),\r\n        Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: diag(4083, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083\", \"Type parameter '{0}' of exported type alias has or is using private name '{1}'.\"),\r\n        Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: diag(4090, DiagnosticCategory.Message, \"Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090\", \"Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.\"),\r\n        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4091, DiagnosticCategory.Error, \"Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091\", \"Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4092, DiagnosticCategory.Error, \"Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092\", \"Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.\"),\r\n        Property_0_of_exported_class_expression_may_not_be_private_or_protected: diag(4094, DiagnosticCategory.Error, \"Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094\", \"Property '{0}' of exported class expression may not be private or protected.\"),\r\n        The_current_host_does_not_support_the_0_option: diag(5001, DiagnosticCategory.Error, \"The_current_host_does_not_support_the_0_option_5001\", \"The current host does not support the '{0}' option.\"),\r\n        Cannot_find_the_common_subdirectory_path_for_the_input_files: diag(5009, DiagnosticCategory.Error, \"Cannot_find_the_common_subdirectory_path_for_the_input_files_5009\", \"Cannot find the common subdirectory path for the input files.\"),\r\n        File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5010, DiagnosticCategory.Error, \"File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010\", \"File specification cannot end in a recursive directory wildcard ('**'): '{0}'.\"),\r\n        File_specification_cannot_contain_multiple_recursive_directory_wildcards_Asterisk_Asterisk_Colon_0: diag(5011, DiagnosticCategory.Error, \"File_specification_cannot_contain_multiple_recursive_directory_wildcards_Asterisk_Asterisk_Colon_0_5011\", \"File specification cannot contain multiple recursive directory wildcards ('**'): '{0}'.\"),\r\n        Cannot_read_file_0_Colon_1: diag(5012, DiagnosticCategory.Error, \"Cannot_read_file_0_Colon_1_5012\", \"Cannot read file '{0}': {1}.\"),\r\n        Failed_to_parse_file_0_Colon_1: diag(5014, DiagnosticCategory.Error, \"Failed_to_parse_file_0_Colon_1_5014\", \"Failed to parse file '{0}': {1}.\"),\r\n        Unknown_compiler_option_0: diag(5023, DiagnosticCategory.Error, \"Unknown_compiler_option_0_5023\", \"Unknown compiler option '{0}'.\"),\r\n        Compiler_option_0_requires_a_value_of_type_1: diag(5024, DiagnosticCategory.Error, \"Compiler_option_0_requires_a_value_of_type_1_5024\", \"Compiler option '{0}' requires a value of type {1}.\"),\r\n        Could_not_write_file_0_Colon_1: diag(5033, DiagnosticCategory.Error, \"Could_not_write_file_0_Colon_1_5033\", \"Could not write file '{0}': {1}.\"),\r\n        Option_project_cannot_be_mixed_with_source_files_on_a_command_line: diag(5042, DiagnosticCategory.Error, \"Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042\", \"Option 'project' cannot be mixed with source files on a command line.\"),\r\n        Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: diag(5047, DiagnosticCategory.Error, \"Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047\", \"Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.\"),\r\n        Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: diag(5051, DiagnosticCategory.Error, \"Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051\", \"Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.\"),\r\n        Option_0_cannot_be_specified_without_specifying_option_1: diag(5052, DiagnosticCategory.Error, \"Option_0_cannot_be_specified_without_specifying_option_1_5052\", \"Option '{0}' cannot be specified without specifying option '{1}'.\"),\r\n        Option_0_cannot_be_specified_with_option_1: diag(5053, DiagnosticCategory.Error, \"Option_0_cannot_be_specified_with_option_1_5053\", \"Option '{0}' cannot be specified with option '{1}'.\"),\r\n        A_tsconfig_json_file_is_already_defined_at_Colon_0: diag(5054, DiagnosticCategory.Error, \"A_tsconfig_json_file_is_already_defined_at_Colon_0_5054\", \"A 'tsconfig.json' file is already defined at: '{0}'.\"),\r\n        Cannot_write_file_0_because_it_would_overwrite_input_file: diag(5055, DiagnosticCategory.Error, \"Cannot_write_file_0_because_it_would_overwrite_input_file_5055\", \"Cannot write file '{0}' because it would overwrite input file.\"),\r\n        Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: diag(5056, DiagnosticCategory.Error, \"Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056\", \"Cannot write file '{0}' because it would be overwritten by multiple input files.\"),\r\n        Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: diag(5057, DiagnosticCategory.Error, \"Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057\", \"Cannot find a tsconfig.json file at the specified directory: '{0}'.\"),\r\n        The_specified_path_does_not_exist_Colon_0: diag(5058, DiagnosticCategory.Error, \"The_specified_path_does_not_exist_Colon_0_5058\", \"The specified path does not exist: '{0}'.\"),\r\n        Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: diag(5059, DiagnosticCategory.Error, \"Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059\", \"Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.\"),\r\n        Option_paths_cannot_be_used_without_specifying_baseUrl_option: diag(5060, DiagnosticCategory.Error, \"Option_paths_cannot_be_used_without_specifying_baseUrl_option_5060\", \"Option 'paths' cannot be used without specifying '--baseUrl' option.\"),\r\n        Pattern_0_can_have_at_most_one_Asterisk_character: diag(5061, DiagnosticCategory.Error, \"Pattern_0_can_have_at_most_one_Asterisk_character_5061\", \"Pattern '{0}' can have at most one '*' character.\"),\r\n        Substitution_0_in_pattern_1_in_can_have_at_most_one_Asterisk_character: diag(5062, DiagnosticCategory.Error, \"Substitution_0_in_pattern_1_in_can_have_at_most_one_Asterisk_character_5062\", \"Substitution '{0}' in pattern '{1}' in can have at most one '*' character.\"),\r\n        Substitutions_for_pattern_0_should_be_an_array: diag(5063, DiagnosticCategory.Error, \"Substitutions_for_pattern_0_should_be_an_array_5063\", \"Substitutions for pattern '{0}' should be an array.\"),\r\n        Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: diag(5064, DiagnosticCategory.Error, \"Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064\", \"Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.\"),\r\n        File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5065, DiagnosticCategory.Error, \"File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065\", \"File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.\"),\r\n        Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: diag(5066, DiagnosticCategory.Error, \"Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066\", \"Substitutions for pattern '{0}' shouldn't be an empty array.\"),\r\n        Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(5067, DiagnosticCategory.Error, \"Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067\", \"Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.\"),\r\n        Concatenate_and_emit_output_to_single_file: diag(6001, DiagnosticCategory.Message, \"Concatenate_and_emit_output_to_single_file_6001\", \"Concatenate and emit output to single file.\"),\r\n        Generates_corresponding_d_ts_file: diag(6002, DiagnosticCategory.Message, \"Generates_corresponding_d_ts_file_6002\", \"Generates corresponding '.d.ts' file.\"),\r\n        Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: diag(6003, DiagnosticCategory.Message, \"Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6003\", \"Specify the location where debugger should locate map files instead of generated locations.\"),\r\n        Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: diag(6004, DiagnosticCategory.Message, \"Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004\", \"Specify the location where debugger should locate TypeScript files instead of source locations.\"),\r\n        Watch_input_files: diag(6005, DiagnosticCategory.Message, \"Watch_input_files_6005\", \"Watch input files.\"),\r\n        Redirect_output_structure_to_the_directory: diag(6006, DiagnosticCategory.Message, \"Redirect_output_structure_to_the_directory_6006\", \"Redirect output structure to the directory.\"),\r\n        Do_not_erase_const_enum_declarations_in_generated_code: diag(6007, DiagnosticCategory.Message, \"Do_not_erase_const_enum_declarations_in_generated_code_6007\", \"Do not erase const enum declarations in generated code.\"),\r\n        Do_not_emit_outputs_if_any_errors_were_reported: diag(6008, DiagnosticCategory.Message, \"Do_not_emit_outputs_if_any_errors_were_reported_6008\", \"Do not emit outputs if any errors were reported.\"),\r\n        Do_not_emit_comments_to_output: diag(6009, DiagnosticCategory.Message, \"Do_not_emit_comments_to_output_6009\", \"Do not emit comments to output.\"),\r\n        Do_not_emit_outputs: diag(6010, DiagnosticCategory.Message, \"Do_not_emit_outputs_6010\", \"Do not emit outputs.\"),\r\n        Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: diag(6011, DiagnosticCategory.Message, \"Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011\", \"Allow default imports from modules with no default export. This does not affect code emit, just typechecking.\"),\r\n        Skip_type_checking_of_declaration_files: diag(6012, DiagnosticCategory.Message, \"Skip_type_checking_of_declaration_files_6012\", \"Skip type checking of declaration files.\"),\r\n        Do_not_resolve_the_real_path_of_symlinks: diag(6013, DiagnosticCategory.Message, \"Do_not_resolve_the_real_path_of_symlinks_6013\", \"Do not resolve the real path of symlinks.\"),\r\n        Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_or_ESNEXT: diag(6015, DiagnosticCategory.Message, \"Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_or_ESNEXT_6015\", \"Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'.\"),\r\n        Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext: diag(6016, DiagnosticCategory.Message, \"Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext_6016\", \"Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'.\"),\r\n        Print_this_message: diag(6017, DiagnosticCategory.Message, \"Print_this_message_6017\", \"Print this message.\"),\r\n        Print_the_compiler_s_version: diag(6019, DiagnosticCategory.Message, \"Print_the_compiler_s_version_6019\", \"Print the compiler's version.\"),\r\n        Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: diag(6020, DiagnosticCategory.Message, \"Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020\", \"Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.\"),\r\n        Syntax_Colon_0: diag(6023, DiagnosticCategory.Message, \"Syntax_Colon_0_6023\", \"Syntax: {0}\"),\r\n        options: diag(6024, DiagnosticCategory.Message, \"options_6024\", \"options\"),\r\n        file: diag(6025, DiagnosticCategory.Message, \"file_6025\", \"file\"),\r\n        Examples_Colon_0: diag(6026, DiagnosticCategory.Message, \"Examples_Colon_0_6026\", \"Examples: {0}\"),\r\n        Options_Colon: diag(6027, DiagnosticCategory.Message, \"Options_Colon_6027\", \"Options:\"),\r\n        Version_0: diag(6029, DiagnosticCategory.Message, \"Version_0_6029\", \"Version {0}\"),\r\n        Insert_command_line_options_and_files_from_a_file: diag(6030, DiagnosticCategory.Message, \"Insert_command_line_options_and_files_from_a_file_6030\", \"Insert command line options and files from a file.\"),\r\n        File_change_detected_Starting_incremental_compilation: diag(6032, DiagnosticCategory.Message, \"File_change_detected_Starting_incremental_compilation_6032\", \"File change detected. Starting incremental compilation...\"),\r\n        KIND: diag(6034, DiagnosticCategory.Message, \"KIND_6034\", \"KIND\"),\r\n        FILE: diag(6035, DiagnosticCategory.Message, \"FILE_6035\", \"FILE\"),\r\n        VERSION: diag(6036, DiagnosticCategory.Message, \"VERSION_6036\", \"VERSION\"),\r\n        LOCATION: diag(6037, DiagnosticCategory.Message, \"LOCATION_6037\", \"LOCATION\"),\r\n        DIRECTORY: diag(6038, DiagnosticCategory.Message, \"DIRECTORY_6038\", \"DIRECTORY\"),\r\n        STRATEGY: diag(6039, DiagnosticCategory.Message, \"STRATEGY_6039\", \"STRATEGY\"),\r\n        FILE_OR_DIRECTORY: diag(6040, DiagnosticCategory.Message, \"FILE_OR_DIRECTORY_6040\", \"FILE OR DIRECTORY\"),\r\n        Compilation_complete_Watching_for_file_changes: diag(6042, DiagnosticCategory.Message, \"Compilation_complete_Watching_for_file_changes_6042\", \"Compilation complete. Watching for file changes.\"),\r\n        Generates_corresponding_map_file: diag(6043, DiagnosticCategory.Message, \"Generates_corresponding_map_file_6043\", \"Generates corresponding '.map' file.\"),\r\n        Compiler_option_0_expects_an_argument: diag(6044, DiagnosticCategory.Error, \"Compiler_option_0_expects_an_argument_6044\", \"Compiler option '{0}' expects an argument.\"),\r\n        Unterminated_quoted_string_in_response_file_0: diag(6045, DiagnosticCategory.Error, \"Unterminated_quoted_string_in_response_file_0_6045\", \"Unterminated quoted string in response file '{0}'.\"),\r\n        Argument_for_0_option_must_be_Colon_1: diag(6046, DiagnosticCategory.Error, \"Argument_for_0_option_must_be_Colon_1_6046\", \"Argument for '{0}' option must be: {1}.\"),\r\n        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: diag(6048, DiagnosticCategory.Error, \"Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048\", \"Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.\"),\r\n        Unsupported_locale_0: diag(6049, DiagnosticCategory.Error, \"Unsupported_locale_0_6049\", \"Unsupported locale '{0}'.\"),\r\n        Unable_to_open_file_0: diag(6050, DiagnosticCategory.Error, \"Unable_to_open_file_0_6050\", \"Unable to open file '{0}'.\"),\r\n        Corrupted_locale_file_0: diag(6051, DiagnosticCategory.Error, \"Corrupted_locale_file_0_6051\", \"Corrupted locale file {0}.\"),\r\n        Raise_error_on_expressions_and_declarations_with_an_implied_any_type: diag(6052, DiagnosticCategory.Message, \"Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052\", \"Raise error on expressions and declarations with an implied 'any' type.\"),\r\n        File_0_not_found: diag(6053, DiagnosticCategory.Error, \"File_0_not_found_6053\", \"File '{0}' not found.\"),\r\n        File_0_has_unsupported_extension_The_only_supported_extensions_are_1: diag(6054, DiagnosticCategory.Error, \"File_0_has_unsupported_extension_The_only_supported_extensions_are_1_6054\", \"File '{0}' has unsupported extension. The only supported extensions are {1}.\"),\r\n        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: diag(6055, DiagnosticCategory.Message, \"Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055\", \"Suppress noImplicitAny errors for indexing objects lacking index signatures.\"),\r\n        Do_not_emit_declarations_for_code_that_has_an_internal_annotation: diag(6056, DiagnosticCategory.Message, \"Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056\", \"Do not emit declarations for code that has an '@internal' annotation.\"),\r\n        Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: diag(6058, DiagnosticCategory.Message, \"Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058\", \"Specify the root directory of input files. Use to control the output directory structure with --outDir.\"),\r\n        File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: diag(6059, DiagnosticCategory.Error, \"File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059\", \"File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.\"),\r\n        Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: diag(6060, DiagnosticCategory.Message, \"Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060\", \"Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).\"),\r\n        NEWLINE: diag(6061, DiagnosticCategory.Message, \"NEWLINE_6061\", \"NEWLINE\"),\r\n        Option_0_can_only_be_specified_in_tsconfig_json_file: diag(6064, DiagnosticCategory.Error, \"Option_0_can_only_be_specified_in_tsconfig_json_file_6064\", \"Option '{0}' can only be specified in 'tsconfig.json' file.\"),\r\n        Enables_experimental_support_for_ES7_decorators: diag(6065, DiagnosticCategory.Message, \"Enables_experimental_support_for_ES7_decorators_6065\", \"Enables experimental support for ES7 decorators.\"),\r\n        Enables_experimental_support_for_emitting_type_metadata_for_decorators: diag(6066, DiagnosticCategory.Message, \"Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066\", \"Enables experimental support for emitting type metadata for decorators.\"),\r\n        Enables_experimental_support_for_ES7_async_functions: diag(6068, DiagnosticCategory.Message, \"Enables_experimental_support_for_ES7_async_functions_6068\", \"Enables experimental support for ES7 async functions.\"),\r\n        Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6: diag(6069, DiagnosticCategory.Message, \"Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069\", \"Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6).\"),\r\n        Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: diag(6070, DiagnosticCategory.Message, \"Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070\", \"Initializes a TypeScript project and creates a tsconfig.json file.\"),\r\n        Successfully_created_a_tsconfig_json_file: diag(6071, DiagnosticCategory.Message, \"Successfully_created_a_tsconfig_json_file_6071\", \"Successfully created a tsconfig.json file.\"),\r\n        Suppress_excess_property_checks_for_object_literals: diag(6072, DiagnosticCategory.Message, \"Suppress_excess_property_checks_for_object_literals_6072\", \"Suppress excess property checks for object literals.\"),\r\n        Stylize_errors_and_messages_using_color_and_context_experimental: diag(6073, DiagnosticCategory.Message, \"Stylize_errors_and_messages_using_color_and_context_experimental_6073\", \"Stylize errors and messages using color and context (experimental).\"),\r\n        Do_not_report_errors_on_unused_labels: diag(6074, DiagnosticCategory.Message, \"Do_not_report_errors_on_unused_labels_6074\", \"Do not report errors on unused labels.\"),\r\n        Report_error_when_not_all_code_paths_in_function_return_a_value: diag(6075, DiagnosticCategory.Message, \"Report_error_when_not_all_code_paths_in_function_return_a_value_6075\", \"Report error when not all code paths in function return a value.\"),\r\n        Report_errors_for_fallthrough_cases_in_switch_statement: diag(6076, DiagnosticCategory.Message, \"Report_errors_for_fallthrough_cases_in_switch_statement_6076\", \"Report errors for fallthrough cases in switch statement.\"),\r\n        Do_not_report_errors_on_unreachable_code: diag(6077, DiagnosticCategory.Message, \"Do_not_report_errors_on_unreachable_code_6077\", \"Do not report errors on unreachable code.\"),\r\n        Disallow_inconsistently_cased_references_to_the_same_file: diag(6078, DiagnosticCategory.Message, \"Disallow_inconsistently_cased_references_to_the_same_file_6078\", \"Disallow inconsistently-cased references to the same file.\"),\r\n        Specify_library_files_to_be_included_in_the_compilation_Colon: diag(6079, DiagnosticCategory.Message, \"Specify_library_files_to_be_included_in_the_compilation_Colon_6079\", \"Specify library files to be included in the compilation: \"),\r\n        Specify_JSX_code_generation_Colon_preserve_react_native_or_react: diag(6080, DiagnosticCategory.Message, \"Specify_JSX_code_generation_Colon_preserve_react_native_or_react_6080\", \"Specify JSX code generation: 'preserve', 'react-native', or 'react'.\"),\r\n        File_0_has_an_unsupported_extension_so_skipping_it: diag(6081, DiagnosticCategory.Message, \"File_0_has_an_unsupported_extension_so_skipping_it_6081\", \"File '{0}' has an unsupported extension, so skipping it.\"),\r\n        Only_amd_and_system_modules_are_supported_alongside_0: diag(6082, DiagnosticCategory.Error, \"Only_amd_and_system_modules_are_supported_alongside_0_6082\", \"Only 'amd' and 'system' modules are supported alongside --{0}.\"),\r\n        Base_directory_to_resolve_non_absolute_module_names: diag(6083, DiagnosticCategory.Message, \"Base_directory_to_resolve_non_absolute_module_names_6083\", \"Base directory to resolve non-absolute module names.\"),\r\n        Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: diag(6084, DiagnosticCategory.Message, \"Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084\", \"[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit\"),\r\n        Enable_tracing_of_the_name_resolution_process: diag(6085, DiagnosticCategory.Message, \"Enable_tracing_of_the_name_resolution_process_6085\", \"Enable tracing of the name resolution process.\"),\r\n        Resolving_module_0_from_1: diag(6086, DiagnosticCategory.Message, \"Resolving_module_0_from_1_6086\", \"======== Resolving module '{0}' from '{1}'. ========\"),\r\n        Explicitly_specified_module_resolution_kind_Colon_0: diag(6087, DiagnosticCategory.Message, \"Explicitly_specified_module_resolution_kind_Colon_0_6087\", \"Explicitly specified module resolution kind: '{0}'.\"),\r\n        Module_resolution_kind_is_not_specified_using_0: diag(6088, DiagnosticCategory.Message, \"Module_resolution_kind_is_not_specified_using_0_6088\", \"Module resolution kind is not specified, using '{0}'.\"),\r\n        Module_name_0_was_successfully_resolved_to_1: diag(6089, DiagnosticCategory.Message, \"Module_name_0_was_successfully_resolved_to_1_6089\", \"======== Module name '{0}' was successfully resolved to '{1}'. ========\"),\r\n        Module_name_0_was_not_resolved: diag(6090, DiagnosticCategory.Message, \"Module_name_0_was_not_resolved_6090\", \"======== Module name '{0}' was not resolved. ========\"),\r\n        paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: diag(6091, DiagnosticCategory.Message, \"paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091\", \"'paths' option is specified, looking for a pattern to match module name '{0}'.\"),\r\n        Module_name_0_matched_pattern_1: diag(6092, DiagnosticCategory.Message, \"Module_name_0_matched_pattern_1_6092\", \"Module name '{0}', matched pattern '{1}'.\"),\r\n        Trying_substitution_0_candidate_module_location_Colon_1: diag(6093, DiagnosticCategory.Message, \"Trying_substitution_0_candidate_module_location_Colon_1_6093\", \"Trying substitution '{0}', candidate module location: '{1}'.\"),\r\n        Resolving_module_name_0_relative_to_base_url_1_2: diag(6094, DiagnosticCategory.Message, \"Resolving_module_name_0_relative_to_base_url_1_2_6094\", \"Resolving module name '{0}' relative to base url '{1}' - '{2}'.\"),\r\n        Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1: diag(6095, DiagnosticCategory.Message, \"Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095\", \"Loading module as file / folder, candidate module location '{0}', target file type '{1}'.\"),\r\n        File_0_does_not_exist: diag(6096, DiagnosticCategory.Message, \"File_0_does_not_exist_6096\", \"File '{0}' does not exist.\"),\r\n        File_0_exist_use_it_as_a_name_resolution_result: diag(6097, DiagnosticCategory.Message, \"File_0_exist_use_it_as_a_name_resolution_result_6097\", \"File '{0}' exist - use it as a name resolution result.\"),\r\n        Loading_module_0_from_node_modules_folder_target_file_type_1: diag(6098, DiagnosticCategory.Message, \"Loading_module_0_from_node_modules_folder_target_file_type_1_6098\", \"Loading module '{0}' from 'node_modules' folder, target file type '{1}'.\"),\r\n        Found_package_json_at_0: diag(6099, DiagnosticCategory.Message, \"Found_package_json_at_0_6099\", \"Found 'package.json' at '{0}'.\"),\r\n        package_json_does_not_have_a_0_field: diag(6100, DiagnosticCategory.Message, \"package_json_does_not_have_a_0_field_6100\", \"'package.json' does not have a '{0}' field.\"),\r\n        package_json_has_0_field_1_that_references_2: diag(6101, DiagnosticCategory.Message, \"package_json_has_0_field_1_that_references_2_6101\", \"'package.json' has '{0}' field '{1}' that references '{2}'.\"),\r\n        Allow_javascript_files_to_be_compiled: diag(6102, DiagnosticCategory.Message, \"Allow_javascript_files_to_be_compiled_6102\", \"Allow javascript files to be compiled.\"),\r\n        Option_0_should_have_array_of_strings_as_a_value: diag(6103, DiagnosticCategory.Error, \"Option_0_should_have_array_of_strings_as_a_value_6103\", \"Option '{0}' should have array of strings as a value.\"),\r\n        Checking_if_0_is_the_longest_matching_prefix_for_1_2: diag(6104, DiagnosticCategory.Message, \"Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104\", \"Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.\"),\r\n        Expected_type_of_0_field_in_package_json_to_be_string_got_1: diag(6105, DiagnosticCategory.Message, \"Expected_type_of_0_field_in_package_json_to_be_string_got_1_6105\", \"Expected type of '{0}' field in 'package.json' to be 'string', got '{1}'.\"),\r\n        baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: diag(6106, DiagnosticCategory.Message, \"baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106\", \"'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'.\"),\r\n        rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: diag(6107, DiagnosticCategory.Message, \"rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107\", \"'rootDirs' option is set, using it to resolve relative module name '{0}'.\"),\r\n        Longest_matching_prefix_for_0_is_1: diag(6108, DiagnosticCategory.Message, \"Longest_matching_prefix_for_0_is_1_6108\", \"Longest matching prefix for '{0}' is '{1}'.\"),\r\n        Loading_0_from_the_root_dir_1_candidate_location_2: diag(6109, DiagnosticCategory.Message, \"Loading_0_from_the_root_dir_1_candidate_location_2_6109\", \"Loading '{0}' from the root dir '{1}', candidate location '{2}'.\"),\r\n        Trying_other_entries_in_rootDirs: diag(6110, DiagnosticCategory.Message, \"Trying_other_entries_in_rootDirs_6110\", \"Trying other entries in 'rootDirs'.\"),\r\n        Module_resolution_using_rootDirs_has_failed: diag(6111, DiagnosticCategory.Message, \"Module_resolution_using_rootDirs_has_failed_6111\", \"Module resolution using 'rootDirs' has failed.\"),\r\n        Do_not_emit_use_strict_directives_in_module_output: diag(6112, DiagnosticCategory.Message, \"Do_not_emit_use_strict_directives_in_module_output_6112\", \"Do not emit 'use strict' directives in module output.\"),\r\n        Enable_strict_null_checks: diag(6113, DiagnosticCategory.Message, \"Enable_strict_null_checks_6113\", \"Enable strict null checks.\"),\r\n        Unknown_option_excludes_Did_you_mean_exclude: diag(6114, DiagnosticCategory.Error, \"Unknown_option_excludes_Did_you_mean_exclude_6114\", \"Unknown option 'excludes'. Did you mean 'exclude'?\"),\r\n        Raise_error_on_this_expressions_with_an_implied_any_type: diag(6115, DiagnosticCategory.Message, \"Raise_error_on_this_expressions_with_an_implied_any_type_6115\", \"Raise error on 'this' expressions with an implied 'any' type.\"),\r\n        Resolving_type_reference_directive_0_containing_file_1_root_directory_2: diag(6116, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116\", \"======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========\"),\r\n        Resolving_using_primary_search_paths: diag(6117, DiagnosticCategory.Message, \"Resolving_using_primary_search_paths_6117\", \"Resolving using primary search paths...\"),\r\n        Resolving_from_node_modules_folder: diag(6118, DiagnosticCategory.Message, \"Resolving_from_node_modules_folder_6118\", \"Resolving from node_modules folder...\"),\r\n        Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: diag(6119, DiagnosticCategory.Message, \"Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119\", \"======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========\"),\r\n        Type_reference_directive_0_was_not_resolved: diag(6120, DiagnosticCategory.Message, \"Type_reference_directive_0_was_not_resolved_6120\", \"======== Type reference directive '{0}' was not resolved. ========\"),\r\n        Resolving_with_primary_search_path_0: diag(6121, DiagnosticCategory.Message, \"Resolving_with_primary_search_path_0_6121\", \"Resolving with primary search path '{0}'.\"),\r\n        Root_directory_cannot_be_determined_skipping_primary_search_paths: diag(6122, DiagnosticCategory.Message, \"Root_directory_cannot_be_determined_skipping_primary_search_paths_6122\", \"Root directory cannot be determined, skipping primary search paths.\"),\r\n        Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: diag(6123, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123\", \"======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========\"),\r\n        Type_declaration_files_to_be_included_in_compilation: diag(6124, DiagnosticCategory.Message, \"Type_declaration_files_to_be_included_in_compilation_6124\", \"Type declaration files to be included in compilation.\"),\r\n        Looking_up_in_node_modules_folder_initial_location_0: diag(6125, DiagnosticCategory.Message, \"Looking_up_in_node_modules_folder_initial_location_0_6125\", \"Looking up in 'node_modules' folder, initial location '{0}'.\"),\r\n        Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: diag(6126, DiagnosticCategory.Message, \"Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126\", \"Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.\"),\r\n        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: diag(6127, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127\", \"======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========\"),\r\n        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: diag(6128, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128\", \"======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========\"),\r\n        Resolving_real_path_for_0_result_1: diag(6130, DiagnosticCategory.Message, \"Resolving_real_path_for_0_result_1_6130\", \"Resolving real path for '{0}', result '{1}'.\"),\r\n        Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: diag(6131, DiagnosticCategory.Error, \"Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131\", \"Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.\"),\r\n        File_name_0_has_a_1_extension_stripping_it: diag(6132, DiagnosticCategory.Message, \"File_name_0_has_a_1_extension_stripping_it_6132\", \"File name '{0}' has a '{1}' extension - stripping it.\"),\r\n        _0_is_declared_but_its_value_is_never_read: diag(6133, DiagnosticCategory.Error, \"_0_is_declared_but_its_value_is_never_read_6133\", \"'{0}' is declared but its value is never read.\"),\r\n        Report_errors_on_unused_locals: diag(6134, DiagnosticCategory.Message, \"Report_errors_on_unused_locals_6134\", \"Report errors on unused locals.\"),\r\n        Report_errors_on_unused_parameters: diag(6135, DiagnosticCategory.Message, \"Report_errors_on_unused_parameters_6135\", \"Report errors on unused parameters.\"),\r\n        The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: diag(6136, DiagnosticCategory.Message, \"The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136\", \"The maximum dependency depth to search under node_modules and load JavaScript files.\"),\r\n        Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: diag(6137, DiagnosticCategory.Error, \"Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137\", \"Cannot import type declaration files. Consider importing '{0}' instead of '{1}'.\"),\r\n        Property_0_is_declared_but_its_value_is_never_read: diag(6138, DiagnosticCategory.Error, \"Property_0_is_declared_but_its_value_is_never_read_6138\", \"Property '{0}' is declared but its value is never read.\"),\r\n        Import_emit_helpers_from_tslib: diag(6139, DiagnosticCategory.Message, \"Import_emit_helpers_from_tslib_6139\", \"Import emit helpers from 'tslib'.\"),\r\n        Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: diag(6140, DiagnosticCategory.Error, \"Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140\", \"Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.\"),\r\n        Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: diag(6141, DiagnosticCategory.Message, \"Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141\", \"Parse in strict mode and emit \\\"use strict\\\" for each source file.\"),\r\n        Module_0_was_resolved_to_1_but_jsx_is_not_set: diag(6142, DiagnosticCategory.Error, \"Module_0_was_resolved_to_1_but_jsx_is_not_set_6142\", \"Module '{0}' was resolved to '{1}', but '--jsx' is not set.\"),\r\n        Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: diag(6144, DiagnosticCategory.Message, \"Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144\", \"Module '{0}' was resolved as locally declared ambient module in file '{1}'.\"),\r\n        Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: diag(6145, DiagnosticCategory.Message, \"Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145\", \"Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.\"),\r\n        Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: diag(6146, DiagnosticCategory.Message, \"Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146\", \"Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.\"),\r\n        Resolution_for_module_0_was_found_in_cache: diag(6147, DiagnosticCategory.Message, \"Resolution_for_module_0_was_found_in_cache_6147\", \"Resolution for module '{0}' was found in cache.\"),\r\n        Directory_0_does_not_exist_skipping_all_lookups_in_it: diag(6148, DiagnosticCategory.Message, \"Directory_0_does_not_exist_skipping_all_lookups_in_it_6148\", \"Directory '{0}' does not exist, skipping all lookups in it.\"),\r\n        Show_diagnostic_information: diag(6149, DiagnosticCategory.Message, \"Show_diagnostic_information_6149\", \"Show diagnostic information.\"),\r\n        Show_verbose_diagnostic_information: diag(6150, DiagnosticCategory.Message, \"Show_verbose_diagnostic_information_6150\", \"Show verbose diagnostic information.\"),\r\n        Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: diag(6151, DiagnosticCategory.Message, \"Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151\", \"Emit a single file with source maps instead of having a separate file.\"),\r\n        Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: diag(6152, DiagnosticCategory.Message, \"Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152\", \"Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set.\"),\r\n        Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: diag(6153, DiagnosticCategory.Message, \"Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153\", \"Transpile each file as a separate module (similar to 'ts.transpileModule').\"),\r\n        Print_names_of_generated_files_part_of_the_compilation: diag(6154, DiagnosticCategory.Message, \"Print_names_of_generated_files_part_of_the_compilation_6154\", \"Print names of generated files part of the compilation.\"),\r\n        Print_names_of_files_part_of_the_compilation: diag(6155, DiagnosticCategory.Message, \"Print_names_of_files_part_of_the_compilation_6155\", \"Print names of files part of the compilation.\"),\r\n        The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: diag(6156, DiagnosticCategory.Message, \"The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156\", \"The locale used when displaying messages to the user (e.g. 'en-us')\"),\r\n        Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: diag(6157, DiagnosticCategory.Message, \"Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157\", \"Do not generate custom helper functions like '__extends' in compiled output.\"),\r\n        Do_not_include_the_default_library_file_lib_d_ts: diag(6158, DiagnosticCategory.Message, \"Do_not_include_the_default_library_file_lib_d_ts_6158\", \"Do not include the default library file (lib.d.ts).\"),\r\n        Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: diag(6159, DiagnosticCategory.Message, \"Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159\", \"Do not add triple-slash references or imported modules to the list of compiled files.\"),\r\n        Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: diag(6160, DiagnosticCategory.Message, \"Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160\", \"[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files.\"),\r\n        List_of_folders_to_include_type_definitions_from: diag(6161, DiagnosticCategory.Message, \"List_of_folders_to_include_type_definitions_from_6161\", \"List of folders to include type definitions from.\"),\r\n        Disable_size_limitations_on_JavaScript_projects: diag(6162, DiagnosticCategory.Message, \"Disable_size_limitations_on_JavaScript_projects_6162\", \"Disable size limitations on JavaScript projects.\"),\r\n        The_character_set_of_the_input_files: diag(6163, DiagnosticCategory.Message, \"The_character_set_of_the_input_files_6163\", \"The character set of the input files.\"),\r\n        Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: diag(6164, DiagnosticCategory.Message, \"Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6164\", \"Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.\"),\r\n        Do_not_truncate_error_messages: diag(6165, DiagnosticCategory.Message, \"Do_not_truncate_error_messages_6165\", \"Do not truncate error messages.\"),\r\n        Output_directory_for_generated_declaration_files: diag(6166, DiagnosticCategory.Message, \"Output_directory_for_generated_declaration_files_6166\", \"Output directory for generated declaration files.\"),\r\n        A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: diag(6167, DiagnosticCategory.Message, \"A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167\", \"A series of entries which re-map imports to lookup locations relative to the 'baseUrl'.\"),\r\n        List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: diag(6168, DiagnosticCategory.Message, \"List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168\", \"List of root folders whose combined content represents the structure of the project at runtime.\"),\r\n        Show_all_compiler_options: diag(6169, DiagnosticCategory.Message, \"Show_all_compiler_options_6169\", \"Show all compiler options.\"),\r\n        Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: diag(6170, DiagnosticCategory.Message, \"Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170\", \"[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file\"),\r\n        Command_line_Options: diag(6171, DiagnosticCategory.Message, \"Command_line_Options_6171\", \"Command-line Options\"),\r\n        Basic_Options: diag(6172, DiagnosticCategory.Message, \"Basic_Options_6172\", \"Basic Options\"),\r\n        Strict_Type_Checking_Options: diag(6173, DiagnosticCategory.Message, \"Strict_Type_Checking_Options_6173\", \"Strict Type-Checking Options\"),\r\n        Module_Resolution_Options: diag(6174, DiagnosticCategory.Message, \"Module_Resolution_Options_6174\", \"Module Resolution Options\"),\r\n        Source_Map_Options: diag(6175, DiagnosticCategory.Message, \"Source_Map_Options_6175\", \"Source Map Options\"),\r\n        Additional_Checks: diag(6176, DiagnosticCategory.Message, \"Additional_Checks_6176\", \"Additional Checks\"),\r\n        Experimental_Options: diag(6177, DiagnosticCategory.Message, \"Experimental_Options_6177\", \"Experimental Options\"),\r\n        Advanced_Options: diag(6178, DiagnosticCategory.Message, \"Advanced_Options_6178\", \"Advanced Options\"),\r\n        Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: diag(6179, DiagnosticCategory.Message, \"Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179\", \"Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'.\"),\r\n        Enable_all_strict_type_checking_options: diag(6180, DiagnosticCategory.Message, \"Enable_all_strict_type_checking_options_6180\", \"Enable all strict type-checking options.\"),\r\n        List_of_language_service_plugins: diag(6181, DiagnosticCategory.Message, \"List_of_language_service_plugins_6181\", \"List of language service plugins.\"),\r\n        Scoped_package_detected_looking_in_0: diag(6182, DiagnosticCategory.Message, \"Scoped_package_detected_looking_in_0_6182\", \"Scoped package detected, looking in '{0}'\"),\r\n        Reusing_resolution_of_module_0_to_file_1_from_old_program: diag(6183, DiagnosticCategory.Message, \"Reusing_resolution_of_module_0_to_file_1_from_old_program_6183\", \"Reusing resolution of module '{0}' to file '{1}' from old program.\"),\r\n        Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program: diag(6184, DiagnosticCategory.Message, \"Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program_6184\", \"Reusing module resolutions originating in '{0}' since resolutions are unchanged from old program.\"),\r\n        Disable_strict_checking_of_generic_signatures_in_function_types: diag(6185, DiagnosticCategory.Message, \"Disable_strict_checking_of_generic_signatures_in_function_types_6185\", \"Disable strict checking of generic signatures in function types.\"),\r\n        Enable_strict_checking_of_function_types: diag(6186, DiagnosticCategory.Message, \"Enable_strict_checking_of_function_types_6186\", \"Enable strict checking of function types.\"),\r\n        Variable_0_implicitly_has_an_1_type: diag(7005, DiagnosticCategory.Error, \"Variable_0_implicitly_has_an_1_type_7005\", \"Variable '{0}' implicitly has an '{1}' type.\"),\r\n        Parameter_0_implicitly_has_an_1_type: diag(7006, DiagnosticCategory.Error, \"Parameter_0_implicitly_has_an_1_type_7006\", \"Parameter '{0}' implicitly has an '{1}' type.\"),\r\n        Member_0_implicitly_has_an_1_type: diag(7008, DiagnosticCategory.Error, \"Member_0_implicitly_has_an_1_type_7008\", \"Member '{0}' implicitly has an '{1}' type.\"),\r\n        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: diag(7009, DiagnosticCategory.Error, \"new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009\", \"'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.\"),\r\n        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: diag(7010, DiagnosticCategory.Error, \"_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010\", \"'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.\"),\r\n        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7011, DiagnosticCategory.Error, \"Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011\", \"Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.\"),\r\n        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7013, DiagnosticCategory.Error, \"Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013\", \"Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.\"),\r\n        Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: diag(7015, DiagnosticCategory.Error, \"Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015\", \"Element implicitly has an 'any' type because index expression is not of type 'number'.\"),\r\n        Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: diag(7016, DiagnosticCategory.Error, \"Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016\", \"Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.\"),\r\n        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: diag(7017, DiagnosticCategory.Error, \"Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017\", \"Element implicitly has an 'any' type because type '{0}' has no index signature.\"),\r\n        Object_literal_s_property_0_implicitly_has_an_1_type: diag(7018, DiagnosticCategory.Error, \"Object_literal_s_property_0_implicitly_has_an_1_type_7018\", \"Object literal's property '{0}' implicitly has an '{1}' type.\"),\r\n        Rest_parameter_0_implicitly_has_an_any_type: diag(7019, DiagnosticCategory.Error, \"Rest_parameter_0_implicitly_has_an_any_type_7019\", \"Rest parameter '{0}' implicitly has an 'any[]' type.\"),\r\n        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7020, DiagnosticCategory.Error, \"Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020\", \"Call signature, which lacks return-type annotation, implicitly has an 'any' return type.\"),\r\n        _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: diag(7022, DiagnosticCategory.Error, \"_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022\", \"'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.\"),\r\n        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7023, DiagnosticCategory.Error, \"_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023\", \"'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\"),\r\n        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7024, DiagnosticCategory.Error, \"Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024\", \"Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\"),\r\n        Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type: diag(7025, DiagnosticCategory.Error, \"Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_typ_7025\", \"Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.\"),\r\n        JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: diag(7026, DiagnosticCategory.Error, \"JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026\", \"JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists.\"),\r\n        Unreachable_code_detected: diag(7027, DiagnosticCategory.Error, \"Unreachable_code_detected_7027\", \"Unreachable code detected.\"),\r\n        Unused_label: diag(7028, DiagnosticCategory.Error, \"Unused_label_7028\", \"Unused label.\"),\r\n        Fallthrough_case_in_switch: diag(7029, DiagnosticCategory.Error, \"Fallthrough_case_in_switch_7029\", \"Fallthrough case in switch.\"),\r\n        Not_all_code_paths_return_a_value: diag(7030, DiagnosticCategory.Error, \"Not_all_code_paths_return_a_value_7030\", \"Not all code paths return a value.\"),\r\n        Binding_element_0_implicitly_has_an_1_type: diag(7031, DiagnosticCategory.Error, \"Binding_element_0_implicitly_has_an_1_type_7031\", \"Binding element '{0}' implicitly has an '{1}' type.\"),\r\n        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: diag(7032, DiagnosticCategory.Error, \"Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032\", \"Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.\"),\r\n        Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: diag(7033, DiagnosticCategory.Error, \"Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033\", \"Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.\"),\r\n        Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: diag(7034, DiagnosticCategory.Error, \"Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034\", \"Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.\"),\r\n        Try_npm_install_types_Slash_0_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: diag(7035, DiagnosticCategory.Error, \"Try_npm_install_types_Slash_0_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_mod_7035\", \"Try `npm install @types/{0}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`\"),\r\n        Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: diag(7036, DiagnosticCategory.Error, \"Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036\", \"Dynamic import's specifier must be of type 'string', but here has type '{0}'.\"),\r\n        You_cannot_rename_this_element: diag(8000, DiagnosticCategory.Error, \"You_cannot_rename_this_element_8000\", \"You cannot rename this element.\"),\r\n        You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: diag(8001, DiagnosticCategory.Error, \"You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001\", \"You cannot rename elements that are defined in the standard TypeScript library.\"),\r\n        import_can_only_be_used_in_a_ts_file: diag(8002, DiagnosticCategory.Error, \"import_can_only_be_used_in_a_ts_file_8002\", \"'import ... =' can only be used in a .ts file.\"),\r\n        export_can_only_be_used_in_a_ts_file: diag(8003, DiagnosticCategory.Error, \"export_can_only_be_used_in_a_ts_file_8003\", \"'export=' can only be used in a .ts file.\"),\r\n        type_parameter_declarations_can_only_be_used_in_a_ts_file: diag(8004, DiagnosticCategory.Error, \"type_parameter_declarations_can_only_be_used_in_a_ts_file_8004\", \"'type parameter declarations' can only be used in a .ts file.\"),\r\n        implements_clauses_can_only_be_used_in_a_ts_file: diag(8005, DiagnosticCategory.Error, \"implements_clauses_can_only_be_used_in_a_ts_file_8005\", \"'implements clauses' can only be used in a .ts file.\"),\r\n        interface_declarations_can_only_be_used_in_a_ts_file: diag(8006, DiagnosticCategory.Error, \"interface_declarations_can_only_be_used_in_a_ts_file_8006\", \"'interface declarations' can only be used in a .ts file.\"),\r\n        module_declarations_can_only_be_used_in_a_ts_file: diag(8007, DiagnosticCategory.Error, \"module_declarations_can_only_be_used_in_a_ts_file_8007\", \"'module declarations' can only be used in a .ts file.\"),\r\n        type_aliases_can_only_be_used_in_a_ts_file: diag(8008, DiagnosticCategory.Error, \"type_aliases_can_only_be_used_in_a_ts_file_8008\", \"'type aliases' can only be used in a .ts file.\"),\r\n        _0_can_only_be_used_in_a_ts_file: diag(8009, DiagnosticCategory.Error, \"_0_can_only_be_used_in_a_ts_file_8009\", \"'{0}' can only be used in a .ts file.\"),\r\n        types_can_only_be_used_in_a_ts_file: diag(8010, DiagnosticCategory.Error, \"types_can_only_be_used_in_a_ts_file_8010\", \"'types' can only be used in a .ts file.\"),\r\n        type_arguments_can_only_be_used_in_a_ts_file: diag(8011, DiagnosticCategory.Error, \"type_arguments_can_only_be_used_in_a_ts_file_8011\", \"'type arguments' can only be used in a .ts file.\"),\r\n        parameter_modifiers_can_only_be_used_in_a_ts_file: diag(8012, DiagnosticCategory.Error, \"parameter_modifiers_can_only_be_used_in_a_ts_file_8012\", \"'parameter modifiers' can only be used in a .ts file.\"),\r\n        non_null_assertions_can_only_be_used_in_a_ts_file: diag(8013, DiagnosticCategory.Error, \"non_null_assertions_can_only_be_used_in_a_ts_file_8013\", \"'non-null assertions' can only be used in a .ts file.\"),\r\n        enum_declarations_can_only_be_used_in_a_ts_file: diag(8015, DiagnosticCategory.Error, \"enum_declarations_can_only_be_used_in_a_ts_file_8015\", \"'enum declarations' can only be used in a .ts file.\"),\r\n        type_assertion_expressions_can_only_be_used_in_a_ts_file: diag(8016, DiagnosticCategory.Error, \"type_assertion_expressions_can_only_be_used_in_a_ts_file_8016\", \"'type assertion expressions' can only be used in a .ts file.\"),\r\n        Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: diag(8017, DiagnosticCategory.Error, \"Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017\", \"Octal literal types must use ES2015 syntax. Use the syntax '{0}'.\"),\r\n        Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: diag(8018, DiagnosticCategory.Error, \"Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018\", \"Octal literals are not allowed in enums members initializer. Use the syntax '{0}'.\"),\r\n        Report_errors_in_js_files: diag(8019, DiagnosticCategory.Message, \"Report_errors_in_js_files_8019\", \"Report errors in .js files.\"),\r\n        JSDoc_types_can_only_be_used_inside_documentation_comments: diag(8020, DiagnosticCategory.Error, \"JSDoc_types_can_only_be_used_inside_documentation_comments_8020\", \"JSDoc types can only be used inside documentation comments.\"),\r\n        JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: diag(8021, DiagnosticCategory.Error, \"JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021\", \"JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags.\"),\r\n        JSDoc_0_is_not_attached_to_a_class: diag(8022, DiagnosticCategory.Error, \"JSDoc_0_is_not_attached_to_a_class_8022\", \"JSDoc '@{0}' is not attached to a class.\"),\r\n        JSDoc_0_1_does_not_match_the_extends_2_clause: diag(8023, DiagnosticCategory.Error, \"JSDoc_0_1_does_not_match_the_extends_2_clause_8023\", \"JSDoc '@{0} {1}' does not match the 'extends {2}' clause.\"),\r\n        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: diag(8024, DiagnosticCategory.Error, \"JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024\", \"JSDoc '@param' tag has name '{0}', but there is no parameter with that name.\"),\r\n        Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: diag(8025, DiagnosticCategory.Error, \"Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025\", \"Class declarations cannot have more than one `@augments` or `@extends` tag.\"),\r\n        Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_class_extends_clause: diag(9002, DiagnosticCategory.Error, \"Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_clas_9002\", \"Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clause.\"),\r\n        class_expressions_are_not_currently_supported: diag(9003, DiagnosticCategory.Error, \"class_expressions_are_not_currently_supported_9003\", \"'class' expressions are not currently supported.\"),\r\n        Language_service_is_disabled: diag(9004, DiagnosticCategory.Error, \"Language_service_is_disabled_9004\", \"Language service is disabled.\"),\r\n        JSX_attributes_must_only_be_assigned_a_non_empty_expression: diag(17000, DiagnosticCategory.Error, \"JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000\", \"JSX attributes must only be assigned a non-empty 'expression'.\"),\r\n        JSX_elements_cannot_have_multiple_attributes_with_the_same_name: diag(17001, DiagnosticCategory.Error, \"JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001\", \"JSX elements cannot have multiple attributes with the same name.\"),\r\n        Expected_corresponding_JSX_closing_tag_for_0: diag(17002, DiagnosticCategory.Error, \"Expected_corresponding_JSX_closing_tag_for_0_17002\", \"Expected corresponding JSX closing tag for '{0}'.\"),\r\n        JSX_attribute_expected: diag(17003, DiagnosticCategory.Error, \"JSX_attribute_expected_17003\", \"JSX attribute expected.\"),\r\n        Cannot_use_JSX_unless_the_jsx_flag_is_provided: diag(17004, DiagnosticCategory.Error, \"Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004\", \"Cannot use JSX unless the '--jsx' flag is provided.\"),\r\n        A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: diag(17005, DiagnosticCategory.Error, \"A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005\", \"A constructor cannot contain a 'super' call when its class extends 'null'.\"),\r\n        An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17006, DiagnosticCategory.Error, \"An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006\", \"An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.\"),\r\n        A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17007, DiagnosticCategory.Error, \"A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007\", \"A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.\"),\r\n        JSX_element_0_has_no_corresponding_closing_tag: diag(17008, DiagnosticCategory.Error, \"JSX_element_0_has_no_corresponding_closing_tag_17008\", \"JSX element '{0}' has no corresponding closing tag.\"),\r\n        super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: diag(17009, DiagnosticCategory.Error, \"super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009\", \"'super' must be called before accessing 'this' in the constructor of a derived class.\"),\r\n        Unknown_type_acquisition_option_0: diag(17010, DiagnosticCategory.Error, \"Unknown_type_acquisition_option_0_17010\", \"Unknown type acquisition option '{0}'.\"),\r\n        super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: diag(17011, DiagnosticCategory.Error, \"super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011\", \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\"),\r\n        _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: diag(17012, DiagnosticCategory.Error, \"_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012\", \"'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?\"),\r\n        Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: diag(17013, DiagnosticCategory.Error, \"Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013\", \"Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.\"),\r\n        Circularity_detected_while_resolving_configuration_Colon_0: diag(18000, DiagnosticCategory.Error, \"Circularity_detected_while_resolving_configuration_Colon_0_18000\", \"Circularity detected while resolving configuration: {0}\"),\r\n        A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not: diag(18001, DiagnosticCategory.Error, \"A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not_18001\", \"A path in an 'extends' option must be relative or rooted, but '{0}' is not.\"),\r\n        The_files_list_in_config_file_0_is_empty: diag(18002, DiagnosticCategory.Error, \"The_files_list_in_config_file_0_is_empty_18002\", \"The 'files' list in config file '{0}' is empty.\"),\r\n        No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: diag(18003, DiagnosticCategory.Error, \"No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003\", \"No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.\"),\r\n        Add_missing_super_call: diag(90001, DiagnosticCategory.Message, \"Add_missing_super_call_90001\", \"Add missing 'super()' call.\"),\r\n        Make_super_call_the_first_statement_in_the_constructor: diag(90002, DiagnosticCategory.Message, \"Make_super_call_the_first_statement_in_the_constructor_90002\", \"Make 'super()' call the first statement in the constructor.\"),\r\n        Change_extends_to_implements: diag(90003, DiagnosticCategory.Message, \"Change_extends_to_implements_90003\", \"Change 'extends' to 'implements'.\"),\r\n        Remove_declaration_for_Colon_0: diag(90004, DiagnosticCategory.Message, \"Remove_declaration_for_Colon_0_90004\", \"Remove declaration for: '{0}'.\"),\r\n        Implement_interface_0: diag(90006, DiagnosticCategory.Message, \"Implement_interface_0_90006\", \"Implement interface '{0}'.\"),\r\n        Implement_inherited_abstract_class: diag(90007, DiagnosticCategory.Message, \"Implement_inherited_abstract_class_90007\", \"Implement inherited abstract class.\"),\r\n        Add_this_to_unresolved_variable: diag(90008, DiagnosticCategory.Message, \"Add_this_to_unresolved_variable_90008\", \"Add 'this.' to unresolved variable.\"),\r\n        Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: diag(90009, DiagnosticCategory.Error, \"Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__90009\", \"Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig.\"),\r\n        Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: diag(90010, DiagnosticCategory.Error, \"Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_90010\", \"Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.\"),\r\n        Import_0_from_1: diag(90013, DiagnosticCategory.Message, \"Import_0_from_1_90013\", \"Import '{0}' from \\\"{1}\\\".\"),\r\n        Change_0_to_1: diag(90014, DiagnosticCategory.Message, \"Change_0_to_1_90014\", \"Change '{0}' to '{1}'.\"),\r\n        Add_0_to_existing_import_declaration_from_1: diag(90015, DiagnosticCategory.Message, \"Add_0_to_existing_import_declaration_from_1_90015\", \"Add '{0}' to existing import declaration from \\\"{1}\\\".\"),\r\n        Declare_property_0: diag(90016, DiagnosticCategory.Message, \"Declare_property_0_90016\", \"Declare property '{0}'.\"),\r\n        Add_index_signature_for_property_0: diag(90017, DiagnosticCategory.Message, \"Add_index_signature_for_property_0_90017\", \"Add index signature for property '{0}'.\"),\r\n        Disable_checking_for_this_file: diag(90018, DiagnosticCategory.Message, \"Disable_checking_for_this_file_90018\", \"Disable checking for this file.\"),\r\n        Ignore_this_error_message: diag(90019, DiagnosticCategory.Message, \"Ignore_this_error_message_90019\", \"Ignore this error message.\"),\r\n        Initialize_property_0_in_the_constructor: diag(90020, DiagnosticCategory.Message, \"Initialize_property_0_in_the_constructor_90020\", \"Initialize property '{0}' in the constructor.\"),\r\n        Initialize_static_property_0: diag(90021, DiagnosticCategory.Message, \"Initialize_static_property_0_90021\", \"Initialize static property '{0}'.\"),\r\n        Change_spelling_to_0: diag(90022, DiagnosticCategory.Message, \"Change_spelling_to_0_90022\", \"Change spelling to '{0}'.\"),\r\n        Declare_method_0: diag(90023, DiagnosticCategory.Message, \"Declare_method_0_90023\", \"Declare method '{0}'.\"),\r\n        Declare_static_method_0: diag(90024, DiagnosticCategory.Message, \"Declare_static_method_0_90024\", \"Declare static method '{0}'.\"),\r\n        Prefix_0_with_an_underscore: diag(90025, DiagnosticCategory.Message, \"Prefix_0_with_an_underscore_90025\", \"Prefix '{0}' with an underscore.\"),\r\n        Rewrite_as_the_indexed_access_type_0: diag(90026, DiagnosticCategory.Message, \"Rewrite_as_the_indexed_access_type_0_90026\", \"Rewrite as the indexed access type '{0}'.\"),\r\n        Declare_static_property_0: diag(90027, DiagnosticCategory.Message, \"Declare_static_property_0_90027\", \"Declare static property '{0}'.\"),\r\n        Call_decorator_expression: diag(90028, DiagnosticCategory.Message, \"Call_decorator_expression_90028\", \"Call decorator expression.\"),\r\n        Convert_function_to_an_ES2015_class: diag(95001, DiagnosticCategory.Message, \"Convert_function_to_an_ES2015_class_95001\", \"Convert function to an ES2015 class\"),\r\n        Convert_function_0_to_class: diag(95002, DiagnosticCategory.Message, \"Convert_function_0_to_class_95002\", \"Convert function '{0}' to class\"),\r\n        Extract_symbol: diag(95003, DiagnosticCategory.Message, \"Extract_symbol_95003\", \"Extract symbol\"),\r\n        Extract_to_0_in_1: diag(95004, DiagnosticCategory.Message, \"Extract_to_0_in_1_95004\", \"Extract to {0} in {1}\"),\r\n        Extract_function: diag(95005, DiagnosticCategory.Message, \"Extract_function_95005\", \"Extract function\"),\r\n        Extract_constant: diag(95006, DiagnosticCategory.Message, \"Extract_constant_95006\", \"Extract constant\"),\r\n        Extract_to_0_in_enclosing_scope: diag(95007, DiagnosticCategory.Message, \"Extract_to_0_in_enclosing_scope_95007\", \"Extract to {0} in enclosing scope\"),\r\n        Extract_to_0_in_1_scope: diag(95008, DiagnosticCategory.Message, \"Extract_to_0_in_1_scope_95008\", \"Extract to {0} in {1} scope\"),\r\n        Annotate_with_type_from_JSDoc: diag(95009, DiagnosticCategory.Message, \"Annotate_with_type_from_JSDoc_95009\", \"Annotate with type from JSDoc\"),\r\n        Annotate_with_types_from_JSDoc: diag(95010, DiagnosticCategory.Message, \"Annotate_with_types_from_JSDoc_95010\", \"Annotate with types from JSDoc\"),\r\n        Infer_type_of_0_from_usage: diag(95011, DiagnosticCategory.Message, \"Infer_type_of_0_from_usage_95011\", \"Infer type of '{0}' from usage.\"),\r\n        Infer_parameter_types_from_usage: diag(95012, DiagnosticCategory.Message, \"Infer_parameter_types_from_usage_95012\", \"Infer parameter types from usage.\"),\r\n        字典语句包含错误: diag(100001, DiagnosticCategory.Error, \"字典语句包含错误_100001\", \"字典语句包含错误.\"),\r\n        有与关键字冲突的词典标识符_名称为_0: diag(100002, DiagnosticCategory.Error, \"有与关键字冲突的词典标识符_名称为_0_100002\", \"有与关键字冲突的词典标识符,名称为'{0}'.\"),\r\n        字典的键为文字字面量值必须为文字字面量_错误名称为_0: diag(100003, DiagnosticCategory.Error, \"字典的键为文字字面量值必须为文字字面量_错误名称为_0_100003\", \"字典的键为文字字面量值必须为文字字面量,错误名称为'{0}'.\"),\r\n        词典值不能为空_请完成词典值的录入: diag(100004, DiagnosticCategory.Error, \"词典值不能为空_请完成词典值的录入_100004\", \"词典值不能为空, 请完成词典值的录入\"),\r\n        词典值内包含非法字符_禁止录入: diag(100005, DiagnosticCategory.Error, \"词典值内包含非法字符_禁止录入_100005\", \"词典值内包含非法字符,禁止录入.\"),\r\n        _0_Colon_1_与_2_Colon_3_的_4_冲突_位置在_Colon_5_行_6_列: diag(100006, DiagnosticCategory.Error, \"_0_Colon_1_与_2_Colon_3_的_4_冲突_位置在_Colon_5_行_6_列_100006\", \"{0}:'{1}' 与 {2}:'{3}' 的[{4}]冲突, 位置在:[{5}行,{6}列]\"),\r\n        _0_Colon_1_与_2_Colon_3_的_4_冲突: diag(100007, DiagnosticCategory.Error, \"_0_Colon_1_与_2_Colon_3_的_4_冲突_100007\", \"{0}:'{1}'与 {2}:'{3}'的[{4}]冲突.\"),\r\n    };\r\n}","/// <reference path=\"sys.ts\" />\r\n\r\n/* @internal */\r\nnamespace ts {\r\n    export const emptyArray: never[] = [] as never[];\r\n    export const emptyMap: ReadonlyMap<never> = createMap<never>();\r\n\r\n    export const externalHelpersModuleNameText = \"tslib\";\r\n\r\n    export interface ReferencePathMatchResult {\r\n        fileReference?: FileReference;\r\n        diagnosticMessage?: DiagnosticMessage;\r\n        isNoDefaultLib?: boolean;\r\n        isTypeReferenceDirective?: boolean;\r\n    }\r\n\r\n    export function getDeclarationOfKind<T extends Declaration>(symbol: Symbol, kind: T[\"kind\"]): T {\r\n        const declarations = symbol.declarations;\r\n        if (declarations) {\r\n            for (const declaration of declarations) {\r\n                if (declaration.kind === kind) {\r\n                    return declaration as T;\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export interface StringSymbolWriter extends SymbolWriter {\r\n        string(): string;\r\n    }\r\n\r\n    const stringWriter = createSingleLineStringWriter();\r\n\r\n    function createSingleLineStringWriter(): StringSymbolWriter {\r\n        let str = \"\";\r\n\r\n        const writeText: (text: string) => void = text => str += text;\r\n        return {\r\n            string: () => str,\r\n            writeKeyword: writeText,\r\n            writeOperator: writeText,\r\n            writePunctuation: writeText,\r\n            writeSpace: writeText,\r\n            writeStringLiteral: writeText,\r\n            writeParameter: writeText,\r\n            writeProperty: writeText,\r\n            writeSymbol: writeText,\r\n\r\n            // Completely ignore indentation for string writers.  And map newlines to\r\n            // a single space.\r\n            writeLine: () => str += \" \",\r\n            increaseIndent: noop,\r\n            decreaseIndent: noop,\r\n            clear: () => str = \"\",\r\n            trackSymbol: noop,\r\n            reportInaccessibleThisError: noop,\r\n            reportPrivateInBaseOfClassExpression: noop,\r\n        };\r\n    }\r\n\r\n    export function usingSingleLineStringWriter(action: (writer: StringSymbolWriter) => void): string {\r\n        const oldString = stringWriter.string();\r\n        try {\r\n            action(stringWriter);\r\n            return stringWriter.string();\r\n        }\r\n        finally {\r\n            stringWriter.clear();\r\n            stringWriter.writeKeyword(oldString);\r\n        }\r\n    }\r\n\r\n    export function getFullWidth(node: Node) {\r\n        return node.end - node.pos;\r\n    }\r\n\r\n    export function getResolvedModule(sourceFile: SourceFile, moduleNameText: string): ResolvedModuleFull | undefined {\r\n        return sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText);\r\n    }\r\n\r\n    export function setResolvedModule(sourceFile: SourceFile, moduleNameText: string, resolvedModule: ResolvedModuleFull): void {\r\n        if (!sourceFile.resolvedModules) {\r\n            sourceFile.resolvedModules = createMap<ResolvedModuleFull>();\r\n        }\r\n\r\n        sourceFile.resolvedModules.set(moduleNameText, resolvedModule);\r\n    }\r\n\r\n    export function setResolvedTypeReferenceDirective(sourceFile: SourceFile, typeReferenceDirectiveName: string, resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective): void {\r\n        if (!sourceFile.resolvedTypeReferenceDirectiveNames) {\r\n            sourceFile.resolvedTypeReferenceDirectiveNames = createMap<ResolvedTypeReferenceDirective>();\r\n        }\r\n\r\n        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, resolvedTypeReferenceDirective);\r\n    }\r\n\r\n    export function moduleResolutionIsEqualTo(oldResolution: ResolvedModuleFull, newResolution: ResolvedModuleFull): boolean {\r\n        return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &&\r\n            oldResolution.extension === newResolution.extension &&\r\n            oldResolution.resolvedFileName === newResolution.resolvedFileName &&\r\n            packageIdIsEqual(oldResolution.packageId, newResolution.packageId);\r\n    }\r\n\r\n    function packageIdIsEqual(a: PackageId | undefined, b: PackageId | undefined): boolean {\r\n        return a === b || a && b && a.name === b.name && a.subModuleName === b.subModuleName && a.version === b.version;\r\n    }\r\n\r\n    export function typeDirectiveIsEqualTo(oldResolution: ResolvedTypeReferenceDirective, newResolution: ResolvedTypeReferenceDirective): boolean {\r\n        return oldResolution.resolvedFileName === newResolution.resolvedFileName && oldResolution.primary === newResolution.primary;\r\n    }\r\n\r\n    export function hasChangesInResolutions<T>(\r\n        names: ReadonlyArray<string>,\r\n        newResolutions: ReadonlyArray<T>,\r\n        oldResolutions: ReadonlyMap<T>,\r\n        comparer: (oldResolution: T, newResolution: T) => boolean): boolean {\r\n        Debug.assert(names.length === newResolutions.length);\r\n\r\n        for (let i = 0; i < names.length; i++) {\r\n            const newResolution = newResolutions[i];\r\n            const oldResolution = oldResolutions && oldResolutions.get(names[i]);\r\n            const changed =\r\n                oldResolution\r\n                    ? !newResolution || !comparer(oldResolution, newResolution)\r\n                    : newResolution;\r\n            if (changed) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Returns true if this node contains a parse error anywhere underneath it.\r\n    export function containsParseError(node: Node): boolean {\r\n        aggregateChildData(node);\r\n        return (node.flags & NodeFlags.ThisNodeOrAnySubNodesHasError) !== 0;\r\n    }\r\n\r\n    function aggregateChildData(node: Node): void {\r\n        if (!(node.flags & NodeFlags.HasAggregatedChildData)) {\r\n            // A node is considered to contain a parse error if:\r\n            //  a) the parser explicitly marked that it had an error\r\n            //  b) any of it's children reported that it had an error.\r\n            const thisNodeOrAnySubNodesHasError = ((node.flags & NodeFlags.ThisNodeHasError) !== 0) ||\r\n                forEachChild(node, containsParseError);\r\n\r\n            // If so, mark ourselves accordingly.\r\n            if (thisNodeOrAnySubNodesHasError) {\r\n                node.flags |= NodeFlags.ThisNodeOrAnySubNodesHasError;\r\n            }\r\n\r\n            // Also mark that we've propagated the child information to this node.  This way we can\r\n            // always consult the bit directly on this node without needing to check its children\r\n            // again.\r\n            node.flags |= NodeFlags.HasAggregatedChildData;\r\n        }\r\n    }\r\n\r\n    export function getSourceFileOfNode(node: Node): SourceFile {\r\n        while (node && node.kind !== SyntaxKind.SourceFile) {\r\n            node = node.parent;\r\n        }\r\n        return <SourceFile>node;\r\n    }\r\n\r\n    export function isStatementWithLocals(node: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.CaseBlock:\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getStartPositionOfLine(line: number, sourceFile: SourceFileLike): number {\r\n        Debug.assert(line >= 0);\r\n        return getLineStarts(sourceFile)[line];\r\n    }\r\n\r\n    // This is a useful function for debugging purposes.\r\n    export function nodePosToString(node: Node): string {\r\n        const file = getSourceFileOfNode(node);\r\n        const loc = getLineAndCharacterOfPosition(file, node.pos);\r\n        return `${file.fileName}(${loc.line + 1},${loc.character + 1})`;\r\n    }\r\n\r\n    export function getEndLinePosition(line: number, sourceFile: SourceFileLike): number {\r\n        Debug.assert(line >= 0);\r\n        const lineStarts = getLineStarts(sourceFile);\r\n\r\n        const lineIndex = line;\r\n        const sourceText = sourceFile.text;\r\n        if (lineIndex + 1 === lineStarts.length) {\r\n            // last line - return EOF\r\n            return sourceText.length - 1;\r\n        }\r\n        else {\r\n            // current line start\r\n            const start = lineStarts[lineIndex];\r\n            // take the start position of the next line - 1 = it should be some line break\r\n            let pos = lineStarts[lineIndex + 1] - 1;\r\n            Debug.assert(isLineBreak(sourceText.charCodeAt(pos)));\r\n            // walk backwards skipping line breaks, stop the the beginning of current line.\r\n            // i.e:\r\n            // <some text>\r\n            // $ <- end of line for this position should match the start position\r\n            while (start <= pos && isLineBreak(sourceText.charCodeAt(pos))) {\r\n                pos--;\r\n            }\r\n            return pos;\r\n        }\r\n    }\r\n\r\n    // Returns true if this node is missing from the actual source code. A 'missing' node is different\r\n    // from 'undefined/defined'. When a node is undefined (which can happen for optional nodes\r\n    // in the tree), it is definitely missing. However, a node may be defined, but still be\r\n    // missing.  This happens whenever the parser knows it needs to parse something, but can't\r\n    // get anything in the source code that it expects at that location. For example:\r\n    //\r\n    //          let a: ;\r\n    //\r\n    // Here, the Type in the Type-Annotation is not-optional (as there is a colon in the source\r\n    // code). So the parser will attempt to parse out a type, and will create an actual node.\r\n    // However, this node will be 'missing' in the sense that no actual source-code/tokens are\r\n    // contained within it.\r\n    export function nodeIsMissing(node: Node) {\r\n        if (node === undefined) {\r\n            return true;\r\n        }\r\n\r\n        return node.pos === node.end && node.pos >= 0 && node.kind !== SyntaxKind.EndOfFileToken;\r\n    }\r\n\r\n    export function nodeIsPresent(node: Node) {\r\n        return !nodeIsMissing(node);\r\n    }\r\n\r\n    /**\r\n     * Determine if the given comment is a triple-slash\r\n     *\r\n     * @return true if the comment is a triple-slash comment else false\r\n     */\r\n    export function isRecognizedTripleSlashComment(text: string, commentPos: number, commentEnd: number) {\r\n        // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text\r\n        // so that we don't end up computing comment string and doing match for all // comments\r\n        if (text.charCodeAt(commentPos + 1) === CharacterCodes.slash &&\r\n            commentPos + 2 < commentEnd &&\r\n            text.charCodeAt(commentPos + 2) === CharacterCodes.slash) {\r\n            const textSubStr = text.substring(commentPos, commentEnd);\r\n            return textSubStr.match(fullTripleSlashReferencePathRegEx) ||\r\n                textSubStr.match(fullTripleSlashReferencePathRegExCH) ||\r\n                textSubStr.match(fullTripleSlashAMDReferencePathRegEx) ||\r\n                textSubStr.match(fullTripleSlashAMDReferencePathRegExCH) ||\r\n                textSubStr.match(fullTripleSlashReferenceTypeReferenceDirectiveRegEx) ||\r\n                textSubStr.match(fullTripleSlashReferenceTypeReferenceDirectiveRegExCH) ||\r\n                textSubStr.match(defaultLibReferenceRegEx) ||\r\n                textSubStr.match(defaultLibReferenceRegExCH) ?\r\n                true : false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isPinnedComment(text: string, comment: CommentRange) {\r\n        return text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(comment.pos + 2) === CharacterCodes.exclamation;\r\n    }\r\n\r\n    export function getTokenPosOfNode(node: Node, sourceFile?: SourceFileLike, includeJsDoc?: boolean): number {\r\n        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*\r\n        // want to skip trivia because this will launch us forward to the next token.\r\n        if (nodeIsMissing(node)) {\r\n            return node.pos;\r\n        }\r\n\r\n        if (isJSDocNode(node)) {\r\n            return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, /*stopAfterLineBreak*/ false, /*stopAtComments*/ true);\r\n        }\r\n\r\n        if (includeJsDoc && hasJSDocNodes(node)) {\r\n            return getTokenPosOfNode(node.jsDoc[0]);\r\n        }\r\n\r\n        // For a syntax list, it is possible that one of its children has JSDocComment nodes, while\r\n        // the syntax list itself considers them as normal trivia. Therefore if we simply skip\r\n        // trivia for the list, we may have skipped the JSDocComment as well. So we should process its\r\n        // first child to determine the actual position of its first token.\r\n        if (node.kind === SyntaxKind.SyntaxList && (<SyntaxList>node)._children.length > 0) {\r\n            return getTokenPosOfNode((<SyntaxList>node)._children[0], sourceFile, includeJsDoc);\r\n        }\r\n\r\n        return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);\r\n    }\r\n\r\n    export function getNonDecoratorTokenPosOfNode(node: Node, sourceFile?: SourceFileLike): number {\r\n        if (nodeIsMissing(node) || !node.decorators) {\r\n            return getTokenPosOfNode(node, sourceFile);\r\n        }\r\n\r\n        return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.decorators.end);\r\n    }\r\n\r\n    export function getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia = false): string {\r\n        if (nodeIsMissing(node)) {\r\n            return \"\";\r\n        }\r\n\r\n        const text = sourceFile.text;\r\n        return text.substring(includeTrivia ? node.pos : skipTrivia(text, node.pos), node.end);\r\n    }\r\n\r\n    export function getTextOfNodeFromSourceText(sourceText: string, node: Node): string {\r\n        if (nodeIsMissing(node)) {\r\n            return \"\";\r\n        }\r\n\r\n        return sourceText.substring(skipTrivia(sourceText, node.pos), node.end);\r\n    }\r\n\r\n    export function getTextOfNode(node: Node, includeTrivia = false): string {\r\n        return  getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);\r\n    }\r\n\r\n    /**\r\n     * Note: it is expected that the `nodeArray` and the `node` are within the same file.\r\n     * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.\r\n     */\r\n    export function indexOfNode(nodeArray: ReadonlyArray<Node>, node: Node) {\r\n        return binarySearch(nodeArray, node, compareNodePos);\r\n    }\r\n\r\n    function compareNodePos({ pos: aPos }: Node, { pos: bPos }: Node) {\r\n        return aPos < bPos ? Comparison.LessThan : bPos < aPos ? Comparison.GreaterThan : Comparison.EqualTo;\r\n    }\r\n\r\n    /**\r\n     * Gets flags that control emit behavior of a node.\r\n     */\r\n    export function getEmitFlags(node: Node): EmitFlags | undefined {\r\n        const emitNode = node.emitNode;\r\n        return emitNode && emitNode.flags;\r\n    }\r\n\r\n    export function getLiteralText(node: LiteralLikeNode, sourceFile: SourceFile) {\r\n        // If we don't need to downlevel and we can reach the original source text using\r\n        // the node's parent reference, then simply get the text as it was originally written.\r\n        if (!nodeIsSynthesized(node) && node.parent) {\r\n            return 取输出文本从源文件按节点(sourceFile, node);\r\n        }\r\n\r\n        const escapeText = getEmitFlags(node) & EmitFlags.NoAsciiEscaping ? escapeString : escapeNonAsciiString;\r\n        const 输出文本 = ((<StringLiteral>node).别名 && (<StringLiteral>node).别名.旗帜 & 别名旗帜.汉英) ? (<StringLiteral>node).别名.名称 as string : node.text\r\n\r\n        // If we can't reach the original source text, use the canonical form if it's a number,\r\n        // or a (possibly escaped) quoted form of the original text if it's string-like.\r\n        switch (node.kind) {\r\n            case SyntaxKind.StringLiteral:\r\n                if ((<StringLiteral>node).singleQuote) {\r\n                    return \"'\" + escapeText(输出文本, CharacterCodes.singleQuote) + \"'\";\r\n                }\r\n                else {\r\n                    return '\"' + escapeText(输出文本, CharacterCodes.doubleQuote) + '\"';\r\n                }\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                return \"`\" + escapeText(输出文本, CharacterCodes.backtick) + \"`\";\r\n            case SyntaxKind.TemplateHead:\r\n                return \"`\" + escapeText(输出文本, CharacterCodes.backtick) + \"${\";\r\n            case SyntaxKind.TemplateMiddle:\r\n                return \"}\" + escapeText(输出文本, CharacterCodes.backtick) + \"${\";\r\n            case SyntaxKind.TemplateTail:\r\n                return \"}\" + escapeText(输出文本, CharacterCodes.backtick) + \"`\";\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n                return 输出文本;\r\n        }\r\n\r\n        Debug.fail(`Literal kind '${node.kind}' not accounted for.`);\r\n    }\r\n\r\n    export function getTextOfConstantValue(value: string | number) {\r\n        return isString(value) ? '\"' + escapeNonAsciiString(value) + '\"' : \"\" + value;\r\n    }\r\n\r\n    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'\r\n    export function escapeLeadingUnderscores(identifier: string): __String {\r\n        return (identifier.length >= 2 && identifier.charCodeAt(0) === CharacterCodes._ && identifier.charCodeAt(1) === CharacterCodes._ ? \"_\" + identifier : identifier) as __String;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `id.escapedText` to get the escaped text of an Identifier.\r\n     * @param identifier The identifier to escape\r\n     */\r\n    export function escapeIdentifier(identifier: string): string {\r\n        return identifier;\r\n    }\r\n\r\n    // Make an identifier from an external module name by extracting the string after the last \"/\" and replacing\r\n    // all non-alphanumeric characters with underscores\r\n    export function makeIdentifierFromModuleName(moduleName: string): string {\r\n        return getBaseFileName(moduleName).replace(/^(\\d)/, \"_$1\").replace(/\\W/g, \"_\");\r\n    }\r\n\r\n    export function isBlockOrCatchScoped(declaration: Declaration) {\r\n        return (getCombinedNodeFlags(declaration) & NodeFlags.BlockScoped) !== 0 ||\r\n            isCatchClauseVariableDeclarationOrBindingElement(declaration);\r\n    }\r\n\r\n    export function isCatchClauseVariableDeclarationOrBindingElement(declaration: Declaration) {\r\n        const node = getRootDeclaration(declaration);\r\n        return node.kind === SyntaxKind.VariableDeclaration && node.parent.kind === SyntaxKind.CatchClause;\r\n    }\r\n\r\n    export function isAmbientModule(node: Node): boolean {\r\n        return node && node.kind === SyntaxKind.ModuleDeclaration &&\r\n            ((<ModuleDeclaration>node).name.kind === SyntaxKind.StringLiteral || isGlobalScopeAugmentation(<ModuleDeclaration>node));\r\n    }\r\n\r\n    export function isModuleWithStringLiteralName(node: Node): node is ModuleDeclaration {\r\n        return isModuleDeclaration(node) && node.name.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function isNonGlobalAmbientModule(node: Node): node is ModuleDeclaration & { name: StringLiteral } {\r\n        return isModuleDeclaration(node) && isStringLiteral(node.name);\r\n    }\r\n\r\n    /** Given a symbol for a module, checks that it is a shorthand ambient module. */\r\n    export function isShorthandAmbientModuleSymbol(moduleSymbol: Symbol): boolean {\r\n        return isShorthandAmbientModule(moduleSymbol.valueDeclaration);\r\n    }\r\n\r\n    function isShorthandAmbientModule(node: Node): boolean {\r\n        // The only kind of module that can be missing a body is a shorthand ambient module.\r\n        return node && node.kind === SyntaxKind.ModuleDeclaration && (!(<ModuleDeclaration>node).body);\r\n    }\r\n\r\n    export function isBlockScopedContainerTopLevel(node: Node): boolean {\r\n        return node.kind === SyntaxKind.SourceFile ||\r\n            node.kind === SyntaxKind.ModuleDeclaration ||\r\n            isFunctionLike(node);\r\n    }\r\n\r\n    export function isGlobalScopeAugmentation(module: ModuleDeclaration): boolean {\r\n        return !!(module.flags & NodeFlags.GlobalAugmentation);\r\n    }\r\n\r\n    export function isExternalModuleAugmentation(node: Node): boolean {\r\n        // external module augmentation is a ambient module declaration that is either:\r\n        // - defined in the top level scope and source file is an external module\r\n        // - defined inside ambient module declaration located in the top level scope and source file not an external module\r\n        if (!node || !isAmbientModule(node)) {\r\n            return false;\r\n        }\r\n        switch (node.parent.kind) {\r\n            case SyntaxKind.SourceFile:\r\n                return isExternalModule(<SourceFile>node.parent);\r\n            case SyntaxKind.ModuleBlock:\r\n                return isAmbientModule(node.parent.parent) && !isExternalModule(<SourceFile>node.parent.parent.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isEffectiveExternalModule(node: SourceFile, compilerOptions: CompilerOptions) {\r\n        return isExternalModule(node) || compilerOptions.isolatedModules;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isBlockScope(node: Node, parentNode: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.SourceFile:\r\n            case SyntaxKind.CaseBlock:\r\n            case SyntaxKind.CatchClause:\r\n            case SyntaxKind.ModuleDeclaration:\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n\r\n            case SyntaxKind.Block:\r\n                // function block is not considered block-scope container\r\n                // see comment in binder.ts: bind(...), case for SyntaxKind.Block\r\n                return parentNode && !isFunctionLike(parentNode);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isDeclarationWithTypeParameters(node: Node): node is DeclarationWithTypeParameters;\r\n    export function isDeclarationWithTypeParameters(node: DeclarationWithTypeParameters): node is DeclarationWithTypeParameters {\r\n        switch (node.kind) {\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n            case SyntaxKind.JSDocTemplateTag:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n            default:\r\n                assertTypeIsNever(node);\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isAnyImportSyntax(node: Node): node is AnyImportSyntax {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    // Gets the nearest enclosing block scope container that has the provided node\r\n    // as a descendant, that is not the provided node.\r\n    export function getEnclosingBlockScopeContainer(node: Node): Node {\r\n        let current = node.parent;\r\n        while (current) {\r\n            if (isBlockScope(current, current.parent)) {\r\n                return current;\r\n            }\r\n\r\n            current = current.parent;\r\n        }\r\n    }\r\n\r\n    // Return display name of an identifier\r\n    // Computed property names will just be emitted as \"[<expr>]\", where <expr> is the source\r\n    // text of the expression in the computed property.\r\n    export function declarationNameToString(name: DeclarationName) {\r\n        return getFullWidth(name) === 0 ? \"(Missing)\" : getTextOfNode(name);\r\n    }\r\n\r\n    export function getNameFromIndexInfo(info: IndexInfo): string | undefined {\r\n        return info.declaration ? declarationNameToString(info.declaration.parameters[0].name) : undefined;\r\n    }\r\n\r\n    export function getTextOfPropertyName(name: PropertyName): __String {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n                return (<Identifier>name).escapedText;\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                return escapeLeadingUnderscores((<LiteralExpression>name).text);\r\n            case SyntaxKind.ComputedPropertyName:\r\n                if (isStringOrNumericLiteral((<ComputedPropertyName>name).expression)) {\r\n                    return escapeLeadingUnderscores((<LiteralExpression>(<ComputedPropertyName>name).expression).text);\r\n                }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function entityNameToString(name: EntityNameOrEntityNameExpression): string {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n                return getFullWidth(name) === 0 ? idText(name) : getTextOfNode(name);\r\n            case SyntaxKind.QualifiedName:\r\n                return entityNameToString(name.left) + \".\" + entityNameToString(name.right);\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return entityNameToString(name.expression) + \".\" + entityNameToString(name.name);\r\n        }\r\n    }\r\n\r\n    export function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number): Diagnostic {\r\n        const sourceFile = getSourceFileOfNode(node);\r\n        return createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2);\r\n    }\r\n\r\n    export function createDiagnosticForNodeInSourceFile(sourceFile: SourceFile, node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number): Diagnostic {\r\n        const span = getErrorSpanForNode(sourceFile, node);\r\n        return createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2);\r\n    }\r\n\r\n    export function createDiagnosticForNodeFromMessageChain(node: Node, messageChain: DiagnosticMessageChain): Diagnostic {\r\n        const sourceFile = getSourceFileOfNode(node);\r\n        const span = getErrorSpanForNode(sourceFile, node);\r\n        return {\r\n            file: sourceFile,\r\n            start: span.start,\r\n            length: span.length,\r\n            code: messageChain.code,\r\n            category: messageChain.category,\r\n            messageText: messageChain.next ? messageChain : messageChain.messageText\r\n        };\r\n    }\r\n\r\n    export function getSpanOfTokenAtPosition(sourceFile: SourceFile, pos: number): TextSpan {\r\n        const scanner = createScanner(sourceFile.languageVersion, /*skipTrivia*/ true, sourceFile.languageVariant, sourceFile.text, /*onError:*/ undefined, pos);\r\n        scanner.scan();\r\n        const start = scanner.getTokenPos();\r\n        return createTextSpanFromBounds(start, scanner.getTextPos());\r\n    }\r\n\r\n    function getErrorSpanForArrowFunction(sourceFile: SourceFile, node: ArrowFunction): TextSpan {\r\n        const pos = skipTrivia(sourceFile.text, node.pos);\r\n        if (node.body && node.body.kind === SyntaxKind.Block) {\r\n            const { line: startLine } = getLineAndCharacterOfPosition(sourceFile, node.body.pos);\r\n            const { line: endLine } = getLineAndCharacterOfPosition(sourceFile, node.body.end);\r\n            if (startLine < endLine) {\r\n                // The arrow function spans multiple lines,\r\n                // make the error span be the first line, inclusive.\r\n                return createTextSpan(pos, getEndLinePosition(startLine, sourceFile) - pos + 1);\r\n            }\r\n        }\r\n        return createTextSpanFromBounds(pos, node.end);\r\n    }\r\n\r\n    export function getErrorSpanForNode(sourceFile: SourceFile, node: Node): TextSpan {\r\n        let errorNode = node;\r\n        switch (node.kind) {\r\n            case SyntaxKind.SourceFile:\r\n                const pos = skipTrivia(sourceFile.text, 0, /*stopAfterLineBreak*/ false);\r\n                if (pos === sourceFile.text.length) {\r\n                    // file is empty - return span for the beginning of the file\r\n                    return createTextSpan(0, 0);\r\n                }\r\n                return getSpanOfTokenAtPosition(sourceFile, pos);\r\n            // This list is a work in progress. Add missing node kinds to improve their error\r\n            // spans.\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.BindingElement:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.ModuleDeclaration:\r\n            case SyntaxKind.EnumDeclaration:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n                errorNode = (<NamedDeclaration>node).name;\r\n                break;\r\n            case SyntaxKind.ArrowFunction:\r\n                return getErrorSpanForArrowFunction(sourceFile, <ArrowFunction>node);\r\n        }\r\n\r\n        if (errorNode === undefined) {\r\n            // If we don't have a better node, then just set the error on the first token of\r\n            // construct.\r\n            return getSpanOfTokenAtPosition(sourceFile, node.pos);\r\n        }\r\n\r\n        const pos = nodeIsMissing(errorNode)\r\n            ? errorNode.pos\r\n            : skipTrivia(sourceFile.text, errorNode.pos);\r\n\r\n        return createTextSpanFromBounds(pos, errorNode.end);\r\n    }\r\n\r\n    export function isExternalOrCommonJsModule(file: SourceFile): boolean {\r\n        return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;\r\n    }\r\n\r\n    export function isConstEnumDeclaration(node: Node): boolean {\r\n        return node.kind === SyntaxKind.EnumDeclaration && isConst(node);\r\n    }\r\n\r\n    export function isConst(node: Node): boolean {\r\n        return !!(getCombinedNodeFlags(node) & NodeFlags.Const)\r\n            || !!(getCombinedModifierFlags(node) & ModifierFlags.Const);\r\n    }\r\n\r\n    export function isLet(node: Node): boolean {\r\n        return !!(getCombinedNodeFlags(node) & NodeFlags.Let);\r\n    }\r\n\r\n    export function isSuperCall(n: Node): n is SuperCall {\r\n        return n.kind === SyntaxKind.CallExpression && (<CallExpression>n).expression.kind === SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    export function isImportCall(n: Node): n is ImportCall {\r\n        return n.kind === SyntaxKind.CallExpression && (<CallExpression>n).expression.kind === SyntaxKind.ImportKeyword;\r\n    }\r\n\r\n    export function isPrologueDirective(node: Node): node is PrologueDirective {\r\n        return node.kind === SyntaxKind.ExpressionStatement\r\n            && (<ExpressionStatement>node).expression.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function getLeadingCommentRangesOfNode(node: Node, sourceFileOfNode: SourceFile) {\r\n        return node.kind !== SyntaxKind.JsxText ? getLeadingCommentRanges(sourceFileOfNode.text, node.pos) : undefined;\r\n    }\r\n\r\n    export function getJSDocCommentRanges(node: Node, text: string) {\r\n        const commentRanges = (node.kind === SyntaxKind.Parameter ||\r\n            node.kind === SyntaxKind.TypeParameter ||\r\n            node.kind === SyntaxKind.FunctionExpression ||\r\n            node.kind === SyntaxKind.ArrowFunction ||\r\n            node.kind === SyntaxKind.ParenthesizedExpression) ?\r\n            concatenate(getTrailingCommentRanges(text, node.pos), getLeadingCommentRanges(text, node.pos)) :\r\n            getLeadingCommentRanges(text, node.pos);\r\n        // True if the comment starts with '/**' but not if it is '/**/'\r\n        return filter(commentRanges, comment =>\r\n            text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(comment.pos + 2) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(comment.pos + 3) !== CharacterCodes.slash);\r\n    }\r\n\r\n\r\n\r\n\r\n    export const fullTripleSlashReferencePathRegEx = /^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    export const fullTripleSlashReferencePathRegExCH = /^(\\/\\/\\/\\s*<引用\\s+路径\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n\r\n    const fullTripleSlashReferenceTypeReferenceDirectiveRegEx = /^(\\/\\/\\/\\s*<reference\\s+types\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    const fullTripleSlashReferenceTypeReferenceDirectiveRegExCH = /^(\\/\\/\\/\\s*<引用\\s+类型集\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n\r\n    export const fullTripleSlashAMDReferencePathRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    export const fullTripleSlashAMDReferencePathRegExCH = /^(\\/\\/\\/\\s*<AMD附件\\s+路径\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n\r\n    const defaultLibReferenceRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/;\r\n    const defaultLibReferenceRegExCH = /^(\\/\\/\\/\\s*<引用\\s+不使用默认支持库\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/;\r\n\r\n    export function isPartOfTypeNode(node: Node): boolean {\r\n        if (SyntaxKind.FirstTypeNode <= node.kind && node.kind <= SyntaxKind.LastTypeNode) {\r\n            return true;\r\n        }\r\n\r\n        switch (node.kind) {\r\n            case SyntaxKind.AnyKeyword:\r\n            case SyntaxKind.NumberKeyword:\r\n            case SyntaxKind.StringKeyword:\r\n            case SyntaxKind.BooleanKeyword:\r\n            case SyntaxKind.SymbolKeyword:\r\n            case SyntaxKind.UndefinedKeyword:\r\n            case SyntaxKind.NeverKeyword:\r\n                return true;\r\n            case SyntaxKind.VoidKeyword:\r\n                return node.parent.kind !== SyntaxKind.VoidExpression;\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return !isExpressionWithTypeArgumentsInClassExtendsClause(node);\r\n\r\n            // Identifiers and qualified names may be type nodes, depending on their context. Climb\r\n            // above them to find the lowest container\r\n            case SyntaxKind.Identifier:\r\n                // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.\r\n                if (node.parent.kind === SyntaxKind.QualifiedName && (<QualifiedName>node.parent).right === node) {\r\n                    node = node.parent;\r\n                }\r\n                else if (node.parent.kind === SyntaxKind.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).name === node) {\r\n                    node = node.parent;\r\n                }\r\n                // At this point, node is either a qualified name or an identifier\r\n                Debug.assert(node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName || node.kind === SyntaxKind.PropertyAccessExpression,\r\n                    \"'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.\");\r\n            // falls through\r\n            case SyntaxKind.QualifiedName:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ThisKeyword:\r\n                const parent = node.parent;\r\n                if (parent.kind === SyntaxKind.TypeQuery) {\r\n                    return false;\r\n                }\r\n                // Do not recursively call isPartOfTypeNode on the parent. In the example:\r\n                //\r\n                //     let a: A.B.C;\r\n                //\r\n                // Calling isPartOfTypeNode would consider the qualified name A.B a type node.\r\n                // Only C and A.B.C are type nodes.\r\n                if (SyntaxKind.FirstTypeNode <= parent.kind && parent.kind <= SyntaxKind.LastTypeNode) {\r\n                    return true;\r\n                }\r\n                switch (parent.kind) {\r\n                    case SyntaxKind.ExpressionWithTypeArguments:\r\n                        return !isExpressionWithTypeArgumentsInClassExtendsClause(parent);\r\n                    case SyntaxKind.TypeParameter:\r\n                        return node === (<TypeParameterDeclaration>parent).constraint;\r\n                    case SyntaxKind.PropertyDeclaration:\r\n                    case SyntaxKind.PropertySignature:\r\n                    case SyntaxKind.Parameter:\r\n                    case SyntaxKind.VariableDeclaration:\r\n                        return node === (<VariableLikeDeclaration>parent).type;\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.MethodDeclaration:\r\n                    case SyntaxKind.MethodSignature:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                        return node === (<FunctionLikeDeclaration>parent).type;\r\n                    case SyntaxKind.CallSignature:\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                        return node === (<SignatureDeclaration>parent).type;\r\n                    case SyntaxKind.TypeAssertionExpression:\r\n                        return node === (<TypeAssertion>parent).type;\r\n                    case SyntaxKind.CallExpression:\r\n                    case SyntaxKind.NewExpression:\r\n                        return (<CallExpression>parent).typeArguments && indexOf((<CallExpression>parent).typeArguments, node) >= 0;\r\n                    case SyntaxKind.TaggedTemplateExpression:\r\n                        // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isChildOfNodeWithKind(node: Node, kind: SyntaxKind): boolean {\r\n        while (node) {\r\n            if (node.kind === kind) {\r\n                return true;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Warning: This has the same semantics as the forEach family of functions,\r\n    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.\r\n    export function forEachReturnStatement<T>(body: Block, visitor: (stmt: ReturnStatement) => T): T {\r\n\r\n        return traverse(body);\r\n\r\n        function traverse(node: Node): T {\r\n            switch (node.kind) {\r\n                case SyntaxKind.ReturnStatement:\r\n                    return visitor(<ReturnStatement>node);\r\n                case SyntaxKind.CaseBlock:\r\n                case SyntaxKind.Block:\r\n                case SyntaxKind.IfStatement:\r\n                case SyntaxKind.DoStatement:\r\n                case SyntaxKind.WhileStatement:\r\n                case SyntaxKind.ForStatement:\r\n                case SyntaxKind.ForInStatement:\r\n                case SyntaxKind.ForOfStatement:\r\n                case SyntaxKind.WithStatement:\r\n                case SyntaxKind.SwitchStatement:\r\n                case SyntaxKind.CaseClause:\r\n                case SyntaxKind.DefaultClause:\r\n                case SyntaxKind.LabeledStatement:\r\n                case SyntaxKind.TryStatement:\r\n                case SyntaxKind.CatchClause:\r\n                    return forEachChild(node, traverse);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function forEachYieldExpression(body: Block, visitor: (expr: YieldExpression) => void): void {\r\n\r\n        return traverse(body);\r\n\r\n        function traverse(node: Node): void {\r\n            switch (node.kind) {\r\n                case SyntaxKind.YieldExpression:\r\n                    visitor(<YieldExpression>node);\r\n                    const operand = (<YieldExpression>node).expression;\r\n                    if (operand) {\r\n                        traverse(operand);\r\n                    }\r\n                    return;\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                case SyntaxKind.TypeAliasDeclaration:\r\n                case SyntaxKind.ClassDeclaration:\r\n                case SyntaxKind.ClassExpression:\r\n                    // These are not allowed inside a generator now, but eventually they may be allowed\r\n                    // as local types. Regardless, any yield statements contained within them should be\r\n                    // skipped in this traversal.\r\n                    return;\r\n                default:\r\n                    if (isFunctionLike(node)) {\r\n                        const name = (<FunctionLikeDeclaration>node).name;\r\n                        if (name && name.kind === SyntaxKind.ComputedPropertyName) {\r\n                            // Note that we will not include methods/accessors of a class because they would require\r\n                            // first descending into the class. This is by design.\r\n                            traverse((<ComputedPropertyName>name).expression);\r\n                            return;\r\n                        }\r\n                    }\r\n                    else if (!isPartOfTypeNode(node)) {\r\n                        // This is the general case, which should include mostly expressions and statements.\r\n                        // Also includes NodeArrays.\r\n                        forEachChild(node, traverse);\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the most likely element type for a TypeNode. This is not an exhaustive test\r\n     * as it assumes a rest argument can only be an array type (either T[], or Array<T>).\r\n     *\r\n     * @param node The type node.\r\n     */\r\n    export function getRestParameterElementType(node: TypeNode) {\r\n        if (node && node.kind === SyntaxKind.ArrayType) {\r\n            return (<ArrayTypeNode>node).elementType;\r\n        }\r\n        else if (node && node.kind === SyntaxKind.TypeReference) {\r\n            return singleOrUndefined((<TypeReferenceNode>node).typeArguments);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    export function isVariableLike(node: Node): node is VariableLikeDeclaration {\r\n        if (node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.BindingElement:\r\n                case SyntaxKind.EnumMember:\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.PropertyAssignment:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                case SyntaxKind.VariableDeclaration:\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function introducesArgumentsExoticObject(node: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function unwrapInnermostStatementOfLabel(node: LabeledStatement, beforeUnwrapLabelCallback?: (node: LabeledStatement) => void) {\r\n        while (true) {\r\n            if (beforeUnwrapLabelCallback) {\r\n                beforeUnwrapLabelCallback(node);\r\n            }\r\n            if (node.statement.kind !== SyntaxKind.LabeledStatement) {\r\n                return node.statement;\r\n            }\r\n            node = <LabeledStatement>node.statement;\r\n        }\r\n    }\r\n\r\n    export function isFunctionBlock(node: Node) {\r\n        return node && node.kind === SyntaxKind.Block && isFunctionLike(node.parent);\r\n    }\r\n\r\n    export function isObjectLiteralMethod(node: Node): node is MethodDeclaration {\r\n        return node && node.kind === SyntaxKind.MethodDeclaration && node.parent.kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n    export function isObjectLiteralOrClassExpressionMethod(node: Node): node is MethodDeclaration {\r\n        return node.kind === SyntaxKind.MethodDeclaration &&\r\n            (node.parent.kind === SyntaxKind.ObjectLiteralExpression ||\r\n                node.parent.kind === SyntaxKind.ClassExpression);\r\n    }\r\n\r\n    export function isIdentifierTypePredicate(predicate: TypePredicate): predicate is IdentifierTypePredicate {\r\n        return predicate && predicate.kind === TypePredicateKind.Identifier;\r\n    }\r\n\r\n    export function isThisTypePredicate(predicate: TypePredicate): predicate is ThisTypePredicate {\r\n        return predicate && predicate.kind === TypePredicateKind.This;\r\n    }\r\n\r\n    export function getPropertyAssignment(objectLiteral: ObjectLiteralExpression, key: string, key2?: string): ReadonlyArray<PropertyAssignment> {\r\n        return filter(objectLiteral.properties, (property): property is PropertyAssignment => {\r\n            if (property.kind === SyntaxKind.PropertyAssignment) {\r\n                const propName = getTextOfPropertyName(property.name);\r\n                return key === propName || (key2 && key2 === propName);\r\n            }\r\n        });\r\n    }\r\n\r\n    export function getContainingFunction(node: Node): FunctionLike {\r\n        return findAncestor(node.parent, isFunctionLike);\r\n    }\r\n\r\n    export function getContainingClass(node: Node): ClassLikeDeclaration {\r\n        return findAncestor(node.parent, isClassLike);\r\n    }\r\n\r\n    export function getThisContainer(node: Node, includeArrowFunctions: boolean): Node {\r\n        while (true) {\r\n            node = node.parent;\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            switch (node.kind) {\r\n                case SyntaxKind.ComputedPropertyName:\r\n                    // If the grandparent node is an object literal (as opposed to a class),\r\n                    // then the computed property is not a 'this' container.\r\n                    // A computed property name in a class needs to be a this container\r\n                    // so that we can error on it.\r\n                    if (isClassLike(node.parent.parent)) {\r\n                        return node;\r\n                    }\r\n                    // If this is a computed property, then the parent should not\r\n                    // make it a this container. The parent might be a property\r\n                    // in an object literal, like a method or accessor. But in order for\r\n                    // such a parent to be a this container, the reference must be in\r\n                    // the *body* of the container.\r\n                    node = node.parent;\r\n                    break;\r\n                case SyntaxKind.Decorator:\r\n                    // Decorators are always applied outside of the body of a class or method.\r\n                    if (node.parent.kind === SyntaxKind.Parameter && isClassElement(node.parent.parent)) {\r\n                        // If the decorator's parent is a Parameter, we resolve the this container from\r\n                        // the grandparent class declaration.\r\n                        node = node.parent.parent;\r\n                    }\r\n                    else if (isClassElement(node.parent)) {\r\n                        // If the decorator's parent is a class element, we resolve the 'this' container\r\n                        // from the parent class declaration.\r\n                        node = node.parent;\r\n                    }\r\n                    break;\r\n                case SyntaxKind.ArrowFunction:\r\n                    if (!includeArrowFunctions) {\r\n                        continue;\r\n                    }\r\n                // falls through\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                case SyntaxKind.CallSignature:\r\n                case SyntaxKind.ConstructSignature:\r\n                case SyntaxKind.IndexSignature:\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.SourceFile:\r\n                    return node;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function getNewTargetContainer(node: Node) {\r\n        const container = getThisContainer(node, /*includeArrowFunctions*/ false);\r\n        if (container) {\r\n            switch (container.kind) {\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                    return container;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Given an super call/property node, returns the closest node where\r\n     * - a super call/property access is legal in the node and not legal in the parent node the node.\r\n     *   i.e. super call is legal in constructor but not legal in the class body.\r\n     * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)\r\n     * - a super call/property is definitely illegal in the container (but might be legal in some subnode)\r\n     *   i.e. super property access is illegal in function declaration but can be legal in the statement list\r\n     */\r\n    export function getSuperContainer(node: Node, stopOnFunctions: boolean): Node {\r\n        while (true) {\r\n            node = node.parent;\r\n            if (!node) {\r\n                return node;\r\n            }\r\n            switch (node.kind) {\r\n                case SyntaxKind.ComputedPropertyName:\r\n                    node = node.parent;\r\n                    break;\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    if (!stopOnFunctions) {\r\n                        continue;\r\n                    }\r\n                // falls through\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                    return node;\r\n                case SyntaxKind.Decorator:\r\n                    // Decorators are always applied outside of the body of a class or method.\r\n                    if (node.parent.kind === SyntaxKind.Parameter && isClassElement(node.parent.parent)) {\r\n                        // If the decorator's parent is a Parameter, we resolve the this container from\r\n                        // the grandparent class declaration.\r\n                        node = node.parent.parent;\r\n                    }\r\n                    else if (isClassElement(node.parent)) {\r\n                        // If the decorator's parent is a class element, we resolve the 'this' container\r\n                        // from the parent class declaration.\r\n                        node = node.parent;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function getImmediatelyInvokedFunctionExpression(func: Node): CallExpression {\r\n        if (func.kind === SyntaxKind.FunctionExpression || func.kind === SyntaxKind.ArrowFunction) {\r\n            let prev = func;\r\n            let parent = func.parent;\r\n            while (parent.kind === SyntaxKind.ParenthesizedExpression) {\r\n                prev = parent;\r\n                parent = parent.parent;\r\n            }\r\n            if (parent.kind === SyntaxKind.CallExpression && (parent as CallExpression).expression === prev) {\r\n                return parent as CallExpression;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is a property or element access expression for super.\r\n     */\r\n    export function isSuperProperty(node: Node): node is SuperProperty {\r\n        const kind = node.kind;\r\n        return (kind === SyntaxKind.PropertyAccessExpression || kind === SyntaxKind.ElementAccessExpression)\r\n            && (<PropertyAccessExpression | ElementAccessExpression>node).expression.kind === SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    export function getEntityNameFromTypeNode(node: TypeNode): EntityNameOrEntityNameExpression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.TypeReference:\r\n                return (<TypeReferenceNode>node).typeName;\r\n\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return isEntityNameExpression((<ExpressionWithTypeArguments>node).expression)\r\n                    ? <EntityNameExpression>(<ExpressionWithTypeArguments>node).expression\r\n                    : undefined;\r\n\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.QualifiedName:\r\n                return (<EntityName><Node>node);\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function getInvokedExpression(node: CallLikeExpression): Expression {\r\n        if (node.kind === SyntaxKind.TaggedTemplateExpression) {\r\n            return (<TaggedTemplateExpression>node).tag;\r\n        }\r\n        else if (isJsxOpeningLikeElement(node)) {\r\n            return node.tagName;\r\n        }\r\n\r\n        // Will either be a CallExpression, NewExpression, or Decorator.\r\n        return (<CallExpression | Decorator>node).expression;\r\n    }\r\n\r\n    export function nodeCanBeDecorated(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ClassDeclaration:\r\n                // classes are valid targets\r\n                return true;\r\n\r\n            case SyntaxKind.PropertyDeclaration:\r\n                // property declarations are valid if their parent is a class declaration.\r\n                return node.parent.kind === SyntaxKind.ClassDeclaration;\r\n\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.MethodDeclaration:\r\n                // if this method has a body and its parent is a class declaration, this is a valid target.\r\n                return (<FunctionLikeDeclaration>node).body !== undefined\r\n                    && node.parent.kind === SyntaxKind.ClassDeclaration;\r\n\r\n            case SyntaxKind.Parameter:\r\n                // if the parameter's parent has a body and its grandparent is a class declaration, this is a valid target;\r\n                return (<FunctionLikeDeclaration>node.parent).body !== undefined\r\n                    && (node.parent.kind === SyntaxKind.Constructor\r\n                        || node.parent.kind === SyntaxKind.MethodDeclaration\r\n                        || node.parent.kind === SyntaxKind.SetAccessor)\r\n                    && node.parent.parent.kind === SyntaxKind.ClassDeclaration;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function nodeIsDecorated(node: Node): boolean {\r\n        return node.decorators !== undefined\r\n            && nodeCanBeDecorated(node);\r\n    }\r\n\r\n    export function nodeOrChildIsDecorated(node: Node): boolean {\r\n        return nodeIsDecorated(node) || childIsDecorated(node);\r\n    }\r\n\r\n    export function childIsDecorated(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ClassDeclaration:\r\n                return forEach((<ClassDeclaration>node).members, nodeOrChildIsDecorated);\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.SetAccessor:\r\n                return forEach((<FunctionLikeDeclaration>node).parameters, nodeIsDecorated);\r\n        }\r\n    }\r\n\r\n    export function isJSXTagName(node: Node) {\r\n        const parent = node.parent;\r\n        if (parent.kind === SyntaxKind.JsxOpeningElement ||\r\n            parent.kind === SyntaxKind.JsxSelfClosingElement ||\r\n            parent.kind === SyntaxKind.JsxClosingElement) {\r\n            return (<JsxOpeningLikeElement>parent).tagName === node;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isPartOfExpression(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.NonNullExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.BinaryExpression:\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.SpreadElement:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.OmittedExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.YieldExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.MetaProperty:\r\n                return true;\r\n            case SyntaxKind.QualifiedName:\r\n                while (node.parent.kind === SyntaxKind.QualifiedName) {\r\n                    node = node.parent;\r\n                }\r\n                return node.parent.kind === SyntaxKind.TypeQuery || isJSXTagName(node);\r\n            case SyntaxKind.Identifier:\r\n                if (node.parent.kind === SyntaxKind.TypeQuery || isJSXTagName(node)) {\r\n                    return true;\r\n                }\r\n            // falls through\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.ThisKeyword:\r\n                return isInExpressionContext(node);\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isInExpressionContext(node: Node): boolean {\r\n        const parent = node.parent;\r\n        switch (parent.kind) {\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.BindingElement:\r\n                return (<VariableLikeDeclaration>parent).initializer === node;\r\n            case SyntaxKind.ExpressionStatement:\r\n            case SyntaxKind.IfStatement:\r\n            case SyntaxKind.DoStatement:\r\n            case SyntaxKind.WhileStatement:\r\n            case SyntaxKind.ReturnStatement:\r\n            case SyntaxKind.WithStatement:\r\n            case SyntaxKind.SwitchStatement:\r\n            case SyntaxKind.CaseClause:\r\n            case SyntaxKind.ThrowStatement:\r\n                return (<ExpressionStatement>parent).expression === node;\r\n            case SyntaxKind.ForStatement:\r\n                const forStatement = <ForStatement>parent;\r\n                return (forStatement.initializer === node && forStatement.initializer.kind !== SyntaxKind.VariableDeclarationList) ||\r\n                    forStatement.condition === node ||\r\n                    forStatement.incrementor === node;\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n                const forInStatement = <ForInStatement | ForOfStatement>parent;\r\n                return (forInStatement.initializer === node && forInStatement.initializer.kind !== SyntaxKind.VariableDeclarationList) ||\r\n                    forInStatement.expression === node;\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.AsExpression:\r\n                return node === (<AssertionExpression>parent).expression;\r\n            case SyntaxKind.TemplateSpan:\r\n                return node === (<TemplateSpan>parent).expression;\r\n            case SyntaxKind.ComputedPropertyName:\r\n                return node === (<ComputedPropertyName>parent).expression;\r\n            case SyntaxKind.Decorator:\r\n            case SyntaxKind.JsxExpression:\r\n            case SyntaxKind.JsxSpreadAttribute:\r\n            case SyntaxKind.SpreadAssignment:\r\n                return true;\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return (<ExpressionWithTypeArguments>parent).expression === node && isExpressionWithTypeArgumentsInClassExtendsClause(parent);\r\n            default:\r\n                return isPartOfExpression(parent);\r\n        }\r\n    }\r\n\r\n    export function isExternalModuleImportEqualsDeclaration(node: Node) {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind === SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    export function getExternalModuleImportEqualsDeclarationExpression(node: Node) {\r\n        Debug.assert(isExternalModuleImportEqualsDeclaration(node));\r\n        return (<ExternalModuleReference>(<ImportEqualsDeclaration>node).moduleReference).expression;\r\n    }\r\n\r\n    export function isInternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind !== SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    export function isSourceFileJavaScript(file: SourceFile): boolean {\r\n        return isInJavaScriptFile(file);\r\n    }\r\n\r\n    export function isInJavaScriptFile(node: Node | undefined): boolean {\r\n        return node && !!(node.flags & NodeFlags.JavaScriptFile);\r\n    }\r\n\r\n    export function isInJSDoc(node: Node | undefined): boolean {\r\n        return node && !!(node.flags & NodeFlags.JSDoc);\r\n    }\r\n\r\n    export function isJSDocIndexSignature(node: TypeReferenceNode | ExpressionWithTypeArguments) {\r\n        return isTypeReferenceNode(node) &&\r\n            isIdentifier(node.typeName) &&\r\n            node.typeName.escapedText === \"Object\" &&\r\n            node.typeArguments && node.typeArguments.length === 2 &&\r\n            (node.typeArguments[0].kind === SyntaxKind.StringKeyword || node.typeArguments[0].kind === SyntaxKind.NumberKeyword);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the node is a CallExpression to the identifier 'require' with\r\n     * exactly one argument (of the form 'require(\"name\")').\r\n     * This function does not test if the node is in a JavaScript file or not.\r\n     */\r\n    export function isRequireCall(callExpression: Node, checkArgumentIsStringLiteral: boolean): callExpression is CallExpression {\r\n        if (callExpression.kind !== SyntaxKind.CallExpression) {\r\n            return false;\r\n        }\r\n        const { expression, arguments: args } = callExpression as CallExpression;\r\n\r\n        if (expression.kind !== SyntaxKind.Identifier || ((expression as Identifier).escapedText !== \"require\" && (expression as Identifier).escapedText !== \"需要\")) {\r\n            return false;\r\n        }\r\n\r\n        if (args.length !== 1) {\r\n            return false;\r\n        }\r\n        const arg = args[0];\r\n        return !checkArgumentIsStringLiteral || arg.kind === SyntaxKind.StringLiteral || arg.kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    export function isSingleOrDoubleQuote(charCode: number) {\r\n        return charCode === CharacterCodes.singleQuote || charCode === CharacterCodes.doubleQuote;\r\n    }\r\n\r\n    export function isStringDoubleQuoted(string: StringLiteral, sourceFile: SourceFile): boolean {\r\n        return getSourceTextOfNodeFromSourceFile(sourceFile, string).charCodeAt(0) === CharacterCodes.doubleQuote;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the node is a variable declaration whose initializer is a function expression.\r\n     * This function does not test if the node is in a JavaScript file or not.\r\n     */\r\n    export function isDeclarationOfFunctionOrClassExpression(s: Symbol) {\r\n        if (s.valueDeclaration && s.valueDeclaration.kind === SyntaxKind.VariableDeclaration) {\r\n            const declaration = s.valueDeclaration as VariableDeclaration;\r\n            return declaration.initializer && (declaration.initializer.kind === SyntaxKind.FunctionExpression || declaration.initializer.kind === SyntaxKind.ClassExpression);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getRightMostAssignedExpression(node: Node) {\r\n        while (isAssignmentExpression(node, /*excludeCompoundAssignements*/ true)) {\r\n            node = node.right;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function isExportsIdentifier(node: Node) {\r\n        return isIdentifier(node) && node.escapedText === \"exports\";\r\n    }\r\n\r\n    export function isModuleExportsPropertyAccessExpression(node: Node) {\r\n        return isPropertyAccessExpression(node) && isIdentifier(node.expression) && node.expression.escapedText === \"module\" && node.name.escapedText === \"exports\";\r\n    }\r\n\r\n    /// Given a BinaryExpression, returns SpecialPropertyAssignmentKind for the various kinds of property\r\n    /// assignments we treat as special in the binder\r\n    export function getSpecialPropertyAssignmentKind(expr: ts.BinaryExpression): SpecialPropertyAssignmentKind {\r\n        if (!isInJavaScriptFile(expr)) {\r\n            return SpecialPropertyAssignmentKind.None;\r\n        }\r\n        if (expr.operatorToken.kind !== SyntaxKind.EqualsToken || expr.left.kind !== SyntaxKind.PropertyAccessExpression) {\r\n            return SpecialPropertyAssignmentKind.None;\r\n        }\r\n        const lhs = <PropertyAccessExpression>expr.left;\r\n        if (lhs.expression.kind === SyntaxKind.Identifier) {\r\n            const lhsId = <Identifier>lhs.expression;\r\n            if (lhsId.escapedText === \"exports\") {\r\n                // exports.name = expr\r\n                return SpecialPropertyAssignmentKind.ExportsProperty;\r\n            }\r\n            else if (lhsId.escapedText === \"module\" && lhs.name.escapedText === \"exports\") {\r\n                // module.exports = expr\r\n                return SpecialPropertyAssignmentKind.ModuleExports;\r\n            }\r\n            else {\r\n                // F.x = expr\r\n                return SpecialPropertyAssignmentKind.Property;\r\n            }\r\n        }\r\n        else if (lhs.expression.kind === SyntaxKind.ThisKeyword) {\r\n            return SpecialPropertyAssignmentKind.ThisProperty;\r\n        }\r\n        else if (lhs.expression.kind === SyntaxKind.PropertyAccessExpression) {\r\n            // chained dot, e.g. x.y.z = expr; this var is the 'x.y' part\r\n            const innerPropertyAccess = <PropertyAccessExpression>lhs.expression;\r\n            if (innerPropertyAccess.expression.kind === SyntaxKind.Identifier) {\r\n                // module.exports.name = expr\r\n                const innerPropertyAccessIdentifier = <Identifier>innerPropertyAccess.expression;\r\n                if (innerPropertyAccessIdentifier.escapedText === \"module\" && innerPropertyAccess.name.escapedText === \"exports\") {\r\n                    return SpecialPropertyAssignmentKind.ExportsProperty;\r\n                }\r\n                if (innerPropertyAccess.name.escapedText === \"prototype\") {\r\n                    return SpecialPropertyAssignmentKind.PrototypeProperty;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return SpecialPropertyAssignmentKind.None;\r\n    }\r\n\r\n    export function getExternalModuleName(node: Node): Expression {\r\n        if (node.kind === SyntaxKind.ImportDeclaration) {\r\n            return (<ImportDeclaration>node).moduleSpecifier;\r\n        }\r\n        if (node.kind === SyntaxKind.ImportEqualsDeclaration) {\r\n            const reference = (<ImportEqualsDeclaration>node).moduleReference;\r\n            if (reference.kind === SyntaxKind.ExternalModuleReference) {\r\n                return (<ExternalModuleReference>reference).expression;\r\n            }\r\n        }\r\n        if (node.kind === SyntaxKind.ExportDeclaration) {\r\n            return (<ExportDeclaration>node).moduleSpecifier;\r\n        }\r\n        if (isModuleWithStringLiteralName(node)) {\r\n            return node.name;\r\n        }\r\n    }\r\n\r\n    export function getNamespaceDeclarationNode(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): ImportEqualsDeclaration | NamespaceImport {\r\n        if (node.kind === SyntaxKind.ImportEqualsDeclaration) {\r\n            return <ImportEqualsDeclaration>node;\r\n        }\r\n\r\n        const importClause = (<ImportDeclaration>node).importClause;\r\n        if (importClause && importClause.namedBindings && importClause.namedBindings.kind === SyntaxKind.NamespaceImport) {\r\n            return <NamespaceImport>importClause.namedBindings;\r\n        }\r\n    }\r\n\r\n    export function isDefaultImport(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration) {\r\n        return node.kind === SyntaxKind.ImportDeclaration\r\n            && (<ImportDeclaration>node).importClause\r\n            && !!(<ImportDeclaration>node).importClause.name;\r\n    }\r\n\r\n    export function hasQuestionToken(node: Node) {\r\n        if (node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                case SyntaxKind.PropertyAssignment:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                    return (<ParameterDeclaration | MethodDeclaration | PropertyDeclaration>node).questionToken !== undefined;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isJSDocConstructSignature(node: Node) {\r\n        return node.kind === SyntaxKind.JSDocFunctionType &&\r\n            (node as JSDocFunctionType).parameters.length > 0 &&\r\n            (node as JSDocFunctionType).parameters[0].name &&\r\n            ((node as JSDocFunctionType).parameters[0].name as Identifier).escapedText === \"new\";\r\n    }\r\n\r\n    export function getAllJSDocs(node: Node): (JSDoc | JSDocTag)[] {\r\n        if (isJSDocTypedefTag(node)) {\r\n            return [node.parent];\r\n        }\r\n        return getJSDocCommentsAndTags(node);\r\n    }\r\n\r\n    export function getSourceOfAssignment(node: Node): Node {\r\n        return isExpressionStatement(node) &&\r\n            node.expression && isBinaryExpression(node.expression) &&\r\n            node.expression.operatorToken.kind === SyntaxKind.EqualsToken &&\r\n            node.expression.right;\r\n    }\r\n\r\n    export function getSingleInitializerOfVariableStatement(node: Node, child?: Node): Node {\r\n        return isVariableStatement(node) &&\r\n            node.declarationList.declarations.length > 0 &&\r\n            (!child || node.declarationList.declarations[0].initializer === child) &&\r\n            node.declarationList.declarations[0].initializer;\r\n    }\r\n\r\n    export function getSingleVariableOfVariableStatement(node: Node, child?: Node): Node {\r\n        return isVariableStatement(node) &&\r\n            node.declarationList.declarations.length > 0 &&\r\n            (!child || node.declarationList.declarations[0] === child) &&\r\n            node.declarationList.declarations[0];\r\n    }\r\n\r\n    export function getNestedModuleDeclaration(node: Node): Node {\r\n        return node.kind === SyntaxKind.ModuleDeclaration &&\r\n            (node as ModuleDeclaration).body &&\r\n            (node as ModuleDeclaration).body.kind === SyntaxKind.ModuleDeclaration &&\r\n            (node as ModuleDeclaration).body;\r\n    }\r\n\r\n    export function getJSDocCommentsAndTags(node: Node): (JSDoc | JSDocTag)[] {\r\n        let result: (JSDoc | JSDocTag)[] | undefined;\r\n        getJSDocCommentsAndTagsWorker(node);\r\n        return result || emptyArray;\r\n\r\n        function getJSDocCommentsAndTagsWorker(node: Node): void {\r\n            const parent = node.parent;\r\n            // Try to recognize this pattern when node is initializer of variable declaration and JSDoc comments are on containing variable statement.\r\n            // /**\r\n            //   * @param {number} name\r\n            //   * @returns {number}\r\n            //   */\r\n            // var x = function(name) { return name.length; }\r\n            if (parent && (parent.kind === SyntaxKind.PropertyAssignment || getNestedModuleDeclaration(parent))) {\r\n                getJSDocCommentsAndTagsWorker(parent);\r\n            }\r\n            if (parent && parent.parent &&\r\n                (getSingleVariableOfVariableStatement(parent.parent, node) || getSourceOfAssignment(parent.parent))) {\r\n                getJSDocCommentsAndTagsWorker(parent.parent);\r\n            }\r\n            if (parent && parent.parent && parent.parent.parent && getSingleInitializerOfVariableStatement(parent.parent.parent, node)) {\r\n                getJSDocCommentsAndTagsWorker(parent.parent.parent);\r\n            }\r\n\r\n            // Pull parameter comments from declaring function as well\r\n            if (node.kind === SyntaxKind.Parameter) {\r\n                result = addRange(result, getJSDocParameterTags(node as ParameterDeclaration));\r\n            }\r\n\r\n            if (isVariableLike(node) && node.initializer && hasJSDocNodes(node.initializer)) {\r\n                result = addRange(result, node.initializer.jsDoc);\r\n            }\r\n\r\n            if (hasJSDocNodes(node)) {\r\n                result = addRange(result, node.jsDoc);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it. */\r\n    export function getParameterSymbolFromJSDoc(node: JSDocParameterTag): Symbol | undefined {\r\n        if (node.symbol) {\r\n            return node.symbol;\r\n        }\r\n        if (!isIdentifier(node.name)) {\r\n            return undefined;\r\n        }\r\n        const name = node.name.escapedText;\r\n        const host = getJSDocHost(node);\r\n        const decl = getSourceOfAssignment(host) ||\r\n            getSingleInitializerOfVariableStatement(host) ||\r\n            getSingleVariableOfVariableStatement(host) ||\r\n            getNestedModuleDeclaration(host) ||\r\n            host;\r\n        if (decl && isFunctionLike(decl)) {\r\n            const parameter = find(decl.parameters, p => p.name.kind === SyntaxKind.Identifier && p.name.escapedText === name);\r\n            return parameter && parameter.symbol;\r\n        }\r\n    }\r\n\r\n    export function getJSDocHost(node: JSDocTag): HasJSDoc {\r\n        Debug.assert(node.parent!.kind === SyntaxKind.JSDocComment);\r\n        return node.parent!.parent!;\r\n    }\r\n\r\n    export function getTypeParameterFromJsDoc(node: TypeParameterDeclaration & { parent: JSDocTemplateTag }): TypeParameterDeclaration | undefined {\r\n        const name = node.name.escapedText;\r\n        const { typeParameters } = (node.parent.parent.parent as ts.SignatureDeclaration | ts.InterfaceDeclaration | ts.ClassDeclaration);\r\n        return find(typeParameters, p => p.name.escapedText === name);\r\n    }\r\n\r\n    export function hasRestParameter(s: SignatureDeclaration): boolean {\r\n        const last = lastOrUndefined(s.parameters);\r\n        return last && isRestParameter(last);\r\n    }\r\n\r\n    export function isRestParameter(node: ParameterDeclaration): boolean {\r\n        return node.dotDotDotToken !== undefined;\r\n    }\r\n\r\n    export const enum AssignmentKind {\r\n        None, Definite, Compound\r\n    }\r\n\r\n    export function getAssignmentTargetKind(node: Node): AssignmentKind {\r\n        let parent = node.parent;\r\n        while (true) {\r\n            switch (parent.kind) {\r\n                case SyntaxKind.BinaryExpression:\r\n                    const binaryOperator = (<BinaryExpression>parent).operatorToken.kind;\r\n                    return isAssignmentOperator(binaryOperator) && (<BinaryExpression>parent).left === node ?\r\n                        binaryOperator === SyntaxKind.EqualsToken ? AssignmentKind.Definite : AssignmentKind.Compound :\r\n                        AssignmentKind.None;\r\n                case SyntaxKind.PrefixUnaryExpression:\r\n                case SyntaxKind.PostfixUnaryExpression:\r\n                    const unaryOperator = (<PrefixUnaryExpression | PostfixUnaryExpression>parent).operator;\r\n                    return unaryOperator === SyntaxKind.PlusPlusToken || unaryOperator === SyntaxKind.MinusMinusToken ? AssignmentKind.Compound : AssignmentKind.None;\r\n                case SyntaxKind.ForInStatement:\r\n                case SyntaxKind.ForOfStatement:\r\n                    return (<ForInOrOfStatement>parent).initializer === node ? AssignmentKind.Definite : AssignmentKind.None;\r\n                case SyntaxKind.ParenthesizedExpression:\r\n                case SyntaxKind.ArrayLiteralExpression:\r\n                case SyntaxKind.SpreadElement:\r\n                    node = parent;\r\n                    break;\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                    if ((parent as ShorthandPropertyAssignment).name !== node) {\r\n                        return AssignmentKind.None;\r\n                    }\r\n                    node = parent.parent;\r\n                    break;\r\n                case SyntaxKind.PropertyAssignment:\r\n                    if ((parent as ShorthandPropertyAssignment).name === node) {\r\n                        return AssignmentKind.None;\r\n                    }\r\n                    node = parent.parent;\r\n                    break;\r\n                default:\r\n                    return AssignmentKind.None;\r\n            }\r\n            parent = node.parent;\r\n        }\r\n    }\r\n\r\n    // A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property\r\n    // assignment in an object literal that is an assignment target, or if it is parented by an array literal that is\r\n    // an assignment target. Examples include 'a = xxx', '{ p: a } = xxx', '[{ a }] = xxx'.\r\n    // (Note that `p` is not a target in the above examples, only `a`.)\r\n    export function isAssignmentTarget(node: Node): boolean {\r\n        return getAssignmentTargetKind(node) !== AssignmentKind.None;\r\n    }\r\n\r\n    // a node is delete target iff. it is PropertyAccessExpression/ElementAccessExpression with parentheses skipped\r\n    export function isDeleteTarget(node: Node): boolean {\r\n        if (node.kind !== SyntaxKind.PropertyAccessExpression && node.kind !== SyntaxKind.ElementAccessExpression) {\r\n            return false;\r\n        }\r\n        node = node.parent;\r\n        while (node && node.kind === SyntaxKind.ParenthesizedExpression) {\r\n            node = node.parent;\r\n        }\r\n        return node && node.kind === SyntaxKind.DeleteExpression;\r\n    }\r\n\r\n    export function isNodeDescendantOf(node: Node, ancestor: Node): boolean {\r\n        while (node) {\r\n            if (node === ancestor) return true;\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isInAmbientContext(node: Node): boolean {\r\n        while (node) {\r\n            if (hasModifier(node, ModifierFlags.Ambient) || (node.kind === SyntaxKind.SourceFile && (node as SourceFile).isDeclarationFile)) {\r\n                return true;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // True if the given identifier, string literal, or number literal is the name of a declaration node\r\n    export function isDeclarationName(name: Node): boolean {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                return isDeclaration(name.parent) && name.parent.name === name;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    // See GH#16030\r\n    export function isAnyDeclarationName(name: Node): boolean {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                if (isDeclaration(name.parent)) {\r\n                    return name.parent.name === name;\r\n                }\r\n                const binExp = name.parent.parent;\r\n                return isBinaryExpression(binExp) && getSpecialPropertyAssignmentKind(binExp) !== SpecialPropertyAssignmentKind.None && getNameOfDeclaration(binExp) === name;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isLiteralComputedPropertyDeclarationName(node: Node) {\r\n        return (node.kind === SyntaxKind.StringLiteral || node.kind === SyntaxKind.NumericLiteral) &&\r\n            node.parent.kind === SyntaxKind.ComputedPropertyName &&\r\n            isDeclaration(node.parent.parent);\r\n    }\r\n\r\n    // Return true if the given identifier is classified as an IdentifierName\r\n    export function isIdentifierName(node: Identifier): boolean {\r\n        let parent = node.parent;\r\n        switch (parent.kind) {\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                // Name in member declaration or property name in property access\r\n                return (<NamedDeclaration | PropertyAccessExpression>parent).name === node;\r\n            case SyntaxKind.QualifiedName:\r\n                // Name on right hand side of dot in a type query\r\n                if ((<QualifiedName>parent).right === node) {\r\n                    while (parent.kind === SyntaxKind.QualifiedName) {\r\n                        parent = parent.parent;\r\n                    }\r\n                    return parent.kind === SyntaxKind.TypeQuery;\r\n                }\r\n                return false;\r\n            case SyntaxKind.BindingElement:\r\n            case SyntaxKind.ImportSpecifier:\r\n                // Property name in binding element or import specifier\r\n                return (<BindingElement | ImportSpecifier>parent).propertyName === node;\r\n            case SyntaxKind.ExportSpecifier:\r\n            case SyntaxKind.JsxAttribute:\r\n                // Any name in an export specifier or JSX Attribute\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // An alias symbol is created by one of the following declarations:\r\n    // import <symbol> = ...\r\n    // import <symbol> from ...\r\n    // import * as <symbol> from ...\r\n    // import { x as <symbol> } from ...\r\n    // export { x as <symbol> } from ...\r\n    // export = <EntityNameExpression>\r\n    // export default <EntityNameExpression>\r\n    export function isAliasSymbolDeclaration(node: Node): boolean {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration ||\r\n            node.kind === SyntaxKind.NamespaceExportDeclaration ||\r\n            node.kind === SyntaxKind.ImportClause && !!(<ImportClause>node).name ||\r\n            node.kind === SyntaxKind.NamespaceImport ||\r\n            node.kind === SyntaxKind.ImportSpecifier ||\r\n            node.kind === SyntaxKind.ExportSpecifier ||\r\n            node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(<ExportAssignment>node);\r\n    }\r\n\r\n    export function exportAssignmentIsAlias(node: ExportAssignment): boolean {\r\n        return isEntityNameExpression(node.expression);\r\n    }\r\n\r\n    export function getClassExtendsHeritageClauseElement(node: ClassLikeDeclaration | InterfaceDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ExtendsKeyword);\r\n        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;\r\n    }\r\n\r\n    export function getClassImplementsHeritageClauseElements(node: ClassLikeDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ImplementsKeyword);\r\n        return heritageClause ? heritageClause.types : undefined;\r\n    }\r\n\r\n    export function getInterfaceBaseTypeNodes(node: InterfaceDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ExtendsKeyword);\r\n        return heritageClause ? heritageClause.types : undefined;\r\n    }\r\n\r\n    export function getHeritageClause(clauses: NodeArray<HeritageClause>, kind: SyntaxKind) {\r\n        if (clauses) {\r\n            for (const clause of clauses) {\r\n                if (clause.token === kind) {\r\n                    return clause;\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function tryResolveScriptReference(host: ScriptReferenceHost, sourceFile: SourceFile, reference: FileReference) {\r\n        if (!host.getCompilerOptions().noResolve) {\r\n            const referenceFileName = isRootedDiskPath(reference.fileName) ? reference.fileName : combinePaths(getDirectoryPath(sourceFile.fileName), reference.fileName);\r\n            return host.getSourceFile(referenceFileName);\r\n        }\r\n    }\r\n\r\n    export function getAncestor(node: Node | undefined, kind: SyntaxKind): Node | undefined {\r\n        while (node) {\r\n            if (node.kind === kind) {\r\n                return node;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function getFileReferenceFromReferencePath(comment: string, commentRange: CommentRange): ReferencePathMatchResult {\r\n        const simpleReferenceRegEx = /^\\/\\/\\/\\s*<reference\\s+/gim;\r\n        const simpleReferenceRegExCH = /^\\/\\/\\/\\s*<引用\\s+/gim;\r\n        const isNoDefaultLibRegEx = new RegExp(defaultLibReferenceRegEx.source, \"gim\");\r\n        const isNoDefaultLibRegExCH = new RegExp(defaultLibReferenceRegExCH.source, \"gim\");\r\n        if (simpleReferenceRegEx.test(comment) || simpleReferenceRegExCH.test(comment)) {\r\n            if (isNoDefaultLibRegEx.test(comment) || isNoDefaultLibRegExCH.test(comment)) {\r\n                return { isNoDefaultLib: true };\r\n            }\r\n            else {\r\n                const refMatchResult = fullTripleSlashReferencePathRegEx.exec(comment) || fullTripleSlashReferencePathRegExCH.exec(comment);\r\n                const refLibResult = !refMatchResult && (fullTripleSlashReferenceTypeReferenceDirectiveRegEx.exec(comment) || fullTripleSlashReferenceTypeReferenceDirectiveRegExCH.exec(comment));\r\n                const match = refMatchResult || refLibResult;\r\n                if (match) {\r\n                    const pos = commentRange.pos + match[1].length + match[2].length;\r\n                    return {\r\n                        fileReference: {\r\n                            pos,\r\n                            end: pos + match[3].length,\r\n                            fileName: match[3]\r\n                        },\r\n                        isNoDefaultLib: false,\r\n                        isTypeReferenceDirective: !!refLibResult\r\n                    };\r\n                }\r\n\r\n                return {\r\n                    diagnosticMessage: Diagnostics.Invalid_reference_directive_syntax,\r\n                    isNoDefaultLib: false\r\n                };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function isKeyword(token: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstKeyword <= token && token <= SyntaxKind.LastKeyword;\r\n    }\r\n\r\n    export function isTrivia(token: SyntaxKind) {\r\n        return SyntaxKind.FirstTriviaToken <= token && token <= SyntaxKind.LastTriviaToken;\r\n    }\r\n\r\n    export const enum FunctionFlags {\r\n        Normal = 0,             // Function is a normal function\r\n        Generator = 1 << 0,     // Function is a generator function or async generator function\r\n        Async = 1 << 1,         // Function is an async function or an async generator function\r\n        Invalid = 1 << 2,       // Function is a signature or overload and does not have a body.\r\n        AsyncGenerator = Async | Generator, // Function is an async generator function\r\n    }\r\n\r\n    export function getFunctionFlags(node: FunctionLike | undefined) {\r\n        if (!node) {\r\n            return FunctionFlags.Invalid;\r\n        }\r\n\r\n        let flags = FunctionFlags.Normal;\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.MethodDeclaration:\r\n                if (node.asteriskToken) {\r\n                    flags |= FunctionFlags.Generator;\r\n                }\r\n            // falls through\r\n            case SyntaxKind.ArrowFunction:\r\n                if (hasModifier(node, ModifierFlags.Async)) {\r\n                    flags |= FunctionFlags.Async;\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (!(node as FunctionLikeDeclaration).body) {\r\n            flags |= FunctionFlags.Invalid;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    export function isAsyncFunction(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.MethodDeclaration:\r\n                return (<FunctionLikeDeclaration>node).body !== undefined\r\n                    && (<FunctionLikeDeclaration>node).asteriskToken === undefined\r\n                    && hasModifier(node, ModifierFlags.Async);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isStringOrNumericLiteral(node: Node): node is StringLiteral | NumericLiteral {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.NumericLiteral;\r\n    }\r\n\r\n    /**\r\n     * A declaration has a dynamic name if both of the following are true:\r\n     *   1. The declaration has a computed property name\r\n     *   2. The computed name is *not* expressed as Symbol.<name>, where name\r\n     *      is a property of the Symbol constructor that denotes a built in\r\n     *      Symbol.\r\n     */\r\n    export function hasDynamicName(declaration: Declaration): boolean {\r\n        const name = getNameOfDeclaration(declaration);\r\n        return name && isDynamicName(name);\r\n    }\r\n\r\n    export function isDynamicName(name: DeclarationName): boolean {\r\n        return name.kind === SyntaxKind.ComputedPropertyName &&\r\n            !isStringOrNumericLiteral((<ComputedPropertyName>name).expression) &&\r\n            !isWellKnownSymbolSyntactically((<ComputedPropertyName>name).expression);\r\n    }\r\n\r\n    /**\r\n     * Checks if the expression is of the form:\r\n     *    Symbol.name\r\n     * where Symbol is literally the word \"Symbol\", and name is any identifierName\r\n     */\r\n    export function isWellKnownSymbolSyntactically(node: Expression): boolean {\r\n        return isPropertyAccessExpression(node) && isESSymbolIdentifier(node.expression);\r\n    }\r\n\r\n    export function getPropertyNameForPropertyNameNode(name: DeclarationName): __String {\r\n        if (name.kind === SyntaxKind.Identifier) {\r\n            return name.escapedText;\r\n        }\r\n        if (name.kind === SyntaxKind.StringLiteral || name.kind === SyntaxKind.NumericLiteral) {\r\n            return escapeLeadingUnderscores(name.text);\r\n        }\r\n        if (name.kind === SyntaxKind.ComputedPropertyName) {\r\n            const nameExpression = name.expression;\r\n            if (isWellKnownSymbolSyntactically(nameExpression)) {\r\n                return getPropertyNameForKnownSymbolName(idText((<PropertyAccessExpression>nameExpression).name));\r\n            }\r\n            else if (nameExpression.kind === SyntaxKind.StringLiteral || nameExpression.kind === SyntaxKind.NumericLiteral) {\r\n                return escapeLeadingUnderscores((<LiteralExpression>nameExpression).text);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function getTextOfIdentifierOrLiteral(node: Identifier | LiteralLikeNode) {\r\n        if (node) {\r\n            if (node.kind === SyntaxKind.Identifier) {\r\n                return idText(node as Identifier);\r\n            }\r\n            if (node.kind === SyntaxKind.StringLiteral ||\r\n                node.kind === SyntaxKind.NumericLiteral) {\r\n                return (node as LiteralLikeNode).text;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function getEscapedTextOfIdentifierOrLiteral(node: Identifier | LiteralLikeNode) {\r\n        if (node) {\r\n            if (node.kind === SyntaxKind.Identifier) {\r\n                return (node as Identifier).escapedText;\r\n            }\r\n            if (node.kind === SyntaxKind.StringLiteral ||\r\n                node.kind === SyntaxKind.NumericLiteral) {\r\n\r\n                return escapeLeadingUnderscores((node as LiteralLikeNode).text);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function getPropertyNameForKnownSymbolName(symbolName: string): __String {\r\n        return \"__@\" + symbolName as __String;\r\n    }\r\n\r\n    /**\r\n     * Includes the word \"Symbol\" with unicode escapes\r\n     */\r\n    export function isESSymbolIdentifier(node: Node): boolean {\r\n        return node.kind === SyntaxKind.Identifier && (<Identifier>node).escapedText === \"Symbol\";\r\n    }\r\n\r\n    export function isPushOrUnshiftIdentifier(node: Identifier) {\r\n        return node.escapedText === \"push\" || node.escapedText === \"unshift\";\r\n    }\r\n\r\n    export function isParameterDeclaration(node: VariableLikeDeclaration) {\r\n        const root = getRootDeclaration(node);\r\n        return root.kind === SyntaxKind.Parameter;\r\n    }\r\n\r\n    export function getRootDeclaration(node: Node): Node {\r\n        while (node.kind === SyntaxKind.BindingElement) {\r\n            node = node.parent.parent;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function nodeStartsNewLexicalEnvironment(node: Node): boolean {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.FunctionExpression\r\n            || kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.ArrowFunction\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.SourceFile;\r\n    }\r\n\r\n    export function nodeIsSynthesized(range: TextRange): boolean {\r\n        return positionIsSynthesized(range.pos)\r\n            || positionIsSynthesized(range.end);\r\n    }\r\n\r\n    export function getOriginalSourceFile(sourceFile: SourceFile) {\r\n        return getParseTreeNode(sourceFile, isSourceFile) || sourceFile;\r\n    }\r\n\r\n    export const enum Associativity {\r\n        Left,\r\n        Right\r\n    }\r\n\r\n    export function getExpressionAssociativity(expression: Expression) {\r\n        const operator = getOperator(expression);\r\n        const hasArguments = expression.kind === SyntaxKind.NewExpression && (<NewExpression>expression).arguments !== undefined;\r\n        return getOperatorAssociativity(expression.kind, operator, hasArguments);\r\n    }\r\n\r\n    export function getOperatorAssociativity(kind: SyntaxKind, operator: SyntaxKind, hasArguments?: boolean) {\r\n        switch (kind) {\r\n            case SyntaxKind.NewExpression:\r\n                return hasArguments ? Associativity.Left : Associativity.Right;\r\n\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.YieldExpression:\r\n                return Associativity.Right;\r\n\r\n            case SyntaxKind.BinaryExpression:\r\n                switch (operator) {\r\n                    case SyntaxKind.AsteriskAsteriskToken:\r\n                    case SyntaxKind.EqualsToken:\r\n                    case SyntaxKind.PlusEqualsToken:\r\n                    case SyntaxKind.MinusEqualsToken:\r\n                    case SyntaxKind.AsteriskAsteriskEqualsToken:\r\n                    case SyntaxKind.AsteriskEqualsToken:\r\n                    case SyntaxKind.SlashEqualsToken:\r\n                    case SyntaxKind.PercentEqualsToken:\r\n                    case SyntaxKind.LessThanLessThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.AmpersandEqualsToken:\r\n                    case SyntaxKind.CaretEqualsToken:\r\n                    case SyntaxKind.BarEqualsToken:\r\n                        return Associativity.Right;\r\n                }\r\n        }\r\n        return Associativity.Left;\r\n    }\r\n\r\n    export function getExpressionPrecedence(expression: Expression) {\r\n        const operator = getOperator(expression);\r\n        const hasArguments = expression.kind === SyntaxKind.NewExpression && (<NewExpression>expression).arguments !== undefined;\r\n        return getOperatorPrecedence(expression.kind, operator, hasArguments);\r\n    }\r\n\r\n    export function getOperator(expression: Expression) {\r\n        if (expression.kind === SyntaxKind.BinaryExpression) {\r\n            return (<BinaryExpression>expression).operatorToken.kind;\r\n        }\r\n        else if (expression.kind === SyntaxKind.PrefixUnaryExpression || expression.kind === SyntaxKind.PostfixUnaryExpression) {\r\n            return (<PrefixUnaryExpression | PostfixUnaryExpression>expression).operator;\r\n        }\r\n        else {\r\n            return expression.kind;\r\n        }\r\n    }\r\n\r\n    export function getOperatorPrecedence(nodeKind: SyntaxKind, operatorKind: SyntaxKind, hasArguments?: boolean) {\r\n        switch (nodeKind) {\r\n            case SyntaxKind.ThisKeyword:\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.OmittedExpression:\r\n                return 19;\r\n\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n                return 18;\r\n\r\n            case SyntaxKind.NewExpression:\r\n                return hasArguments ? 18 : 17;\r\n\r\n            case SyntaxKind.CallExpression:\r\n                return 17;\r\n\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return 16;\r\n\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n                return 15;\r\n\r\n            case SyntaxKind.BinaryExpression:\r\n                switch (operatorKind) {\r\n                    case SyntaxKind.ExclamationToken:\r\n                    case SyntaxKind.TildeToken:\r\n                        return 15;\r\n\r\n                    case SyntaxKind.AsteriskAsteriskToken:\r\n                    case SyntaxKind.AsteriskToken:\r\n                    case SyntaxKind.SlashToken:\r\n                    case SyntaxKind.PercentToken:\r\n                        return 14;\r\n\r\n                    case SyntaxKind.PlusToken:\r\n                    case SyntaxKind.MinusToken:\r\n                        return 13;\r\n\r\n                    case SyntaxKind.LessThanLessThanToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\r\n                        return 12;\r\n\r\n                    case SyntaxKind.LessThanToken:\r\n                    case SyntaxKind.LessThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanToken:\r\n                    case SyntaxKind.GreaterThanEqualsToken:\r\n                    case SyntaxKind.InKeyword:\r\n                    case SyntaxKind.InstanceOfKeyword:\r\n                        return 11;\r\n\r\n                    case SyntaxKind.EqualsEqualsToken:\r\n                    case SyntaxKind.EqualsEqualsEqualsToken:\r\n                    case SyntaxKind.ExclamationEqualsToken:\r\n                    case SyntaxKind.ExclamationEqualsEqualsToken:\r\n                        return 10;\r\n\r\n                    case SyntaxKind.AmpersandToken:\r\n                        return 9;\r\n\r\n                    case SyntaxKind.CaretToken:\r\n                        return 8;\r\n\r\n                    case SyntaxKind.BarToken:\r\n                        return 7;\r\n\r\n                    case SyntaxKind.AmpersandAmpersandToken:\r\n                        return 6;\r\n\r\n                    case SyntaxKind.BarBarToken:\r\n                        return 5;\r\n\r\n                    case SyntaxKind.EqualsToken:\r\n                    case SyntaxKind.PlusEqualsToken:\r\n                    case SyntaxKind.MinusEqualsToken:\r\n                    case SyntaxKind.AsteriskAsteriskEqualsToken:\r\n                    case SyntaxKind.AsteriskEqualsToken:\r\n                    case SyntaxKind.SlashEqualsToken:\r\n                    case SyntaxKind.PercentEqualsToken:\r\n                    case SyntaxKind.LessThanLessThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.AmpersandEqualsToken:\r\n                    case SyntaxKind.CaretEqualsToken:\r\n                    case SyntaxKind.BarEqualsToken:\r\n                        return 3;\r\n\r\n                    case SyntaxKind.CommaToken:\r\n                        return 0;\r\n\r\n                    default:\r\n                        return -1;\r\n                }\r\n\r\n            case SyntaxKind.ConditionalExpression:\r\n                return 4;\r\n\r\n            case SyntaxKind.YieldExpression:\r\n                return 2;\r\n\r\n            case SyntaxKind.SpreadElement:\r\n                return 1;\r\n\r\n            case SyntaxKind.CommaListExpression:\r\n                return 0;\r\n\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n\r\n    export function createDiagnosticCollection(): DiagnosticCollection {\r\n        let nonFileDiagnostics: Diagnostic[] = [];\r\n        const fileDiagnostics = createMap<Diagnostic[]>();\r\n\r\n        let diagnosticsModified = false;\r\n        let modificationCount = 0;\r\n\r\n        return {\r\n            add,\r\n            getGlobalDiagnostics,\r\n            getDiagnostics,\r\n            getModificationCount,\r\n            reattachFileDiagnostics\r\n        };\r\n\r\n        function getModificationCount() {\r\n            return modificationCount;\r\n        }\r\n\r\n        function reattachFileDiagnostics(newFile: SourceFile): void {\r\n            forEach(fileDiagnostics.get(newFile.fileName), diagnostic => diagnostic.file = newFile);\r\n        }\r\n\r\n        function add(diagnostic: Diagnostic): void {\r\n            let diagnostics: Diagnostic[];\r\n            if (diagnostic.file) {\r\n                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);\r\n                if (!diagnostics) {\r\n                    diagnostics = [];\r\n                    fileDiagnostics.set(diagnostic.file.fileName, diagnostics);\r\n                }\r\n            }\r\n            else {\r\n                diagnostics = nonFileDiagnostics;\r\n            }\r\n\r\n            diagnostics.push(diagnostic);\r\n            diagnosticsModified = true;\r\n            modificationCount++;\r\n        }\r\n\r\n        function getGlobalDiagnostics(): Diagnostic[] {\r\n            sortAndDeduplicate();\r\n            return nonFileDiagnostics;\r\n        }\r\n\r\n        function getDiagnostics(fileName?: string): Diagnostic[] {\r\n            sortAndDeduplicate();\r\n            if (fileName) {\r\n                return fileDiagnostics.get(fileName) || [];\r\n            }\r\n\r\n            const allDiagnostics: Diagnostic[] = [];\r\n            function pushDiagnostic(d: Diagnostic) {\r\n                allDiagnostics.push(d);\r\n            }\r\n\r\n            forEach(nonFileDiagnostics, pushDiagnostic);\r\n\r\n            fileDiagnostics.forEach(diagnostics => {\r\n                forEach(diagnostics, pushDiagnostic);\r\n            });\r\n\r\n            return sortAndDeduplicateDiagnostics(allDiagnostics);\r\n        }\r\n\r\n        function sortAndDeduplicate() {\r\n            if (!diagnosticsModified) {\r\n                return;\r\n            }\r\n\r\n            diagnosticsModified = false;\r\n            nonFileDiagnostics = sortAndDeduplicateDiagnostics(nonFileDiagnostics);\r\n\r\n            fileDiagnostics.forEach((diagnostics, key) => {\r\n                fileDiagnostics.set(key, sortAndDeduplicateDiagnostics(diagnostics));\r\n            });\r\n        }\r\n    }\r\n\r\n    // This consists of the first 19 unprintable ASCII characters, canonical escapes, lineSeparator,\r\n    // paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in\r\n    // the language service. These characters should be escaped when printing, and if any characters are added,\r\n    // the map below must be updated. Note that this regexp *does not* include the 'delete' character.\r\n    // There is no reason for this other than that JSON.stringify does not handle it either.\r\n    const doubleQuoteEscapedCharsRegExp = /[\\\\\\\"\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const singleQuoteEscapedCharsRegExp = /[\\\\\\'\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const backtickQuoteEscapedCharsRegExp = /[\\\\\\`\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const escapedCharsMap = createMapFromTemplate({\r\n        \"\\0\": \"\\\\0\",\r\n        \"\\t\": \"\\\\t\",\r\n        \"\\v\": \"\\\\v\",\r\n        \"\\f\": \"\\\\f\",\r\n        \"\\b\": \"\\\\b\",\r\n        \"\\r\": \"\\\\r\",\r\n        \"\\n\": \"\\\\n\",\r\n        \"\\\\\": \"\\\\\\\\\",\r\n        \"\\\"\": \"\\\\\\\"\",\r\n        \"\\'\": \"\\\\\\'\",\r\n        \"\\`\": \"\\\\\\`\",\r\n        \"\\u2028\": \"\\\\u2028\", // lineSeparator\r\n        \"\\u2029\": \"\\\\u2029\", // paragraphSeparator\r\n        \"\\u0085\": \"\\\\u0085\"  // nextLine\r\n    });\r\n    const escapedNullRegExp = /\\\\0[0-9]/g;\r\n\r\n    /**\r\n     * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),\r\n     * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)\r\n     * Note that this doesn't actually wrap the input in double quotes.\r\n     */\r\n    export function escapeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string {\r\n        const escapedCharsRegExp =\r\n            quoteChar === CharacterCodes.backtick ? backtickQuoteEscapedCharsRegExp :\r\n                quoteChar === CharacterCodes.singleQuote ? singleQuoteEscapedCharsRegExp :\r\n                    doubleQuoteEscapedCharsRegExp;\r\n        return s.replace(escapedCharsRegExp, getReplacement).replace(escapedNullRegExp, nullReplacement);\r\n    }\r\n\r\n    function nullReplacement(c: string) {\r\n        return \"\\\\x00\" + c.charAt(c.length - 1);\r\n    }\r\n\r\n    function getReplacement(c: string) {\r\n        return escapedCharsMap.get(c) || get16BitUnicodeEscapeSequence(c.charCodeAt(0));\r\n    }\r\n\r\n    export function isIntrinsicJsxName(name: __String | string) {\r\n        // An escaped identifier had a leading underscore prior to being escaped, which would return true\r\n        // The escape adds an extra underscore which does not change the result\r\n        const ch = (name as string).substr(0, 1);\r\n        return ch.toLowerCase() === ch;\r\n    }\r\n\r\n    function get16BitUnicodeEscapeSequence(charCode: number): string {\r\n        const hexCharCode = charCode.toString(16).toUpperCase();\r\n        const paddedHexCode = (\"0000\" + hexCharCode).slice(-4);\r\n        return \"\\\\u\" + paddedHexCode;\r\n    }\r\n\r\n    const nonAsciiCharacters = /[^\\u0000-\\u007F]/g;\r\n    export function escapeNonAsciiString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string {\r\n        s = escapeString(s, quoteChar);\r\n        // Replace non-ASCII characters with '\\uNNNN' escapes if any exist.\r\n        // Otherwise just return the original string.\r\n        return nonAsciiCharacters.test(s) ?\r\n            s.replace(nonAsciiCharacters, c => get16BitUnicodeEscapeSequence(c.charCodeAt(0))) :\r\n            s;\r\n    }\r\n\r\n    const indentStrings: string[] = [\"\", \"    \"];\r\n    export function getIndentString(level: number) {\r\n        if (indentStrings[level] === undefined) {\r\n            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];\r\n        }\r\n        return indentStrings[level];\r\n    }\r\n\r\n    export function getIndentSize() {\r\n        return indentStrings[1].length;\r\n    }\r\n\r\n    export function createTextWriter(newLine: string): EmitTextWriter {\r\n        let output: string;\r\n        let indent: number;\r\n        let lineStart: boolean;\r\n        let lineCount: number;\r\n        let linePos: number;\r\n\r\n        function write(s: string) {\r\n            if (s && s.length) {\r\n                if (lineStart) {\r\n                    output += getIndentString(indent);\r\n                    lineStart = false;\r\n                }\r\n                output += s;\r\n            }\r\n        }\r\n\r\n        function reset(): void {\r\n            output = \"\";\r\n            indent = 0;\r\n            lineStart = true;\r\n            lineCount = 0;\r\n            linePos = 0;\r\n        }\r\n\r\n        function rawWrite(s: string) {\r\n            if (s !== undefined) {\r\n                if (lineStart) {\r\n                    lineStart = false;\r\n                }\r\n                output += s;\r\n            }\r\n        }\r\n\r\n        function writeLiteral(s: string) {\r\n            if (s && s.length) {\r\n                write(s);\r\n                const lineStartsOfS = computeLineStarts(s);\r\n                if (lineStartsOfS.length > 1) {\r\n                    lineCount = lineCount + lineStartsOfS.length - 1;\r\n                    linePos = output.length - s.length + lastOrUndefined(lineStartsOfS);\r\n                }\r\n            }\r\n        }\r\n\r\n        function writeLine() {\r\n            if (!lineStart) {\r\n                output += newLine;\r\n                lineCount++;\r\n                linePos = output.length;\r\n                lineStart = true;\r\n            }\r\n        }\r\n\r\n        function writeTextOfNode(text: string, node: Node) {\r\n            write(getTextOfNodeFromSourceText(text, node));\r\n        }\r\n\r\n        reset();\r\n\r\n        return {\r\n            write,\r\n            rawWrite,\r\n            writeTextOfNode,\r\n            writeLiteral,\r\n            writeLine,\r\n            increaseIndent: () => { indent++; },\r\n            decreaseIndent: () => { indent--; },\r\n            getIndent: () => indent,\r\n            getTextPos: () => output.length,\r\n            getLine: () => lineCount + 1,\r\n            getColumn: () => lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1,\r\n            getText: () => output,\r\n            isAtStartOfLine: () => lineStart,\r\n            reset\r\n        };\r\n    }\r\n\r\n    export function getResolvedExternalModuleName(host: EmitHost, file: SourceFile): string {\r\n        return file.moduleName || getExternalModuleNameFromPath(host, file.fileName);\r\n    }\r\n\r\n    export function getExternalModuleNameFromDeclaration(host: EmitHost, resolver: EmitResolver, declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration): string {\r\n        const file = resolver.getExternalModuleFileFromDeclaration(declaration);\r\n        if (!file || file.isDeclarationFile) {\r\n            return undefined;\r\n        }\r\n        return getResolvedExternalModuleName(host, file);\r\n    }\r\n\r\n    /**\r\n     * Resolves a local path to a path which is absolute to the base of the emit\r\n     */\r\n    export function getExternalModuleNameFromPath(host: EmitHost, fileName: string): string {\r\n        const getCanonicalFileName = (f: string) => host.getCanonicalFileName(f);\r\n        const dir = toPath(host.getCommonSourceDirectory(), host.getCurrentDirectory(), getCanonicalFileName);\r\n        const filePath = getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());\r\n        const relativePath = getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);\r\n        return removeFileExtension(relativePath);\r\n    }\r\n\r\n    export function getOwnEmitOutputFilePath(sourceFile: SourceFile, host: EmitHost, extension: string) {\r\n        const compilerOptions = host.getCompilerOptions();\r\n        let emitOutputFilePathWithoutExtension: string;\r\n        if (compilerOptions.outDir) {\r\n            emitOutputFilePathWithoutExtension = removeFileExtension(getSourceFilePathInNewDir(sourceFile, host, compilerOptions.outDir));\r\n        }\r\n        else {\r\n            emitOutputFilePathWithoutExtension = removeFileExtension(sourceFile.fileName);\r\n        }\r\n\r\n        return emitOutputFilePathWithoutExtension + extension;\r\n    }\r\n\r\n    export function getDeclarationEmitOutputFilePath(sourceFile: SourceFile, host: EmitHost) {\r\n        const options = host.getCompilerOptions();\r\n        const outputDir = options.declarationDir || options.outDir; // Prefer declaration folder if specified\r\n\r\n\r\n        const path = outputDir\r\n            ? getSourceFilePathInNewDir(sourceFile, host, outputDir)\r\n            : sourceFile.fileName;\r\n\r\n        const 扩展名 = options.中文关键字 ? Extension.DCts : Extension.Dts\r\n        return removeFileExtension(path) + 扩展名;\r\n    }\r\n\r\n    export interface EmitFileNames {\r\n        jsFilePath: string;\r\n        sourceMapFilePath: string;\r\n        declarationFilePath: string;\r\n    }\r\n\r\n    /**\r\n     * Gets the source files that are expected to have an emit output.\r\n     *\r\n     * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support\r\n     * transformations.\r\n     *\r\n     * @param host An EmitHost.\r\n     * @param targetSourceFile An optional target source file to emit.\r\n     */\r\n    export function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile): ReadonlyArray<SourceFile> {\r\n        const options = host.getCompilerOptions();\r\n        const isSourceFileFromExternalLibrary = (file: SourceFile) => host.isSourceFileFromExternalLibrary(file);\r\n        if (options.outFile || options.out) {\r\n            const moduleKind = getEmitModuleKind(options);\r\n            const moduleEmitEnabled = moduleKind === ModuleKind.AMD || moduleKind === ModuleKind.System;\r\n            // Can emit only sources that are not declaration file and are either non module code or module with --module or --target es6 specified\r\n            return filter(host.getSourceFiles(), sourceFile =>\r\n                (moduleEmitEnabled || !isExternalModule(sourceFile)) && sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary));\r\n        }\r\n        else {\r\n            const sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];\r\n            return filter(sourceFiles, sourceFile => sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary));\r\n        }\r\n    }\r\n\r\n    /** Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks. */\r\n    export function sourceFileMayBeEmitted(sourceFile: SourceFile, options: CompilerOptions, isSourceFileFromExternalLibrary: (file: SourceFile) => boolean) {\r\n        return !(options.noEmitForJsFiles && isSourceFileJavaScript(sourceFile)) && !sourceFile.isDeclarationFile && !isSourceFileFromExternalLibrary(sourceFile);\r\n    }\r\n\r\n    export function getSourceFilePathInNewDir(sourceFile: SourceFile, host: EmitHost, newDirPath: string) {\r\n        let sourceFilePath = getNormalizedAbsolutePath(sourceFile.fileName, host.getCurrentDirectory());\r\n        const commonSourceDirectory = host.getCommonSourceDirectory();\r\n        const isSourceFileInCommonSourceDirectory = host.getCanonicalFileName(sourceFilePath).indexOf(host.getCanonicalFileName(commonSourceDirectory)) === 0;\r\n        sourceFilePath = isSourceFileInCommonSourceDirectory ? sourceFilePath.substring(commonSourceDirectory.length) : sourceFilePath;\r\n        return combinePaths(newDirPath, sourceFilePath);\r\n    }\r\n\r\n    export function writeFile(host: EmitHost, diagnostics: DiagnosticCollection, fileName: string, data: string, writeByteOrderMark: boolean, sourceFiles?: ReadonlyArray<SourceFile>) {\r\n        host.writeFile(fileName, data, writeByteOrderMark, hostErrorMessage => {\r\n            diagnostics.add(createCompilerDiagnostic(Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage));\r\n        }, sourceFiles);\r\n    }\r\n\r\n    export function getLineOfLocalPosition(currentSourceFile: SourceFile, pos: number) {\r\n        return getLineAndCharacterOfPosition(currentSourceFile, pos).line;\r\n    }\r\n\r\n    export function getLineOfLocalPositionFromLineMap(lineMap: ReadonlyArray<number>, pos: number) {\r\n        return computeLineAndCharacterOfPosition(lineMap, pos).line;\r\n    }\r\n\r\n    export function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration {\r\n        return forEach(node.members, member => {\r\n            if (member.kind === SyntaxKind.Constructor && nodeIsPresent((<ConstructorDeclaration>member).body)) {\r\n                return <ConstructorDeclaration>member;\r\n            }\r\n        });\r\n    }\r\n\r\n    function getSetAccessorValueParameter(accessor: SetAccessorDeclaration): ParameterDeclaration | undefined {\r\n        if (accessor && accessor.parameters.length > 0) {\r\n            const hasThis = accessor.parameters.length === 2 && parameterIsThisKeyword(accessor.parameters[0]);\r\n            return accessor.parameters[hasThis ? 1 : 0];\r\n        }\r\n    }\r\n\r\n    /** Get the type annotation for the value parameter. */\r\n    export function getSetAccessorTypeAnnotationNode(accessor: SetAccessorDeclaration): TypeNode {\r\n        const parameter = getSetAccessorValueParameter(accessor);\r\n        return parameter && parameter.type;\r\n    }\r\n\r\n    export function getThisParameter(signature: SignatureDeclaration): ParameterDeclaration | undefined {\r\n        if (signature.parameters.length) {\r\n            const thisParameter = signature.parameters[0];\r\n            if (parameterIsThisKeyword(thisParameter)) {\r\n                return thisParameter;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function parameterIsThisKeyword(parameter: ParameterDeclaration): boolean {\r\n        return isThisIdentifier(parameter.name);\r\n    }\r\n\r\n    export function isThisIdentifier(node: Node | undefined): boolean {\r\n        return node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node as Identifier);\r\n    }\r\n\r\n    export function identifierIsThisKeyword(id: Identifier): boolean {\r\n        return id.originalKeywordKind === SyntaxKind.ThisKeyword;\r\n    }\r\n\r\n    export interface AllAccessorDeclarations {\r\n        firstAccessor: AccessorDeclaration;\r\n        secondAccessor: AccessorDeclaration;\r\n        getAccessor: AccessorDeclaration;\r\n        setAccessor: AccessorDeclaration;\r\n    }\r\n\r\n    export function getAllAccessorDeclarations(declarations: NodeArray<Declaration>, accessor: AccessorDeclaration): AllAccessorDeclarations {\r\n        let firstAccessor: AccessorDeclaration;\r\n        let secondAccessor: AccessorDeclaration;\r\n        let getAccessor: AccessorDeclaration;\r\n        let setAccessor: AccessorDeclaration;\r\n        if (hasDynamicName(accessor)) {\r\n            firstAccessor = accessor;\r\n            if (accessor.kind === SyntaxKind.GetAccessor) {\r\n                getAccessor = accessor;\r\n            }\r\n            else if (accessor.kind === SyntaxKind.SetAccessor) {\r\n                setAccessor = accessor;\r\n            }\r\n            else {\r\n                Debug.fail(\"Accessor has wrong kind\");\r\n            }\r\n        }\r\n        else {\r\n            forEach(declarations, (member: Declaration) => {\r\n                if ((member.kind === SyntaxKind.GetAccessor || member.kind === SyntaxKind.SetAccessor)\r\n                    && hasModifier(member, ModifierFlags.Static) === hasModifier(accessor, ModifierFlags.Static)) {\r\n                    const memberName = getPropertyNameForPropertyNameNode((member as NamedDeclaration).name);\r\n                    const accessorName = getPropertyNameForPropertyNameNode(accessor.name);\r\n                    if (memberName === accessorName) {\r\n                        if (!firstAccessor) {\r\n                            firstAccessor = <AccessorDeclaration>member;\r\n                        }\r\n                        else if (!secondAccessor) {\r\n                            secondAccessor = <AccessorDeclaration>member;\r\n                        }\r\n\r\n                        if (member.kind === SyntaxKind.GetAccessor && !getAccessor) {\r\n                            getAccessor = <AccessorDeclaration>member;\r\n                        }\r\n\r\n                        if (member.kind === SyntaxKind.SetAccessor && !setAccessor) {\r\n                            setAccessor = <AccessorDeclaration>member;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return {\r\n            firstAccessor,\r\n            secondAccessor,\r\n            getAccessor,\r\n            setAccessor\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type annotation of a variable, parameter, or property. If the node was\r\n     * parsed in a JavaScript file, gets the type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveTypeAnnotationNode(node: VariableLikeDeclaration, checkJSDoc?: boolean): TypeNode | undefined {\r\n        if (node.type) {\r\n            return node.type;\r\n        }\r\n        if (checkJSDoc || isInJavaScriptFile(node)) {\r\n            return getJSDocType(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the effective return type annotation of a signature. If the node was parsed in a\r\n     * JavaScript file, gets the return type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveReturnTypeNode(node: SignatureDeclaration, checkJSDoc?: boolean): TypeNode | undefined {\r\n        if (node.type) {\r\n            return node.type;\r\n        }\r\n        if (checkJSDoc || isInJavaScriptFile(node)) {\r\n            return getJSDocReturnType(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type parameters. If the node was parsed in a\r\n     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.\r\n     */\r\n    export function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters, checkJSDoc?: boolean): ReadonlyArray<TypeParameterDeclaration> {\r\n        if (node.typeParameters) {\r\n            return node.typeParameters;\r\n        }\r\n        if (checkJSDoc || isInJavaScriptFile(node)) {\r\n            const templateTag = getJSDocTemplateTag(node);\r\n            return templateTag && templateTag.typeParameters;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type annotation of the value parameter of a set accessor. If the node\r\n     * was parsed in a JavaScript file, gets the type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveSetAccessorTypeAnnotationNode(node: SetAccessorDeclaration, checkJSDoc?: boolean): TypeNode {\r\n        const parameter = getSetAccessorValueParameter(node);\r\n        return parameter && getEffectiveTypeAnnotationNode(parameter, checkJSDoc);\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingComments(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, node: TextRange, leadingComments: ReadonlyArray<CommentRange>) {\r\n        emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments);\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingCommentsOfPosition(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, pos: number, leadingComments: ReadonlyArray<CommentRange>) {\r\n        // If the leading comments start on different line than the start of node, write new line\r\n        if (leadingComments && leadingComments.length && pos !== leadingComments[0].pos &&\r\n            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos)) {\r\n            writer.writeLine();\r\n        }\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingCommentOfPosition(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, pos: number, commentPos: number) {\r\n        // If the leading comments start on different line than the start of node, write new line\r\n        if (pos !== commentPos &&\r\n            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, commentPos)) {\r\n            writer.writeLine();\r\n        }\r\n    }\r\n\r\n    export function emitComments(\r\n        text: string,\r\n        lineMap: ReadonlyArray<number>,\r\n        writer: EmitTextWriter,\r\n        comments: ReadonlyArray<CommentRange>,\r\n        leadingSeparator: boolean,\r\n        trailingSeparator: boolean,\r\n        newLine: string,\r\n        writeComment: (text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void) {\r\n        if (comments && comments.length > 0) {\r\n            if (leadingSeparator) {\r\n                writer.write(\" \");\r\n            }\r\n\r\n            let emitInterveningSeparator = false;\r\n            for (const comment of comments) {\r\n                if (emitInterveningSeparator) {\r\n                    writer.write(\" \");\r\n                    emitInterveningSeparator = false;\r\n                }\r\n\r\n                writeComment(text, lineMap, writer, comment.pos, comment.end, newLine);\r\n                if (comment.hasTrailingNewLine) {\r\n                    writer.writeLine();\r\n                }\r\n                else {\r\n                    emitInterveningSeparator = true;\r\n                }\r\n            }\r\n\r\n            if (emitInterveningSeparator && trailingSeparator) {\r\n                writer.write(\" \");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detached comment is a comment at the top of file or function body that is separated from\r\n     * the next statement by space.\r\n     */\r\n    export function emitDetachedComments(text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter,\r\n        writeComment: (text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void,\r\n        node: TextRange, newLine: string, removeComments: boolean) {\r\n        let leadingComments: CommentRange[];\r\n        let currentDetachedCommentInfo: { nodePos: number, detachedCommentEndPos: number };\r\n        if (removeComments) {\r\n            // removeComments is true, only reserve pinned comment at the top of file\r\n            // For example:\r\n            //      /*! Pinned Comment */\r\n            //\r\n            //      var x = 10;\r\n            if (node.pos === 0) {\r\n                leadingComments = filter(getLeadingCommentRanges(text, node.pos), isPinnedCommentLocal);\r\n            }\r\n        }\r\n        else {\r\n            // removeComments is false, just get detached as normal and bypass the process to filter comment\r\n            leadingComments = getLeadingCommentRanges(text, node.pos);\r\n        }\r\n\r\n        if (leadingComments) {\r\n            const detachedComments: CommentRange[] = [];\r\n            let lastComment: CommentRange;\r\n\r\n            for (const comment of leadingComments) {\r\n                if (lastComment) {\r\n                    const lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastComment.end);\r\n                    const commentLine = getLineOfLocalPositionFromLineMap(lineMap, comment.pos);\r\n\r\n                    if (commentLine >= lastCommentLine + 2) {\r\n                        // There was a blank line between the last comment and this comment.  This\r\n                        // comment is not part of the copyright comments.  Return what we have so\r\n                        // far.\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                detachedComments.push(comment);\r\n                lastComment = comment;\r\n            }\r\n\r\n            if (detachedComments.length) {\r\n                // All comments look like they could have been part of the copyright header.  Make\r\n                // sure there is at least one blank line between it and the node.  If not, it's not\r\n                // a copyright header.\r\n                const lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastOrUndefined(detachedComments).end);\r\n                const nodeLine = getLineOfLocalPositionFromLineMap(lineMap, skipTrivia(text, node.pos));\r\n                if (nodeLine >= lastCommentLine + 2) {\r\n                    // Valid detachedComments\r\n                    emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments);\r\n                    emitComments(text, lineMap, writer, detachedComments, /*leadingSeparator*/ false, /*trailingSeparator*/ true, newLine, writeComment);\r\n                    currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: lastOrUndefined(detachedComments).end };\r\n                }\r\n            }\r\n        }\r\n\r\n        return currentDetachedCommentInfo;\r\n\r\n        function isPinnedCommentLocal(comment: CommentRange) {\r\n            return isPinnedComment(text, comment);\r\n        }\r\n\r\n    }\r\n\r\n    export function writeCommentRange(text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) {\r\n        if (text.charCodeAt(commentPos + 1) === CharacterCodes.asterisk) {\r\n            const firstCommentLineAndCharacter = computeLineAndCharacterOfPosition(lineMap, commentPos);\r\n            const lineCount = lineMap.length;\r\n            let firstCommentLineIndent: number;\r\n            for (let pos = commentPos, currentLine = firstCommentLineAndCharacter.line; pos < commentEnd; currentLine++) {\r\n                const nextLineStart = (currentLine + 1) === lineCount\r\n                    ? text.length + 1\r\n                    : lineMap[currentLine + 1];\r\n\r\n                if (pos !== commentPos) {\r\n                    // If we are not emitting first line, we need to write the spaces to adjust the alignment\r\n                    if (firstCommentLineIndent === undefined) {\r\n                        firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos);\r\n                    }\r\n\r\n                    // These are number of spaces writer is going to write at current indent\r\n                    const currentWriterIndentSpacing = writer.getIndent() * getIndentSize();\r\n\r\n                    // Number of spaces we want to be writing\r\n                    // eg: Assume writer indent\r\n                    // module m {\r\n                    //         /* starts at character 9 this is line 1\r\n                    //    * starts at character pos 4 line                        --1  = 8 - 8 + 3\r\n                    //   More left indented comment */                            --2  = 8 - 8 + 2\r\n                    //     class c { }\r\n                    // }\r\n                    // module m {\r\n                    //     /* this is line 1 -- Assume current writer indent 8\r\n                    //      * line                                                --3 = 8 - 4 + 5\r\n                    //            More right indented comment */                  --4 = 8 - 4 + 11\r\n                    //     class c { }\r\n                    // }\r\n                    const spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart);\r\n                    if (spacesToEmit > 0) {\r\n                        let numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();\r\n                        const indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());\r\n\r\n                        // Write indent size string ( in eg 1: = \"\", 2: \"\" , 3: string with 8 spaces 4: string with 12 spaces\r\n                        writer.rawWrite(indentSizeSpaceString);\r\n\r\n                        // Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)\r\n                        while (numberOfSingleSpacesToEmit) {\r\n                            writer.rawWrite(\" \");\r\n                            numberOfSingleSpacesToEmit--;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // No spaces to emit write empty string\r\n                        writer.rawWrite(\"\");\r\n                    }\r\n                }\r\n\r\n                // Write the comment line text\r\n                writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart);\r\n\r\n                pos = nextLineStart;\r\n            }\r\n        }\r\n        else {\r\n            // Single line comment of style //....\r\n            writer.write(text.substring(commentPos, commentEnd));\r\n        }\r\n    }\r\n\r\n    function writeTrimmedCurrentLine(text: string, commentEnd: number, writer: EmitTextWriter, newLine: string, pos: number, nextLineStart: number) {\r\n        const end = Math.min(commentEnd, nextLineStart - 1);\r\n        const currentLineText = text.substring(pos, end).replace(/^\\s+|\\s+$/g, \"\");\r\n        if (currentLineText) {\r\n            // trimmed forward and ending spaces text\r\n            writer.write(currentLineText);\r\n            if (end !== commentEnd) {\r\n                writer.writeLine();\r\n            }\r\n        }\r\n        else {\r\n            // Empty string - make sure we write empty line\r\n            writer.writeLiteral(newLine);\r\n        }\r\n    }\r\n\r\n    function calculateIndent(text: string, pos: number, end: number) {\r\n        let currentLineIndent = 0;\r\n        for (; pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos)); pos++) {\r\n            if (text.charCodeAt(pos) === CharacterCodes.tab) {\r\n                // Tabs = TabSize = indent size and go to next tabStop\r\n                currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());\r\n            }\r\n            else {\r\n                // Single space\r\n                currentLineIndent++;\r\n            }\r\n        }\r\n\r\n        return currentLineIndent;\r\n    }\r\n\r\n    export function hasModifiers(node: Node) {\r\n        return getModifierFlags(node) !== ModifierFlags.None;\r\n    }\r\n\r\n    export function hasModifier(node: Node, flags: ModifierFlags): boolean {\r\n        return !!getSelectedModifierFlags(node, flags);\r\n    }\r\n\r\n    export function getSelectedModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags {\r\n        return getModifierFlags(node) & flags;\r\n    }\r\n\r\n    export function getModifierFlags(node: Node): ModifierFlags {\r\n        if (node.modifierFlagsCache & ModifierFlags.HasComputedFlags) {\r\n            return node.modifierFlagsCache & ~ModifierFlags.HasComputedFlags;\r\n        }\r\n\r\n        const flags = getModifierFlagsNoCache(node);\r\n        node.modifierFlagsCache = flags | ModifierFlags.HasComputedFlags;\r\n        return flags;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getModifierFlagsNoCache(node: Node): ModifierFlags {\r\n\r\n        let flags = ModifierFlags.None;\r\n        if (node.modifiers) {\r\n            for (const modifier of node.modifiers) {\r\n                flags |= modifierToFlag(modifier.kind);\r\n            }\r\n        }\r\n\r\n        if (node.flags & NodeFlags.NestedNamespace || (node.kind === SyntaxKind.Identifier && (<Identifier>node).isInJSDocNamespace)) {\r\n            flags |= ModifierFlags.Export;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    export function modifierToFlag(token: SyntaxKind): ModifierFlags {\r\n        switch (token) {\r\n            case SyntaxKind.StaticKeyword: return ModifierFlags.Static;\r\n            case SyntaxKind.PublicKeyword: return ModifierFlags.Public;\r\n            case SyntaxKind.ProtectedKeyword: return ModifierFlags.Protected;\r\n            case SyntaxKind.PrivateKeyword: return ModifierFlags.Private;\r\n            case SyntaxKind.AbstractKeyword: return ModifierFlags.Abstract;\r\n            case SyntaxKind.ExportKeyword: return ModifierFlags.Export;\r\n            case SyntaxKind.DeclareKeyword: return ModifierFlags.Ambient;\r\n            case SyntaxKind.ConstKeyword: return ModifierFlags.Const;\r\n            case SyntaxKind.DefaultKeyword: return ModifierFlags.Default;\r\n            case SyntaxKind.AsyncKeyword: return ModifierFlags.Async;\r\n            case SyntaxKind.ReadonlyKeyword: return ModifierFlags.Readonly;\r\n        }\r\n        return ModifierFlags.None;\r\n    }\r\n\r\n    export function isLogicalOperator(token: SyntaxKind): boolean {\r\n        return token === SyntaxKind.BarBarToken\r\n            || token === SyntaxKind.AmpersandAmpersandToken\r\n            || token === SyntaxKind.ExclamationToken;\r\n    }\r\n\r\n    export function isAssignmentOperator(token: SyntaxKind): boolean {\r\n        return token >= SyntaxKind.FirstAssignment && token <= SyntaxKind.LastAssignment;\r\n    }\r\n\r\n    /** Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments. */\r\n    export function tryGetClassExtendingExpressionWithTypeArguments(node: Node): ClassLikeDeclaration | undefined {\r\n        if (node.kind === SyntaxKind.ExpressionWithTypeArguments &&\r\n            (<HeritageClause>node.parent).token === SyntaxKind.ExtendsKeyword &&\r\n            isClassLike(node.parent.parent)) {\r\n            return node.parent.parent;\r\n        }\r\n    }\r\n\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment: true): node is AssignmentExpression<EqualsToken>;\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment?: false): node is AssignmentExpression<AssignmentOperatorToken>;\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment?: boolean): node is AssignmentExpression<AssignmentOperatorToken> {\r\n        return isBinaryExpression(node)\r\n            && (excludeCompoundAssignment\r\n                ? node.operatorToken.kind === SyntaxKind.EqualsToken\r\n                : isAssignmentOperator(node.operatorToken.kind))\r\n            && isLeftHandSideExpression(node.left);\r\n    }\r\n\r\n    export function isDestructuringAssignment(node: Node): node is DestructuringAssignment {\r\n        if (isAssignmentExpression(node, /*excludeCompoundAssignment*/ true)) {\r\n            const kind = node.left.kind;\r\n            return kind === SyntaxKind.ObjectLiteralExpression\r\n                || kind === SyntaxKind.ArrayLiteralExpression;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isExpressionWithTypeArgumentsInClassExtendsClause(node: Node): boolean {\r\n        return tryGetClassExtendingExpressionWithTypeArguments(node) !== undefined;\r\n    }\r\n\r\n    export function isExpressionWithTypeArgumentsInClassImplementsClause(node: Node): node is ExpressionWithTypeArguments {\r\n        return node.kind === SyntaxKind.ExpressionWithTypeArguments\r\n            && isEntityNameExpression((node as ExpressionWithTypeArguments).expression)\r\n            && node.parent\r\n            && (<HeritageClause>node.parent).token === SyntaxKind.ImplementsKeyword\r\n            && node.parent.parent\r\n            && isClassLike(node.parent.parent);\r\n    }\r\n\r\n    export function isEntityNameExpression(node: Expression): node is EntityNameExpression {\r\n        return node.kind === SyntaxKind.Identifier ||\r\n            node.kind === SyntaxKind.PropertyAccessExpression && isEntityNameExpression((<PropertyAccessExpression>node).expression);\r\n    }\r\n\r\n    export function isRightSideOfQualifiedNameOrPropertyAccess(node: Node) {\r\n        return (node.parent.kind === SyntaxKind.QualifiedName && (<QualifiedName>node.parent).right === node) ||\r\n            (node.parent.kind === SyntaxKind.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).name === node);\r\n    }\r\n\r\n    export function isEmptyObjectLiteral(expression: Node): boolean {\r\n        return expression.kind === SyntaxKind.ObjectLiteralExpression &&\r\n            (<ObjectLiteralExpression>expression).properties.length === 0;\r\n    }\r\n\r\n    export function isEmptyArrayLiteral(expression: Node): boolean {\r\n        return expression.kind === SyntaxKind.ArrayLiteralExpression &&\r\n            (<ArrayLiteralExpression>expression).elements.length === 0;\r\n    }\r\n\r\n    export function getLocalSymbolForExportDefault(symbol: Symbol) {\r\n        return isExportDefaultSymbol(symbol) ? symbol.declarations[0].localSymbol : undefined;\r\n    }\r\n\r\n    function isExportDefaultSymbol(symbol: Symbol): boolean {\r\n        return symbol && length(symbol.declarations) > 0 && hasModifier(symbol.declarations[0], ModifierFlags.Default);\r\n    }\r\n\r\n    /** Return \".ts\", \".d.ts\", or \".tsx\", if that is the extension. */\r\n    export function tryExtractTypeScriptExtension(fileName: string): string | undefined {\r\n        return find(supportedTypescriptExtensionsForExtractExtension, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n    /**\r\n     * Replace each instance of non-ascii characters by one, two, three, or four escape sequences\r\n     * representing the UTF-8 encoding of the character, and return the expanded char code list.\r\n     */\r\n    function getExpandedCharCodes(input: string): number[] {\r\n        const output: number[] = [];\r\n        const length = input.length;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            const charCode = input.charCodeAt(i);\r\n\r\n            // handel utf8\r\n            if (charCode < 0x80) {\r\n                output.push(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                output.push((charCode >> 6) | 0B11000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else if (charCode < 0x10000) {\r\n                output.push((charCode >> 12) | 0B11100000);\r\n                output.push(((charCode >> 6) & 0B00111111) | 0B10000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else if (charCode < 0x20000) {\r\n                output.push((charCode >> 18) | 0B11110000);\r\n                output.push(((charCode >> 12) & 0B00111111) | 0B10000000);\r\n                output.push(((charCode >> 6) & 0B00111111) | 0B10000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else {\r\n                Debug.assert(false, \"Unexpected code point\");\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    const base64Digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n\r\n    /**\r\n     * Converts a string to a base-64 encoded ASCII string.\r\n     */\r\n    export function convertToBase64(input: string): string {\r\n        let result = \"\";\r\n        const charCodes = getExpandedCharCodes(input);\r\n        let i = 0;\r\n        const length = charCodes.length;\r\n        let byte1: number, byte2: number, byte3: number, byte4: number;\r\n\r\n        while (i < length) {\r\n            // Convert every 6-bits in the input 3 character points\r\n            // into a base64 digit\r\n            byte1 = charCodes[i] >> 2;\r\n            byte2 = (charCodes[i] & 0B00000011) << 4 | charCodes[i + 1] >> 4;\r\n            byte3 = (charCodes[i + 1] & 0B00001111) << 2 | charCodes[i + 2] >> 6;\r\n            byte4 = charCodes[i + 2] & 0B00111111;\r\n\r\n            // We are out of characters in the input, set the extra\r\n            // digits to 64 (padding character).\r\n            if (i + 1 >= length) {\r\n                byte3 = byte4 = 64;\r\n            }\r\n            else if (i + 2 >= length) {\r\n                byte4 = 64;\r\n            }\r\n\r\n            // Write to the output\r\n            result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4);\r\n\r\n            i += 3;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    const carriageReturnLineFeed = \"\\r\\n\";\r\n    const lineFeed = \"\\n\";\r\n    export function getNewLineCharacter(options: CompilerOptions | PrinterOptions, system?: { newLine: string }): string {\r\n        switch (options.newLine) {\r\n            case NewLineKind.CarriageReturnLineFeed:\r\n                return carriageReturnLineFeed;\r\n            case NewLineKind.LineFeed:\r\n                return lineFeed;\r\n        }\r\n        return system ? system.newLine : sys ? sys.newLine : carriageReturnLineFeed;\r\n    }\r\n\r\n    /**\r\n     * Formats an enum value as a string for debugging and debug assertions.\r\n     */\r\n    function formatEnum(value = 0, enumObject: any, isFlags?: boolean) {\r\n        const members = getEnumMembers(enumObject);\r\n        if (value === 0) {\r\n            return members.length > 0 && members[0][0] === 0 ? members[0][1] : \"0\";\r\n        }\r\n        if (isFlags) {\r\n            let result = \"\";\r\n            let remainingFlags = value;\r\n            for (let i = members.length - 1; i >= 0 && remainingFlags !== 0; i--) {\r\n                const [enumValue, enumName] = members[i];\r\n                if (enumValue !== 0 && (remainingFlags & enumValue) === enumValue) {\r\n                    remainingFlags &= ~enumValue;\r\n                    result = `${enumName}${result ? \", \" : \"\"}${result}`;\r\n                }\r\n            }\r\n            if (remainingFlags === 0) {\r\n                return result;\r\n            }\r\n        }\r\n        else {\r\n            for (const [enumValue, enumName] of members) {\r\n                if (enumValue === value) {\r\n                    return enumName;\r\n                }\r\n            }\r\n        }\r\n        return value.toString();\r\n    }\r\n\r\n    function getEnumMembers(enumObject: any) {\r\n        const result: [number, string][] = [];\r\n        for (const name in enumObject) {\r\n            const value = enumObject[name];\r\n            if (typeof value === \"number\") {\r\n                result.push([value, name]);\r\n            }\r\n        }\r\n\r\n        return stableSort<[number, string]>(result, (x, y) => compareValues(x[0], y[0]));\r\n    }\r\n\r\n    export function formatSyntaxKind(kind: SyntaxKind): string {\r\n        return formatEnum(kind, (<any>ts).SyntaxKind, /*isFlags*/ false);\r\n    }\r\n\r\n    export function formatModifierFlags(flags: ModifierFlags): string {\r\n        return formatEnum(flags, (<any>ts).ModifierFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatTransformFlags(flags: TransformFlags): string {\r\n        return formatEnum(flags, (<any>ts).TransformFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatEmitFlags(flags: EmitFlags): string {\r\n        return formatEnum(flags, (<any>ts).EmitFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatSymbolFlags(flags: SymbolFlags): string {\r\n        return formatEnum(flags, (<any>ts).SymbolFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatTypeFlags(flags: TypeFlags): string {\r\n        return formatEnum(flags, (<any>ts).TypeFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatObjectFlags(flags: ObjectFlags): string {\r\n        return formatEnum(flags, (<any>ts).ObjectFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from the provided pos and end.\r\n     *\r\n     * @param pos The start position.\r\n     * @param end The end position.\r\n     */\r\n    export function createRange(pos: number, end: number): TextRange {\r\n        return { pos, end };\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from a provided range with a new end position.\r\n     *\r\n     * @param range A TextRange.\r\n     * @param end The new end position.\r\n     */\r\n    export function moveRangeEnd(range: TextRange, end: number): TextRange {\r\n        return createRange(range.pos, end);\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from a provided range with a new start position.\r\n     *\r\n     * @param range A TextRange.\r\n     * @param pos The new Start position.\r\n     */\r\n    export function moveRangePos(range: TextRange, pos: number): TextRange {\r\n        return createRange(pos, range.end);\r\n    }\r\n\r\n    /**\r\n     * Moves the start position of a range past any decorators.\r\n     */\r\n    export function moveRangePastDecorators(node: Node): TextRange {\r\n        return node.decorators && node.decorators.length > 0\r\n            ? moveRangePos(node, node.decorators.end)\r\n            : node;\r\n    }\r\n\r\n    /**\r\n     * Moves the start position of a range past any decorators or modifiers.\r\n     */\r\n    export function moveRangePastModifiers(node: Node): TextRange {\r\n        return node.modifiers && node.modifiers.length > 0\r\n            ? moveRangePos(node, node.modifiers.end)\r\n            : moveRangePastDecorators(node);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a TextRange has the same start and end positions.\r\n     *\r\n     * @param range A TextRange.\r\n     */\r\n    export function isCollapsedRange(range: TextRange) {\r\n        return range.pos === range.end;\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange for a token at the provides start position.\r\n     *\r\n     * @param pos The start position.\r\n     * @param token The token.\r\n     */\r\n    export function createTokenRange(pos: number, token: SyntaxKind): TextRange {\r\n        return createRange(pos, pos + tokenToString(token).length);\r\n    }\r\n\r\n    export function rangeIsOnSingleLine(range: TextRange, sourceFile: SourceFile) {\r\n        return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);\r\n    }\r\n\r\n    export function rangeStartPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), getStartPositionOfRange(range2, sourceFile), sourceFile);\r\n    }\r\n\r\n    export function rangeEndPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(range1.end, range2.end, sourceFile);\r\n    }\r\n\r\n    export function rangeStartIsOnSameLineAsRangeEnd(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), range2.end, sourceFile);\r\n    }\r\n\r\n    export function rangeEndIsOnSameLineAsRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile), sourceFile);\r\n    }\r\n\r\n    export function positionsAreOnSameLine(pos1: number, pos2: number, sourceFile: SourceFile) {\r\n        return pos1 === pos2 ||\r\n            getLineOfLocalPosition(sourceFile, pos1) === getLineOfLocalPosition(sourceFile, pos2);\r\n    }\r\n\r\n    export function getStartPositionOfRange(range: TextRange, sourceFile: SourceFile) {\r\n        return positionIsSynthesized(range.pos) ? -1 : skipTrivia(sourceFile.text, range.pos);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a name was originally the declaration name of an enum or namespace\r\n     * declaration.\r\n     */\r\n    export function isDeclarationNameOfEnumOrNamespace(node: Identifier) {\r\n        const parseNode = getParseTreeNode(node);\r\n        if (parseNode) {\r\n            switch (parseNode.parent.kind) {\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    return parseNode === (<EnumDeclaration | ModuleDeclaration>parseNode.parent).name;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getInitializedVariables(node: VariableDeclarationList) {\r\n        return filter(node.declarations, isInitializedVariable);\r\n    }\r\n\r\n    function isInitializedVariable(node: VariableDeclaration) {\r\n        return node.initializer !== undefined;\r\n    }\r\n\r\n    export function isWatchSet(options: CompilerOptions) {\r\n        // Firefox has Object.prototype.watch\r\n        return options.watch && options.hasOwnProperty(\"watch\");\r\n    }\r\n\r\n    export function getCheckFlags(symbol: Symbol): CheckFlags {\r\n        return symbol.flags & SymbolFlags.Transient ? (<TransientSymbol>symbol).checkFlags : 0;\r\n    }\r\n\r\n    export function getDeclarationModifierFlagsFromSymbol(s: Symbol): ModifierFlags {\r\n        if (s.valueDeclaration) {\r\n            const flags = getCombinedModifierFlags(s.valueDeclaration);\r\n            return s.parent && s.parent.flags & SymbolFlags.Class ? flags : flags & ~ModifierFlags.AccessibilityModifier;\r\n        }\r\n        if (getCheckFlags(s) & CheckFlags.Synthetic) {\r\n            const checkFlags = (<TransientSymbol>s).checkFlags;\r\n            const accessModifier = checkFlags & CheckFlags.ContainsPrivate ? ModifierFlags.Private :\r\n                checkFlags & CheckFlags.ContainsPublic ? ModifierFlags.Public :\r\n                    ModifierFlags.Protected;\r\n            const staticModifier = checkFlags & CheckFlags.ContainsStatic ? ModifierFlags.Static : 0;\r\n            return accessModifier | staticModifier;\r\n        }\r\n        if (s.flags & SymbolFlags.Prototype) {\r\n            return ModifierFlags.Public | ModifierFlags.Static;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    export function levenshtein(s1: string, s2: string): number {\r\n        let previous: number[] = new Array(s2.length + 1);\r\n        let current: number[] = new Array(s2.length + 1);\r\n        for (let i = 0; i < s2.length + 1; i++) {\r\n            previous[i] = i;\r\n            current[i] = -1;\r\n        }\r\n        for (let i = 1; i < s1.length + 1; i++) {\r\n            current[0] = i;\r\n            for (let j = 1; j < s2.length + 1; j++) {\r\n                current[j] = Math.min(\r\n                    previous[j] + 1,\r\n                    current[j - 1] + 1,\r\n                    previous[j - 1] + (s1[i - 1] === s2[j - 1] ? 0 : 2));\r\n            }\r\n            // shift current back to previous, and then reuse previous' array\r\n            const tmp = previous;\r\n            previous = current;\r\n            current = tmp;\r\n        }\r\n        return previous[previous.length - 1];\r\n    }\r\n\r\n    export function skipAlias(symbol: Symbol, checker: TypeChecker) {\r\n        return symbol.flags & SymbolFlags.Alias ? checker.getAliasedSymbol(symbol) : symbol;\r\n    }\r\n\r\n    /** See comment on `declareModuleMember` in `binder.ts`. */\r\n    export function getCombinedLocalAndExportSymbolFlags(symbol: Symbol): SymbolFlags {\r\n        return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;\r\n    }\r\n\r\n    export function isWriteOnlyAccess(node: Node) {\r\n        return accessKind(node) === AccessKind.Write;\r\n    }\r\n\r\n    export function isWriteAccess(node: Node) {\r\n        return accessKind(node) !== AccessKind.Read;\r\n    }\r\n\r\n    const enum AccessKind {\r\n        /** Only reads from a variable. */\r\n        Read,\r\n        /** Only writes to a variable without using the result. E.g.: `x++;`. */\r\n        Write,\r\n        /** Writes to a variable and uses the result as an expression. E.g.: `f(x++);`. */\r\n        ReadWrite\r\n    }\r\n    function accessKind(node: Node): AccessKind {\r\n        const { parent } = node;\r\n        if (!parent) return AccessKind.Read;\r\n\r\n        switch (parent.kind) {\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                const { operator } = parent as PrefixUnaryExpression | PostfixUnaryExpression;\r\n                return operator === SyntaxKind.PlusPlusToken || operator === SyntaxKind.MinusMinusToken ? writeOrReadWrite() : AccessKind.Read;\r\n            case SyntaxKind.BinaryExpression:\r\n                const { left, operatorToken } = parent as BinaryExpression;\r\n                return left === node && isAssignmentOperator(operatorToken.kind) ? writeOrReadWrite() : AccessKind.Read;\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return (parent as PropertyAccessExpression).name !== node ? AccessKind.Read : accessKind(parent);\r\n            default:\r\n                return AccessKind.Read;\r\n        }\r\n\r\n        function writeOrReadWrite(): AccessKind {\r\n            // If grandparent is not an ExpressionStatement, this is used as an expression in addition to having a side effect.\r\n            return parent.parent && parent.parent.kind === SyntaxKind.ExpressionStatement ? AccessKind.Write : AccessKind.ReadWrite;\r\n        }\r\n    }\r\n\r\n    export function compareDataObjects(dst: any, src: any): boolean {\r\n        if (!dst || !src || Object.keys(dst).length !== Object.keys(src).length) {\r\n            return false;\r\n        }\r\n\r\n        for (const e in dst) {\r\n            if (typeof dst[e] === \"object\") {\r\n                if (!compareDataObjects(dst[e], src[e])) {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (typeof dst[e] !== \"function\") {\r\n                if (dst[e] !== src[e]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * clears already present map by calling onDeleteExistingValue callback before deleting that key/value\r\n     */\r\n    export function clearMap<T>(map: Map<T>, onDeleteValue: (valueInMap: T, key: string) => void) {\r\n        // Remove all\r\n        map.forEach(onDeleteValue);\r\n        map.clear();\r\n    }\r\n\r\n    export interface MutateMapOptions<T, U> {\r\n        createNewValue(key: string, valueInNewMap: U): T;\r\n        onDeleteValue(existingValue: T, key: string): void;\r\n\r\n        /**\r\n         * If present this is called with the key when there is value for that key both in new map as well as existing map provided\r\n         * Caller can then decide to update or remove this key.\r\n         * If the key is removed, caller will get callback of createNewValue for that key.\r\n         * If this callback is not provided, the value of such keys is not updated.\r\n         */\r\n        onExistingValue?(existingValue: T, valueInNewMap: U, key: string): void;\r\n    }\r\n\r\n    /**\r\n     * Mutates the map with newMap such that keys in map will be same as newMap.\r\n     */\r\n    export function mutateMap<T, U>(map: Map<T>, newMap: ReadonlyMap<U>, options: MutateMapOptions<T, U>) {\r\n        const { createNewValue, onDeleteValue, onExistingValue } = options;\r\n        // Needs update\r\n        map.forEach((existingValue, key) => {\r\n            const valueInNewMap = newMap.get(key);\r\n            // Not present any more in new map, remove it\r\n            if (valueInNewMap === undefined) {\r\n                map.delete(key);\r\n                onDeleteValue(existingValue, key);\r\n            }\r\n            // If present notify about existing values\r\n            else if (onExistingValue) {\r\n                onExistingValue(existingValue, valueInNewMap, key);\r\n            }\r\n        });\r\n\r\n        // Add new values that are not already present\r\n        newMap.forEach((valueInNewMap, key) => {\r\n            if (!map.has(key)) {\r\n                // New values\r\n                map.set(key, createNewValue(key, valueInNewMap));\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Calls `callback` on `directory` and every ancestor directory it has, returning the first defined result. */\r\n    export function forEachAncestorDirectory<T>(directory: string, callback: (directory: string) => T): T {\r\n        while (true) {\r\n            const result = callback(directory);\r\n            if (result !== undefined) {\r\n                return result;\r\n            }\r\n\r\n            const parentPath = getDirectoryPath(directory);\r\n            if (parentPath === directory) {\r\n                return undefined;\r\n            }\r\n\r\n            directory = parentPath;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace ts {\r\n    export function getDefaultLibFileName(options: CompilerOptions): string {\r\n        switch (options.target) {\r\n            case ScriptTarget.ESNext:\r\n                return \"lib.esnext.full.d.ts\";\r\n            case ScriptTarget.ES2017:\r\n                return \"lib.es2017.full.d.ts\";\r\n            case ScriptTarget.ES2016:\r\n                return \"lib.es2016.full.d.ts\";\r\n            case ScriptTarget.ES2015:\r\n                return \"lib.es6.d.ts\";  // We don't use lib.es2015.full.d.ts due to breaking change.\r\n            default:\r\n                return \"lib.d.ts\";\r\n        }\r\n    }\r\n\r\n    export function textSpanEnd(span: TextSpan) {\r\n        return span.start + span.length;\r\n    }\r\n\r\n    export function textSpanIsEmpty(span: TextSpan) {\r\n        return span.length === 0;\r\n    }\r\n\r\n    export function textSpanContainsPosition(span: TextSpan, position: number) {\r\n        return position >= span.start && position < textSpanEnd(span);\r\n    }\r\n\r\n    // Returns true if 'span' contains 'other'.\r\n    export function textSpanContainsTextSpan(span: TextSpan, other: TextSpan) {\r\n        return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span);\r\n    }\r\n\r\n    export function textSpanOverlapsWith(span: TextSpan, other: TextSpan) {\r\n        const overlapStart = Math.max(span.start, other.start);\r\n        const overlapEnd = Math.min(textSpanEnd(span), textSpanEnd(other));\r\n        return overlapStart < overlapEnd;\r\n    }\r\n\r\n    export function textSpanOverlap(span1: TextSpan, span2: TextSpan) {\r\n        const overlapStart = Math.max(span1.start, span2.start);\r\n        const overlapEnd = Math.min(textSpanEnd(span1), textSpanEnd(span2));\r\n        if (overlapStart < overlapEnd) {\r\n            return createTextSpanFromBounds(overlapStart, overlapEnd);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan) {\r\n        return other.start <= textSpanEnd(span) && textSpanEnd(other) >= span.start;\r\n    }\r\n\r\n    export function textSpanIntersectsWith(span: TextSpan, start: number, length: number) {\r\n        const end = start + length;\r\n        return start <= textSpanEnd(span) && end >= span.start;\r\n    }\r\n\r\n    export function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number) {\r\n        const end1 = start1 + length1;\r\n        const end2 = start2 + length2;\r\n        return start2 <= end1 && end2 >= start1;\r\n    }\r\n\r\n    export function textSpanIntersectsWithPosition(span: TextSpan, position: number) {\r\n        return position <= textSpanEnd(span) && position >= span.start;\r\n    }\r\n\r\n    export function textSpanIntersection(span1: TextSpan, span2: TextSpan) {\r\n        const intersectStart = Math.max(span1.start, span2.start);\r\n        const intersectEnd = Math.min(textSpanEnd(span1), textSpanEnd(span2));\r\n        if (intersectStart <= intersectEnd) {\r\n            return createTextSpanFromBounds(intersectStart, intersectEnd);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function createTextSpan(start: number, length: number): TextSpan {\r\n        if (start < 0) {\r\n            throw new Error(\"start < 0\");\r\n        }\r\n        if (length < 0) {\r\n            throw new Error(\"length < 0\");\r\n        }\r\n\r\n        return { start, length };\r\n    }\r\n\r\n    export function createTextSpanFromBounds(start: number, end: number) {\r\n        return createTextSpan(start, end - start);\r\n    }\r\n\r\n    export function textChangeRangeNewSpan(range: TextChangeRange) {\r\n        return createTextSpan(range.span.start, range.newLength);\r\n    }\r\n\r\n    export function textChangeRangeIsUnchanged(range: TextChangeRange) {\r\n        return textSpanIsEmpty(range.span) && range.newLength === 0;\r\n    }\r\n\r\n    export function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange {\r\n        if (newLength < 0) {\r\n            throw new Error(\"newLength < 0\");\r\n        }\r\n\r\n        return { span, newLength };\r\n    }\r\n\r\n    export let unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0);\r\n\r\n    /**\r\n     * Called to merge all the changes that occurred across several versions of a script snapshot\r\n     * into a single change.  i.e. if a user keeps making successive edits to a script we will\r\n     * have a text change from V1 to V2, V2 to V3, ..., Vn.\r\n     *\r\n     * This function will then merge those changes into a single change range valid between V1 and\r\n     * Vn.\r\n     */\r\n    export function collapseTextChangeRangesAcrossMultipleVersions(changes: ReadonlyArray<TextChangeRange>): TextChangeRange {\r\n        if (changes.length === 0) {\r\n            return unchangedTextChangeRange;\r\n        }\r\n\r\n        if (changes.length === 1) {\r\n            return changes[0];\r\n        }\r\n\r\n        // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }\r\n        // as it makes things much easier to reason about.\r\n        const change0 = changes[0];\r\n\r\n        let oldStartN = change0.span.start;\r\n        let oldEndN = textSpanEnd(change0.span);\r\n        let newEndN = oldStartN + change0.newLength;\r\n\r\n        for (let i = 1; i < changes.length; i++) {\r\n            const nextChange = changes[i];\r\n\r\n            // Consider the following case:\r\n            // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting\r\n            // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.\r\n            // i.e. the span starting at 30 with length 30 is increased to length 40.\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //                |                                                 /\r\n            //                |                                            /----\r\n            //  T1            |                                       /----\r\n            //                |                                  /----\r\n            //                |                             /----\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //                                     |                            \\\r\n            //                                     |                               \\\r\n            //   T2                                |                                 \\\r\n            //                                     |                                   \\\r\n            //                                     |                                      \\\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //\r\n            // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial\r\n            // it's just the min of the old and new starts.  i.e.:\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      ------------------------------------------------------------*------------------------------------------\r\n            //                |                                                 /\r\n            //                |                                            /----\r\n            //  T1            |                                       /----\r\n            //                |                                  /----\r\n            //                |                             /----\r\n            //      ----------------------------------------$-------------------$------------------------------------------\r\n            //                .                    |                            \\\r\n            //                .                    |                               \\\r\n            //   T2           .                    |                                 \\\r\n            //                .                    |                                   \\\r\n            //                .                    |                                      \\\r\n            //      ----------------------------------------------------------------------*--------------------------------\r\n            //\r\n            // (Note the dots represent the newly inferred start.\r\n            // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the\r\n            // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see\r\n            // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that\r\n            // means:\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      --------------------------------------------------------------------------------*----------------------\r\n            //                |                                                                     /\r\n            //                |                                                                /----\r\n            //  T1            |                                                           /----\r\n            //                |                                                      /----\r\n            //                |                                                 /----\r\n            //      ------------------------------------------------------------$------------------------------------------\r\n            //                .                    |                            \\\r\n            //                .                    |                               \\\r\n            //   T2           .                    |                                 \\\r\n            //                .                    |                                   \\\r\n            //                .                    |                                      \\\r\n            //      ----------------------------------------------------------------------*--------------------------------\r\n            //\r\n            // In other words (in this case), we're recognizing that the second edit happened after where the first edit\r\n            // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started\r\n            // that's the same as if we started at char 80 instead of 60.\r\n            //\r\n            // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather\r\n            // than pushing the first edit forward to match the second, we'll push the second edit forward to match the\r\n            // first.\r\n            //\r\n            // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange\r\n            // semantics: { { start: 10, length: 70 }, newLength: 60 }\r\n            //\r\n            // The math then works out as follows.\r\n            // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the\r\n            // final result like so:\r\n            //\r\n            // {\r\n            //      oldStart3: Min(oldStart1, oldStart2),\r\n            //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),\r\n            //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))\r\n            // }\r\n\r\n            const oldStart1 = oldStartN;\r\n            const oldEnd1 = oldEndN;\r\n            const newEnd1 = newEndN;\r\n\r\n            const oldStart2 = nextChange.span.start;\r\n            const oldEnd2 = textSpanEnd(nextChange.span);\r\n            const newEnd2 = oldStart2 + nextChange.newLength;\r\n\r\n            oldStartN = Math.min(oldStart1, oldStart2);\r\n            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));\r\n            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));\r\n        }\r\n\r\n        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), /*newLength*/ newEndN - oldStartN);\r\n    }\r\n\r\n    export function getTypeParameterOwner(d: Declaration): Declaration {\r\n        if (d && d.kind === SyntaxKind.TypeParameter) {\r\n            for (let current: Node = d; current; current = current.parent) {\r\n                if (isFunctionLike(current) || isClassLike(current) || current.kind === SyntaxKind.InterfaceDeclaration) {\r\n                    return <Declaration>current;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export function isParameterPropertyDeclaration(node: Node): boolean {\r\n        return hasModifier(node, ModifierFlags.ParameterPropertyModifier) && node.parent.kind === SyntaxKind.Constructor && isClassLike(node.parent.parent);\r\n    }\r\n\r\n    export function isEmptyBindingPattern(node: BindingName): node is BindingPattern {\r\n        if (isBindingPattern(node)) {\r\n            return every(node.elements, isEmptyBindingElement);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isEmptyBindingElement(node: BindingElement): boolean {\r\n        if (isOmittedExpression(node)) {\r\n            return true;\r\n        }\r\n        return isEmptyBindingPattern(node.name);\r\n    }\r\n\r\n    function walkUpBindingElementsAndPatterns(node: Node): Node {\r\n        while (node && (node.kind === SyntaxKind.BindingElement || isBindingPattern(node))) {\r\n            node = node.parent;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    export function getCombinedModifierFlags(node: Node): ModifierFlags {\r\n        node = walkUpBindingElementsAndPatterns(node);\r\n        let flags = getModifierFlags(node);\r\n        if (node.kind === SyntaxKind.VariableDeclaration) {\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableDeclarationList) {\r\n            flags |= getModifierFlags(node);\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableStatement) {\r\n            flags |= getModifierFlags(node);\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    // Returns the node flags for this node and all relevant parent nodes.  This is done so that\r\n    // nodes like variable declarations and binding elements can returned a view of their flags\r\n    // that includes the modifiers from their container.  i.e. flags like export/declare aren't\r\n    // stored on the variable declaration directly, but on the containing variable statement\r\n    // (if it has one).  Similarly, flags for let/const are store on the variable declaration\r\n    // list.  By calling this function, all those flags are combined so that the client can treat\r\n    // the node as if it actually had those flags.\r\n    export function getCombinedNodeFlags(node: Node): NodeFlags {\r\n        node = walkUpBindingElementsAndPatterns(node);\r\n\r\n        let flags = node.flags;\r\n        if (node.kind === SyntaxKind.VariableDeclaration) {\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableDeclarationList) {\r\n            flags |= node.flags;\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableStatement) {\r\n            flags |= node.flags;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the locale is in the appropriate format,\r\n     * and if it is, attempts to set the appropriate language.\r\n     */\r\n    export function validateLocaleAndSetLanguage(\r\n        locale: string,\r\n        sys: { getExecutingFilePath(): string, resolvePath(path: string): string, fileExists(fileName: string): boolean, readFile(fileName: string): string | undefined },\r\n        errors?: Push<Diagnostic>) {\r\n        const matchResult = /^([a-z]+)([_\\-]([a-z]+))?$/.exec(locale.toLowerCase());\r\n\r\n        if (!matchResult) {\r\n            if (errors) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, \"en\", \"ja-jp\"));\r\n            }\r\n            return;\r\n        }\r\n\r\n        const language = matchResult[1];\r\n        const territory = matchResult[3];\r\n\r\n        // First try the entire locale, then fall back to just language if that's all we have.\r\n        // Either ways do not fail, and fallback to the English diagnostic strings.\r\n        if (!trySetLanguageAndTerritory(language, territory, errors)) {\r\n            trySetLanguageAndTerritory(language, /*territory*/ undefined, errors);\r\n        }\r\n\r\n        function trySetLanguageAndTerritory(language: string, territory: string, errors?: Push<Diagnostic>): boolean {\r\n            const compilerFilePath = normalizePath(sys.getExecutingFilePath());\r\n            const containingDirectoryPath = getDirectoryPath(compilerFilePath);\r\n\r\n            let filePath = combinePaths(containingDirectoryPath, language);\r\n\r\n            if (territory) {\r\n                filePath = filePath + \"-\" + territory;\r\n            }\r\n\r\n            filePath = sys.resolvePath(combinePaths(filePath, \"diagnosticMessages.generated.json\"));\r\n\r\n            if (!sys.fileExists(filePath)) {\r\n                return false;\r\n            }\r\n\r\n            // TODO: Add codePage support for readFile?\r\n            let fileContents = \"\";\r\n            try {\r\n                fileContents = sys.readFile(filePath);\r\n            }\r\n            catch (e) {\r\n                if (errors) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Unable_to_open_file_0, filePath));\r\n                }\r\n                return false;\r\n            }\r\n            try {\r\n                ts.localizedDiagnosticMessages = JSON.parse(fileContents);\r\n            }\r\n            catch (e) {\r\n                if (errors) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath));\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    export function getOriginalNode(node: Node): Node;\r\n    export function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;\r\n    export function getOriginalNode(node: Node, nodeTest?: (node: Node) => boolean): Node {\r\n        if (node) {\r\n            while (node.original !== undefined) {\r\n                node = node.original;\r\n            }\r\n        }\r\n\r\n        return !nodeTest || nodeTest(node) ? node : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating whether a node originated in the parse tree.\r\n     *\r\n     * @param node The node to test.\r\n     */\r\n    export function isParseTreeNode(node: Node): boolean {\r\n        return (node.flags & NodeFlags.Synthesized) === 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the original parse tree node for a node.\r\n     *\r\n     * @param node The original node.\r\n     * @returns The original parse tree node if found; otherwise, undefined.\r\n     */\r\n    export function getParseTreeNode(node: Node): Node;\r\n\r\n    /**\r\n     * Gets the original parse tree node for a node.\r\n     *\r\n     * @param node The original node.\r\n     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.\r\n     * @returns The original parse tree node if found; otherwise, undefined.\r\n     */\r\n    export function getParseTreeNode<T extends Node>(node: Node, nodeTest?: (node: Node) => node is T): T;\r\n    export function getParseTreeNode(node: Node, nodeTest?: (node: Node) => boolean): Node {\r\n        if (node === undefined || isParseTreeNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        node = getOriginalNode(node);\r\n\r\n        if (isParseTreeNode(node) && (!nodeTest || nodeTest(node))) {\r\n            return node;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Remove extra underscore from escaped identifier text content.\r\n     *\r\n     * @param identifier The escaped identifier text.\r\n     * @returns The unescaped identifier text.\r\n     */\r\n    export function unescapeLeadingUnderscores(identifier: __String): string {\r\n        const id = identifier as string;\r\n        return id.length >= 3 && id.charCodeAt(0) === CharacterCodes._ && id.charCodeAt(1) === CharacterCodes._ && id.charCodeAt(2) === CharacterCodes._ ? id.substr(1) : id;\r\n    }\r\n\r\n    export function idText(identifier: Identifier): string {\r\n        return unescapeLeadingUnderscores(identifier.escapedText);\r\n    }\r\n    export function symbolName(symbol: Symbol): string {\r\n        return unescapeLeadingUnderscores(symbol.escapedName);\r\n    }\r\n\r\n    /**\r\n     * Remove extra underscore from escaped identifier text content.\r\n     * @deprecated Use `id.text` for the unescaped text.\r\n     * @param identifier The escaped identifier text.\r\n     * @returns The unescaped identifier text.\r\n     */\r\n    export function unescapeIdentifier(id: string): string {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * A JSDocTypedef tag has an _optional_ name field - if a name is not directly present, we should\r\n     * attempt to draw the name from the node the declaration is on (as that declaration is what its' symbol\r\n     * will be merged with)\r\n     */\r\n    function nameForNamelessJSDocTypedef(declaration: JSDocTypedefTag): Identifier | undefined {\r\n        const hostNode = declaration.parent.parent;\r\n        if (!hostNode) {\r\n            return undefined;\r\n        }\r\n        // Covers classes, functions - any named declaration host node\r\n        if (isDeclaration(hostNode)) {\r\n            return getDeclarationIdentifier(hostNode);\r\n        }\r\n        // Covers remaining cases\r\n        switch (hostNode.kind) {\r\n            case SyntaxKind.VariableStatement:\r\n                if ((hostNode as VariableStatement).declarationList &&\r\n                    (hostNode as VariableStatement).declarationList.declarations[0]) {\r\n                    return getDeclarationIdentifier((hostNode as VariableStatement).declarationList.declarations[0]);\r\n                }\r\n                return undefined;\r\n            case SyntaxKind.ExpressionStatement:\r\n                const expr = (hostNode as ExpressionStatement).expression;\r\n                switch (expr.kind) {\r\n                    case SyntaxKind.PropertyAccessExpression:\r\n                        return (expr as PropertyAccessExpression).name;\r\n                    case SyntaxKind.ElementAccessExpression:\r\n                        const arg = (expr as ElementAccessExpression).argumentExpression;\r\n                        if (isIdentifier(arg)) {\r\n                            return arg;\r\n                        }\r\n                }\r\n                return undefined;\r\n            case SyntaxKind.EndOfFileToken:\r\n                return undefined;\r\n            case SyntaxKind.ParenthesizedExpression: {\r\n                return getDeclarationIdentifier(hostNode.expression);\r\n            }\r\n            case SyntaxKind.LabeledStatement: {\r\n                if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {\r\n                    return getDeclarationIdentifier(hostNode.statement);\r\n                }\r\n                return undefined;\r\n            }\r\n            default:\r\n                Debug.assertNever(hostNode, \"Found typedef tag attached to node which it should not be!\");\r\n        }\r\n    }\r\n\r\n    function getDeclarationIdentifier(node: Declaration | Expression) {\r\n        const name = getNameOfDeclaration(node);\r\n        return isIdentifier(name) ? name : undefined;\r\n    }\r\n\r\n    export function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | undefined {\r\n        return declaration.name || nameForNamelessJSDocTypedef(declaration as JSDocTypedefTag);\r\n    }\r\n\r\n    export function getNameOfDeclaration(declaration: Declaration | Expression): DeclarationName | undefined {\r\n        if (!declaration) {\r\n            return undefined;\r\n        }\r\n        switch (declaration.kind) {\r\n            case SyntaxKind.JSDocPropertyTag:\r\n            case SyntaxKind.JSDocParameterTag: {\r\n                const { name } = declaration as JSDocPropertyLikeTag;\r\n                if (name.kind === SyntaxKind.QualifiedName) {\r\n                    return name.right;\r\n                }\r\n                break;\r\n            }\r\n            case SyntaxKind.BinaryExpression: {\r\n                const expr = declaration as BinaryExpression;\r\n                switch (getSpecialPropertyAssignmentKind(expr)) {\r\n                    case SpecialPropertyAssignmentKind.ExportsProperty:\r\n                    case SpecialPropertyAssignmentKind.ThisProperty:\r\n                    case SpecialPropertyAssignmentKind.Property:\r\n                    case SpecialPropertyAssignmentKind.PrototypeProperty:\r\n                        return (expr.left as PropertyAccessExpression).name;\r\n                    default:\r\n                        return undefined;\r\n                }\r\n            }\r\n            case SyntaxKind.JSDocTypedefTag:\r\n                return getNameOfJSDocTypedef(declaration as JSDocTypedefTag);\r\n            case SyntaxKind.ExportAssignment: {\r\n                const { expression } = declaration as ExportAssignment;\r\n                return isIdentifier(expression) ? expression : undefined;\r\n            }\r\n        }\r\n        return (declaration as NamedDeclaration).name;\r\n    }\r\n\r\n    /**\r\n     * Gets the JSDoc parameter tags for the node if present.\r\n     *\r\n     * @remarks Returns any JSDoc param tag that matches the provided\r\n     * parameter, whether a param tag on a containing function\r\n     * expression, or a param tag on a variable declaration whose\r\n     * initializer is the containing function. The tags closest to the\r\n     * node are returned first, so in the previous example, the param\r\n     * tag on the containing function expression would be first.\r\n     *\r\n     * Does not return tags for binding patterns, because JSDoc matches\r\n     * parameters by name and binding patterns do not have a name.\r\n     */\r\n    export function getJSDocParameterTags(param: ParameterDeclaration): ReadonlyArray<JSDocParameterTag> | undefined {\r\n        if (param.name && isIdentifier(param.name)) {\r\n            const name = param.name.escapedText;\r\n            return getJSDocTags(param.parent).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name) as JSDocParameterTag[];\r\n        }\r\n        // a binding pattern doesn't have a name, so it's not possible to match it a JSDoc parameter, which is identified by name\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Return true if the node has JSDoc parameter tags.\r\n     *\r\n     * @remarks Includes parameter tags that are not directly on the node,\r\n     * for example on a variable declaration whose initializer is a function expression.\r\n     */\r\n    export function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean {\r\n        return !!getFirstJSDocTag(node, SyntaxKind.JSDocParameterTag);\r\n    }\r\n\r\n    /** Gets the JSDoc augments tag for the node if present */\r\n    export function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined {\r\n        return getFirstJSDocTag(node, SyntaxKind.JSDocAugmentsTag) as JSDocAugmentsTag;\r\n    }\r\n\r\n    /** Gets the JSDoc class tag for the node if present */\r\n    export function getJSDocClassTag(node: Node): JSDocClassTag | undefined {\r\n        return getFirstJSDocTag(node, SyntaxKind.JSDocClassTag) as JSDocClassTag;\r\n    }\r\n\r\n    /** Gets the JSDoc return tag for the node if present */\r\n    export function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined {\r\n        return getFirstJSDocTag(node, SyntaxKind.JSDocReturnTag) as JSDocReturnTag;\r\n    }\r\n\r\n    /** Gets the JSDoc template tag for the node if present */\r\n    export function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined {\r\n        return getFirstJSDocTag(node, SyntaxKind.JSDocTemplateTag) as JSDocTemplateTag;\r\n    }\r\n\r\n    /** Gets the JSDoc type tag for the node if present and valid */\r\n    export function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined {\r\n        // We should have already issued an error if there were multiple type jsdocs, so just use the first one.\r\n        const tag = getFirstJSDocTag(node, SyntaxKind.JSDocTypeTag) as JSDocTypeTag;\r\n        if (tag && tag.typeExpression && tag.typeExpression.type) {\r\n            return tag;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the type node for the node if provided via JSDoc.\r\n     *\r\n     * @remarks The search includes any JSDoc param tag that relates\r\n     * to the provided parameter, for example a type tag on the\r\n     * parameter itself, or a param tag on a containing function\r\n     * expression, or a param tag on a variable declaration whose\r\n     * initializer is the containing function. The tags closest to the\r\n     * node are examined first, so in the previous example, the type\r\n     * tag directly on the node would be returned.\r\n     */\r\n    export function getJSDocType(node: Node): TypeNode | undefined {\r\n        let tag: JSDocTypeTag | JSDocParameterTag = getFirstJSDocTag(node, SyntaxKind.JSDocTypeTag) as JSDocTypeTag;\r\n        if (!tag && node.kind === SyntaxKind.Parameter) {\r\n            const paramTags = getJSDocParameterTags(node as ParameterDeclaration);\r\n            if (paramTags) {\r\n                tag = find(paramTags, tag => !!tag.typeExpression);\r\n            }\r\n        }\r\n\r\n        return tag && tag.typeExpression && tag.typeExpression.type;\r\n    }\r\n\r\n    /**\r\n     * Gets the return type node for the node if provided via JSDoc's return tag.\r\n     *\r\n     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function\r\n     * gets the type from inside the braces.\r\n     */\r\n    export function getJSDocReturnType(node: Node): TypeNode | undefined {\r\n        const returnTag = getJSDocReturnTag(node);\r\n        return returnTag && returnTag.typeExpression && returnTag.typeExpression.type;\r\n    }\r\n\r\n    /** Get all JSDoc tags related to a node, including those on parent nodes. */\r\n    export function getJSDocTags(node: Node): ReadonlyArray<JSDocTag> | undefined {\r\n        let tags = (node as JSDocContainer).jsDocCache;\r\n        // If cache is 'null', that means we did the work of searching for JSDoc tags and came up with nothing.\r\n        if (tags === undefined) {\r\n            (node as JSDocContainer).jsDocCache = tags = flatMap(getJSDocCommentsAndTags(node), j => isJSDoc(j) ? j.tags : j);\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    /** Get the first JSDoc tag of a specified kind, or undefined if not present. */\r\n    function getFirstJSDocTag(node: Node, kind: SyntaxKind): JSDocTag | undefined {\r\n        const tags = getJSDocTags(node);\r\n        return find(tags, doc => doc.kind === kind);\r\n    }\r\n\r\n    /** Gets all JSDoc tags of a specified kind, or undefined if not present. */\r\n    export function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): ReadonlyArray<JSDocTag> | undefined {\r\n        const tags = getJSDocTags(node);\r\n        return filter(tags, doc => doc.kind === kind);\r\n    }\r\n\r\n}\r\n\r\n// Simple node tests of the form `node.kind === SyntaxKind.Foo`.\r\nnamespace ts {\r\n    // Literals\r\n    export function isNumericLiteral(node: Node): node is NumericLiteral {\r\n        return node.kind === SyntaxKind.NumericLiteral;\r\n    }\r\n\r\n    export function isStringLiteral(node: Node): node is StringLiteral {\r\n        return node.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function isJsxText(node: Node): node is JsxText {\r\n        return node.kind === SyntaxKind.JsxText;\r\n    }\r\n\r\n    export function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral {\r\n        return node.kind === SyntaxKind.RegularExpressionLiteral;\r\n    }\r\n\r\n    export function isNoSubstitutionTemplateLiteral(node: Node): node is LiteralExpression {\r\n        return node.kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    // Pseudo-literals\r\n\r\n    export function isTemplateHead(node: Node): node is TemplateHead {\r\n        return node.kind === SyntaxKind.TemplateHead;\r\n    }\r\n\r\n    export function isTemplateMiddle(node: Node): node is TemplateMiddle {\r\n        return node.kind === SyntaxKind.TemplateMiddle;\r\n    }\r\n\r\n    export function isTemplateTail(node: Node): node is TemplateTail {\r\n        return node.kind === SyntaxKind.TemplateTail;\r\n    }\r\n\r\n    export function isIdentifier(node: Node): node is Identifier {\r\n        return node.kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    // Names\r\n\r\n    export function isQualifiedName(node: Node): node is QualifiedName {\r\n        return node.kind === SyntaxKind.QualifiedName;\r\n    }\r\n\r\n    export function isComputedPropertyName(node: Node): node is ComputedPropertyName {\r\n        return node.kind === SyntaxKind.ComputedPropertyName;\r\n    }\r\n\r\n    // Signature elements\r\n\r\n    export function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration {\r\n        return node.kind === SyntaxKind.TypeParameter;\r\n    }\r\n\r\n    export function isParameter(node: Node): node is ParameterDeclaration {\r\n        return node.kind === SyntaxKind.Parameter;\r\n    }\r\n\r\n    export function isDecorator(node: Node): node is Decorator {\r\n        return node.kind === SyntaxKind.Decorator;\r\n    }\r\n\r\n    // TypeMember\r\n\r\n    export function isPropertySignature(node: Node): node is PropertySignature {\r\n        return node.kind === SyntaxKind.PropertySignature;\r\n    }\r\n\r\n    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration {\r\n        return node.kind === SyntaxKind.PropertyDeclaration;\r\n    }\r\n\r\n    export function isMethodSignature(node: Node): node is MethodSignature {\r\n        return node.kind === SyntaxKind.MethodSignature;\r\n    }\r\n\r\n    export function isMethodDeclaration(node: Node): node is MethodDeclaration {\r\n        return node.kind === SyntaxKind.MethodDeclaration;\r\n    }\r\n\r\n    export function isConstructorDeclaration(node: Node): node is ConstructorDeclaration {\r\n        return node.kind === SyntaxKind.Constructor;\r\n    }\r\n\r\n    export function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.GetAccessor;\r\n    }\r\n\r\n    export function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.SetAccessor;\r\n    }\r\n\r\n    export function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration {\r\n        return node.kind === SyntaxKind.CallSignature;\r\n    }\r\n\r\n    export function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration {\r\n        return node.kind === SyntaxKind.ConstructSignature;\r\n    }\r\n\r\n    export function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration {\r\n        return node.kind === SyntaxKind.IndexSignature;\r\n    }\r\n\r\n    // Type\r\n\r\n    export function isTypePredicateNode(node: Node): node is TypePredicateNode {\r\n        return node.kind === SyntaxKind.TypePredicate;\r\n    }\r\n\r\n    export function isTypeReferenceNode(node: Node): node is TypeReferenceNode {\r\n        return node.kind === SyntaxKind.TypeReference;\r\n    }\r\n\r\n    export function isFunctionTypeNode(node: Node): node is FunctionTypeNode {\r\n        return node.kind === SyntaxKind.FunctionType;\r\n    }\r\n\r\n    export function isConstructorTypeNode(node: Node): node is ConstructorTypeNode {\r\n        return node.kind === SyntaxKind.ConstructorType;\r\n    }\r\n\r\n    export function isTypeQueryNode(node: Node): node is TypeQueryNode {\r\n        return node.kind === SyntaxKind.TypeQuery;\r\n    }\r\n\r\n    export function isTypeLiteralNode(node: Node): node is TypeLiteralNode {\r\n        return node.kind === SyntaxKind.TypeLiteral;\r\n    }\r\n\r\n    export function isArrayTypeNode(node: Node): node is ArrayTypeNode {\r\n        return node.kind === SyntaxKind.ArrayType;\r\n    }\r\n\r\n    export function isTupleTypeNode(node: Node): node is TupleTypeNode {\r\n        return node.kind === SyntaxKind.TupleType;\r\n    }\r\n\r\n    export function isUnionTypeNode(node: Node): node is UnionTypeNode {\r\n        return node.kind === SyntaxKind.UnionType;\r\n    }\r\n\r\n    export function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode {\r\n        return node.kind === SyntaxKind.IntersectionType;\r\n    }\r\n\r\n    export function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode {\r\n        return node.kind === SyntaxKind.ParenthesizedType;\r\n    }\r\n\r\n    export function isThisTypeNode(node: Node): node is ThisTypeNode {\r\n        return node.kind === SyntaxKind.ThisType;\r\n    }\r\n\r\n    export function isTypeOperatorNode(node: Node): node is TypeOperatorNode {\r\n        return node.kind === SyntaxKind.TypeOperator;\r\n    }\r\n\r\n    export function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode {\r\n        return node.kind === SyntaxKind.IndexedAccessType;\r\n    }\r\n\r\n    export function isMappedTypeNode(node: Node): node is MappedTypeNode {\r\n        return node.kind === SyntaxKind.MappedType;\r\n    }\r\n\r\n    export function isLiteralTypeNode(node: Node): node is LiteralTypeNode {\r\n        return node.kind === SyntaxKind.LiteralType;\r\n    }\r\n\r\n    // Binding patterns\r\n\r\n    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern {\r\n        return node.kind === SyntaxKind.ObjectBindingPattern;\r\n    }\r\n\r\n    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern {\r\n        return node.kind === SyntaxKind.ArrayBindingPattern;\r\n    }\r\n\r\n    export function isBindingElement(node: Node): node is BindingElement {\r\n        return node.kind === SyntaxKind.BindingElement;\r\n    }\r\n\r\n    // Expression\r\n\r\n    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression {\r\n        return node.kind === SyntaxKind.ArrayLiteralExpression;\r\n    }\r\n\r\n    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression {\r\n        return node.kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression {\r\n        return node.kind === SyntaxKind.PropertyAccessExpression;\r\n    }\r\n\r\n    export function isElementAccessExpression(node: Node): node is ElementAccessExpression {\r\n        return node.kind === SyntaxKind.ElementAccessExpression;\r\n    }\r\n\r\n    export function isCallExpression(node: Node): node is CallExpression {\r\n        return node.kind === SyntaxKind.CallExpression;\r\n    }\r\n\r\n    export function isNewExpression(node: Node): node is NewExpression {\r\n        return node.kind === SyntaxKind.NewExpression;\r\n    }\r\n\r\n    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression {\r\n        return node.kind === SyntaxKind.TaggedTemplateExpression;\r\n    }\r\n\r\n    export function isTypeAssertion(node: Node): node is TypeAssertion {\r\n        return node.kind === SyntaxKind.TypeAssertionExpression;\r\n    }\r\n\r\n    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression {\r\n        return node.kind === SyntaxKind.ParenthesizedExpression;\r\n    }\r\n\r\n    export function skipPartiallyEmittedExpressions(node: Expression): Expression;\r\n    export function skipPartiallyEmittedExpressions(node: Node): Node;\r\n    export function skipPartiallyEmittedExpressions(node: Node) {\r\n        while (node.kind === SyntaxKind.PartiallyEmittedExpression) {\r\n            node = (<PartiallyEmittedExpression>node).expression;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    export function isFunctionExpression(node: Node): node is FunctionExpression {\r\n        return node.kind === SyntaxKind.FunctionExpression;\r\n    }\r\n\r\n    export function isArrowFunction(node: Node): node is ArrowFunction {\r\n        return node.kind === SyntaxKind.ArrowFunction;\r\n    }\r\n\r\n    export function isDeleteExpression(node: Node): node is DeleteExpression {\r\n        return node.kind === SyntaxKind.DeleteExpression;\r\n    }\r\n\r\n    export function isTypeOfExpression(node: Node): node is TypeOfExpression {\r\n        return node.kind === SyntaxKind.AwaitExpression;\r\n    }\r\n\r\n    export function isVoidExpression(node: Node): node is VoidExpression {\r\n        return node.kind === SyntaxKind.VoidExpression;\r\n    }\r\n\r\n    export function isAwaitExpression(node: Node): node is AwaitExpression {\r\n        return node.kind === SyntaxKind.AwaitExpression;\r\n    }\r\n\r\n    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression {\r\n        return node.kind === SyntaxKind.PrefixUnaryExpression;\r\n    }\r\n\r\n    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression {\r\n        return node.kind === SyntaxKind.PostfixUnaryExpression;\r\n    }\r\n\r\n    export function isBinaryExpression(node: Node): node is BinaryExpression {\r\n        return node.kind === SyntaxKind.BinaryExpression;\r\n    }\r\n\r\n    export function isConditionalExpression(node: Node): node is ConditionalExpression {\r\n        return node.kind === SyntaxKind.ConditionalExpression;\r\n    }\r\n\r\n    export function isTemplateExpression(node: Node): node is TemplateExpression {\r\n        return node.kind === SyntaxKind.TemplateExpression;\r\n    }\r\n\r\n    export function isYieldExpression(node: Node): node is YieldExpression {\r\n        return node.kind === SyntaxKind.YieldExpression;\r\n    }\r\n\r\n    export function isSpreadElement(node: Node): node is SpreadElement {\r\n        return node.kind === SyntaxKind.SpreadElement;\r\n    }\r\n\r\n    export function isClassExpression(node: Node): node is ClassExpression {\r\n        return node.kind === SyntaxKind.ClassExpression;\r\n    }\r\n\r\n    export function isOmittedExpression(node: Node): node is OmittedExpression {\r\n        return node.kind === SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments {\r\n        return node.kind === SyntaxKind.ExpressionWithTypeArguments;\r\n    }\r\n\r\n    export function isAsExpression(node: Node): node is AsExpression {\r\n        return node.kind === SyntaxKind.AsExpression;\r\n    }\r\n\r\n    export function isNonNullExpression(node: Node): node is NonNullExpression {\r\n        return node.kind === SyntaxKind.NonNullExpression;\r\n    }\r\n\r\n    export function isMetaProperty(node: Node): node is MetaProperty {\r\n        return node.kind === SyntaxKind.MetaProperty;\r\n    }\r\n\r\n    // Misc\r\n\r\n    export function isTemplateSpan(node: Node): node is TemplateSpan {\r\n        return node.kind === SyntaxKind.TemplateSpan;\r\n    }\r\n\r\n    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement {\r\n        return node.kind === SyntaxKind.SemicolonClassElement;\r\n    }\r\n\r\n    // Block\r\n\r\n    export function isBlock(node: Node): node is Block {\r\n        return node.kind === SyntaxKind.Block;\r\n    }\r\n\r\n    export function isVariableStatement(node: Node): node is VariableStatement {\r\n        return node.kind === SyntaxKind.VariableStatement;\r\n    }\r\n\r\n    export function isEmptyStatement(node: Node): node is EmptyStatement {\r\n        return node.kind === SyntaxKind.EmptyStatement;\r\n    }\r\n\r\n    export function isExpressionStatement(node: Node): node is ExpressionStatement {\r\n        return node.kind === SyntaxKind.ExpressionStatement;\r\n    }\r\n\r\n    export function isIfStatement(node: Node): node is IfStatement {\r\n        return node.kind === SyntaxKind.IfStatement;\r\n    }\r\n\r\n    export function isDoStatement(node: Node): node is DoStatement {\r\n        return node.kind === SyntaxKind.DoStatement;\r\n    }\r\n\r\n    export function isWhileStatement(node: Node): node is WhileStatement {\r\n        return node.kind === SyntaxKind.WhileStatement;\r\n    }\r\n\r\n    export function isForStatement(node: Node): node is ForStatement {\r\n        return node.kind === SyntaxKind.ForStatement;\r\n    }\r\n\r\n    export function isForInStatement(node: Node): node is ForInStatement {\r\n        return node.kind === SyntaxKind.ForInStatement;\r\n    }\r\n\r\n    export function isForOfStatement(node: Node): node is ForOfStatement {\r\n        return node.kind === SyntaxKind.ForOfStatement;\r\n    }\r\n\r\n    export function isContinueStatement(node: Node): node is ContinueStatement {\r\n        return node.kind === SyntaxKind.ContinueStatement;\r\n    }\r\n\r\n    export function isBreakStatement(node: Node): node is BreakStatement {\r\n        return node.kind === SyntaxKind.BreakStatement;\r\n    }\r\n\r\n    export function isReturnStatement(node: Node): node is ReturnStatement {\r\n        return node.kind === SyntaxKind.ReturnStatement;\r\n    }\r\n\r\n    export function isWithStatement(node: Node): node is WithStatement {\r\n        return node.kind === SyntaxKind.WithStatement;\r\n    }\r\n\r\n    export function isSwitchStatement(node: Node): node is SwitchStatement {\r\n        return node.kind === SyntaxKind.SwitchStatement;\r\n    }\r\n\r\n    export function isLabeledStatement(node: Node): node is LabeledStatement {\r\n        return node.kind === SyntaxKind.LabeledStatement;\r\n    }\r\n\r\n    export function isThrowStatement(node: Node): node is ThrowStatement {\r\n        return node.kind === SyntaxKind.ThrowStatement;\r\n    }\r\n\r\n    export function isTryStatement(node: Node): node is TryStatement {\r\n        return node.kind === SyntaxKind.TryStatement;\r\n    }\r\n\r\n    export function isDebuggerStatement(node: Node): node is DebuggerStatement {\r\n        return node.kind === SyntaxKind.DebuggerStatement;\r\n    }\r\n\r\n    export function isVariableDeclaration(node: Node): node is VariableDeclaration {\r\n        return node.kind === SyntaxKind.VariableDeclaration;\r\n    }\r\n\r\n    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList {\r\n        return node.kind === SyntaxKind.VariableDeclarationList;\r\n    }\r\n\r\n    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\r\n        return node.kind === SyntaxKind.FunctionDeclaration;\r\n    }\r\n\r\n    export function isClassDeclaration(node: Node): node is ClassDeclaration {\r\n        return node.kind === SyntaxKind.ClassDeclaration;\r\n    }\r\n\r\n    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration {\r\n        return node.kind === SyntaxKind.InterfaceDeclaration;\r\n    }\r\n\r\n    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration {\r\n        return node.kind === SyntaxKind.TypeAliasDeclaration;\r\n    }\r\n\r\n    export function isEnumDeclaration(node: Node): node is EnumDeclaration {\r\n        return node.kind === SyntaxKind.EnumDeclaration;\r\n    }\r\n\r\n    export function isModuleDeclaration(node: Node): node is ModuleDeclaration {\r\n        return node.kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    export function isModuleBlock(node: Node): node is ModuleBlock {\r\n        return node.kind === SyntaxKind.ModuleBlock;\r\n    }\r\n\r\n    export function isCaseBlock(node: Node): node is CaseBlock {\r\n        return node.kind === SyntaxKind.CaseBlock;\r\n    }\r\n\r\n    export function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration {\r\n        return node.kind === SyntaxKind.NamespaceExportDeclaration;\r\n    }\r\n\r\n    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration;\r\n    }\r\n\r\n    export function isImportDeclaration(node: Node): node is ImportDeclaration {\r\n        return node.kind === SyntaxKind.ImportDeclaration;\r\n    }\r\n\r\n    export function isImportClause(node: Node): node is ImportClause {\r\n        return node.kind === SyntaxKind.ImportClause;\r\n    }\r\n\r\n    export function isNamespaceImport(node: Node): node is NamespaceImport {\r\n        return node.kind === SyntaxKind.NamespaceImport;\r\n    }\r\n\r\n    export function isNamedImports(node: Node): node is NamedImports {\r\n        return node.kind === SyntaxKind.NamedImports;\r\n    }\r\n\r\n    export function isImportSpecifier(node: Node): node is ImportSpecifier {\r\n        return node.kind === SyntaxKind.ImportSpecifier;\r\n    }\r\n\r\n    export function isExportAssignment(node: Node): node is ExportAssignment {\r\n        return node.kind === SyntaxKind.ExportAssignment;\r\n    }\r\n\r\n    export function isExportDeclaration(node: Node): node is ExportDeclaration {\r\n        return node.kind === SyntaxKind.ExportDeclaration;\r\n    }\r\n\r\n    export function isNamedExports(node: Node): node is NamedExports {\r\n        return node.kind === SyntaxKind.NamedExports;\r\n    }\r\n\r\n    export function isExportSpecifier(node: Node): node is ExportSpecifier {\r\n        return node.kind === SyntaxKind.ExportSpecifier;\r\n    }\r\n\r\n    export function isMissingDeclaration(node: Node): node is MissingDeclaration {\r\n        return node.kind === SyntaxKind.MissingDeclaration;\r\n    }\r\n\r\n    // Module References\r\n\r\n    export function isExternalModuleReference(node: Node): node is ExternalModuleReference {\r\n        return node.kind === SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    // JSX\r\n\r\n    export function isJsxElement(node: Node): node is JsxElement {\r\n        return node.kind === SyntaxKind.JsxElement;\r\n    }\r\n\r\n    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement {\r\n        return node.kind === SyntaxKind.JsxSelfClosingElement;\r\n    }\r\n\r\n    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement {\r\n        return node.kind === SyntaxKind.JsxOpeningElement;\r\n    }\r\n\r\n    export function isJsxClosingElement(node: Node): node is JsxClosingElement {\r\n        return node.kind === SyntaxKind.JsxClosingElement;\r\n    }\r\n\r\n    export function isJsxAttribute(node: Node): node is JsxAttribute {\r\n        return node.kind === SyntaxKind.JsxAttribute;\r\n    }\r\n\r\n    export function isJsxAttributes(node: Node): node is JsxAttributes {\r\n        return node.kind === SyntaxKind.JsxAttributes;\r\n    }\r\n\r\n    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute {\r\n        return node.kind === SyntaxKind.JsxSpreadAttribute;\r\n    }\r\n\r\n    export function isJsxExpression(node: Node): node is JsxExpression {\r\n        return node.kind === SyntaxKind.JsxExpression;\r\n    }\r\n\r\n    // Clauses\r\n\r\n    export function isCaseClause(node: Node): node is CaseClause {\r\n        return node.kind === SyntaxKind.CaseClause;\r\n    }\r\n\r\n    export function isDefaultClause(node: Node): node is DefaultClause {\r\n        return node.kind === SyntaxKind.DefaultClause;\r\n    }\r\n\r\n    export function isHeritageClause(node: Node): node is HeritageClause {\r\n        return node.kind === SyntaxKind.HeritageClause;\r\n    }\r\n\r\n    export function isCatchClause(node: Node): node is CatchClause {\r\n        return node.kind === SyntaxKind.CatchClause;\r\n    }\r\n\r\n    // Property assignments\r\n\r\n    export function isPropertyAssignment(node: Node): node is PropertyAssignment {\r\n        return node.kind === SyntaxKind.PropertyAssignment;\r\n    }\r\n\r\n    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment {\r\n        return node.kind === SyntaxKind.ShorthandPropertyAssignment;\r\n    }\r\n\r\n    export function isSpreadAssignment(node: Node): node is SpreadAssignment {\r\n        return node.kind === SyntaxKind.SpreadAssignment;\r\n    }\r\n\r\n    // Enum\r\n\r\n    export function isEnumMember(node: Node): node is EnumMember {\r\n        return node.kind === SyntaxKind.EnumMember;\r\n    }\r\n\r\n    // Top-level nodes\r\n    export function isSourceFile(node: Node): node is SourceFile {\r\n        return node.kind === SyntaxKind.SourceFile;\r\n    }\r\n\r\n    export function isBundle(node: Node): node is Bundle {\r\n        return node.kind === SyntaxKind.Bundle;\r\n    }\r\n\r\n    // JSDoc\r\n\r\n    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression {\r\n        return node.kind === SyntaxKind.JSDocTypeExpression;\r\n    }\r\n\r\n    export function isJSDocAllType(node: JSDocAllType): node is JSDocAllType {\r\n        return node.kind === SyntaxKind.JSDocAllType;\r\n    }\r\n\r\n    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType {\r\n        return node.kind === SyntaxKind.JSDocUnknownType;\r\n    }\r\n\r\n    export function isJSDocNullableType(node: Node): node is JSDocNullableType {\r\n        return node.kind === SyntaxKind.JSDocNullableType;\r\n    }\r\n\r\n    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType {\r\n        return node.kind === SyntaxKind.JSDocNonNullableType;\r\n    }\r\n\r\n    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType {\r\n        return node.kind === SyntaxKind.JSDocOptionalType;\r\n    }\r\n\r\n    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType {\r\n        return node.kind === SyntaxKind.JSDocFunctionType;\r\n    }\r\n\r\n    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType {\r\n        return node.kind === SyntaxKind.JSDocVariadicType;\r\n    }\r\n\r\n    export function isJSDoc(node: Node): node is JSDoc {\r\n        return node.kind === SyntaxKind.JSDocComment;\r\n    }\r\n\r\n    export function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag {\r\n        return node.kind === SyntaxKind.JSDocAugmentsTag;\r\n    }\r\n\r\n    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag {\r\n        return node.kind === SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag {\r\n        return node.kind === SyntaxKind.JSDocReturnTag;\r\n    }\r\n\r\n    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag {\r\n        return node.kind === SyntaxKind.JSDocTypeTag;\r\n    }\r\n\r\n    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag {\r\n        return node.kind === SyntaxKind.JSDocTemplateTag;\r\n    }\r\n\r\n    export function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag {\r\n        return node.kind === SyntaxKind.JSDocTypedefTag;\r\n    }\r\n\r\n    export function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag {\r\n        return node.kind === SyntaxKind.JSDocPropertyTag;\r\n    }\r\n\r\n    export function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag {\r\n        return node.kind === SyntaxKind.JSDocPropertyTag || node.kind === SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral {\r\n        return node.kind === SyntaxKind.JSDocTypeLiteral;\r\n    }\r\n}\r\n\r\n// Node tests\r\n//\r\n// All node tests in the following list should *not* reference parent pointers so that\r\n// they may be used with transformations.\r\nnamespace ts {\r\n    /* @internal */\r\n    export function isSyntaxList(n: Node): n is SyntaxList {\r\n        return n.kind === SyntaxKind.SyntaxList;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNode(node: Node) {\r\n        return isNodeKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNodeKind(kind: SyntaxKind) {\r\n        return kind >= SyntaxKind.FirstNode;\r\n    }\r\n\r\n    /**\r\n     * True if node is of some token syntax kind.\r\n     * For example, this is true for an IfKeyword but not for an IfStatement.\r\n     */\r\n    export function isToken(n: Node): boolean {\r\n        return n.kind >= SyntaxKind.FirstToken && n.kind <= SyntaxKind.LastToken;\r\n    }\r\n\r\n    // Node Arrays\r\n\r\n    /* @internal */\r\n    export function isNodeArray<T extends Node>(array: ReadonlyArray<T>): array is NodeArray<T> {\r\n        return array.hasOwnProperty(\"pos\") && array.hasOwnProperty(\"end\");\r\n    }\r\n\r\n    // Literals\r\n\r\n    /* @internal */\r\n    export function isLiteralKind(kind: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstLiteralToken <= kind && kind <= SyntaxKind.LastLiteralToken;\r\n    }\r\n\r\n    export function isLiteralExpression(node: Node): node is LiteralExpression {\r\n        return isLiteralKind(node.kind);\r\n    }\r\n\r\n    // Pseudo-literals\r\n\r\n    /* @internal */\r\n    export function isTemplateLiteralKind(kind: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstTemplateToken <= kind && kind <= SyntaxKind.LastTemplateToken;\r\n    }\r\n\r\n    export function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TemplateMiddle\r\n            || kind === SyntaxKind.TemplateTail;\r\n    }\r\n\r\n    export function isStringTextContainingNode(node: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.TemplateHead:\r\n            case SyntaxKind.TemplateMiddle:\r\n            case SyntaxKind.TemplateTail:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    // Identifiers\r\n\r\n    /* @internal */\r\n    export function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier {\r\n        // Using `>` here catches both `GeneratedIdentifierKind.None` and `undefined`.\r\n        return isIdentifier(node) && node.autoGenerateKind > GeneratedIdentifierKind.None;\r\n    }\r\n\r\n    // Keywords\r\n\r\n    /* @internal */\r\n    export function isModifierKind(token: SyntaxKind): boolean {\r\n        switch (token) {\r\n            case SyntaxKind.AbstractKeyword:\r\n            case SyntaxKind.AsyncKeyword:\r\n            case SyntaxKind.ConstKeyword:\r\n            case SyntaxKind.DeclareKeyword:\r\n            case SyntaxKind.DefaultKeyword:\r\n            case SyntaxKind.ExportKeyword:\r\n            case SyntaxKind.PublicKeyword:\r\n            case SyntaxKind.PrivateKeyword:\r\n            case SyntaxKind.ProtectedKeyword:\r\n            case SyntaxKind.ReadonlyKeyword:\r\n            case SyntaxKind.StaticKeyword:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isModifier(node: Node): node is Modifier {\r\n        return isModifierKind(node.kind);\r\n    }\r\n\r\n    export function isEntityName(node: Node): node is EntityName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.QualifiedName\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    export function isPropertyName(node: Node): node is PropertyName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.NumericLiteral\r\n            || kind === SyntaxKind.ComputedPropertyName;\r\n    }\r\n\r\n    export function isBindingName(node: Node): node is BindingName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.ObjectBindingPattern\r\n            || kind === SyntaxKind.ArrayBindingPattern;\r\n    }\r\n\r\n    // Functions\r\n\r\n    export function isFunctionLike(node: Node): node is FunctionLike {\r\n        return node && isFunctionLikeKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration {\r\n        return node && isFunctionLikeDeclarationKind(node.kind);\r\n    }\r\n\r\n    function isFunctionLikeDeclarationKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionLikeKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n                return true;\r\n            default:\r\n                return isFunctionLikeDeclarationKind(kind);\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionOrModuleBlock(node: Node): boolean {\r\n        return isSourceFile(node) || isModuleBlock(node) || isBlock(node) && isFunctionLike(node.parent);\r\n    }\r\n\r\n    // Classes\r\n    export function isClassElement(node: Node): node is ClassElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.PropertyDeclaration\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.IndexSignature\r\n            || kind === SyntaxKind.SemicolonClassElement\r\n            || kind === SyntaxKind.MissingDeclaration;\r\n    }\r\n\r\n    export function isClassLike(node: Node): node is ClassLikeDeclaration {\r\n        return node && (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression);\r\n    }\r\n\r\n    export function isAccessor(node: Node): node is AccessorDeclaration {\r\n        return node && (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor);\r\n    }\r\n\r\n    // Type members\r\n\r\n    export function isTypeElement(node: Node): node is TypeElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ConstructSignature\r\n            || kind === SyntaxKind.CallSignature\r\n            || kind === SyntaxKind.PropertySignature\r\n            || kind === SyntaxKind.MethodSignature\r\n            || kind === SyntaxKind.IndexSignature\r\n            || kind === SyntaxKind.MissingDeclaration;\r\n    }\r\n\r\n    export function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.PropertyAssignment\r\n            || kind === SyntaxKind.ShorthandPropertyAssignment\r\n            || kind === SyntaxKind.SpreadAssignment\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.MissingDeclaration;\r\n    }\r\n\r\n    // Type\r\n\r\n    function isTypeNodeKind(kind: SyntaxKind) {\r\n        return (kind >= SyntaxKind.FirstTypeNode && kind <= SyntaxKind.LastTypeNode)\r\n            || kind === SyntaxKind.AnyKeyword\r\n            || kind === SyntaxKind.NumberKeyword\r\n            || kind === SyntaxKind.ObjectKeyword\r\n            || kind === SyntaxKind.BooleanKeyword\r\n            || kind === SyntaxKind.StringKeyword\r\n            || kind === SyntaxKind.SymbolKeyword\r\n            || kind === SyntaxKind.ThisKeyword\r\n            || kind === SyntaxKind.VoidKeyword\r\n            || kind === SyntaxKind.UndefinedKeyword\r\n            || kind === SyntaxKind.NullKeyword\r\n            || kind === SyntaxKind.NeverKeyword\r\n            || kind === SyntaxKind.ExpressionWithTypeArguments\r\n            || kind === SyntaxKind.JSDocAllType\r\n            || kind === SyntaxKind.JSDocUnknownType\r\n            || kind === SyntaxKind.JSDocNullableType\r\n            || kind === SyntaxKind.JSDocNonNullableType\r\n            || kind === SyntaxKind.JSDocOptionalType\r\n            || kind === SyntaxKind.JSDocFunctionType\r\n            || kind === SyntaxKind.JSDocVariadicType;\r\n    }\r\n\r\n    /**\r\n     * Node test that determines whether a node is a valid type node.\r\n     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*\r\n     * of a TypeNode.\r\n     */\r\n    export function isTypeNode(node: Node): node is TypeNode {\r\n        return isTypeNodeKind(node.kind);\r\n    }\r\n\r\n    export function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode {\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Binding patterns\r\n\r\n    /* @internal */\r\n    export function isBindingPattern(node: Node): node is BindingPattern {\r\n        if (node) {\r\n            const kind = node.kind;\r\n            return kind === SyntaxKind.ArrayBindingPattern\r\n                || kind === SyntaxKind.ObjectBindingPattern;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isAssignmentPattern(node: Node): node is AssignmentPattern {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ArrayLiteralExpression\r\n            || kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n\r\n    /* @internal */\r\n    export function isArrayBindingElement(node: Node): node is ArrayBindingElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.BindingElement\r\n            || kind === SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n\r\n    /**\r\n     * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration\r\n     */\r\n    /* @internal */\r\n    export function isDeclarationBindingElement(bindingElement: BindingOrAssignmentElement): bindingElement is VariableDeclaration | ParameterDeclaration | BindingElement {\r\n        switch (bindingElement.kind) {\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.BindingElement:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is a BindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is BindingOrAssignmentPattern {\r\n        return isObjectBindingOrAssignmentPattern(node)\r\n            || isArrayBindingOrAssignmentPattern(node);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is an ObjectBindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ObjectBindingOrAssignmentPattern {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ObjectBindingPattern:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is an ArrayBindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ArrayBindingOrAssignmentPattern {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ArrayBindingPattern:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Expression\r\n\r\n    export function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.PropertyAccessExpression\r\n            || kind === SyntaxKind.QualifiedName;\r\n    }\r\n\r\n    export function isCallLikeExpression(node: Node): node is CallLikeExpression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.JsxOpeningElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.Decorator:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression {\r\n        return node.kind === SyntaxKind.CallExpression || node.kind === SyntaxKind.NewExpression;\r\n    }\r\n\r\n    export function isTemplateLiteral(node: Node): node is TemplateLiteral {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TemplateExpression\r\n            || kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression {\r\n        return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isLeftHandSideExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.ThisKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.NonNullExpression:\r\n            case SyntaxKind.MetaProperty:\r\n            case SyntaxKind.ImportKeyword: // technically this is only an Expression if it's in a CallExpression\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isUnaryExpression(node: Node): node is UnaryExpression {\r\n        return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isUnaryExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n                return true;\r\n            default:\r\n                return isLeftHandSideExpressionKind(kind);\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpression | PostfixUnaryExpression {\r\n        switch (expr.kind) {\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return true;\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                return (<PrefixUnaryExpression>expr).operator === SyntaxKind.PlusPlusToken ||\r\n                    (<PrefixUnaryExpression>expr).operator === SyntaxKind.MinusMinusToken;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * Determines whether a node is an expression based only on its kind.\r\n     * Use `isPartOfExpression` if not in transforms.\r\n     */\r\n    export function isExpression(node: Node): node is Expression {\r\n        return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.YieldExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.BinaryExpression:\r\n            case SyntaxKind.SpreadElement:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.OmittedExpression:\r\n            case SyntaxKind.CommaListExpression:\r\n            case SyntaxKind.PartiallyEmittedExpression:\r\n                return true;\r\n            default:\r\n                return isUnaryExpressionKind(kind);\r\n        }\r\n    }\r\n\r\n    export function isAssertionExpression(node: Node): node is AssertionExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TypeAssertionExpression\r\n            || kind === SyntaxKind.AsExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression {\r\n        return node.kind === SyntaxKind.PartiallyEmittedExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNotEmittedStatement(node: Node): node is NotEmittedStatement {\r\n        return node.kind === SyntaxKind.NotEmittedStatement;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNotEmittedOrPartiallyEmittedNode(node: Node): node is NotEmittedStatement | PartiallyEmittedExpression {\r\n        return isNotEmittedStatement(node)\r\n            || isPartiallyEmittedExpression(node);\r\n    }\r\n\r\n    // Statement\r\n\r\n    export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n            case SyntaxKind.DoStatement:\r\n            case SyntaxKind.WhileStatement:\r\n                return true;\r\n            case SyntaxKind.LabeledStatement:\r\n                return lookInLabeledStatements && isIterationStatement((<LabeledStatement>node).statement, lookInLabeledStatements);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isForInOrOfStatement(node: Node): node is ForInOrOfStatement {\r\n        return node.kind === SyntaxKind.ForInStatement || node.kind === SyntaxKind.ForOfStatement;\r\n    }\r\n\r\n    // Element\r\n\r\n    /* @internal */\r\n    export function isConciseBody(node: Node): node is ConciseBody {\r\n        return isBlock(node)\r\n            || isExpression(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionBody(node: Node): node is FunctionBody {\r\n        return isBlock(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isForInitializer(node: Node): node is ForInitializer {\r\n        return isVariableDeclarationList(node)\r\n            || isExpression(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isModuleBody(node: Node): node is ModuleBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ModuleBlock\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNamespaceBody(node: Node): node is NamespaceBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ModuleBlock\r\n            || kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJSDocNamespaceBody(node: Node): node is JSDocNamespaceBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNamedImportBindings(node: Node): node is NamedImportBindings {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.NamedImports\r\n            || kind === SyntaxKind.NamespaceImport;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isModuleOrEnumDeclaration(node: Node): node is ModuleDeclaration | EnumDeclaration {\r\n        return node.kind === SyntaxKind.ModuleDeclaration || node.kind === SyntaxKind.EnumDeclaration;\r\n    }\r\n\r\n    function isDeclarationKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.ArrowFunction\r\n            || kind === SyntaxKind.BindingElement\r\n            || kind === SyntaxKind.ClassDeclaration\r\n            || kind === SyntaxKind.ClassExpression\r\n            || kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.EnumDeclaration\r\n            || kind === SyntaxKind.EnumMember\r\n            || kind === SyntaxKind.ExportSpecifier\r\n            || kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.FunctionExpression\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.ImportClause\r\n            || kind === SyntaxKind.ImportEqualsDeclaration\r\n            || kind === SyntaxKind.ImportSpecifier\r\n            || kind === SyntaxKind.InterfaceDeclaration\r\n            || kind === SyntaxKind.JsxAttribute\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.MethodSignature\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.NamespaceExportDeclaration\r\n            || kind === SyntaxKind.NamespaceImport\r\n            || kind === SyntaxKind.Parameter\r\n            || kind === SyntaxKind.PropertyAssignment\r\n            || kind === SyntaxKind.PropertyDeclaration\r\n            || kind === SyntaxKind.PropertySignature\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.ShorthandPropertyAssignment\r\n            || kind === SyntaxKind.TypeAliasDeclaration\r\n            || kind === SyntaxKind.TypeParameter\r\n            || kind === SyntaxKind.VariableDeclaration\r\n            || kind === SyntaxKind.JSDocTypedefTag;\r\n    }\r\n\r\n    function isDeclarationStatementKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.MissingDeclaration\r\n            || kind === SyntaxKind.ClassDeclaration\r\n            || kind === SyntaxKind.InterfaceDeclaration\r\n            || kind === SyntaxKind.TypeAliasDeclaration\r\n            || kind === SyntaxKind.EnumDeclaration\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.ImportDeclaration\r\n            || kind === SyntaxKind.ImportEqualsDeclaration\r\n            || kind === SyntaxKind.ExportDeclaration\r\n            || kind === SyntaxKind.ExportAssignment\r\n            || kind === SyntaxKind.NamespaceExportDeclaration;\r\n    }\r\n\r\n    function isStatementKindButNotDeclarationKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.BreakStatement\r\n            || kind === SyntaxKind.ContinueStatement\r\n            || kind === SyntaxKind.DebuggerStatement\r\n            || kind === SyntaxKind.DoStatement\r\n            || kind === SyntaxKind.ExpressionStatement\r\n            || kind === SyntaxKind.EmptyStatement\r\n            || kind === SyntaxKind.ForInStatement\r\n            || kind === SyntaxKind.ForOfStatement\r\n            || kind === SyntaxKind.ForStatement\r\n            || kind === SyntaxKind.IfStatement\r\n            || kind === SyntaxKind.LabeledStatement\r\n            || kind === SyntaxKind.ReturnStatement\r\n            || kind === SyntaxKind.SwitchStatement\r\n            || kind === SyntaxKind.ThrowStatement\r\n            || kind === SyntaxKind.TryStatement\r\n            || kind === SyntaxKind.VariableStatement\r\n            || kind === SyntaxKind.WhileStatement\r\n            || kind === SyntaxKind.WithStatement\r\n            || kind === SyntaxKind.NotEmittedStatement\r\n            || kind === SyntaxKind.EndOfDeclarationMarker\r\n            || kind === SyntaxKind.MergeDeclarationMarker;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isDeclaration(node: Node): node is NamedDeclaration {\r\n        if (node.kind === SyntaxKind.TypeParameter) {\r\n            return node.parent.kind !== SyntaxKind.JSDocTemplateTag || isInJavaScriptFile(node);\r\n        }\r\n\r\n        return isDeclarationKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isDeclarationStatement(node: Node): node is DeclarationStatement {\r\n        return isDeclarationStatementKind(node.kind);\r\n    }\r\n\r\n    /**\r\n     * Determines whether the node is a statement that is not also a declaration\r\n     */\r\n    /* @internal */\r\n    export function isStatementButNotDeclaration(node: Node): node is Statement {\r\n        return isStatementKindButNotDeclarationKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isStatement(node: Node): node is Statement {\r\n        const kind = node.kind;\r\n        return isStatementKindButNotDeclarationKind(kind)\r\n            || isDeclarationStatementKind(kind)\r\n            || isBlockStatement(node);\r\n    }\r\n\r\n    function isBlockStatement(node: Node): node is Block {\r\n        if (node.kind !== SyntaxKind.Block) return false;\r\n        if (node.parent !== undefined) {\r\n            if (node.parent.kind === SyntaxKind.TryStatement || node.parent.kind === SyntaxKind.CatchClause) {\r\n                return false;\r\n            }\r\n        }\r\n        return !isFunctionBlock(node);\r\n    }\r\n\r\n    // Module references\r\n\r\n    /* @internal */\r\n    export function isModuleReference(node: Node): node is ModuleReference {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ExternalModuleReference\r\n            || kind === SyntaxKind.QualifiedName\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    // JSX\r\n\r\n    /* @internal */\r\n    export function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ThisKeyword\r\n            || kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.PropertyAccessExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJsxChild(node: Node): node is JsxChild {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxElement\r\n            || kind === SyntaxKind.JsxExpression\r\n            || kind === SyntaxKind.JsxSelfClosingElement\r\n            || kind === SyntaxKind.JsxText;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJsxAttributeLike(node: Node): node is JsxAttributeLike {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxAttribute\r\n            || kind === SyntaxKind.JsxSpreadAttribute;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.JsxExpression;\r\n    }\r\n\r\n    export function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxOpeningElement\r\n            || kind === SyntaxKind.JsxSelfClosingElement;\r\n    }\r\n\r\n    // Clauses\r\n\r\n    export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.CaseClause\r\n            || kind === SyntaxKind.DefaultClause;\r\n    }\r\n\r\n    // JSDoc\r\n\r\n    /** True if node is of some JSDoc syntax kind. */\r\n    /* @internal */\r\n    export function isJSDocNode(node: Node): boolean {\r\n        return node.kind >= SyntaxKind.FirstJSDocNode && node.kind <= SyntaxKind.LastJSDocNode;\r\n    }\r\n\r\n    /** True if node is of a kind that may contain comment text. */\r\n    export function isJSDocCommentContainingNode(node: Node): boolean {\r\n        return node.kind === SyntaxKind.JSDocComment || isJSDocTag(node);\r\n    }\r\n\r\n    // TODO: determine what this does before making it public.\r\n    /* @internal */\r\n    export function isJSDocTag(node: Node): boolean {\r\n        return node.kind >= SyntaxKind.FirstJSDocTagNode && node.kind <= SyntaxKind.LastJSDocTagNode;\r\n    }\r\n\r\n    export function isSetAccessor(node: Node): node is SetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.SetAccessor;\r\n    }\r\n\r\n    export function isGetAccessor(node: Node): node is GetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.GetAccessor;\r\n    }\r\n\r\n    /** True if has jsdoc nodes attached to it. */\r\n    /* @internal */\r\n    export function hasJSDocNodes(node: Node): node is HasJSDoc {\r\n        return !!(node as JSDocContainer).jsDoc && (node as JSDocContainer).jsDoc.length > 0;\r\n    }\r\n}\r\n\r\nnamespace ts {\r\n\r\n    export function 创建空对象<T>(): T {\r\n        let 结果 = Object.create(/** o */null)\r\n        结果.__ = undefined\r\n        delete 结果.__\r\n        return 结果\r\n    }\r\n\r\n    export function 取字典注释范围(node: Node, text: string): 词典注释范围[] | undefined {\r\n        const commentRanges = getLeadingCommentRanges(text, node.pos);\r\n        if (commentRanges) {\r\n            let 结果: 词典注释范围[] = []\r\n            for (const 注释 of commentRanges) {\r\n                if (text.charCodeAt(注释.pos + 1) === CharacterCodes.slash &&\r\n                    text.charCodeAt(注释.pos + 2) === CharacterCodes.at &&\r\n                    text.charCodeAt(注释.pos + 3) === CharacterCodes.openBrace) {\r\n                    let 值 = 创建空对象<词典注释范围>()\r\n                    值.词典旗帜 = 别名旗帜.局部词典\r\n                    值.注释范围 = 注释\r\n                    结果.push(值)\r\n                } else if (text.charCodeAt(注释.pos + 1) === CharacterCodes.slash &&\r\n                    text.charCodeAt(注释.pos + 2) === CharacterCodes.at &&\r\n                    text.charCodeAt(注释.pos + 3) === CharacterCodes.at &&\r\n                    text.charCodeAt(注释.pos + 4) === CharacterCodes.openBrace) {\r\n                    let 值 = 创建空对象<词典注释范围>()\r\n                    值.词典旗帜 = 别名旗帜.全局词典\r\n                    值.注释范围 = 注释\r\n                    结果.push(值)\r\n                }\r\n            }\r\n            if (结果 && 结果[0]) {\r\n                return 结果\r\n            }\r\n        }\r\n    }\r\n    export function 取声明的标识符或字面量标识符(声明节点: Declaration): Identifier | StringLiteral | undefined {\r\n        const 标识符 = getNameOfDeclaration(声明节点)\r\n        if (!标识符) {\r\n            return undefined;\r\n        }\r\n        return (isIdentifier(标识符) || isStringLiteral(标识符)) ? 标识符 : undefined;\r\n    }\r\n\r\n    export function 是局部词典语句(词典参数: 词典语句): 词典参数 is 局部词典语句 {\r\n        return 词典参数.kind === SyntaxKind.局部词典语句\r\n    }\r\n\r\n    export function 是全局词典语句(词典参数: 词典语句): 词典参数 is 全局词典语句 {\r\n        return 词典参数.kind === SyntaxKind.全局词典语句\r\n    }\r\n\r\n    export type 可比较名称类型 = 可携带词典类型 | string\r\n    export type 可携带词典类型 = Identifier | StringLiteral | NoSubstitutionTemplateLiteral | Symbol | StringLiteralType\r\n\r\n    function 是标识符(标识符参数: any): 标识符参数 is Identifier {\r\n        if (标识符参数) {\r\n            return !!标识符参数.escapedText\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function 是符号(符号参数: any): 符号参数 is Symbol {\r\n        if (符号参数) {\r\n            return !!符号参数.escapedName\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function 是字面量类型(类型参数: any): 类型参数 is StringLiteralType {\r\n        if (类型参数 && 类型参数.flags && (类型参数.flags & TypeFlags.StringLiteral)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function 是内置类型(类型参数: any): 类型参数 is IntrinsicType {\r\n        if (类型参数 && 类型参数.flags && (类型参数.flags & TypeFlags.Intrinsic)) {\r\n            return true\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function 是字面量节点(node: any): node is StringLiteral {\r\n        return node && node.kind && (node.kind === SyntaxKind.StringLiteral);\r\n    }\r\n\r\n    function 是模板字面量节点(node: any): node is NoSubstitutionTemplateLiteral {\r\n        return node && node.kind && (node.kind === SyntaxKind.NoSubstitutionTemplateLiteral);\r\n    }\r\n\r\n    export function 对象名称比较(左值: 可比较名称类型, 右值: 可比较名称类型) {\r\n        if (左值 === 右值) {\r\n            return true\r\n        } else {\r\n            let 左名称: __String, 右名称: __String, 左别名: __String, 右别名: __String;\r\n            if (isString(左值)) {\r\n                左名称 = (左值 as __String);\r\n            }\r\n            else if (是标识符(左值 as Identifier)) {\r\n                左名称 = (左值 as Identifier).escapedText;\r\n                左别名 = (左值 as Identifier).别名 && (左值 as Identifier).别名.名称;\r\n            }\r\n            else if (是符号(左值)) {\r\n                左名称 = (左值 as Symbol).escapedName;\r\n                左别名 = (左值 as Symbol).别名 && (左值 as Symbol).别名.名称;\r\n            }\r\n            else if (是字面量类型(左值)) {\r\n                左名称 = (左值 as StringLiteralType).value as __String;\r\n                左别名 = (左值 as StringLiteralType).别名 && (左值 as StringLiteralType).别名.名称;\r\n            }\r\n\r\n            if (isString(右值)) {\r\n                右名称 = (右值 as __String);\r\n            }\r\n            else if (是标识符(右值 as Identifier)) {\r\n                右名称 = (右值 as Identifier).escapedText;\r\n                右别名 = (右值 as Identifier).别名 && (右值 as Identifier).别名.名称;\r\n            }\r\n            else if (是符号(右值)) {\r\n                右名称 = (右值 as Symbol).escapedName;\r\n                右别名 = (右值 as Symbol).别名 && (右值 as Symbol).别名.名称;\r\n            }\r\n            else if (是字面量类型(右值)) {\r\n                右名称 = (右值 as StringLiteralType).value as __String;\r\n                右别名 = (右值 as StringLiteralType).别名 && (右值 as StringLiteralType).别名.名称;\r\n            }\r\n            if (左名称 || 右名称 || (左名称 && 右别名) || (右名称 && 左别名)) {\r\n                const 结果 = 对象名称是交叉相等的(创建文本别名(左名称, 左别名), 创建文本别名(右名称, 右别名));\r\n                return 结果\r\n            }\r\n            else {\r\n                return false\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function 对象名称是交叉相等的(左值: 文本名称, 右值: 文本名称) {\r\n        if (左值.名称 === 右值.名称) {\r\n            return true;\r\n        }\r\n        else if (右值.名称 && 左值.别名 === 右值.名称) {\r\n            return true;\r\n        }\r\n        else if (左值.名称 && 右值.别名 === 左值.名称) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function 创建文本别名(名称: __String | string, 别名参数: __String | string): 文本名称 {\r\n        let 结果 = 创建空对象<文本名称>()\r\n        结果.名称 = 名称;\r\n        结果.别名 = 别名参数\r\n        return 结果;\r\n    }\r\n\r\n    export function 交换词典键值(词典: 词典) {\r\n        let 结果 = 创建空对象<词典>();\r\n        结果 = { ...词典 };\r\n        结果.键 = { ...词典.值, kind: SyntaxKind.词典键 };\r\n        结果.值 = { ...词典.键, kind: SyntaxKind.词典值 };\r\n        结果.词典类别 = 词典.词典类别 === 别名旗帜.汉英 ? 别名旗帜.英汉 : 别名旗帜.汉英;\r\n        return 结果;\r\n    }\r\n\r\n    export function 取别名旗帜(词典: 词典, 旗帜?: 别名旗帜) {\r\n        return 旗帜 | 词典.是单向词典 | 词典.是文本字面量词典 | 词典.是内置词典 | 词典.是局部词典 | 词典.词典类别 | 词典.是全局词典;\r\n    }\r\n\r\n    export function 翻转别名旗帜(旗帜: 别名旗帜) {\r\n        return 旗帜 & 别名旗帜.汉英 ? 旗帜 ^ 别名旗帜.汉英 | 别名旗帜.英汉 : 旗帜 ^ 别名旗帜.英汉 | 别名旗帜.汉英;\r\n    }\r\n\r\n    export function 取符号从符号表按名称<T extends 可携带词典类型>(符号表: UnderscoreEscapedMap<T>, 名称: __String, 备选别名: 可携带词典类型 | string) {\r\n        if (!符号表) {\r\n            return\r\n        }\r\n        let 结果 = 符号表.get(名称)\r\n        if (!结果) {\r\n            if (备选别名) {\r\n                let 别名名称: string\r\n                if (isString(备选别名)) {\r\n                    别名名称 = 备选别名\r\n                } else if (备选别名.别名) {\r\n                    别名名称 = 备选别名.别名.名称 as string\r\n                }\r\n                if (别名名称 && 别名名称 !== 名称) {\r\n                    结果 = 符号表.get(别名名称 as __String)\r\n                }\r\n            }\r\n            if (!结果) {\r\n                结果 = forEachEntry(符号表, v => {\r\n                    if (v && v.别名 && v.别名.名称 === 名称) {\r\n                        return v\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        return 结果 as T\r\n    }\r\n\r\n    export function 创建别名数据(数据?: string): 别名数据 {\r\n        let 别名数据集: string[] = [null]\r\n        function 添加(数据: string) {\r\n            if (!数据) {\r\n                return -1\r\n            }\r\n            let 索引 = 别名数据集.lastIndexOf(数据)\r\n            if (索引 === -1) {\r\n                索引 = 别名数据集.push(数据) - 1\r\n            }\r\n            return 索引\r\n        }\r\n\r\n        if (数据) {\r\n            添加(数据)\r\n        }\r\n        let 元素数量 = 别名数据集.length - 1\r\n        return {\r\n            别名数据: 别名数据集,\r\n            添加,\r\n            元素数量\r\n        }\r\n    }\r\n\r\n    export function 词典携带组生成别名数据单元组(...元素: 可携带词典类型[]): string {\r\n        const 返回值: string[] = []\r\n        for (const 值 of 元素) {\r\n            const 临时 = 词典携带者生成别名数据(值)\r\n            if (临时) 返回值.push(临时)\r\n        }\r\n        return 返回值[0] && `{ ${(stableSort(返回值, compareStrings)).join(\", \")} }` || undefined\r\n    }\r\n\r\n    function 词典携带者生成别名数据(元素: 可携带词典类型): string {\r\n        let 原始文本: __String\r\n        if (是符号(元素)) {\r\n            原始文本 = 元素.escapedName\r\n        } else if (是标识符(元素)) {\r\n            原始文本 = 元素.escapedText\r\n        } else if (是字面量类型(元素)) {\r\n            原始文本 = 元素.value as __String\r\n        } else if (是内置类型(元素)) {\r\n            原始文本 = 元素.intrinsicName as __String\r\n        } else if (是字面量节点(元素) || 是模板字面量节点(元素)) {\r\n            原始文本 = 元素.text as __String\r\n        }\r\n        if (!原始文本) {\r\n            return undefined\r\n        }\r\n        let 别名 = 元素.别名\r\n        let 名称值: string\r\n        let 别名值: string\r\n        if (别名) {\r\n            名称值 = `\"${unescapeLeadingUnderscores(原始文本)}\"`\r\n            别名值 = `\"${unescapeLeadingUnderscores(别名.名称)}\"`\r\n            if (别名.旗帜 & 别名旗帜.汉英) {\r\n                return `${名称值}:${别名值}`\r\n            } else {\r\n                return `${别名值}:${名称值}`\r\n            }\r\n        }\r\n        return undefined\r\n    }\r\n\r\n    export function 词典携带者交换别名(源符号: 可比较名称类型, 目标: 可比较名称类型) {\r\n        if (!源符号 || !目标 || isString(源符号) || isString(目标) || (源符号 && 源符号.别名 && 目标 && 目标.别名)) {\r\n            return\r\n        }\r\n        if (源符号 && 源符号.别名 && 目标) {\r\n            传递别名(目标, 源符号)\r\n        } else if (目标 && 目标.别名 && 源符号) {\r\n            传递别名(源符号, 目标)\r\n        } else if (是符号(源符号)) {\r\n            传递符号声明的别名(源符号)\r\n            if (源符号.别名) {\r\n                词典携带者交换别名(目标, 源符号)\r\n            }\r\n        } else if (是符号(目标)) {\r\n            传递符号声明的别名(目标)\r\n            if (目标.别名) {\r\n                词典携带者交换别名(源符号, 目标)\r\n            }\r\n        }\r\n    }\r\n\r\n    function 传递符号声明的别名(符号参数: Symbol) {\r\n        if (是符号(符号参数)) {\r\n            if (符号参数.declarations && 符号参数.declarations.length) {\r\n                let 别名携带者\r\n                for (let 声明参数 of 符号参数.declarations) {\r\n                    let 声明名 = 取声明的标识符或字面量标识符(声明参数)\r\n                    if (声明名 && 声明名.别名) {\r\n                        别名携带者 = 声明名\r\n                        break\r\n                    }\r\n                }\r\n                if (别名携带者) {\r\n                    词典携带者交换别名(符号参数, 别名携带者)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export function 传递别名(别名接受者: 可携带词典类型, 别名提供者: 可携带词典类型) {\r\n        const 源的原始文本 = 取原始文本(别名提供者)\r\n        const 目标的原始文本 = 取原始文本(别名接受者)\r\n        const 别名参数 = 取别名(别名提供者)\r\n        if (源的原始文本 && (源的原始文本 === 目标的原始文本)) {\r\n            别名接受者.别名 = 别名参数\r\n        } else if (别名参数 && 别名参数.名称 && (别名参数.名称 === 目标的原始文本)) {\r\n            const 别名 = 创建空对象<别名>()\r\n            别名.名称 = 源的原始文本 as __String\r\n            别名.旗帜 = 翻转别名旗帜(别名参数.旗帜)\r\n            别名接受者.别名 = 别名\r\n        }\r\n        if (是符号(别名接受者) && 别名接受者.别名) {\r\n            for (const 声明节点 of 别名接受者.declarations) {\r\n                let 声明名 = 取声明的标识符或字面量标识符(声明节点)\r\n                if (声明名 && !声明名.别名) {\r\n                    声明名.别名 = 别名接受者.别名\r\n                    if (声明名.flowNode) {\r\n                        if (声明名.flowNode.flags & FlowFlags.Assignment) {\r\n                            let 流程节点 = (<FlowAssignment>声明名.flowNode).node\r\n                            if (流程节点 && 流程节点.symbol) {\r\n                                传递别名(流程节点.symbol, 声明名)\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function 取原始文本(元素: 可携带词典类型) {\r\n        let 原始文本 = \"\"\r\n        if (是符号(元素)) {\r\n            原始文本 = 元素.escapedName as string\r\n        } else if (是标识符(元素)) {\r\n            原始文本 = 元素.escapedText as string\r\n        } else if (是字面量类型(元素)) {\r\n            原始文本 = 元素.value\r\n        } else if (是内置类型(元素)) {\r\n            原始文本 = 元素.intrinsicName\r\n        } else if (是字面量节点(元素) || 是模板字面量节点(元素)) {\r\n            原始文本 = 元素.text\r\n        }\r\n        return 原始文本\r\n    }\r\n\r\n    function 取别名(元素: 可携带词典类型) {\r\n        return 元素.别名\r\n    }\r\n\r\n    export function 取属性名的标识符(name: PropertyName): Identifier | StringLiteral | undefined {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n                return <Identifier>name;\r\n            case SyntaxKind.StringLiteral:\r\n                return <StringLiteral>name;\r\n            case SyntaxKind.ComputedPropertyName:\r\n                if (isStringLiteral((<ComputedPropertyName>name).expression)) {\r\n                    return <StringLiteral>(<ComputedPropertyName>name).expression\r\n                }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function 取节点的文本(node: Node, includeTrivia = false): string {\r\n        return 取输出文本从源文件按节点(getSourceFileOfNode(node), node, includeTrivia);\r\n    }\r\n\r\n    export function 取输出文本从源文件按节点(sourceFile: SourceFile, node: Node, includeTrivia = false): string {\r\n        if (nodeIsMissing(node)) {\r\n            return \"\";\r\n        }\r\n        const 源码文本 = sourceFile.text;\r\n        let 前部的琐事: string;\r\n        if (includeTrivia) {\r\n            前部的琐事 = 源码文本.substring(node.pos, skipTrivia(源码文本, node.pos));\r\n        }\r\n        const 结果 = 输出节点编码英文(node, 前部的琐事)\r\n        if (结果) {\r\n            return 结果\r\n        }\r\n        return 源码文本.substring(includeTrivia ? node.pos : skipTrivia(源码文本, node.pos), node.end);\r\n    }\r\n\r\n    export function 解码文本(别名参数: 别名) {\r\n        return unescapeLeadingUnderscores(别名参数.名称)\r\n    }\r\n\r\n    function 输出节点编码英文(node: Node, 前部琐事?: string) {\r\n        if (!(node && (isIdentifier(node) || isStringLiteral(node)) && node.别名)) {\r\n            return;\r\n        }\r\n        if (node.别名.旗帜 & 别名旗帜.汉英) {\r\n            if (前部琐事) {\r\n                return 是字面量节点(node) ? `\"${前部琐事}${解码文本(node.别名)}\"` : 前部琐事 + 解码文本(node.别名);\r\n            }\r\n            else {\r\n                return 是字面量节点(node) ? `\"${解码文本(node.别名)}\"` : 解码文本(node.别名);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    export function 取文本从标识符或字面量(node: Identifier | LiteralLikeNode) {\r\n        if (node) {\r\n            if (node.kind === SyntaxKind.Identifier) {\r\n                return (node as Identifier).别名 ? unescapeLeadingUnderscores((node as Identifier).别名.名称) as string : idText(node as Identifier);\r\n            }\r\n            if (node.kind === SyntaxKind.NumericLiteral) {\r\n                return (node as LiteralLikeNode).text;\r\n            }\r\n            if (node.kind === SyntaxKind.StringLiteral) {\r\n                return (node as StringLiteral).别名 ? (node as StringLiteral).别名.名称 as string : (node as StringLiteral).text;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function 取属性别名名称从声明名(name: DeclarationName): __String {\r\n        if (name.kind === SyntaxKind.Identifier) {\r\n            return name.别名 && name.别名.名称\r\n        }\r\n        if (name.kind === SyntaxKind.StringLiteral) {\r\n            return name.别名 && name.别名.名称\r\n        }\r\n        if (name.kind === SyntaxKind.ComputedPropertyName) {\r\n            const nameExpression = name.expression;\r\n            if (isWellKnownSymbolSyntactically(nameExpression)) {\r\n                if ((<PropertyAccessExpression>nameExpression).name.别名) {\r\n                    return (\"__@\" + unescapeLeadingUnderscores((<PropertyAccessExpression>nameExpression).name.别名.名称)) as __String\r\n                }\r\n                return undefined;\r\n\r\n            }\r\n            else if (nameExpression.kind === SyntaxKind.StringLiteral || nameExpression.kind === SyntaxKind.NumericLiteral) {\r\n                if ((<Identifier>nameExpression).别名) {\r\n                    return (<Identifier>nameExpression).别名.名称\r\n                }\r\n                return undefined;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function 取别名从属性名(node: PropertyName) {\r\n        return 取属性名的标识符(node) ? 取属性名的标识符(node).别名 : undefined\r\n    }\r\n\r\n    export function 是单类型节点携带者(node: Node): node is 单类型节点携带者 {\r\n        switch (node.kind) {\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.BindingElement:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.JsxAttribute:\r\n            case SyntaxKind.ShorthandPropertyAssignment:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.JSDocPropertyTag:\r\n            case SyntaxKind.JSDocParameterTag:\r\n            case SyntaxKind.TypePredicate:\r\n            case SyntaxKind.ParenthesizedType:\r\n            case SyntaxKind.TypeOperator:\r\n            case SyntaxKind.MappedType:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n            case SyntaxKind.JSDocTypeExpression:\r\n            case SyntaxKind.JSDocNonNullableType:\r\n            case SyntaxKind.JSDocNullableType:\r\n            case SyntaxKind.JSDocOptionalType:\r\n            case SyntaxKind.JSDocVariadicType:\r\n                return true\r\n            default:\r\n                return false\r\n\r\n        }\r\n    }\r\n\r\n    export function 是类型集节点携带者(node: Node): node is 类型集节点携带者 {\r\n        switch (node.kind) {\r\n            case SyntaxKind.UnionType:\r\n            case SyntaxKind.IntersectionType:\r\n                return true\r\n            default:\r\n                return false\r\n\r\n        }\r\n    }\r\n\r\n    export function 是类型参数节点携带者(node: Node): node is 类型参数节点携带者 {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.TypeReference:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n            case SyntaxKind.NewExpression:\r\n                return true\r\n            default:\r\n                return false\r\n\r\n        }\r\n    }\r\n\r\n    export function 是元素类型节点携带者(node: Node): node is 元素类型节点携带者 {\r\n        return node.kind === SyntaxKind.ArrayType\r\n    }\r\n\r\n    export function 是元素集类型节点携带者(node: Node): node is 元素集类型节点携带者 {\r\n        return node.kind === SyntaxKind.TupleType\r\n\r\n    }\r\n\r\n    export function 是默认及约束类型节点携带者(node: Node): node is 默认及约束类型节点携带者 {\r\n        return node.kind === SyntaxKind.TypeParameter\r\n    }\r\n\r\n    export function 是对象及索引类型节点携带者(node: Node): node is 对象及索引类型节点携带者 {\r\n        return node.kind === SyntaxKind.IndexedAccessType\r\n    }\r\n\r\n    export const 内置JSDoc标签名 = createMapFromTemplate({\r\n        \"@type\": \"@类型\",\r\n        \"@typedef\": \"@定义类型\",\r\n        \"@prop\": \"@属性\",\r\n        \"@property\": \"@属性\",\r\n        \"@arg\": \"@参数\",\r\n        \"@param\": \"@参数\",\r\n        \"@augments\": \"@增强参数集\",\r\n        \"@augment\": \"@增强参数\",\r\n        \"@return\": \"@返回\",\r\n        \"@returns\": \"@返回\",\r\n        \"@class\": \"@类\",\r\n        \"@constructor\": \"@构造函数\",\r\n        \"@template\": \"@模板\",\r\n    });\r\n\r\n\r\n    export const JSDoc标签正则表达式 = /\\b(@type|@property|@prop|@typedef|@augments|@augment|@template|@return|@returns|@arg|@param|@constructor|@class)\\b/gim;\r\n\r\n    export function 替换JSDoc标签(评论文本: string) {\r\n        return 评论文本.replace(JSDoc标签正则表达式, (s) => {\r\n            return 内置JSDoc标签名.get(s) || s;\r\n        });\r\n    }\r\n\r\n\r\n    export function 处理模块引用路径(路径: string) {\r\n        return 规范路径(路径).replace(/@types/gim, \"@typesch\");\r\n        function 规范路径(路径: string) {\r\n            return 路径.replace(/\\\\/g, \"/\");\r\n        }\r\n    }\r\n\r\n    export function 处理头部三斜线指令(文本: string) {\r\n        const 分组 = 文本.split(取换行符(文本));\r\n        let 返回文本: string[];\r\n\r\n        for (const s of 分组) {\r\n            const mod = AMD附属替换(s) || 不使用默认库替换(s) || AMD替换(s) || 路径替换(s) || 类型集替换(s);\r\n            if (mod) {\r\n                (返回文本 || (返回文本 = [])).push(mod);\r\n            }\r\n            else {\r\n                (返回文本 || (返回文本 = [])).push(s);\r\n            }\r\n        }\r\n\r\n        return 返回文本 ? 返回文本.join(取换行符(文本)) : 文本;\r\n\r\n\r\n        function 取换行符(文本: string) {\r\n            const 换行符 = [\"\\r\\n\", \"\\n\", \"\\r\"];\r\n            if (文本.indexOf(换行符[0]) > -1) {\r\n                return 换行符[0];\r\n            }\r\n            if (文本.indexOf(换行符[1]) > -1) {\r\n                return 换行符[1];\r\n            }\r\n            if (文本.indexOf(换行符[2]) > -1) {\r\n                return 换行符[2];\r\n            }\r\n            return 换行符[0];\r\n        }\r\n\r\n        function 不使用默认库替换(s: string) {\r\n            return /^\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*('|\")(.+?)\\1\\s*\\/>/gim.test(s) ?\r\n                s.replace(/^\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*('|\")(.+?)\\1\\s*\\/>/gim, `/// <引用 不使用默认支持库= \"真\"/>`) : undefined;\r\n        }\r\n\r\n        function AMD替换(s: string) {\r\n            return /^\\/\\/\\/\\s*<amd-module\\s+/gim.test(s) ?\r\n                s.replace(/^\\/\\/\\/\\s*<amd-module\\s/gim, \"/// <AMD模块 \").replace(/\\s(path)\\s*=\\s*('|\")(.+?)\\2/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \" 路径= \";\r\n                    return sss + ssss + 处理模块引用路径(sssss) + ssss + \" />\";\r\n                }).replace(/\\s(name)\\s*=\\s*('|\")(.+?)\\2/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \" 名称= \";\r\n                    return sss + ssss + sssss + ssss + \" />\";\r\n                }) : undefined;\r\n        }\r\n\r\n        function AMD附属替换(s: string) {\r\n            return /^\\/\\/\\/\\s*<amd-dependency\\s+/gim.test(s) ?\r\n                s.replace(/^\\/\\/\\/\\s*<amd-dependency\\s+/gim, \"/// <AMD附件 \").replace(/\\s(path)\\s*=\\s*('|\")(.+?)\\2/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \" 路径= \";\r\n                    return sss + ssss + 处理模块引用路径(sssss) + ssss + \" />\";\r\n                }).replace(/\\s(name)\\s*=\\s*('|\")(.+?)\\2/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \" 名称= \";\r\n                    return sss + ssss + sssss + ssss + \" />\";\r\n                }) : undefined;\r\n        }\r\n\r\n        function 路径替换(s: string) {\r\n            return /^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/gim.test(s) ?\r\n                s.replace(/^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \"/// <引用 路径= \";\r\n                    return sss + ssss + 处理模块引用路径(sssss) + ssss + \" />\";\r\n                }) : undefined;\r\n        }\r\n\r\n        function 类型集替换(s: string) {\r\n            return /^(\\/\\/\\/\\s*<reference\\s+types\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/gim.test(s) ?\r\n                s.replace(/^(\\/\\/\\/\\s*<reference\\s+types\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/gim, (ss, sss, ssss, sssss) => {\r\n                    ss = ss;\r\n                    sss = \"/// <引用 类型集= \";\r\n                    return sss + ssss + sssss + ssss + \" />\";\r\n                }) : undefined;\r\n        }\r\n    }\r\n\r\n}\r\n","/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"diagnosticInformationMap.generated.ts\"/>\r\n\r\nnamespace ts {\r\n    export interface ErrorCallback {\r\n        (message: DiagnosticMessage, length: number): void;\r\n    }\r\n\r\n    /* @internal */\r\n    export function tokenIsIdentifierOrKeyword(token: SyntaxKind): boolean {\r\n        return token >= SyntaxKind.Identifier;\r\n    }\r\n\r\n    export interface Scanner {\r\n        getStartPos(): number;\r\n        getToken(): SyntaxKind;\r\n        getTextPos(): number;\r\n        getTokenPos(): number;\r\n        getTokenText(): string;\r\n        getTokenValue(): string;\r\n        hasExtendedUnicodeEscape(): boolean;\r\n        hasPrecedingLineBreak(): boolean;\r\n        isIdentifier(): boolean;\r\n        isReservedWord(): boolean;\r\n        isUnterminated(): boolean;\r\n        /* @internal */\r\n        getNumericLiteralFlags(): NumericLiteralFlags;\r\n        reScanGreaterToken(): SyntaxKind;\r\n        reScanSlashToken(): SyntaxKind;\r\n        reScanTemplateToken(): SyntaxKind;\r\n        scanJsxIdentifier(): SyntaxKind;\r\n        scanJsxAttributeValue(): SyntaxKind;\r\n        reScanJsxToken(): SyntaxKind;\r\n        scanJsxToken(): SyntaxKind;\r\n        scanJSDocToken(): SyntaxKind;\r\n        scan(): SyntaxKind;\r\n        翻译词典扫描(): SyntaxKind;\r\n        扫描词典主体(): SyntaxKind;\r\n        getText(): string;\r\n        // Sets the text for the scanner to scan.  An optional subrange starting point and length\r\n        // can be provided to have the scanner only scan a portion of the text.\r\n        setText(text: string, start?: number, length?: number): void;\r\n        setOnError(onError: ErrorCallback): void;\r\n        setScriptTarget(scriptTarget: ScriptTarget): void;\r\n        setLanguageVariant(variant: LanguageVariant): void;\r\n        setTextPos(textPos: number): void;\r\n        // Invokes the provided callback then unconditionally restores the scanner to the state it\r\n        // was in immediately prior to invoking the callback.  The result of invoking the callback\r\n        // is returned from this function.\r\n        lookAhead<T>(callback: () => T): T;\r\n\r\n        // Invokes the callback with the scanner set to scan the specified range. When the callback\r\n        // returns, the scanner is restored to the state it was in before scanRange was called.\r\n        scanRange<T>(start: number, length: number, callback: () => T): T;\r\n\r\n        // Invokes the provided callback.  If the callback returns something falsy, then it restores\r\n        // the scanner to the state it was in immediately prior to invoking the callback.  If the\r\n        // callback returns something truthy, then the scanner state is not rolled back.  The result\r\n        // of invoking the callback is returned from this function.\r\n        tryScan<T>(callback: () => T): T;\r\n    }\r\n\r\n    const textToToken = createMapFromTemplate({\r\n        \"abstract\": SyntaxKind.AbstractKeyword,\r\n        \"any\": SyntaxKind.AnyKeyword,\r\n        \"as\": SyntaxKind.AsKeyword,\r\n        \"boolean\": SyntaxKind.BooleanKeyword,\r\n        \"break\": SyntaxKind.BreakKeyword,\r\n        \"case\": SyntaxKind.CaseKeyword,\r\n        \"catch\": SyntaxKind.CatchKeyword,\r\n        \"class\": SyntaxKind.ClassKeyword,\r\n        \"continue\": SyntaxKind.ContinueKeyword,\r\n        \"const\": SyntaxKind.ConstKeyword,\r\n        \"constructor\": SyntaxKind.ConstructorKeyword,\r\n        \"debugger\": SyntaxKind.DebuggerKeyword,\r\n        \"declare\": SyntaxKind.DeclareKeyword,\r\n        \"default\": SyntaxKind.DefaultKeyword,\r\n        \"delete\": SyntaxKind.DeleteKeyword,\r\n        \"do\": SyntaxKind.DoKeyword,\r\n        \"else\": SyntaxKind.ElseKeyword,\r\n        \"enum\": SyntaxKind.EnumKeyword,\r\n        \"export\": SyntaxKind.ExportKeyword,\r\n        \"extends\": SyntaxKind.ExtendsKeyword,\r\n        \"false\": SyntaxKind.FalseKeyword,\r\n        \"finally\": SyntaxKind.FinallyKeyword,\r\n        \"for\": SyntaxKind.ForKeyword,\r\n        \"from\": SyntaxKind.FromKeyword,\r\n        \"function\": SyntaxKind.FunctionKeyword,\r\n        \"get\": SyntaxKind.GetKeyword,\r\n        \"if\": SyntaxKind.IfKeyword,\r\n        \"implements\": SyntaxKind.ImplementsKeyword,\r\n        \"import\": SyntaxKind.ImportKeyword,\r\n        \"in\": SyntaxKind.InKeyword,\r\n        \"instanceof\": SyntaxKind.InstanceOfKeyword,\r\n        \"interface\": SyntaxKind.InterfaceKeyword,\r\n        \"is\": SyntaxKind.IsKeyword,\r\n        \"keyof\": SyntaxKind.KeyOfKeyword,\r\n        \"let\": SyntaxKind.LetKeyword,\r\n        \"module\": SyntaxKind.ModuleKeyword,\r\n        \"namespace\": SyntaxKind.NamespaceKeyword,\r\n        \"never\": SyntaxKind.NeverKeyword,\r\n        \"new\": SyntaxKind.NewKeyword,\r\n        \"null\": SyntaxKind.NullKeyword,\r\n        \"number\": SyntaxKind.NumberKeyword,\r\n        \"object\": SyntaxKind.ObjectKeyword,\r\n        \"package\": SyntaxKind.PackageKeyword,\r\n        \"private\": SyntaxKind.PrivateKeyword,\r\n        \"protected\": SyntaxKind.ProtectedKeyword,\r\n        \"public\": SyntaxKind.PublicKeyword,\r\n        \"readonly\": SyntaxKind.ReadonlyKeyword,\r\n        \"require\": SyntaxKind.RequireKeyword,\r\n        \"global\": SyntaxKind.GlobalKeyword,\r\n        \"return\": SyntaxKind.ReturnKeyword,\r\n        \"set\": SyntaxKind.SetKeyword,\r\n        \"static\": SyntaxKind.StaticKeyword,\r\n        \"string\": SyntaxKind.StringKeyword,\r\n        \"super\": SyntaxKind.SuperKeyword,\r\n        \"switch\": SyntaxKind.SwitchKeyword,\r\n        \"symbol\": SyntaxKind.SymbolKeyword,\r\n        \"this\": SyntaxKind.ThisKeyword,\r\n        \"throw\": SyntaxKind.ThrowKeyword,\r\n        \"true\": SyntaxKind.TrueKeyword,\r\n        \"try\": SyntaxKind.TryKeyword,\r\n        \"type\": SyntaxKind.TypeKeyword,\r\n        \"typeof\": SyntaxKind.TypeOfKeyword,\r\n        \"undefined\": SyntaxKind.UndefinedKeyword,\r\n        \"var\": SyntaxKind.VarKeyword,\r\n        \"void\": SyntaxKind.VoidKeyword,\r\n        \"while\": SyntaxKind.WhileKeyword,\r\n        \"with\": SyntaxKind.WithKeyword,\r\n        \"yield\": SyntaxKind.YieldKeyword,\r\n        \"async\": SyntaxKind.AsyncKeyword,\r\n        \"await\": SyntaxKind.AwaitKeyword,\r\n        \"of\": SyntaxKind.OfKeyword,\r\n        \"{\": SyntaxKind.OpenBraceToken,\r\n        \"}\": SyntaxKind.CloseBraceToken,\r\n        \"(\": SyntaxKind.OpenParenToken,\r\n        \")\": SyntaxKind.CloseParenToken,\r\n        \"[\": SyntaxKind.OpenBracketToken,\r\n        \"]\": SyntaxKind.CloseBracketToken,\r\n        \".\": SyntaxKind.DotToken,\r\n        \"...\": SyntaxKind.DotDotDotToken,\r\n        \";\": SyntaxKind.SemicolonToken,\r\n        \",\": SyntaxKind.CommaToken,\r\n        \"<\": SyntaxKind.LessThanToken,\r\n        \">\": SyntaxKind.GreaterThanToken,\r\n        \"<=\": SyntaxKind.LessThanEqualsToken,\r\n        \">=\": SyntaxKind.GreaterThanEqualsToken,\r\n        \"==\": SyntaxKind.EqualsEqualsToken,\r\n        \"!=\": SyntaxKind.ExclamationEqualsToken,\r\n        \"===\": SyntaxKind.EqualsEqualsEqualsToken,\r\n        \"!==\": SyntaxKind.ExclamationEqualsEqualsToken,\r\n        \"=>\": SyntaxKind.EqualsGreaterThanToken,\r\n        \"+\": SyntaxKind.PlusToken,\r\n        \"-\": SyntaxKind.MinusToken,\r\n        \"**\": SyntaxKind.AsteriskAsteriskToken,\r\n        \"*\": SyntaxKind.AsteriskToken,\r\n        \"/\": SyntaxKind.SlashToken,\r\n        \"%\": SyntaxKind.PercentToken,\r\n        \"++\": SyntaxKind.PlusPlusToken,\r\n        \"--\": SyntaxKind.MinusMinusToken,\r\n        \"<<\": SyntaxKind.LessThanLessThanToken,\r\n        \"</\": SyntaxKind.LessThanSlashToken,\r\n        \">>\": SyntaxKind.GreaterThanGreaterThanToken,\r\n        \">>>\": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\r\n        \"&\": SyntaxKind.AmpersandToken,\r\n        \"|\": SyntaxKind.BarToken,\r\n        \"^\": SyntaxKind.CaretToken,\r\n        \"!\": SyntaxKind.ExclamationToken,\r\n        \"~\": SyntaxKind.TildeToken,\r\n        \"&&\": SyntaxKind.AmpersandAmpersandToken,\r\n        \"||\": SyntaxKind.BarBarToken,\r\n        \"?\": SyntaxKind.QuestionToken,\r\n        \":\": SyntaxKind.ColonToken,\r\n        \"=\": SyntaxKind.EqualsToken,\r\n        \"+=\": SyntaxKind.PlusEqualsToken,\r\n        \"-=\": SyntaxKind.MinusEqualsToken,\r\n        \"*=\": SyntaxKind.AsteriskEqualsToken,\r\n        \"**=\": SyntaxKind.AsteriskAsteriskEqualsToken,\r\n        \"/=\": SyntaxKind.SlashEqualsToken,\r\n        \"%=\": SyntaxKind.PercentEqualsToken,\r\n        \"<<=\": SyntaxKind.LessThanLessThanEqualsToken,\r\n        \">>=\": SyntaxKind.GreaterThanGreaterThanEqualsToken,\r\n        \">>>=\": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        \"&=\": SyntaxKind.AmpersandEqualsToken,\r\n        \"|=\": SyntaxKind.BarEqualsToken,\r\n        \"^=\": SyntaxKind.CaretEqualsToken,\r\n        \"@\": SyntaxKind.AtToken,\r\n    });\r\n\r\n    const 中文关键字映射表 = createMapFromTemplate({\r\n\r\n        \"抽象\": SyntaxKind.AbstractKeyword,\r\n        \"任意\": SyntaxKind.AnyKeyword,\r\n        \"转为\": SyntaxKind.AsKeyword,\r\n        \"真假\": SyntaxKind.BooleanKeyword,\r\n        \"跳出\": SyntaxKind.BreakKeyword,\r\n        \"如为\": SyntaxKind.CaseKeyword,\r\n        \"捕获\": SyntaxKind.CatchKeyword,\r\n\r\n        \"类别\": SyntaxKind.ClassKeyword,\r\n        \"类\": SyntaxKind.ClassKeyword,\r\n\r\n        \"继续\": SyntaxKind.ContinueKeyword,\r\n        \"常量\": SyntaxKind.ConstKeyword,\r\n        \"构造\": SyntaxKind.ConstructorKeyword,\r\n        \"调试\": SyntaxKind.DebuggerKeyword,\r\n        \"声明\": SyntaxKind.DeclareKeyword,\r\n        \"默认\": SyntaxKind.DefaultKeyword,\r\n        \"删除\": SyntaxKind.DeleteKeyword,\r\n        \"运行\": SyntaxKind.DoKeyword,\r\n        \"否则\": SyntaxKind.ElseKeyword,\r\n        \"枚举\": SyntaxKind.EnumKeyword,\r\n        \"导出\": SyntaxKind.ExportKeyword,\r\n        \"扩展\": SyntaxKind.ExtendsKeyword,\r\n\r\n        \"为假\": SyntaxKind.FalseKeyword,\r\n        \"假值\": SyntaxKind.FalseKeyword,\r\n        \"假的\": SyntaxKind.FalseKeyword,\r\n        \"假\": SyntaxKind.FalseKeyword,\r\n\r\n        \"善后\": SyntaxKind.FinallyKeyword,\r\n        \"循环\": SyntaxKind.ForKeyword,\r\n        \"来自\": SyntaxKind.FromKeyword,\r\n        \"函数\": SyntaxKind.FunctionKeyword,\r\n        \"获取\": SyntaxKind.GetKeyword,\r\n        \"如果\": SyntaxKind.IfKeyword,\r\n        \"实现\": SyntaxKind.ImplementsKeyword,\r\n        \"导入\": SyntaxKind.ImportKeyword,\r\n        \"位于\": SyntaxKind.InKeyword,\r\n        \"身为\": SyntaxKind.InstanceOfKeyword,\r\n        \"接口\": SyntaxKind.InterfaceKeyword,\r\n\r\n        \"作为\": SyntaxKind.IsKeyword,\r\n        \"键集\": SyntaxKind.KeyOfKeyword,\r\n\r\n        \"变量\": SyntaxKind.LetKeyword,\r\n\r\n        \"模块\": SyntaxKind.ModuleKeyword,\r\n\r\n        \"名域\": SyntaxKind.NamespaceKeyword,\r\n        \"不及\": SyntaxKind.NeverKeyword,\r\n\r\n        \"新建\": SyntaxKind.NewKeyword,\r\n        \"空值\": SyntaxKind.NullKeyword,\r\n        \"数字\": SyntaxKind.NumberKeyword,\r\n        \"实例\": SyntaxKind.ObjectKeyword,\r\n\r\n        \"包装\": SyntaxKind.PackageKeyword,\r\n\r\n        \"私有\": SyntaxKind.PrivateKeyword,\r\n        \"保护\": SyntaxKind.ProtectedKeyword,\r\n        \"公开\": SyntaxKind.PublicKeyword,\r\n        \"只读\": SyntaxKind.ReadonlyKeyword,\r\n        \"需要\": SyntaxKind.RequireKeyword,\r\n        \"全局\": SyntaxKind.GlobalKeyword,\r\n        \"返回\": SyntaxKind.ReturnKeyword,\r\n        \"设置\": SyntaxKind.SetKeyword,\r\n        \"静态\": SyntaxKind.StaticKeyword,\r\n        \"文字\": SyntaxKind.StringKeyword,\r\n\r\n        \"父级\": SyntaxKind.SuperKeyword,\r\n        \"假如\": SyntaxKind.SwitchKeyword,\r\n\r\n        \"符号\": SyntaxKind.SymbolKeyword,\r\n\r\n        \"本体\": SyntaxKind.ThisKeyword,\r\n\r\n        \"抛出\": SyntaxKind.ThrowKeyword,\r\n\r\n        \"为真\": SyntaxKind.TrueKeyword,\r\n        \"真值\": SyntaxKind.TrueKeyword,\r\n        \"真的\": SyntaxKind.TrueKeyword,\r\n        \"真\": SyntaxKind.TrueKeyword,\r\n\r\n        \"尝试\": SyntaxKind.TryKeyword,\r\n        \"类型\": SyntaxKind.TypeKeyword,\r\n\r\n        \"类为\": SyntaxKind.TypeOfKeyword,\r\n        \"未定\": SyntaxKind.UndefinedKeyword,\r\n\r\n        \"值量\": SyntaxKind.VarKeyword,\r\n        \"无值\": SyntaxKind.VoidKeyword,\r\n        \"判断\": SyntaxKind.WhileKeyword,\r\n        \"外扩\": SyntaxKind.WithKeyword,\r\n        \"获得\": SyntaxKind.YieldKeyword,\r\n        \"异步\": SyntaxKind.AsyncKeyword,\r\n        \"等待\": SyntaxKind.AwaitKeyword,\r\n        \"属于\": SyntaxKind.OfKeyword,\r\n\r\n        \"{\": SyntaxKind.OpenBraceToken,\r\n        \"}\": SyntaxKind.CloseBraceToken,\r\n        \"(\": SyntaxKind.OpenParenToken,\r\n        \")\": SyntaxKind.CloseParenToken,\r\n        \"[\": SyntaxKind.OpenBracketToken,\r\n        \"]\": SyntaxKind.CloseBracketToken,\r\n        \".\": SyntaxKind.DotToken,\r\n        \"...\": SyntaxKind.DotDotDotToken,\r\n        \";\": SyntaxKind.SemicolonToken,\r\n        \",\": SyntaxKind.CommaToken,\r\n        \"<\": SyntaxKind.LessThanToken,\r\n        \">\": SyntaxKind.GreaterThanToken,\r\n        \"<=\": SyntaxKind.LessThanEqualsToken,\r\n        \">=\": SyntaxKind.GreaterThanEqualsToken,\r\n        \"==\": SyntaxKind.EqualsEqualsToken,\r\n        \"!=\": SyntaxKind.ExclamationEqualsToken,\r\n        \"===\": SyntaxKind.EqualsEqualsEqualsToken,\r\n        \"!==\": SyntaxKind.ExclamationEqualsEqualsToken,\r\n        \"=>\": SyntaxKind.EqualsGreaterThanToken,\r\n        \"+\": SyntaxKind.PlusToken,\r\n        \"-\": SyntaxKind.MinusToken,\r\n        \"**\": SyntaxKind.AsteriskAsteriskToken,\r\n        \"*\": SyntaxKind.AsteriskToken,\r\n        \"/\": SyntaxKind.SlashToken,\r\n        \"%\": SyntaxKind.PercentToken,\r\n        \"++\": SyntaxKind.PlusPlusToken,\r\n        \"--\": SyntaxKind.MinusMinusToken,\r\n        \"<<\": SyntaxKind.LessThanLessThanToken,\r\n        \"</\": SyntaxKind.LessThanSlashToken,\r\n        \">>\": SyntaxKind.GreaterThanGreaterThanToken,\r\n        \">>>\": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\r\n        \"&\": SyntaxKind.AmpersandToken,\r\n        \"|\": SyntaxKind.BarToken,\r\n        \"^\": SyntaxKind.CaretToken,\r\n        \"!\": SyntaxKind.ExclamationToken,\r\n        \"~\": SyntaxKind.TildeToken,\r\n        \"&&\": SyntaxKind.AmpersandAmpersandToken,\r\n        \"||\": SyntaxKind.BarBarToken,\r\n        \"?\": SyntaxKind.QuestionToken,\r\n        \":\": SyntaxKind.ColonToken,\r\n        \"=\": SyntaxKind.EqualsToken,\r\n        \"+=\": SyntaxKind.PlusEqualsToken,\r\n        \"-=\": SyntaxKind.MinusEqualsToken,\r\n        \"*=\": SyntaxKind.AsteriskEqualsToken,\r\n        \"**=\": SyntaxKind.AsteriskAsteriskEqualsToken,\r\n        \"/=\": SyntaxKind.SlashEqualsToken,\r\n        \"%=\": SyntaxKind.PercentEqualsToken,\r\n        \"<<=\": SyntaxKind.LessThanLessThanEqualsToken,\r\n        \">>=\": SyntaxKind.GreaterThanGreaterThanEqualsToken,\r\n        \">>>=\": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        \"&=\": SyntaxKind.AmpersandEqualsToken,\r\n        \"|=\": SyntaxKind.BarEqualsToken,\r\n        \"^=\": SyntaxKind.CaretEqualsToken,\r\n        \"@\": SyntaxKind.AtToken\r\n    });\r\n    /*\r\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 3.0.0  categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart :: =\r\n            Can contain IdentifierStart + Unicode 3.0.0  categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd), or\r\n            Connector punctuation (Pc).\r\n\r\n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\r\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\r\n    */\r\n    const unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    const unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    /*\r\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 6.2  categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart ::\r\n            Can contain IdentifierStart + Unicode 6.2  categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd),\r\n            Connector punctuation (Pc),\r\n            <ZWNJ>, or\r\n            <ZWJ>.\r\n\r\n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\r\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\r\n    */\r\n    const unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    const unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    function lookupInUnicodeMap(code: number, map: ReadonlyArray<number>): boolean {\r\n        // Bail out quickly if it couldn't possibly be in the map.\r\n        if (code < map[0]) {\r\n            return false;\r\n        }\r\n\r\n        // Perform binary search in one of the Unicode range maps\r\n        let lo = 0;\r\n        let hi: number = map.length;\r\n        let mid: number;\r\n\r\n        while (lo + 1 < hi) {\r\n            mid = lo + (hi - lo) / 2;\r\n            // mid has to be even to catch a range's beginning\r\n            mid -= mid % 2;\r\n            if (map[mid] <= code && code <= map[mid + 1]) {\r\n                return true;\r\n            }\r\n\r\n            if (code < map[mid]) {\r\n                hi = mid;\r\n            }\r\n            else {\r\n                lo = mid + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */ export function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion >= ScriptTarget.ES5 ?\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierStart) :\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierStart);\r\n    }\r\n\r\n    function isUnicodeIdentifierPart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion >= ScriptTarget.ES5 ?\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierPart) :\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierPart);\r\n    }\r\n\r\n    function makeReverseMap(source: Map<number>): string[] {\r\n        const result: string[] = [];\r\n        source.forEach((value, name) => {\r\n            if (!result[value]) {\r\n                result[value] = name;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    const tokenStrings = makeReverseMap(textToToken);\r\n    const tokenStringsCh = makeReverseMap(中文关键字映射表);\r\n\r\n    export function tokenToString(t: SyntaxKind): string | undefined {\r\n        return tokenStrings[t];\r\n    }\r\n    export function 令牌转为关键字(t: SyntaxKind): string | undefined {\r\n        return tokenStrings[t];\r\n    }\r\n    export function 令牌转为中文关键字(t: SyntaxKind): string | undefined {\r\n        return tokenStringsCh[t];\r\n    }\r\n\r\n    /* @internal */\r\n    export function stringToToken(s: string): SyntaxKind {\r\n        return textToToken.get(s) || 中文关键字映射表.get(s);\r\n    }\r\n\r\n    /* @internal */\r\n    export function computeLineStarts(text: string): number[] {\r\n        const result: number[] = new Array();\r\n        let pos = 0;\r\n        let lineStart = 0;\r\n        while (pos < text.length) {\r\n           const ch = text.charCodeAt(pos);\r\n           pos++;\r\n           switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                    result.push(lineStart);\r\n                    lineStart = pos;\r\n                    break;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && isLineBreak(ch)) {\r\n                        result.push(lineStart);\r\n                        lineStart = pos;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        result.push(lineStart);\r\n        return result;\r\n    }\r\n\r\n    export function getPositionOfLineAndCharacter(sourceFile: SourceFile, line: number, character: number): number {\r\n        return computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text);\r\n    }\r\n\r\n    /* @internal */\r\n    export function computePositionOfLineAndCharacter(lineStarts: ReadonlyArray<number>, line: number, character: number, debugText?: string): number {\r\n        Debug.assert(line >= 0 && line < lineStarts.length);\r\n        const res = lineStarts[line] + character;\r\n        if (line < lineStarts.length - 1) {\r\n            Debug.assert(res < lineStarts[line + 1]);\r\n        }\r\n        else if (debugText !== undefined) {\r\n            Debug.assert(res <= debugText.length); // Allow single character overflow for trailing newline\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getLineStarts(sourceFile: SourceFileLike): ReadonlyArray<number> {\r\n        return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * We assume the first line starts at position 0 and 'position' is non-negative.\r\n     */\r\n    export function computeLineAndCharacterOfPosition(lineStarts: ReadonlyArray<number>, position: number): LineAndCharacter {\r\n        let lineNumber = binarySearch(lineStarts, position);\r\n        if (lineNumber < 0) {\r\n            // If the actual position was not found,\r\n            // the binary search returns the 2's-complement of the next line start\r\n            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20\r\n            // then the search will return -2.\r\n            //\r\n            // We want the index of the previous line start, so we subtract 1.\r\n            // Review 2's-complement if this is confusing.\r\n            lineNumber = ~lineNumber - 1;\r\n            Debug.assert(lineNumber !== -1, \"position cannot precede the beginning of the file\");\r\n        }\r\n        return {\r\n            line: lineNumber,\r\n            character: position - lineStarts[lineNumber]\r\n        };\r\n    }\r\n\r\n    export function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter {\r\n        return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);\r\n    }\r\n\r\n    export function isWhiteSpaceLike(ch: number): boolean {\r\n        return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);\r\n    }\r\n\r\n    /** Does not include line breaks. For that, see isWhiteSpaceLike. */\r\n    export function isWhiteSpaceSingleLine(ch: number): boolean {\r\n        // Note: nextLine is in the Zs space, and should be considered to be a whitespace.\r\n        // It is explicitly not a line-break as it isn't in the exact set specified by EcmaScript.\r\n        return ch === CharacterCodes.space ||\r\n            ch === CharacterCodes.tab ||\r\n            ch === CharacterCodes.verticalTab ||\r\n            ch === CharacterCodes.formFeed ||\r\n            ch === CharacterCodes.nonBreakingSpace ||\r\n            ch === CharacterCodes.nextLine ||\r\n            ch === CharacterCodes.ogham ||\r\n            ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\r\n            ch === CharacterCodes.narrowNoBreakSpace ||\r\n            ch === CharacterCodes.mathematicalSpace ||\r\n            ch === CharacterCodes.ideographicSpace ||\r\n            ch === CharacterCodes.byteOrderMark;\r\n      }\r\n\r\n      export function isLineBreak(ch: number): boolean {\r\n          // ES5 7.3:\r\n          // The ECMAScript line terminator characters are listed in Table 3.\r\n          //     Table 3: Line Terminator Characters\r\n          //     Code Unit Value     Name                    Formal Name\r\n          //     \\u000A              Line Feed               <LF>\r\n          //     \\u000D              Carriage Return         <CR>\r\n          //     \\u2028              Line separator          <LS>\r\n          //     \\u2029              Paragraph separator     <PS>\r\n          // Only the characters in Table 3 are treated as line terminators. Other new line or line\r\n          // breaking characters are treated as white space but not as line terminators.\r\n\r\n          return ch === CharacterCodes.lineFeed ||\r\n              ch === CharacterCodes.carriageReturn ||\r\n              ch === CharacterCodes.lineSeparator ||\r\n              ch === CharacterCodes.paragraphSeparator;\r\n      }\r\n\r\n      function isDigit(ch: number): boolean {\r\n          return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\r\n      }\r\n\r\n      /* @internal */\r\n      export function isOctalDigit(ch: number): boolean {\r\n          return ch >= CharacterCodes._0 && ch <= CharacterCodes._7;\r\n      }\r\n\r\n      export function couldStartTrivia(text: string, pos: number): boolean {\r\n          // Keep in sync with skipTrivia\r\n          const ch = text.charCodeAt(pos);\r\n          switch (ch) {\r\n              case CharacterCodes.carriageReturn:\r\n              case CharacterCodes.lineFeed:\r\n              case CharacterCodes.tab:\r\n              case CharacterCodes.verticalTab:\r\n              case CharacterCodes.formFeed:\r\n              case CharacterCodes.space:\r\n              case CharacterCodes.slash:\r\n                  // starts of normal trivia\r\n              case CharacterCodes.lessThan:\r\n              case CharacterCodes.bar:\r\n              case CharacterCodes.equals:\r\n              case CharacterCodes.greaterThan:\r\n                  // Starts of conflict marker trivia\r\n                  return true;\r\n              case CharacterCodes.hash:\r\n                  // Only if its the beginning can we have #! trivia\r\n                  return pos === 0;\r\n              default:\r\n                  return ch > CharacterCodes.maxAsciiCharacter;\r\n          }\r\n      }\r\n\r\n      /* @internal */\r\n      export function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean, stopAtComments = false): number {\r\n          if (positionIsSynthesized(pos)) {\r\n              return pos;\r\n          }\r\n\r\n          // Keep in sync with couldStartTrivia\r\n          while (true) {\r\n              const ch = text.charCodeAt(pos);\r\n              switch (ch) {\r\n                  case CharacterCodes.carriageReturn:\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                          pos++;\r\n                      }\r\n                      // falls through\r\n                  case CharacterCodes.lineFeed:\r\n                      pos++;\r\n                      if (stopAfterLineBreak) {\r\n                          return pos;\r\n                      }\r\n                      continue;\r\n                  case CharacterCodes.tab:\r\n                  case CharacterCodes.verticalTab:\r\n                  case CharacterCodes.formFeed:\r\n                  case CharacterCodes.space:\r\n                      pos++;\r\n                      continue;\r\n                  case CharacterCodes.slash:\r\n                      if (stopAtComments) {\r\n                          break;\r\n                      }\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                          pos += 2;\r\n                          while (pos < text.length) {\r\n                              if (isLineBreak(text.charCodeAt(pos))) {\r\n                                  break;\r\n                              }\r\n                              pos++;\r\n                          }\r\n                          continue;\r\n                      }\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                          pos += 2;\r\n                          while (pos < text.length) {\r\n                              if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                  pos += 2;\r\n                                  break;\r\n                              }\r\n                              pos++;\r\n                          }\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  case CharacterCodes.lessThan:\r\n                  case CharacterCodes.bar:\r\n                  case CharacterCodes.equals:\r\n                  case CharacterCodes.greaterThan:\r\n                      if (isConflictMarkerTrivia(text, pos)) {\r\n                          pos = scanConflictMarkerTrivia(text, pos);\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  case CharacterCodes.hash:\r\n                      if (pos === 0 && isShebangTrivia(text, pos)) {\r\n                          pos = scanShebangTrivia(text, pos);\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  default:\r\n                      if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpaceLike(ch))) {\r\n                          pos++;\r\n                          continue;\r\n                      }\r\n                      break;\r\n              }\r\n              return pos;\r\n          }\r\n      }\r\n\r\n      // All conflict markers consist of the same character repeated seven times.  If it is\r\n      // a <<<<<<< or >>>>>>> marker then it is also followed by a space.\r\n    const mergeConflictMarkerLength = \"<<<<<<<\".length;\r\n\r\n    function isConflictMarkerTrivia(text: string, pos: number) {\r\n        Debug.assert(pos >= 0);\r\n\r\n        // Conflict markers must be at the start of a line.\r\n        if (pos === 0 || isLineBreak(text.charCodeAt(pos - 1))) {\r\n            const ch = text.charCodeAt(pos);\r\n\r\n            if ((pos + mergeConflictMarkerLength) < text.length) {\r\n                for (let i = 0; i < mergeConflictMarkerLength; i++) {\r\n                    if (text.charCodeAt(pos + i) !== ch) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return ch === CharacterCodes.equals ||\r\n                    text.charCodeAt(pos + mergeConflictMarkerLength) === CharacterCodes.space;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function scanConflictMarkerTrivia(text: string, pos: number, error?: ErrorCallback) {\r\n        if (error) {\r\n            error(Diagnostics.Merge_conflict_marker_encountered, mergeConflictMarkerLength);\r\n        }\r\n\r\n        const ch = text.charCodeAt(pos);\r\n        const len = text.length;\r\n\r\n        if (ch === CharacterCodes.lessThan || ch === CharacterCodes.greaterThan) {\r\n            while (pos < len && !isLineBreak(text.charCodeAt(pos))) {\r\n                pos++;\r\n            }\r\n        }\r\n        else {\r\n            Debug.assert(ch === CharacterCodes.bar || ch === CharacterCodes.equals);\r\n            // Consume everything from the start of a ||||||| or ======= marker to the start\r\n            // of the next ======= or >>>>>>> marker.\r\n            while (pos < len) {\r\n                const currentChar = text.charCodeAt(pos);\r\n                if ((currentChar === CharacterCodes.equals || currentChar === CharacterCodes.greaterThan) && currentChar !== ch && isConflictMarkerTrivia(text, pos)) {\r\n                    break;\r\n                }\r\n\r\n                pos++;\r\n            }\r\n        }\r\n\r\n        return pos;\r\n    }\r\n\r\n    const shebangTriviaRegex = /^#!.*/;\r\n\r\n    function isShebangTrivia(text: string, pos: number) {\r\n        // Shebangs check must only be done at the start of the file\r\n        Debug.assert(pos === 0);\r\n        return shebangTriviaRegex.test(text);\r\n    }\r\n\r\n    function scanShebangTrivia(text: string, pos: number) {\r\n        const shebang = shebangTriviaRegex.exec(text)[0];\r\n        pos = pos + shebang.length;\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Invokes a callback for each comment range following the provided position.\r\n     *\r\n     * Single-line comment ranges include the leading double-slash characters but not the ending\r\n     * line break. Multi-line comment ranges include the leading slash-asterisk and trailing\r\n     * asterisk-slash characters.\r\n     *\r\n     * @param reduce If true, accumulates the result of calling the callback in a fashion similar\r\n     *      to reduceLeft. If false, iteration stops when the callback returns a truthy value.\r\n     * @param text The source text to scan.\r\n     * @param pos The position at which to start scanning.\r\n     * @param trailing If false, whitespace is skipped until the first line break and comments\r\n     *      between that location and the next token are returned. If true, comments occurring\r\n     *      between the given position and the next line break are returned.\r\n     * @param cb The callback to execute as each comment range is encountered.\r\n     * @param state A state value to pass to each iteration of the callback.\r\n     * @param initial An initial value to pass when accumulating results (when \"reduce\" is true).\r\n     * @returns If \"reduce\" is true, the accumulated value. If \"reduce\" is false, the first truthy\r\n     *      return value of the callback.\r\n     */\r\n    function iterateCommentRanges<T, U>(reduce: boolean, text: string, pos: number, trailing: boolean, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial?: U): U {\r\n        let pendingPos: number;\r\n        let pendingEnd: number;\r\n        let pendingKind: CommentKind;\r\n        let pendingHasTrailingNewLine: boolean;\r\n        let hasPendingCommentRange = false;\r\n        let collecting = trailing || pos === 0;\r\n        let accumulator = initial;\r\n        scan: while (pos >= 0 && pos < text.length) {\r\n            const ch = text.charCodeAt(pos);\r\n            switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                    pos++;\r\n                    if (trailing) {\r\n                        break scan;\r\n                    }\r\n\r\n                    collecting = true;\r\n                    if (hasPendingCommentRange) {\r\n                        pendingHasTrailingNewLine = true;\r\n                    }\r\n\r\n                    continue;\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    pos++;\r\n                    continue;\r\n                case CharacterCodes.slash:\r\n                    const nextChar = text.charCodeAt(pos + 1);\r\n                    let hasTrailingNewLine = false;\r\n                    if (nextChar === CharacterCodes.slash || nextChar === CharacterCodes.asterisk) {\r\n                        const kind = nextChar === CharacterCodes.slash ? SyntaxKind.SingleLineCommentTrivia : SyntaxKind.MultiLineCommentTrivia;\r\n                        const startPos = pos;\r\n                        pos += 2;\r\n                        if (nextChar === CharacterCodes.slash) {\r\n                            while (pos < text.length) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    hasTrailingNewLine = true;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n                        else {\r\n                            while (pos < text.length) {\r\n                                if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n\r\n                        if (collecting) {\r\n                            if (hasPendingCommentRange) {\r\n                                accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);\r\n                                if (!reduce && accumulator) {\r\n                                    // If we are not reducing and we have a truthy result, return it.\r\n                                    return accumulator;\r\n                                }\r\n\r\n                                hasPendingCommentRange = false;\r\n                            }\r\n\r\n                            pendingPos = startPos;\r\n                            pendingEnd = pos;\r\n                            pendingKind = kind;\r\n                            pendingHasTrailingNewLine = hasTrailingNewLine;\r\n                            hasPendingCommentRange = true;\r\n                        }\r\n\r\n                        continue;\r\n                    }\r\n                    break scan;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpaceLike(ch))) {\r\n                        if (hasPendingCommentRange && isLineBreak(ch)) {\r\n                            pendingHasTrailingNewLine = true;\r\n                        }\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    break scan;\r\n            }\r\n        }\r\n\r\n        if (hasPendingCommentRange) {\r\n            accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);\r\n        }\r\n\r\n        return accumulator;\r\n    }\r\n\r\n    export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state?: T): U | undefined {\r\n        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ false, cb, state);\r\n    }\r\n\r\n    export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state?: T): U | undefined {\r\n        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ true, cb, state);\r\n    }\r\n\r\n    export function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U) {\r\n        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ false, cb, state, initial);\r\n    }\r\n\r\n    export function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U) {\r\n        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ true, cb, state, initial);\r\n    }\r\n\r\n    function appendCommentRange(pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, _state: any, comments: CommentRange[]) {\r\n        if (!comments) {\r\n            comments = [];\r\n        }\r\n\r\n        comments.push({ kind, pos, end, hasTrailingNewLine });\r\n        return comments;\r\n    }\r\n\r\n    export function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined {\r\n        return reduceEachLeadingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);\r\n    }\r\n\r\n    export function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined {\r\n        return reduceEachTrailingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);\r\n    }\r\n\r\n    /** Optionally, get the shebang */\r\n    export function getShebang(text: string): string | undefined {\r\n        const match = shebangTriviaRegex.exec(text);\r\n        if (match) {\r\n            return match[0];\r\n        }\r\n    }\r\n\r\n    export function isIdentifierStart(ch: number, languageVersion: ScriptTarget): boolean {\r\n        return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n            ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n            ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierStart(ch, languageVersion);\r\n    }\r\n\r\n    export function isIdentifierPart(ch: number, languageVersion: ScriptTarget): boolean {\r\n        return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n            ch >= CharacterCodes._0 && ch <= CharacterCodes._9 || ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n            ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierPart(ch, languageVersion);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isIdentifierText(name: string, languageVersion: ScriptTarget): boolean {\r\n        if (!isIdentifierStart(name.charCodeAt(0), languageVersion)) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 1; i < name.length; i++) {\r\n            if (!isIdentifierPart(name.charCodeAt(i), languageVersion)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Creates a scanner over a (possibly unspecified) range of a piece of text.\r\n    export function createScanner(languageVersion: ScriptTarget,\r\n                                  skipTrivia: boolean,\r\n                                  languageVariant = LanguageVariant.Standard,\r\n                                  text?: string,\r\n                                  onError?: ErrorCallback,\r\n                                  start?: number,\r\n                                  length?: number): Scanner {\r\n        // Current position (end position of text of current token)\r\n        let pos: number;\r\n\r\n        // end of text\r\n        let end: number;\r\n\r\n        // Start position of whitespace before current token\r\n        let startPos: number;\r\n\r\n        // Start position of text of current token\r\n        let tokenPos: number;\r\n\r\n        let token: SyntaxKind;\r\n        let tokenValue: string;\r\n        let precedingLineBreak: boolean;\r\n        let hasExtendedUnicodeEscape: boolean;\r\n        let tokenIsUnterminated: boolean;\r\n        let numericLiteralFlags: NumericLiteralFlags;\r\n        let 开始扫描词典主体 = false;\r\n        setText(text, start, length);\r\n\r\n        return {\r\n            getStartPos: () => startPos,\r\n            getTextPos: () => pos,\r\n            getToken: () => token,\r\n            getTokenPos: () => tokenPos,\r\n            getTokenText: () => text.substring(tokenPos, pos),\r\n            getTokenValue: () => tokenValue,\r\n            hasExtendedUnicodeEscape: () => hasExtendedUnicodeEscape,\r\n            hasPrecedingLineBreak: () => precedingLineBreak,\r\n            isIdentifier: () => token === SyntaxKind.Identifier || token > SyntaxKind.LastReservedWord,\r\n            isReservedWord: () => token >= SyntaxKind.FirstReservedWord && token <= SyntaxKind.LastReservedWord,\r\n            isUnterminated: () => tokenIsUnterminated,\r\n            getNumericLiteralFlags: () => numericLiteralFlags,\r\n            reScanGreaterToken,\r\n            reScanSlashToken,\r\n            reScanTemplateToken,\r\n            scanJsxIdentifier,\r\n            scanJsxAttributeValue,\r\n            reScanJsxToken,\r\n            scanJsxToken,\r\n            scanJSDocToken,\r\n            scan,\r\n            翻译词典扫描,\r\n            扫描词典主体,\r\n            getText,\r\n            setText,\r\n            setScriptTarget,\r\n            setLanguageVariant,\r\n            setOnError,\r\n            setTextPos,\r\n            tryScan,\r\n            lookAhead,\r\n            scanRange,\r\n        };\r\n\r\n        function error(message: DiagnosticMessage, length?: number): void {\r\n            if (onError) {\r\n                onError(message, length || 0);\r\n            }\r\n        }\r\n\r\n        function scanNumber(): string {\r\n            const start = pos;\r\n            while (isDigit(text.charCodeAt(pos))) pos++;\r\n            if (text.charCodeAt(pos) === CharacterCodes.dot) {\r\n                pos++;\r\n                while (isDigit(text.charCodeAt(pos))) pos++;\r\n            }\r\n            let end = pos;\r\n            if (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e) {\r\n                pos++;\r\n                numericLiteralFlags = NumericLiteralFlags.Scientific;\r\n                if (text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) pos++;\r\n                if (isDigit(text.charCodeAt(pos))) {\r\n                    pos++;\r\n                    while (isDigit(text.charCodeAt(pos))) pos++;\r\n                    end = pos;\r\n                }\r\n                else {\r\n                    error(Diagnostics.Digit_expected);\r\n                }\r\n            }\r\n            return \"\" + +(text.substring(start, end));\r\n        }\r\n\r\n        function scanOctalDigits(): number {\r\n            const start = pos;\r\n            while (isOctalDigit(text.charCodeAt(pos))) {\r\n                pos++;\r\n            }\r\n            return +(text.substring(start, pos));\r\n        }\r\n\r\n        /**\r\n         * Scans the given number of hexadecimal digits in the text,\r\n         * returning -1 if the given number is unavailable.\r\n         */\r\n        function scanExactNumberOfHexDigits(count: number): number {\r\n            return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ false);\r\n        }\r\n\r\n        /**\r\n         * Scans as many hexadecimal digits as are available in the text,\r\n         * returning -1 if the given number of digits was unavailable.\r\n         */\r\n        function scanMinimumNumberOfHexDigits(count: number): number {\r\n            return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ true);\r\n        }\r\n\r\n        function scanHexDigits(minCount: number, scanAsManyAsPossible: boolean): number {\r\n            let digits = 0;\r\n            let value = 0;\r\n            while (digits < minCount || scanAsManyAsPossible) {\r\n                const ch = text.charCodeAt(pos);\r\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\r\n                    value = value * 16 + ch - CharacterCodes._0;\r\n                }\r\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\r\n                    value = value * 16 + ch - CharacterCodes.A + 10;\r\n                }\r\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\r\n                    value = value * 16 + ch - CharacterCodes.a + 10;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                pos++;\r\n                digits++;\r\n            }\r\n            if (digits < minCount) {\r\n                value = -1;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function scanString(allowEscapes = true): string {\r\n            const quote = text.charCodeAt(pos);\r\n            pos++;\r\n            let result = \"\";\r\n            let start = pos;\r\n            while (true) {\r\n                if (pos >= end) {\r\n                    result += text.substring(start, pos);\r\n                    tokenIsUnterminated = true;\r\n                    error(Diagnostics.Unterminated_string_literal);\r\n                    break;\r\n                }\r\n                const ch = text.charCodeAt(pos);\r\n                if (ch === quote) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    break;\r\n                }\r\n                if (ch === CharacterCodes.backslash && allowEscapes) {\r\n                    result += text.substring(start, pos);\r\n                    result += scanEscapeSequence();\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n                if (isLineBreak(ch)) {\r\n                    result += text.substring(start, pos);\r\n                    tokenIsUnterminated = true;\r\n                    error(Diagnostics.Unterminated_string_literal);\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or\r\n         * a literal component of a TemplateExpression.\r\n         */\r\n        function scanTemplateAndSetTokenValue(): SyntaxKind {\r\n            const startedWithBacktick = text.charCodeAt(pos) === CharacterCodes.backtick;\r\n\r\n            pos++;\r\n            let start = pos;\r\n            let contents = \"\";\r\n            let resultingToken: SyntaxKind;\r\n\r\n            while (true) {\r\n                if (pos >= end) {\r\n                    contents += text.substring(start, pos);\r\n                    tokenIsUnterminated = true;\r\n                    error(Diagnostics.Unterminated_template_literal);\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.NoSubstitutionTemplateLiteral : SyntaxKind.TemplateTail;\r\n                    break;\r\n                }\r\n\r\n                const currChar = text.charCodeAt(pos);\r\n\r\n                // '`'\r\n                if (currChar === CharacterCodes.backtick) {\r\n                    contents += text.substring(start, pos);\r\n                    pos++;\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.NoSubstitutionTemplateLiteral : SyntaxKind.TemplateTail;\r\n                    break;\r\n                }\r\n\r\n                // '${'\r\n                if (currChar === CharacterCodes.$ && pos + 1 < end && text.charCodeAt(pos + 1) === CharacterCodes.openBrace) {\r\n                    contents += text.substring(start, pos);\r\n                    pos += 2;\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.TemplateHead : SyntaxKind.TemplateMiddle;\r\n                    break;\r\n                }\r\n\r\n                // Escape character\r\n                if (currChar === CharacterCodes.backslash) {\r\n                    contents += text.substring(start, pos);\r\n                    contents += scanEscapeSequence();\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n\r\n                // Speculated ECMAScript 6 Spec 11.8.6.1:\r\n                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values\r\n                if (currChar === CharacterCodes.carriageReturn) {\r\n                    contents += text.substring(start, pos);\r\n                    pos++;\r\n\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n\r\n                    contents += \"\\n\";\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n\r\n                pos++;\r\n            }\r\n\r\n            Debug.assert(resultingToken !== undefined);\r\n\r\n            tokenValue = contents;\r\n            return resultingToken;\r\n        }\r\n\r\n        function scanEscapeSequence(): string {\r\n            pos++;\r\n            if (pos >= end) {\r\n                error(Diagnostics.Unexpected_end_of_text);\r\n                return \"\";\r\n            }\r\n            const ch = text.charCodeAt(pos);\r\n            pos++;\r\n            switch (ch) {\r\n                case CharacterCodes._0:\r\n                    return \"\\0\";\r\n                case CharacterCodes.b:\r\n                    return \"\\b\";\r\n                case CharacterCodes.t:\r\n                    return \"\\t\";\r\n                case CharacterCodes.n:\r\n                    return \"\\n\";\r\n                case CharacterCodes.v:\r\n                    return \"\\v\";\r\n                case CharacterCodes.f:\r\n                    return \"\\f\";\r\n                case CharacterCodes.r:\r\n                    return \"\\r\";\r\n                case CharacterCodes.singleQuote:\r\n                    return \"\\'\";\r\n                case CharacterCodes.doubleQuote:\r\n                    return \"\\\"\";\r\n                case CharacterCodes.u:\r\n                    // '\\u{DDDDDDDD}'\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.openBrace) {\r\n                        hasExtendedUnicodeEscape = true;\r\n                        pos++;\r\n                        return scanExtendedUnicodeEscape();\r\n                    }\r\n\r\n                    // '\\uDDDD'\r\n                    return scanHexadecimalEscape(/*numDigits*/ 4);\r\n\r\n                case CharacterCodes.x:\r\n                    // '\\xDD'\r\n                    return scanHexadecimalEscape(/*numDigits*/ 2);\r\n\r\n                // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),\r\n                // the line terminator is interpreted to be \"the empty code unit sequence\".\r\n                case CharacterCodes.carriageReturn:\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                case CharacterCodes.lineSeparator:\r\n                case CharacterCodes.paragraphSeparator:\r\n                    return \"\";\r\n                default:\r\n                    return String.fromCharCode(ch);\r\n            }\r\n        }\r\n\r\n        function scanHexadecimalEscape(numDigits: number): string {\r\n            const escapedValue = scanExactNumberOfHexDigits(numDigits);\r\n\r\n            if (escapedValue >= 0) {\r\n                return String.fromCharCode(escapedValue);\r\n            }\r\n            else {\r\n                error(Diagnostics.Hexadecimal_digit_expected);\r\n                return \"\";\r\n            }\r\n        }\r\n\r\n        function scanExtendedUnicodeEscape(): string {\r\n            const escapedValue = scanMinimumNumberOfHexDigits(1);\r\n            let isInvalidExtendedEscape = false;\r\n\r\n            // Validate the value of the digit\r\n            if (escapedValue < 0) {\r\n                error(Diagnostics.Hexadecimal_digit_expected);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n            else if (escapedValue > 0x10FFFF) {\r\n                error(Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n\r\n            if (pos >= end) {\r\n                error(Diagnostics.Unexpected_end_of_text);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n            else if (text.charCodeAt(pos) === CharacterCodes.closeBrace) {\r\n                // Only swallow the following character up if it's a '}'.\r\n                pos++;\r\n            }\r\n            else {\r\n                error(Diagnostics.Unterminated_Unicode_escape_sequence);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n\r\n            if (isInvalidExtendedEscape) {\r\n                return \"\";\r\n            }\r\n\r\n            return utf16EncodeAsString(escapedValue);\r\n        }\r\n\r\n        // Derived from the 10.1.1 UTF16Encoding of the ES6 Spec.\r\n        function utf16EncodeAsString(codePoint: number): string {\r\n            Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);\r\n\r\n            if (codePoint <= 65535) {\r\n                return String.fromCharCode(codePoint);\r\n            }\r\n\r\n            const codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;\r\n            const codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;\r\n\r\n            return String.fromCharCode(codeUnit1, codeUnit2);\r\n        }\r\n\r\n        // Current character is known to be a backslash. Check for Unicode escape of the form '\\uXXXX'\r\n        // and return code point value if valid Unicode escape is found. Otherwise return -1.\r\n        function peekUnicodeEscape(): number {\r\n            if (pos + 5 < end && text.charCodeAt(pos + 1) === CharacterCodes.u) {\r\n                const start = pos;\r\n                pos += 2;\r\n                const value = scanExactNumberOfHexDigits(4);\r\n                pos = start;\r\n                return value;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function scanIdentifierParts(): string {\r\n            let result = \"\";\r\n            let start = pos;\r\n            while (pos < end) {\r\n                let ch = text.charCodeAt(pos);\r\n                if (isIdentifierPart(ch, languageVersion)) {\r\n                    pos++;\r\n                }\r\n                else if (ch === CharacterCodes.backslash) {\r\n                    ch = peekUnicodeEscape();\r\n                    if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {\r\n                        break;\r\n                    }\r\n                    result += text.substring(start, pos);\r\n                    result += String.fromCharCode(ch);\r\n                    // Valid Unicode escape is always six characters\r\n                    pos += 6;\r\n                    start = pos;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            result += text.substring(start, pos);\r\n            return result;\r\n        }\r\n\r\n        function getIdentifierToken(): SyntaxKind {\r\n            /** 保留字在2到11个字符之间，以小写字母开头 */\r\n            const len = tokenValue.length;\r\n\r\n            if (len >= 1 && len <= 2) {\r\n                token = 中文关键字映射表.get(tokenValue);\r\n                if (token !== undefined) {\r\n                    return token;\r\n                }\r\n            }\r\n            if (len >= 2 && len <= 11) {\r\n                const ch = tokenValue.charCodeAt(0);\r\n                if (len >= 2 && ch >= CharacterCodes.a && ch <= CharacterCodes.z) {\r\n                    token = textToToken.get(tokenValue);\r\n                    if (token !== undefined) {\r\n                        return token;\r\n                    }\r\n                }\r\n            }\r\n            return token = SyntaxKind.Identifier;\r\n        }\r\n\r\n        function scanBinaryOrOctalDigits(base: number): number {\r\n            Debug.assert(base === 2 || base === 8, \"Expected either base 2 or base 8\");\r\n\r\n            let value = 0;\r\n            // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.\r\n            // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.\r\n            let numberOfDigits = 0;\r\n            while (true) {\r\n                const ch = text.charCodeAt(pos);\r\n                const valueOfCh = ch - CharacterCodes._0;\r\n                if (!isDigit(ch) || valueOfCh >= base) {\r\n                    break;\r\n                }\r\n                value = value * base + valueOfCh;\r\n                pos++;\r\n                numberOfDigits++;\r\n            }\r\n            // Invalid binaryIntegerLiteral or octalIntegerLiteral\r\n            if (numberOfDigits === 0) {\r\n                return -1;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function scan(): SyntaxKind {\r\n            startPos = pos;\r\n            hasExtendedUnicodeEscape = false;\r\n            precedingLineBreak = false;\r\n            tokenIsUnterminated = false;\r\n            numericLiteralFlags = 0;\r\n            while (true) {\r\n                tokenPos = pos;\r\n                if (pos >= end) {\r\n                    return token = SyntaxKind.EndOfFileToken;\r\n                }\r\n                let ch = text.charCodeAt(pos);\r\n\r\n                // Special handling for shebang\r\n                if (ch === CharacterCodes.hash && pos === 0 && isShebangTrivia(text, pos)) {\r\n                    pos = scanShebangTrivia(text, pos);\r\n                    if (skipTrivia) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        return token = SyntaxKind.ShebangTrivia;\r\n                    }\r\n                }\r\n\r\n                switch (ch) {\r\n                    case CharacterCodes.lineFeed:\r\n                    case CharacterCodes.carriageReturn:\r\n                        precedingLineBreak = true;\r\n                        if (skipTrivia) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else {\r\n                            if (ch === CharacterCodes.carriageReturn && pos + 1 < end && text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                                // consume both CR and LF\r\n                                pos += 2;\r\n                            }\r\n                            else {\r\n                                pos++;\r\n                            }\r\n                            return token = SyntaxKind.NewLineTrivia;\r\n                        }\r\n                    case CharacterCodes.tab:\r\n                    case CharacterCodes.verticalTab:\r\n                    case CharacterCodes.formFeed:\r\n                    case CharacterCodes.space:\r\n                        if (skipTrivia) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else {\r\n                            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {\r\n                                pos++;\r\n                            }\r\n                            return token = SyntaxKind.WhitespaceTrivia;\r\n                        }\r\n                    case CharacterCodes.exclamation:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.ExclamationEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.ExclamationEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.ExclamationToken;\r\n                    case CharacterCodes.doubleQuote:\r\n                    case CharacterCodes.singleQuote:\r\n                        tokenValue = scanString();\r\n                        return token = SyntaxKind.StringLiteral;\r\n                    case CharacterCodes.backtick:\r\n                        return token = scanTemplateAndSetTokenValue();\r\n                    case CharacterCodes.percent:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PercentEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.PercentToken;\r\n                    case CharacterCodes.ampersand:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.ampersand) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandAmpersandToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.AmpersandToken;\r\n                    case CharacterCodes.openParen:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenParenToken;\r\n                    case CharacterCodes.closeParen:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseParenToken;\r\n                    case CharacterCodes.asterisk:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AsteriskEqualsToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.AsteriskAsteriskEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.AsteriskAsteriskToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.AsteriskToken;\r\n                    case CharacterCodes.plus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.plus) {\r\n                            return pos += 2, token = SyntaxKind.PlusPlusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PlusEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.PlusToken;\r\n                    case CharacterCodes.comma:\r\n                        pos++;\r\n                        return token = SyntaxKind.CommaToken;\r\n                    case CharacterCodes.minus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.minus) {\r\n                            return pos += 2, token = SyntaxKind.MinusMinusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.MinusEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.MinusToken;\r\n                    case CharacterCodes.dot:\r\n                        if (isDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = scanNumber();\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.dot && text.charCodeAt(pos + 2) === CharacterCodes.dot) {\r\n                            return pos += 3, token = SyntaxKind.DotDotDotToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.DotToken;\r\n                    case CharacterCodes.slash:\r\n                        // 全局词典扫描\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.slash && text.charCodeAt(pos + 2) === CharacterCodes.at && text.charCodeAt(pos + 3) === CharacterCodes.at && text.charCodeAt(pos + 4) === CharacterCodes.openBrace) {\r\n                            pos += 5;\r\n                            let 有结尾 = false;\r\n                            while (pos < end) {\r\n                                if (text.charCodeAt(pos) === CharacterCodes.closeBrace) {\r\n                                    有结尾 = true;\r\n                                }\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    if (!有结尾) {\r\n                                        error(Diagnostics.字典语句包含错误);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.全局词典语句;\r\n                            }\r\n                        }\r\n                        // 局部词典扫描\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.slash && text.charCodeAt(pos + 2) === CharacterCodes.at && text.charCodeAt(pos + 3) === CharacterCodes.openBrace) {\r\n                            pos += 4;\r\n                            let 有结尾 = false;\r\n                            while (pos < end) {\r\n                                if (text.charCodeAt(pos) === CharacterCodes.closeBrace) {\r\n                                    有结尾 = true;\r\n                                }\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    if (!有结尾) {\r\n                                        error(Diagnostics.字典语句包含错误);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.局部词典语句;\r\n                            }\r\n                        }\r\n                        // Single-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                            pos += 2;\r\n\r\n                            while (pos < end) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.SingleLineCommentTrivia;\r\n                            }\r\n                        }\r\n                        // Multi-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                            pos += 2;\r\n\r\n                            let commentClosed = false;\r\n                            while (pos < end) {\r\n                                const ch = text.charCodeAt(pos);\r\n\r\n                                if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    commentClosed = true;\r\n                                    break;\r\n                                }\r\n\r\n                                if (isLineBreak(ch)) {\r\n                                    precedingLineBreak = true;\r\n                                }\r\n                                pos++;\r\n                            }\r\n\r\n                            if (!commentClosed) {\r\n                                error(Diagnostics.Asterisk_Slash_expected);\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                tokenIsUnterminated = !commentClosed;\r\n                                return token = SyntaxKind.MultiLineCommentTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.SlashEqualsToken;\r\n                        }\r\n\r\n                        pos++;\r\n                        return token = SyntaxKind.SlashToken;\r\n\r\n                    case CharacterCodes._0:\r\n                        if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.X || text.charCodeAt(pos + 1) === CharacterCodes.x)) {\r\n                            pos += 2;\r\n                            let value = scanMinimumNumberOfHexDigits(1);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Hexadecimal_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            numericLiteralFlags = NumericLiteralFlags.HexSpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.B || text.charCodeAt(pos + 1) === CharacterCodes.b)) {\r\n                            pos += 2;\r\n                            let value = scanBinaryOrOctalDigits(/* base */ 2);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Binary_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            numericLiteralFlags = NumericLiteralFlags.BinarySpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.O || text.charCodeAt(pos + 1) === CharacterCodes.o)) {\r\n                            pos += 2;\r\n                            let value = scanBinaryOrOctalDigits(/* base */ 8);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Octal_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            numericLiteralFlags = NumericLiteralFlags.OctalSpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // Try to parse as an octal\r\n                        if (pos + 1 < end && isOctalDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = \"\" + scanOctalDigits();\r\n                            numericLiteralFlags = NumericLiteralFlags.Octal;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero\r\n                        // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being\r\n                        // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do).\r\n                        // falls through\r\n                    case CharacterCodes._1:\r\n                    case CharacterCodes._2:\r\n                    case CharacterCodes._3:\r\n                    case CharacterCodes._4:\r\n                    case CharacterCodes._5:\r\n                    case CharacterCodes._6:\r\n                    case CharacterCodes._7:\r\n                    case CharacterCodes._8:\r\n                    case CharacterCodes._9:\r\n                        tokenValue = scanNumber();\r\n                        return token = SyntaxKind.NumericLiteral;\r\n                    case CharacterCodes.colon:\r\n                        pos++;\r\n                        return  token = SyntaxKind.ColonToken;\r\n                    case CharacterCodes.semicolon:\r\n                        pos++;\r\n                        return token = SyntaxKind.SemicolonToken;\r\n                    case CharacterCodes.lessThan:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.lessThan) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.LessThanLessThanEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.LessThanLessThanToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.LessThanEqualsToken;\r\n                        }\r\n                        if (languageVariant === LanguageVariant.JSX &&\r\n                                text.charCodeAt(pos + 1) === CharacterCodes.slash &&\r\n                                text.charCodeAt(pos + 2) !== CharacterCodes.asterisk) {\r\n                            return pos += 2, token = SyntaxKind.LessThanSlashToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.LessThanToken;\r\n                    case CharacterCodes.equals:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.EqualsEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.EqualsEqualsToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                            return pos += 2, token = SyntaxKind.EqualsGreaterThanToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.EqualsToken;\r\n                    case CharacterCodes.greaterThan:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        pos++;\r\n                        return token = SyntaxKind.GreaterThanToken;\r\n                    case CharacterCodes.question:\r\n                        pos++;\r\n                        return token = SyntaxKind.QuestionToken;\r\n                    case CharacterCodes.openBracket:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenBracketToken;\r\n                    case CharacterCodes.closeBracket:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseBracketToken;\r\n                    case CharacterCodes.caret:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.CaretEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.CaretToken;\r\n                    case CharacterCodes.openBrace:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenBraceToken;\r\n                    case CharacterCodes.bar:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.bar) {\r\n                            return pos += 2, token = SyntaxKind.BarBarToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.BarEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.BarToken;\r\n                    case CharacterCodes.closeBrace:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseBraceToken;\r\n                    case CharacterCodes.tilde:\r\n                        pos++;\r\n                        return token = SyntaxKind.TildeToken;\r\n                    case CharacterCodes.at:\r\n                        pos++;\r\n                        return token = SyntaxKind.AtToken;\r\n                    case CharacterCodes.backslash:\r\n                        const cookedChar = peekUnicodeEscape();\r\n                        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {\r\n                            pos += 6;\r\n                            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        pos++;\r\n                        return token = SyntaxKind.Unknown;\r\n                    default:\r\n                        if (isIdentifierStart(ch, languageVersion)) {\r\n                            pos++;\r\n                            while (pos < end && isIdentifierPart(ch = text.charCodeAt(pos), languageVersion)) pos++;\r\n                            tokenValue = text.substring(tokenPos, pos);\r\n                            if (ch === CharacterCodes.backslash) {\r\n                                tokenValue += scanIdentifierParts();\r\n                            }\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        else if (isWhiteSpaceSingleLine(ch)) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else if (isLineBreak(ch)) {\r\n                            precedingLineBreak = true;\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        pos++;\r\n                        return token = SyntaxKind.Unknown;\r\n                }\r\n            }\r\n        }\r\n\r\n        function 翻译词典扫描(): SyntaxKind {\r\n            startPos = pos;\r\n            while (true) {\r\n                tokenPos = pos;\r\n                if (pos >= end) {\r\n                    开始扫描词典主体 = false;\r\n                    return SyntaxKind.EndOfFileToken;\r\n                }\r\n                if (text.charCodeAt(pos) === CharacterCodes.slash) {\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                        if (text.charCodeAt(pos + 2) === CharacterCodes.at) {\r\n                            if (text.charCodeAt(pos + 3) === CharacterCodes.at) {\r\n                                if (text.charCodeAt(pos + 4) === CharacterCodes.openBrace) {\r\n                                    pos += 5;\r\n                                    开始扫描词典主体 = true;\r\n                                    tokenValue = \"//@@\";\r\n                                    return SyntaxKind.全局词典语句;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return 扫描主体();\r\n            }\r\n        }\r\n        function 扫描词典主体() {\r\n            开始扫描词典主体 = true;\r\n            startPos = pos;\r\n            return 扫描主体();\r\n        }\r\n        function 扫描主体() {\r\n            while (开始扫描词典主体) {\r\n                tokenPos = pos;\r\n                if (pos >= end) {\r\n                    开始扫描词典主体 = false;\r\n                    return SyntaxKind.EndOfFileToken;\r\n                }\r\n                let ch = text.charCodeAt(pos);\r\n                switch (ch) {\r\n                    case CharacterCodes.openBrace:\r\n                        pos++;\r\n                        tokenValue = \"{\";\r\n                        return SyntaxKind.OpenBraceToken;\r\n                    case CharacterCodes.colon:\r\n                        pos++;\r\n                        tokenValue = \":\";\r\n                        return SyntaxKind.ColonToken;\r\n                    case CharacterCodes.comma:\r\n                        pos++;\r\n                        tokenValue = \",\";\r\n                        return SyntaxKind.CommaToken;\r\n                    case CharacterCodes.closeBrace:\r\n                        pos++;\r\n                        tokenValue = \"}\";\r\n                        开始扫描词典主体 = false;\r\n                        return SyntaxKind.CloseBraceToken;\r\n                    case CharacterCodes.doubleQuote:\r\n                    case CharacterCodes.singleQuote:\r\n                        tokenValue = scanString();\r\n                        return token = SyntaxKind.StringLiteral;\r\n                    default:\r\n                        if (isLineBreak(ch)) {\r\n                            error(Diagnostics.字典语句包含错误);\r\n                            pos++;\r\n                            开始扫描词典主体 = false;\r\n                            return token = SyntaxKind.NewLineTrivia;\r\n                        }\r\n                        if (isIdentifierStart(ch, languageVersion)) {\r\n                            pos++;\r\n                            while (pos < end && isIdentifierPart(ch = text.charCodeAt(pos), languageVersion)) pos++;\r\n                            tokenValue = text.substring(tokenPos, pos);\r\n                            if (ch === CharacterCodes.backslash) {\r\n                                tokenValue += scanIdentifierParts();\r\n                            }\r\n                            return token = SyntaxKind.Identifier;\r\n                        }\r\n                        else if (isWhiteSpaceSingleLine(ch)) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        error(Diagnostics.字典语句包含错误);\r\n                        pos++;\r\n                        // 开始扫描词典主体 = false\r\n                        return token = SyntaxKind.Unknown;\r\n                }\r\n            }\r\n            pos++;\r\n        }\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            if (token === SyntaxKind.GreaterThanToken) {\r\n                if (text.charCodeAt(pos) === CharacterCodes.greaterThan) {\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                        if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                            return pos += 3, token = SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;\r\n                        }\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\r\n                    }\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanEqualsToken;\r\n                    }\r\n                    pos++;\r\n                    return token = SyntaxKind.GreaterThanGreaterThanToken;\r\n                }\r\n                if (text.charCodeAt(pos) === CharacterCodes.equals) {\r\n                    pos++;\r\n                    return token = SyntaxKind.GreaterThanEqualsToken;\r\n                }\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            if (token === SyntaxKind.SlashToken || token === SyntaxKind.SlashEqualsToken) {\r\n                let p = tokenPos + 1;\r\n                let inEscape = false;\r\n                let inCharacterClass = false;\r\n                while (true) {\r\n                    // If we reach the end of a file, or hit a newline, then this is an unterminated\r\n                    // regex.  Report error and return what we have so far.\r\n                    if (p >= end) {\r\n                        tokenIsUnterminated = true;\r\n                        error(Diagnostics.Unterminated_regular_expression_literal);\r\n                        break;\r\n                    }\r\n\r\n                    const ch = text.charCodeAt(p);\r\n                    if (isLineBreak(ch)) {\r\n                        tokenIsUnterminated = true;\r\n                        error(Diagnostics.Unterminated_regular_expression_literal);\r\n                        break;\r\n                    }\r\n\r\n                    if (inEscape) {\r\n                        // Parsing an escape character;\r\n                        // reset the flag and just advance to the next char.\r\n                        inEscape = false;\r\n                    }\r\n                    else if (ch === CharacterCodes.slash && !inCharacterClass) {\r\n                        // A slash within a character class is permissible,\r\n                        // but in general it signals the end of the regexp literal.\r\n                        p++;\r\n                        break;\r\n                    }\r\n                    else if (ch === CharacterCodes.openBracket) {\r\n                        inCharacterClass = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.backslash) {\r\n                        inEscape = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.closeBracket) {\r\n                        inCharacterClass = false;\r\n                    }\r\n                    p++;\r\n                }\r\n\r\n                while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {\r\n                    p++;\r\n                }\r\n                pos = p;\r\n                tokenValue = text.substring(tokenPos, pos);\r\n                token = SyntaxKind.RegularExpressionLiteral;\r\n            }\r\n            return token;\r\n        }\r\n\r\n        /**\r\n         * Unconditionally back up and scan a template expression portion.\r\n         */\r\n        function reScanTemplateToken(): SyntaxKind {\r\n            Debug.assert(token === SyntaxKind.CloseBraceToken, \"'reScanTemplateToken' should only be called on a '}'\");\r\n            pos = tokenPos;\r\n            return token = scanTemplateAndSetTokenValue();\r\n        }\r\n\r\n        function reScanJsxToken(): SyntaxKind {\r\n            pos = tokenPos = startPos;\r\n            return token = scanJsxToken();\r\n        }\r\n\r\n        function scanJsxToken(): SyntaxKind {\r\n            startPos = tokenPos = pos;\r\n\r\n            if (pos >= end) {\r\n                return token = SyntaxKind.EndOfFileToken;\r\n            }\r\n\r\n            let char = text.charCodeAt(pos);\r\n            if (char === CharacterCodes.lessThan) {\r\n                if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                    pos += 2;\r\n                    return token = SyntaxKind.LessThanSlashToken;\r\n                }\r\n                pos++;\r\n                return token = SyntaxKind.LessThanToken;\r\n            }\r\n\r\n            if (char === CharacterCodes.openBrace) {\r\n                pos++;\r\n                return token = SyntaxKind.OpenBraceToken;\r\n            }\r\n\r\n            // First non-whitespace character on this line.\r\n            let firstNonWhitespace = 0;\r\n            // These initial values are special because the first line is:\r\n            // firstNonWhitespace = 0 to indicate that we want leading whitspace,\r\n\r\n            while (pos < end) {\r\n                char = text.charCodeAt(pos);\r\n                if (char === CharacterCodes.openBrace) {\r\n                    break;\r\n                }\r\n                if (char === CharacterCodes.lessThan) {\r\n                    if (isConflictMarkerTrivia(text, pos)) {\r\n                        pos = scanConflictMarkerTrivia(text, pos, error);\r\n                        return token = SyntaxKind.ConflictMarkerTrivia;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                // FirstNonWhitespace is 0, then we only see whitespaces so far. If we see a linebreak, we want to ignore that whitespaces.\r\n                // i.e (- : whitespace)\r\n                //      <div>----\r\n                //      </div> becomes <div></div>\r\n                //\r\n                //      <div>----</div> becomes <div>----</div>\r\n                if (isLineBreak(char) && firstNonWhitespace === 0) {\r\n                    firstNonWhitespace = -1;\r\n                }\r\n                else if (!isWhiteSpaceLike(char)) {\r\n                    firstNonWhitespace = pos;\r\n                }\r\n                pos++;\r\n            }\r\n\r\n            return firstNonWhitespace === -1 ? SyntaxKind.JsxTextAllWhiteSpaces : SyntaxKind.JsxText;\r\n        }\r\n\r\n        // Scans a JSX identifier; these differ from normal identifiers in that\r\n        // they allow dashes\r\n        function scanJsxIdentifier(): SyntaxKind {\r\n            if (tokenIsIdentifierOrKeyword(token)) {\r\n                const firstCharPosition = pos;\r\n                while (pos < end) {\r\n                    const ch = text.charCodeAt(pos);\r\n                    if (ch === CharacterCodes.minus || ((firstCharPosition === pos) ? isIdentifierStart(ch, languageVersion) : isIdentifierPart(ch, languageVersion))) {\r\n                        pos++;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                tokenValue += text.substr(firstCharPosition, pos - firstCharPosition);\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function scanJsxAttributeValue(): SyntaxKind {\r\n            startPos = pos;\r\n\r\n            switch (text.charCodeAt(pos)) {\r\n                case CharacterCodes.doubleQuote:\r\n                case CharacterCodes.singleQuote:\r\n                    tokenValue = scanString(/*allowEscapes*/ false);\r\n                    return token = SyntaxKind.StringLiteral;\r\n                default:\r\n                    // If this scans anything other than `{`, it's a parse error.\r\n                    return scan();\r\n            }\r\n        }\r\n\r\n        function scanJSDocToken(): SyntaxKind {\r\n            if (pos >= end) {\r\n                return token = SyntaxKind.EndOfFileToken;\r\n            }\r\n\r\n            startPos = pos;\r\n            tokenPos = pos;\r\n\r\n            const ch = text.charCodeAt(pos);\r\n            switch (ch) {\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {\r\n                        pos++;\r\n                    }\r\n                    return token = SyntaxKind.WhitespaceTrivia;\r\n                case CharacterCodes.at:\r\n                    pos++;\r\n                    return token = SyntaxKind.AtToken;\r\n                case CharacterCodes.lineFeed:\r\n                case CharacterCodes.carriageReturn:\r\n                    pos++;\r\n                    return token = SyntaxKind.NewLineTrivia;\r\n                case CharacterCodes.asterisk:\r\n                    pos++;\r\n                    return token = SyntaxKind.AsteriskToken;\r\n                case CharacterCodes.openBrace:\r\n                    pos++;\r\n                    return token = SyntaxKind.OpenBraceToken;\r\n                case CharacterCodes.closeBrace:\r\n                    pos++;\r\n                    return token = SyntaxKind.CloseBraceToken;\r\n                case CharacterCodes.openBracket:\r\n                    pos++;\r\n                    return token = SyntaxKind.OpenBracketToken;\r\n                case CharacterCodes.closeBracket:\r\n                    pos++;\r\n                    return token = SyntaxKind.CloseBracketToken;\r\n                case CharacterCodes.lessThan:\r\n                    pos++;\r\n                    return token = SyntaxKind.LessThanToken;\r\n                case CharacterCodes.greaterThan:\r\n                    pos++;\r\n                    return token = SyntaxKind.GreaterThanToken;\r\n                case CharacterCodes.equals:\r\n                    pos++;\r\n                    return token = SyntaxKind.EqualsToken;\r\n                case CharacterCodes.comma:\r\n                    pos++;\r\n                    return token = SyntaxKind.CommaToken;\r\n                case CharacterCodes.dot:\r\n                    pos++;\r\n                    return token = SyntaxKind.DotToken;\r\n            }\r\n\r\n            if (isIdentifierStart(ch, ScriptTarget.Latest)) {\r\n                pos++;\r\n                while (isIdentifierPart(text.charCodeAt(pos), ScriptTarget.Latest) && pos < end) {\r\n                    pos++;\r\n                }\r\n                return token = SyntaxKind.Identifier;\r\n            }\r\n            else {\r\n                return pos += 1, token = SyntaxKind.Unknown;\r\n            }\r\n        }\r\n\r\n        function speculationHelper<T>(callback: () => T, isLookahead: boolean): T {\r\n            const savePos = pos;\r\n            const saveStartPos = startPos;\r\n            const saveTokenPos = tokenPos;\r\n            const saveToken = token;\r\n            const saveTokenValue = tokenValue;\r\n            const savePrecedingLineBreak = precedingLineBreak;\r\n            const result = callback();\r\n\r\n            // If our callback returned something 'falsy' or we're just looking ahead,\r\n            // then unconditionally restore us to where we were.\r\n            if (!result || isLookahead) {\r\n                pos = savePos;\r\n                startPos = saveStartPos;\r\n                tokenPos = saveTokenPos;\r\n                token = saveToken;\r\n                tokenValue = saveTokenValue;\r\n                precedingLineBreak = savePrecedingLineBreak;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function scanRange<T>(start: number, length: number, callback: () => T): T {\r\n            const saveEnd = end;\r\n            const savePos = pos;\r\n            const saveStartPos = startPos;\r\n            const saveTokenPos = tokenPos;\r\n            const saveToken = token;\r\n            const savePrecedingLineBreak = precedingLineBreak;\r\n            const saveTokenValue = tokenValue;\r\n            const saveHasExtendedUnicodeEscape = hasExtendedUnicodeEscape;\r\n            const saveTokenIsUnterminated = tokenIsUnterminated;\r\n\r\n            setText(text, start, length);\r\n            const result = callback();\r\n\r\n            end = saveEnd;\r\n            pos = savePos;\r\n            startPos = saveStartPos;\r\n            tokenPos = saveTokenPos;\r\n            token = saveToken;\r\n            precedingLineBreak = savePrecedingLineBreak;\r\n            tokenValue = saveTokenValue;\r\n            hasExtendedUnicodeEscape = saveHasExtendedUnicodeEscape;\r\n            tokenIsUnterminated = saveTokenIsUnterminated;\r\n\r\n            return result;\r\n        }\r\n\r\n        function lookAhead<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookahead*/ true);\r\n        }\r\n\r\n        function tryScan<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookahead*/ false);\r\n        }\r\n\r\n        function getText(): string {\r\n            return text;\r\n        }\r\n\r\n        function setText(newText: string, start: number, length: number) {\r\n            text = newText || \"\";\r\n            end = length === undefined ? text.length : start + length;\r\n            setTextPos(start || 0);\r\n        }\r\n\r\n        function setOnError(errorCallback: ErrorCallback) {\r\n            onError = errorCallback;\r\n        }\r\n\r\n        function setScriptTarget(scriptTarget: ScriptTarget) {\r\n            languageVersion = scriptTarget;\r\n        }\r\n\r\n        function setLanguageVariant(variant: LanguageVariant) {\r\n            languageVariant = variant;\r\n        }\r\n\r\n        function setTextPos(textPos: number) {\r\n            Debug.assert(textPos >= 0);\r\n            pos = textPos;\r\n            startPos = textPos;\r\n            tokenPos = textPos;\r\n            token = SyntaxKind.Unknown;\r\n            precedingLineBreak = false;\r\n\r\n            tokenValue = undefined;\r\n            hasExtendedUnicodeEscape = false;\r\n            tokenIsUnterminated = false;\r\n        }\r\n    }\r\n}\r\n","/// <reference path=\"utilities.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n\r\nnamespace ts {\r\n    const enum SignatureFlags {\r\n        None = 0,\r\n        Yield = 1 << 0,\r\n        Await = 1 << 1,\r\n        Type = 1 << 2,\r\n        RequireCompleteParameterList = 1 << 3,\r\n        IgnoreMissingOpenBrace = 1 << 4,\r\n        JSDoc = 1 << 5,\r\n    }\r\n\r\n    let NodeConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let TokenConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let IdentifierConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let SourceFileConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    export function createNode(kind: SyntaxKind, pos?: number, end?: number): Node {\r\n        if (kind === SyntaxKind.SourceFile) {\r\n            return new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, pos, end);\r\n        }\r\n        else if (kind === SyntaxKind.Identifier) {\r\n            return new (IdentifierConstructor || (IdentifierConstructor = objectAllocator.getIdentifierConstructor()))(kind, pos, end);\r\n        }\r\n        else if (!isNodeKind(kind)) {\r\n            return new (TokenConstructor || (TokenConstructor = objectAllocator.getTokenConstructor()))(kind, pos, end);\r\n        }\r\n        else {\r\n            return new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, pos, end);\r\n        }\r\n    }\r\n\r\n    function visitNode<T>(cbNode: (node: Node) => T, node: Node): T | undefined {\r\n        return node && cbNode(node);\r\n    }\r\n\r\n    function visitNodes<T>(cbNode: (node: Node) => T, cbNodes: (node: NodeArray<Node>) => T | undefined, nodes: NodeArray<Node>): T | undefined {\r\n        if (nodes) {\r\n            if (cbNodes) {\r\n                return cbNodes(nodes);\r\n            }\r\n            for (const node of nodes) {\r\n                const result = cbNode(node);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes\r\n     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,\r\n     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\r\n     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\r\n     *\r\n     * @param node a given node to visit its children\r\n     * @param cbNode a callback to be invoked for all child nodes\r\n     * @param cbNodes a callback to be invoked for embedded array\r\n     *\r\n     * @remarks `forEachChild` must visit the children of a node in the order\r\n     * that they appear in the source code. The language service depends on this property to locate nodes by position.\r\n     */\r\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined {\r\n        if (!node || node.kind <= SyntaxKind.LastToken) {\r\n            return;\r\n        }\r\n        switch (node.kind) {\r\n            case SyntaxKind.QualifiedName:\r\n                return visitNode(cbNode, (<QualifiedName>node).left) ||\r\n                    visitNode(cbNode, (<QualifiedName>node).right);\r\n            case SyntaxKind.TypeParameter:\r\n                return visitNode(cbNode, (<TypeParameterDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).constraint) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).default) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).expression);\r\n            case SyntaxKind.ShorthandPropertyAssignment:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).name) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).questionToken) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).equalsToken) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).objectAssignmentInitializer);\r\n            case SyntaxKind.SpreadAssignment:\r\n                return visitNode(cbNode, (<SpreadAssignment>node).expression);\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.BindingElement:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).propertyName) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).dotDotDotToken) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).questionToken) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<VariableLikeDeclaration>node).initializer);\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNodes(cbNode, cbNodes, (<SignatureDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<SignatureDeclaration>node).parameters) ||\r\n                    visitNode(cbNode, (<SignatureDeclaration>node).type);\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.ArrowFunction:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).asteriskToken) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).questionToken) ||\r\n                    visitNodes(cbNode, cbNodes, (<FunctionLikeDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<FunctionLikeDeclaration>node).parameters) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<ArrowFunction>node).equalsGreaterThanToken) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).body);\r\n            case SyntaxKind.TypeReference:\r\n                return visitNode(cbNode, (<TypeReferenceNode>node).typeName) ||\r\n                    visitNodes(cbNode, cbNodes, (<TypeReferenceNode>node).typeArguments);\r\n            case SyntaxKind.TypePredicate:\r\n                return visitNode(cbNode, (<TypePredicateNode>node).parameterName) ||\r\n                    visitNode(cbNode, (<TypePredicateNode>node).type);\r\n            case SyntaxKind.TypeQuery:\r\n                return visitNode(cbNode, (<TypeQueryNode>node).exprName);\r\n            case SyntaxKind.TypeLiteral:\r\n                return visitNodes(cbNode, cbNodes, (<TypeLiteralNode>node).members);\r\n            case SyntaxKind.ArrayType:\r\n                return visitNode(cbNode, (<ArrayTypeNode>node).elementType);\r\n            case SyntaxKind.TupleType:\r\n                return visitNodes(cbNode, cbNodes, (<TupleTypeNode>node).elementTypes);\r\n            case SyntaxKind.UnionType:\r\n            case SyntaxKind.IntersectionType:\r\n                return visitNodes(cbNode, cbNodes, (<UnionOrIntersectionTypeNode>node).types);\r\n            case SyntaxKind.ParenthesizedType:\r\n            case SyntaxKind.TypeOperator:\r\n                return visitNode(cbNode, (<ParenthesizedTypeNode | TypeOperatorNode>node).type);\r\n            case SyntaxKind.IndexedAccessType:\r\n                return visitNode(cbNode, (<IndexedAccessTypeNode>node).objectType) ||\r\n                    visitNode(cbNode, (<IndexedAccessTypeNode>node).indexType);\r\n            case SyntaxKind.MappedType:\r\n                return visitNode(cbNode, (<MappedTypeNode>node).readonlyToken) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).typeParameter) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).questionToken) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).type);\r\n            case SyntaxKind.LiteralType:\r\n                return visitNode(cbNode, (<LiteralTypeNode>node).literal);\r\n            case SyntaxKind.ObjectBindingPattern:\r\n            case SyntaxKind.ArrayBindingPattern:\r\n                return visitNodes(cbNode, cbNodes, (<BindingPattern>node).elements);\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n                return visitNodes(cbNode, cbNodes, (<ArrayLiteralExpression>node).elements);\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n                return visitNodes(cbNode, cbNodes, (<ObjectLiteralExpression>node).properties);\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return visitNode(cbNode, (<PropertyAccessExpression>node).expression) ||\r\n                    visitNode(cbNode, (<PropertyAccessExpression>node).name);\r\n            case SyntaxKind.ElementAccessExpression:\r\n                return visitNode(cbNode, (<ElementAccessExpression>node).expression) ||\r\n                    visitNode(cbNode, (<ElementAccessExpression>node).argumentExpression);\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n                return visitNode(cbNode, (<CallExpression>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<CallExpression>node).typeArguments) ||\r\n                    visitNodes(cbNode, cbNodes, (<CallExpression>node).arguments);\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n                return visitNode(cbNode, (<TaggedTemplateExpression>node).tag) ||\r\n                    visitNode(cbNode, (<TaggedTemplateExpression>node).template);\r\n            case SyntaxKind.TypeAssertionExpression:\r\n                return visitNode(cbNode, (<TypeAssertion>node).type) ||\r\n                    visitNode(cbNode, (<TypeAssertion>node).expression);\r\n            case SyntaxKind.ParenthesizedExpression:\r\n                return visitNode(cbNode, (<ParenthesizedExpression>node).expression);\r\n            case SyntaxKind.DeleteExpression:\r\n                return visitNode(cbNode, (<DeleteExpression>node).expression);\r\n            case SyntaxKind.TypeOfExpression:\r\n                return visitNode(cbNode, (<TypeOfExpression>node).expression);\r\n            case SyntaxKind.VoidExpression:\r\n                return visitNode(cbNode, (<VoidExpression>node).expression);\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                return visitNode(cbNode, (<PrefixUnaryExpression>node).operand);\r\n            case SyntaxKind.YieldExpression:\r\n                return visitNode(cbNode, (<YieldExpression>node).asteriskToken) ||\r\n                    visitNode(cbNode, (<YieldExpression>node).expression);\r\n            case SyntaxKind.AwaitExpression:\r\n                return visitNode(cbNode, (<AwaitExpression>node).expression);\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return visitNode(cbNode, (<PostfixUnaryExpression>node).operand);\r\n            case SyntaxKind.BinaryExpression:\r\n                return visitNode(cbNode, (<BinaryExpression>node).left) ||\r\n                    visitNode(cbNode, (<BinaryExpression>node).operatorToken) ||\r\n                    visitNode(cbNode, (<BinaryExpression>node).right);\r\n            case SyntaxKind.AsExpression:\r\n                return visitNode(cbNode, (<AsExpression>node).expression) ||\r\n                    visitNode(cbNode, (<AsExpression>node).type);\r\n            case SyntaxKind.NonNullExpression:\r\n                return visitNode(cbNode, (<NonNullExpression>node).expression);\r\n            case SyntaxKind.MetaProperty:\r\n                return visitNode(cbNode, (<MetaProperty>node).name);\r\n            case SyntaxKind.ConditionalExpression:\r\n                return visitNode(cbNode, (<ConditionalExpression>node).condition) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).questionToken) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).whenTrue) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).colonToken) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).whenFalse);\r\n            case SyntaxKind.SpreadElement:\r\n                return visitNode(cbNode, (<SpreadElement>node).expression);\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.ModuleBlock:\r\n                return visitNodes(cbNode, cbNodes, (<Block>node).statements);\r\n            case SyntaxKind.SourceFile:\r\n                return visitNodes(cbNode, cbNodes, (<SourceFile>node).statements) ||\r\n                    visitNode(cbNode, (<SourceFile>node).endOfFileToken);\r\n            case SyntaxKind.VariableStatement:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<VariableStatement>node).declarationList);\r\n            case SyntaxKind.VariableDeclarationList:\r\n                return visitNodes(cbNode, cbNodes, (<VariableDeclarationList>node).declarations);\r\n            case SyntaxKind.ExpressionStatement:\r\n                return visitNode(cbNode, (<ExpressionStatement>node).expression);\r\n            case SyntaxKind.IfStatement:\r\n                return visitNode(cbNode, (<IfStatement>node).expression) ||\r\n                    visitNode(cbNode, (<IfStatement>node).thenStatement) ||\r\n                    visitNode(cbNode, (<IfStatement>node).elseStatement);\r\n            case SyntaxKind.DoStatement:\r\n                return visitNode(cbNode, (<DoStatement>node).statement) ||\r\n                    visitNode(cbNode, (<DoStatement>node).expression);\r\n            case SyntaxKind.WhileStatement:\r\n                return visitNode(cbNode, (<WhileStatement>node).expression) ||\r\n                    visitNode(cbNode, (<WhileStatement>node).statement);\r\n            case SyntaxKind.ForStatement:\r\n                return visitNode(cbNode, (<ForStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForStatement>node).condition) ||\r\n                    visitNode(cbNode, (<ForStatement>node).incrementor) ||\r\n                    visitNode(cbNode, (<ForStatement>node).statement);\r\n            case SyntaxKind.ForInStatement:\r\n                return visitNode(cbNode, (<ForInStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForInStatement>node).expression) ||\r\n                    visitNode(cbNode, (<ForInStatement>node).statement);\r\n            case SyntaxKind.ForOfStatement:\r\n                return visitNode(cbNode, (<ForOfStatement>node).awaitModifier) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).expression) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).statement);\r\n            case SyntaxKind.ContinueStatement:\r\n            case SyntaxKind.BreakStatement:\r\n                return visitNode(cbNode, (<BreakOrContinueStatement>node).label);\r\n            case SyntaxKind.ReturnStatement:\r\n                return visitNode(cbNode, (<ReturnStatement>node).expression);\r\n            case SyntaxKind.WithStatement:\r\n                return visitNode(cbNode, (<WithStatement>node).expression) ||\r\n                    visitNode(cbNode, (<WithStatement>node).statement);\r\n            case SyntaxKind.SwitchStatement:\r\n                return visitNode(cbNode, (<SwitchStatement>node).expression) ||\r\n                    visitNode(cbNode, (<SwitchStatement>node).caseBlock);\r\n            case SyntaxKind.CaseBlock:\r\n                return visitNodes(cbNode, cbNodes, (<CaseBlock>node).clauses);\r\n            case SyntaxKind.CaseClause:\r\n                return visitNode(cbNode, (<CaseClause>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<CaseClause>node).statements);\r\n            case SyntaxKind.DefaultClause:\r\n                return visitNodes(cbNode, cbNodes, (<DefaultClause>node).statements);\r\n            case SyntaxKind.LabeledStatement:\r\n                return visitNode(cbNode, (<LabeledStatement>node).label) ||\r\n                    visitNode(cbNode, (<LabeledStatement>node).statement);\r\n            case SyntaxKind.ThrowStatement:\r\n                return visitNode(cbNode, (<ThrowStatement>node).expression);\r\n            case SyntaxKind.TryStatement:\r\n                return visitNode(cbNode, (<TryStatement>node).tryBlock) ||\r\n                    visitNode(cbNode, (<TryStatement>node).catchClause) ||\r\n                    visitNode(cbNode, (<TryStatement>node).finallyBlock);\r\n            case SyntaxKind.CatchClause:\r\n                return visitNode(cbNode, (<CatchClause>node).variableDeclaration) ||\r\n                    visitNode(cbNode, (<CatchClause>node).block);\r\n            case SyntaxKind.Decorator:\r\n                return visitNode(cbNode, (<Decorator>node).expression);\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ClassLikeDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).heritageClauses) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).members);\r\n            case SyntaxKind.InterfaceDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<InterfaceDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<InterfaceDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassDeclaration>node).heritageClauses) ||\r\n                    visitNodes(cbNode, cbNodes, (<InterfaceDeclaration>node).members);\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<TypeAliasDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<TypeAliasDeclaration>node).typeParameters) ||\r\n                    visitNode(cbNode, (<TypeAliasDeclaration>node).type);\r\n            case SyntaxKind.EnumDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<EnumDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<EnumDeclaration>node).members);\r\n            case SyntaxKind.EnumMember:\r\n                return visitNode(cbNode, (<EnumMember>node).name) ||\r\n                    visitNode(cbNode, (<EnumMember>node).initializer);\r\n            case SyntaxKind.ModuleDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ModuleDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<ModuleDeclaration>node).body);\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ImportEqualsDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<ImportEqualsDeclaration>node).moduleReference);\r\n            case SyntaxKind.ImportDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ImportDeclaration>node).importClause) ||\r\n                    visitNode(cbNode, (<ImportDeclaration>node).moduleSpecifier);\r\n            case SyntaxKind.ImportClause:\r\n                return visitNode(cbNode, (<ImportClause>node).name) ||\r\n                    visitNode(cbNode, (<ImportClause>node).namedBindings);\r\n            case SyntaxKind.NamespaceExportDeclaration:\r\n                return visitNode(cbNode, (<NamespaceExportDeclaration>node).name);\r\n\r\n            case SyntaxKind.NamespaceImport:\r\n                return visitNode(cbNode, (<NamespaceImport>node).name);\r\n            case SyntaxKind.NamedImports:\r\n            case SyntaxKind.NamedExports:\r\n                return visitNodes(cbNode, cbNodes, (<NamedImportsOrExports>node).elements);\r\n            case SyntaxKind.ExportDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ExportDeclaration>node).exportClause) ||\r\n                    visitNode(cbNode, (<ExportDeclaration>node).moduleSpecifier);\r\n            case SyntaxKind.ImportSpecifier:\r\n            case SyntaxKind.ExportSpecifier:\r\n                return visitNode(cbNode, (<ImportOrExportSpecifier>node).propertyName) ||\r\n                    visitNode(cbNode, (<ImportOrExportSpecifier>node).name);\r\n            case SyntaxKind.ExportAssignment:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ExportAssignment>node).expression);\r\n            case SyntaxKind.TemplateExpression:\r\n                return visitNode(cbNode, (<TemplateExpression>node).head) || visitNodes(cbNode, cbNodes, (<TemplateExpression>node).templateSpans);\r\n            case SyntaxKind.TemplateSpan:\r\n                return visitNode(cbNode, (<TemplateSpan>node).expression) || visitNode(cbNode, (<TemplateSpan>node).literal);\r\n            case SyntaxKind.ComputedPropertyName:\r\n                return visitNode(cbNode, (<ComputedPropertyName>node).expression);\r\n            case SyntaxKind.HeritageClause:\r\n                return visitNodes(cbNode, cbNodes, (<HeritageClause>node).types);\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return visitNode(cbNode, (<ExpressionWithTypeArguments>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<ExpressionWithTypeArguments>node).typeArguments);\r\n            case SyntaxKind.ExternalModuleReference:\r\n                return visitNode(cbNode, (<ExternalModuleReference>node).expression);\r\n            case SyntaxKind.MissingDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators);\r\n            case SyntaxKind.CommaListExpression:\r\n                return visitNodes(cbNode, cbNodes, (<CommaListExpression>node).elements);\r\n\r\n            case SyntaxKind.JsxElement:\r\n                return visitNode(cbNode, (<JsxElement>node).openingElement) ||\r\n                    visitNodes(cbNode, cbNodes, (<JsxElement>node).children) ||\r\n                    visitNode(cbNode, (<JsxElement>node).closingElement);\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.JsxOpeningElement:\r\n                return visitNode(cbNode, (<JsxOpeningLikeElement>node).tagName) ||\r\n                    visitNode(cbNode, (<JsxOpeningLikeElement>node).attributes);\r\n            case SyntaxKind.JsxAttributes:\r\n                return visitNodes(cbNode, cbNodes, (<JsxAttributes>node).properties);\r\n            case SyntaxKind.JsxAttribute:\r\n                return visitNode(cbNode, (<JsxAttribute>node).name) ||\r\n                    visitNode(cbNode, (<JsxAttribute>node).initializer);\r\n            case SyntaxKind.JsxSpreadAttribute:\r\n                return visitNode(cbNode, (<JsxSpreadAttribute>node).expression);\r\n            case SyntaxKind.JsxExpression:\r\n                return visitNode(cbNode, (node as JsxExpression).dotDotDotToken) ||\r\n                    visitNode(cbNode, (node as JsxExpression).expression);\r\n            case SyntaxKind.JsxClosingElement:\r\n                return visitNode(cbNode, (<JsxClosingElement>node).tagName);\r\n\r\n            case SyntaxKind.JSDocTypeExpression:\r\n                return visitNode(cbNode, (<JSDocTypeExpression>node).type);\r\n            case SyntaxKind.JSDocNonNullableType:\r\n                return visitNode(cbNode, (<JSDocNonNullableType>node).type);\r\n            case SyntaxKind.JSDocNullableType:\r\n                return visitNode(cbNode, (<JSDocNullableType>node).type);\r\n            case SyntaxKind.JSDocOptionalType:\r\n                return visitNode(cbNode, (<JSDocOptionalType>node).type);\r\n            case SyntaxKind.JSDocFunctionType:\r\n                return visitNodes(cbNode, cbNodes, (<JSDocFunctionType>node).parameters) ||\r\n                    visitNode(cbNode, (<JSDocFunctionType>node).type);\r\n            case SyntaxKind.JSDocVariadicType:\r\n                return visitNode(cbNode, (<JSDocVariadicType>node).type);\r\n            case SyntaxKind.JSDocComment:\r\n                return visitNodes(cbNode, cbNodes, (<JSDoc>node).tags);\r\n            case SyntaxKind.JSDocParameterTag:\r\n            case SyntaxKind.JSDocPropertyTag:\r\n                if ((node as JSDocPropertyLikeTag).isNameFirst) {\r\n                    return visitNode(cbNode, (<JSDocPropertyLikeTag>node).name) ||\r\n                        visitNode(cbNode, (<JSDocPropertyLikeTag>node).typeExpression);\r\n                }\r\n                else {\r\n                    return visitNode(cbNode, (<JSDocPropertyLikeTag>node).typeExpression) ||\r\n                        visitNode(cbNode, (<JSDocPropertyLikeTag>node).name);\r\n                }\r\n            case SyntaxKind.JSDocReturnTag:\r\n                return visitNode(cbNode, (<JSDocReturnTag>node).typeExpression);\r\n            case SyntaxKind.JSDocTypeTag:\r\n                return visitNode(cbNode, (<JSDocTypeTag>node).typeExpression);\r\n            case SyntaxKind.JSDocAugmentsTag:\r\n                return visitNode(cbNode, (<JSDocAugmentsTag>node).class);\r\n            case SyntaxKind.JSDocTemplateTag:\r\n                return visitNodes(cbNode, cbNodes, (<JSDocTemplateTag>node).typeParameters);\r\n            case SyntaxKind.JSDocTypedefTag:\r\n                if ((node as JSDocTypedefTag).typeExpression &&\r\n                    (node as JSDocTypedefTag).typeExpression.kind === SyntaxKind.JSDocTypeExpression) {\r\n                    return visitNode(cbNode, (<JSDocTypedefTag>node).typeExpression) ||\r\n                        visitNode(cbNode, (<JSDocTypedefTag>node).fullName);\r\n                }\r\n                else {\r\n                    return visitNode(cbNode, (<JSDocTypedefTag>node).fullName) ||\r\n                        visitNode(cbNode, (<JSDocTypedefTag>node).typeExpression);\r\n                }\r\n            case SyntaxKind.JSDocTypeLiteral:\r\n                if ((node as JSDocTypeLiteral).jsDocPropertyTags) {\r\n                    for (const tag of (node as JSDocTypeLiteral).jsDocPropertyTags) {\r\n                        visitNode(cbNode, tag);\r\n                    }\r\n                }\r\n                return;\r\n            case SyntaxKind.PartiallyEmittedExpression:\r\n                return visitNode(cbNode, (<PartiallyEmittedExpression>node).expression);\r\n        }\r\n    }\r\n\r\n    export function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes = false, scriptKind?: ScriptKind): SourceFile {\r\n        performance.mark(\"beforeParse\");\r\n        const result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, scriptKind);\r\n        performance.mark(\"afterParse\");\r\n        performance.measure(\"Parse\", \"beforeParse\", \"afterParse\");\r\n        return result;\r\n    }\r\n\r\n    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName {\r\n        return Parser.parseIsolatedEntityName(text, languageVersion);\r\n    }\r\n\r\n    /**\r\n     * Parse json text into SyntaxTree and return node and parse errors if any\r\n     * @param fileName\r\n     * @param sourceText\r\n     */\r\n    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile {\r\n        return Parser.parseJsonText(fileName, sourceText);\r\n    }\r\n\r\n    // See also `isExternalOrCommonJsModule` in utilities.ts\r\n    export function isExternalModule(file: SourceFile): boolean {\r\n        return file.externalModuleIndicator !== undefined;\r\n    }\r\n\r\n    // Produces a new SourceFile for the 'newText' provided. The 'textChangeRange' parameter\r\n    // indicates what changed between the 'text' that this SourceFile has and the 'newText'.\r\n    // The SourceFile will be created with the compiler attempting to reuse as many nodes from\r\n    // this file as possible.\r\n    //\r\n    // Note: this function mutates nodes from this SourceFile. That means any existing nodes\r\n    // from this SourceFile that are being held onto may change as a result (including\r\n    // becoming detached from any SourceFile).  It is recommended that this SourceFile not\r\n    // be used once 'update' is called on it.\r\n    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile {\r\n        const newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);\r\n        // Because new source file node is created, it may not have the flag PossiblyContainDynamicImport. This is the case if there is no new edit to add dynamic import.\r\n        // We will manually port the flag to the new source file.\r\n        newSourceFile.flags |= (sourceFile.flags & NodeFlags.PossiblyContainsDynamicImport);\r\n        return newSourceFile;\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseIsolatedJSDocComment(content: string, start?: number, length?: number) {\r\n        const result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);\r\n        if (result && result.jsDoc) {\r\n            // because the jsDocComment was parsed out of the source file, it might\r\n            // not be covered by the fixupParentReferences.\r\n            Parser.fixupParentReferences(result.jsDoc);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /* @internal */\r\n    // Exposed only for testing.\r\n    export function parseJSDocTypeExpressionForTests(content: string, start?: number, length?: number) {\r\n        return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);\r\n    }\r\n\r\n    // Implement the parser as a singleton module.  We do this for perf reasons because creating\r\n    // parser instances can actually be expensive enough to impact us on projects with many source\r\n    // files.\r\n    namespace Parser {\r\n        // Share a single scanner across all calls to parse a source file.  This helps speed things\r\n        // up by avoiding the cost of creating/compiling scanners over and over again.\r\n        const scanner = createScanner(ScriptTarget.Latest, /*skipTrivia*/ true);\r\n        const disallowInAndDecoratorContext = NodeFlags.DisallowInContext | NodeFlags.DecoratorContext;\r\n\r\n        // capture constructors in 'initializeState' to avoid null checks\r\n        let NodeConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let TokenConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let IdentifierConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let SourceFileConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let 别名构造函数: new (旗帜: 别名旗帜, 名称: __String) => 别名;\r\n\r\n\r\n        let sourceFile: SourceFile;\r\n        let parseDiagnostics: Diagnostic[];\r\n        let syntaxCursor: IncrementalParser.SyntaxCursor;\r\n\r\n        let currentToken: SyntaxKind;\r\n        let sourceText: string;\r\n        let nodeCount: number;\r\n        let identifiers: Map<string>;\r\n        let identifierCount: number;\r\n\r\n        let parsingContext: ParsingContext;\r\n\r\n        // Flags that dictate what parsing context we're in.  For example:\r\n        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is\r\n        // that some tokens that would be considered identifiers may be considered keywords.\r\n        //\r\n        // When adding more parser context flags, consider which is the more common case that the\r\n        // flag will be in.  This should be the 'false' state for that flag.  The reason for this is\r\n        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,\r\n        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for\r\n        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost\r\n        // all nodes would need extra state on them to store this info.\r\n        //\r\n        // Note:  'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6\r\n        // grammar specification.\r\n        //\r\n        // An important thing about these context concepts.  By default they are effectively inherited\r\n        // while parsing through every grammar production.  i.e. if you don't change them, then when\r\n        // you parse a sub-production, it will have the same context values as the parent production.\r\n        // This is great most of the time.  After all, consider all the 'expression' grammar productions\r\n        // and how nearly all of them pass along the 'in' and 'yield' context values:\r\n        //\r\n        // EqualityExpression[In, Yield] :\r\n        //      RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]\r\n        //\r\n        // Where you have to be careful is then understanding what the points are in the grammar\r\n        // where the values are *not* passed along.  For example:\r\n        //\r\n        // SingleNameBinding[Yield,GeneratorParameter]\r\n        //      [+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt\r\n        //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt\r\n        //\r\n        // Here this is saying that if the GeneratorParameter context flag is set, that we should\r\n        // explicitly set the 'yield' context flag to false before calling into the BindingIdentifier\r\n        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.\r\n        // production.  Conversely, if the GeneratorParameter context flag is not set, then we\r\n        // should leave the 'yield' context flag alone.\r\n        //\r\n        // Getting this all correct is tricky and requires careful reading of the grammar to\r\n        // understand when these values should be changed versus when they should be inherited.\r\n        //\r\n        // Note: it should not be necessary to save/restore these flags during speculative/lookahead\r\n        // parsing.  These context flags are naturally stored and restored through normal recursive\r\n        // descent parsing and unwinding.\r\n        let contextFlags: NodeFlags;\r\n\r\n        // Whether or not we've had a parse error since creating the last AST node.  If we have\r\n        // encountered an error, it will be stored on the next AST node we create.  Parse errors\r\n        // can be broken down into three categories:\r\n        //\r\n        // 1) An error that occurred during scanning.  For example, an unterminated literal, or a\r\n        //    character that was completely not understood.\r\n        //\r\n        // 2) A token was expected, but was not present.  This type of error is commonly produced\r\n        //    by the 'parseExpected' function.\r\n        //\r\n        // 3) A token was present that no parsing function was able to consume.  This type of error\r\n        //    only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser\r\n        //    decides to skip the token.\r\n        //\r\n        // In all of these cases, we want to mark the next node as having had an error before it.\r\n        // With this mark, we can know in incremental settings if this node can be reused, or if\r\n        // we have to reparse it.  If we don't keep this information around, we may just reuse the\r\n        // node.  in that event we would then not produce the same errors as we did before, causing\r\n        // significant confusion problems.\r\n        //\r\n        // Note: it is necessary that this value be saved/restored during speculative/lookahead\r\n        // parsing.  During lookahead parsing, we will often create a node.  That node will have\r\n        // this value attached, and then this value will be set back to 'false'.  If we decide to\r\n        // rewind, we must get back to the same value we had prior to the lookahead.\r\n        //\r\n        // Note: any errors at the end of the file that do not precede a regular node, should get\r\n        // attached to the EOF token.\r\n        let parseErrorBeforeNextFinishedNode = false;\r\n\r\n        export function parseSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, syntaxCursor: IncrementalParser.SyntaxCursor, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile {\r\n            scriptKind = ensureScriptKind(fileName, scriptKind);\r\n            initializeState(sourceText, languageVersion, syntaxCursor, scriptKind);\r\n\r\n            const result = parseSourceFileWorker(fileName, languageVersion, setParentNodes, scriptKind);\r\n\r\n            clearState();\r\n\r\n            return result;\r\n        }\r\n\r\n        export function parseIsolatedEntityName(content: string, languageVersion: ScriptTarget): EntityName {\r\n            initializeState(content, languageVersion, /*syntaxCursor*/ undefined, ScriptKind.JS);\r\n            // Prime the scanner.\r\n            nextToken();\r\n            const entityName = parseEntityName(/*allowReservedWords*/ true);\r\n            const isInvalid = token() === SyntaxKind.EndOfFileToken && !parseDiagnostics.length;\r\n            clearState();\r\n            return isInvalid ? entityName : undefined;\r\n        }\r\n\r\n        export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile {\r\n            initializeState(sourceText, ScriptTarget.ES2015, /*syntaxCursor*/ undefined, ScriptKind.JSON);\r\n            // Set source file so that errors will be reported with this file name\r\n            sourceFile = createSourceFile(fileName, ScriptTarget.ES2015, ScriptKind.JSON);\r\n            const result = <JsonSourceFile>sourceFile;\r\n\r\n            // Prime the scanner.\r\n            nextToken();\r\n            if (token() === SyntaxKind.EndOfFileToken) {\r\n                sourceFile.endOfFileToken = <EndOfFileToken>parseTokenNode();\r\n            }\r\n            else if (token() === SyntaxKind.OpenBraceToken ||\r\n                lookAhead(() => token() === SyntaxKind.StringLiteral)) {\r\n                result.jsonObject = parseObjectLiteralExpression();\r\n                sourceFile.endOfFileToken = parseExpectedToken(SyntaxKind.EndOfFileToken, /*reportAtCurrentPosition*/ false, Diagnostics.Unexpected_token);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.OpenBraceToken);\r\n            }\r\n\r\n            sourceFile.parseDiagnostics = parseDiagnostics;\r\n            clearState();\r\n            return result;\r\n        }\r\n\r\n        function getLanguageVariant(scriptKind: ScriptKind) {\r\n            // .tsx and .jsx files are treated as jsx language variant.\r\n            return scriptKind === ScriptKind.TSX || scriptKind === ScriptKind.CTSX || scriptKind === ScriptKind.JSX || scriptKind === ScriptKind.JS || scriptKind === ScriptKind.JSON ? LanguageVariant.JSX : LanguageVariant.Standard;\r\n        }\r\n\r\n        function initializeState(_sourceText: string, languageVersion: ScriptTarget, _syntaxCursor: IncrementalParser.SyntaxCursor, scriptKind: ScriptKind) {\r\n            NodeConstructor = objectAllocator.getNodeConstructor();\r\n            TokenConstructor = objectAllocator.getTokenConstructor();\r\n            IdentifierConstructor = objectAllocator.getIdentifierConstructor();\r\n            SourceFileConstructor = objectAllocator.getSourceFileConstructor();\r\n            别名构造函数 = objectAllocator.get别名构造函数();\r\n\r\n            sourceText = _sourceText;\r\n            syntaxCursor = _syntaxCursor;\r\n\r\n            parseDiagnostics = [];\r\n            parsingContext = 0;\r\n            identifiers = createMap<string>();\r\n            identifierCount = 0;\r\n            nodeCount = 0;\r\n\r\n            contextFlags = scriptKind === ScriptKind.JS || scriptKind === ScriptKind.JSX || scriptKind === ScriptKind.JSON ? NodeFlags.JavaScriptFile : NodeFlags.None;\r\n            parseErrorBeforeNextFinishedNode = false;\r\n\r\n            // Initialize and prime the scanner before parsing the source elements.\r\n            scanner.setText(sourceText);\r\n            scanner.setOnError(scanError);\r\n            scanner.setScriptTarget(languageVersion);\r\n            scanner.setLanguageVariant(getLanguageVariant(scriptKind));\r\n        }\r\n\r\n        function clearState() {\r\n            // Clear out the text the scanner is pointing at, so it doesn't keep anything alive unnecessarily.\r\n            scanner.setText(\"\");\r\n            scanner.setOnError(undefined);\r\n\r\n            // Clear any data.  We don't want to accidentally hold onto it for too long.\r\n            parseDiagnostics = undefined;\r\n            sourceFile = undefined;\r\n            identifiers = undefined;\r\n            syntaxCursor = undefined;\r\n            sourceText = undefined;\r\n        }\r\n\r\n        function parseSourceFileWorker(fileName: string, languageVersion: ScriptTarget, setParentNodes: boolean, scriptKind: ScriptKind): SourceFile {\r\n            sourceFile = createSourceFile(fileName, languageVersion, scriptKind);\r\n            sourceFile.flags = contextFlags;\r\n\r\n            // Prime the scanner.\r\n            nextToken();\r\n            processReferenceComments(sourceFile);\r\n\r\n            sourceFile.statements = parseList(ParsingContext.SourceElements, parseStatement);\r\n            Debug.assert(token() === SyntaxKind.EndOfFileToken);\r\n            sourceFile.endOfFileToken = addJSDocComment(parseTokenNode() as EndOfFileToken);\r\n\r\n            setExternalModuleIndicator(sourceFile);\r\n\r\n            sourceFile.nodeCount = nodeCount;\r\n            sourceFile.identifierCount = identifierCount;\r\n            sourceFile.identifiers = identifiers;\r\n            sourceFile.parseDiagnostics = parseDiagnostics;\r\n\r\n            if (setParentNodes) {\r\n                fixupParentReferences(sourceFile);\r\n            }\r\n\r\n            return sourceFile;\r\n        }\r\n\r\n        let 局部词典组: Map<词典>\r\n        function addJSDocComment<T extends HasJSDoc>(node: T): T {\r\n            const comments = getJSDocCommentRanges(node, sourceFile.text);\r\n            if (comments) {\r\n                for (const comment of comments) {\r\n                    const jsDoc = JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos);\r\n                    if (!jsDoc) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!node.jsDoc) {\r\n                        node.jsDoc = [];\r\n                    }\r\n                    node.jsDoc.push(jsDoc);\r\n                }\r\n            }\r\n            // 词典只能存在于 声明文件\r\n            if (sourceFile.isDeclarationFile) {\r\n                const 词典注释 = 取字典注释范围(node, sourceFile.text)\r\n                if (词典注释) {\r\n                    for (const 注释 of 词典注释) {\r\n                        if (注释.词典旗帜 & 别名旗帜.局部词典) {\r\n                            const 局部词典 = 编译词典标签.编译词典(注释.注释范围.pos, 注释.注释范围.end - 注释.注释范围.pos, /** 头部长度 */ \"//@\".length, node)\r\n                            if (!局部词典) {\r\n                                continue;\r\n                            }\r\n                            if (!node.局部词典语句) {\r\n                                node.局部词典语句 = [];\r\n                            }\r\n                            if (是局部词典语句(局部词典)) {\r\n                                node.局部词典语句.push(局部词典);\r\n                            }\r\n                        }\r\n                        else {\r\n                            let 全局语句 = 编译词典标签.编译词典(注释.注释范围.pos, 注释.注释范围.end - 注释.注释范围.pos, /** 头部长度 */  \"//@@\".length)\r\n                            if (全局语句) {\r\n                                if (!sourceFile.全局词典) {\r\n                                    sourceFile.全局词典 = createMap<词典>()\r\n                                }\r\n                                全局语句.表达式.forEach(词典节点 => {\r\n                                    const 键文本 = ts.isIdentifier(词典节点.键.name) ? 词典节点.键.name.escapedText : 词典节点.键.name.text\r\n                                    const 存在 = sourceFile.全局词典.get(键文本 as string)\r\n                                    if (!存在) {\r\n                                        sourceFile.全局词典.set(键文本 as string, 词典节点)\r\n                                    }\r\n                                })\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node && node.局部词典语句 && node.局部词典语句[0]) {\r\n                        局部词典组 = createMap<词典>();\r\n                        node.局部词典语句.forEach(语句 => {\r\n                            语句.表达式.forEach(v => {\r\n                                const 键文本: string = ts.isIdentifier(v.键.name) ? v.键.name.escapedText as string : v.键.name.text;\r\n                                局部词典组.set(键文本, v);\r\n                                if (!v.是单向词典) {\r\n                                    const 值文本: string = ts.isIdentifier(v.值.name) ? v.值.name.escapedText as string : v.值.name.text;\r\n                                    局部词典组.set(值文本, 交换词典键值(v));\r\n                                }\r\n                            });\r\n                        });\r\n                        forEachChild(node, 局部词典绑定回调);\r\n                        局部词典组.clear();\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function 局部词典绑定回调(node: Node) {\r\n            if (node.kind === SyntaxKind.Identifier) {\r\n                const 子词典 = 局部词典组.get((<Identifier>node).escapedText as string);\r\n                if (子词典 && (子词典.flags & NodeFlags.ThisNodeHasError) === 0) {\r\n                    const 别名名称: string = (子词典.值.name as Identifier).escapedText as string;\r\n                    const 别名: 别名 = new 别名构造函数(取别名旗帜(子词典), 别名名称 as __String);\r\n                    (<Identifier>node).别名 = 别名;\r\n                    return;\r\n                }\r\n            }\r\n            else if (node.kind === SyntaxKind.StringLiteral) {\r\n                const 子词典 = 局部词典组.get((<StringLiteral>node).text);\r\n                if (子词典 && 子词典.是文本字面量词典 && (子词典.flags & NodeFlags.ThisNodeHasError) === 0) {\r\n                    const 别名名称: string = (子词典.值.name as StringLiteral).text;\r\n                    const 别名: 别名 = new 别名构造函数(取别名旗帜(子词典), 别名名称 as __String);\r\n                    (<StringLiteral>node).别名 = 别名;\r\n                    return;\r\n                }\r\n            }\r\n            forEachChild(node, 局部词典绑定回调)\r\n        }\r\n\r\n        export function fixupParentReferences(rootNode: Node) {\r\n            // normally parent references are set during binding. However, for clients that only need\r\n            // a syntax tree, and no semantic features, then the binding process is an unnecessary\r\n            // overhead.  This functions allows us to set all the parents, without all the expense of\r\n            // binding.\r\n\r\n            let parent: Node = rootNode;\r\n            forEachChild(rootNode, visitNode);\r\n            return;\r\n\r\n            function visitNode(n: Node): void {\r\n                // walk down setting parents that differ from the parent we think it should be.  This\r\n                // allows us to quickly bail out of setting parents for subtrees during incremental\r\n                // parsing\r\n                if (n.parent !== parent) {\r\n                    n.parent = parent;\r\n\r\n                    const saveParent = parent;\r\n                    parent = n;\r\n                    forEachChild(n, visitNode);\r\n                    if (hasJSDocNodes(n)) {\r\n                        for (const jsDoc of n.jsDoc) {\r\n                            jsDoc.parent = n;\r\n                            parent = jsDoc;\r\n                            forEachChild(jsDoc, visitNode);\r\n                        }\r\n                    }\r\n                    parent = saveParent;\r\n                }\r\n            }\r\n        }\r\n\r\n        function createSourceFile(fileName: string, languageVersion: ScriptTarget, scriptKind: ScriptKind): SourceFile {\r\n            // code from createNode is inlined here so createNode won't have to deal with special case of creating source files\r\n            // this is quite rare comparing to other nodes and createNode should be as fast as possible\r\n            const sourceFile = <SourceFile>new SourceFileConstructor(SyntaxKind.SourceFile, /*pos*/ 0, /* end */ sourceText.length);\r\n            nodeCount++;\r\n\r\n            sourceFile.text = sourceText;\r\n            sourceFile.bindDiagnostics = [];\r\n            sourceFile.languageVersion = languageVersion;\r\n            sourceFile.fileName = normalizePath(fileName);\r\n            sourceFile.languageVariant = getLanguageVariant(scriptKind);\r\n            sourceFile.isDeclarationFile = fileExtensionIs(sourceFile.fileName, Extension.Dts) || fileExtensionIs(sourceFile.fileName, Extension.DCts);\r\n            sourceFile.scriptKind = scriptKind;\r\n\r\n            return sourceFile;\r\n        }\r\n\r\n        function setContextFlag(val: boolean, flag: NodeFlags) {\r\n            if (val) {\r\n                contextFlags |= flag;\r\n            }\r\n            else {\r\n                contextFlags &= ~flag;\r\n            }\r\n        }\r\n\r\n        function setDisallowInContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.DisallowInContext);\r\n        }\r\n\r\n        function setYieldContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.YieldContext);\r\n        }\r\n\r\n        function setDecoratorContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.DecoratorContext);\r\n        }\r\n\r\n        function setAwaitContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.AwaitContext);\r\n        }\r\n\r\n        function doOutsideOfContext<T>(context: NodeFlags, func: () => T): T {\r\n            // contextFlagsToClear will contain only the context flags that are\r\n            // currently set that we need to temporarily clear\r\n            // We don't just blindly reset to the previous flags to ensure\r\n            // that we do not mutate cached flags for the incremental\r\n            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and\r\n            // HasAggregatedChildData).\r\n            const contextFlagsToClear = context & contextFlags;\r\n            if (contextFlagsToClear) {\r\n                // clear the requested context flags\r\n                setContextFlag(/*val*/ false, contextFlagsToClear);\r\n                const result = func();\r\n                // restore the context flags we just cleared\r\n                setContextFlag(/*val*/ true, contextFlagsToClear);\r\n                return result;\r\n            }\r\n\r\n            // no need to do anything special as we are not in any of the requested contexts\r\n            return func();\r\n        }\r\n\r\n        function doInsideOfContext<T>(context: NodeFlags, func: () => T): T {\r\n            // contextFlagsToSet will contain only the context flags that\r\n            // are not currently set that we need to temporarily enable.\r\n            // We don't just blindly reset to the previous flags to ensure\r\n            // that we do not mutate cached flags for the incremental\r\n            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and\r\n            // HasAggregatedChildData).\r\n            const contextFlagsToSet = context & ~contextFlags;\r\n            if (contextFlagsToSet) {\r\n                // set the requested context flags\r\n                setContextFlag(/*val*/ true, contextFlagsToSet);\r\n                const result = func();\r\n                // reset the context flags we just set\r\n                setContextFlag(/*val*/ false, contextFlagsToSet);\r\n                return result;\r\n            }\r\n\r\n            // no need to do anything special as we are already in all of the requested contexts\r\n            return func();\r\n        }\r\n\r\n        function allowInAnd<T>(func: () => T): T {\r\n            return doOutsideOfContext(NodeFlags.DisallowInContext, func);\r\n        }\r\n\r\n        function disallowInAnd<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.DisallowInContext, func);\r\n        }\r\n\r\n        function doInYieldContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.YieldContext, func);\r\n        }\r\n\r\n        function doInDecoratorContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.DecoratorContext, func);\r\n        }\r\n\r\n        function doInAwaitContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function doOutsideOfAwaitContext<T>(func: () => T): T {\r\n            return doOutsideOfContext(NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function doInYieldAndAwaitContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.YieldContext | NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function inContext(flags: NodeFlags) {\r\n            return (contextFlags & flags) !== 0;\r\n        }\r\n\r\n        function inYieldContext() {\r\n            return inContext(NodeFlags.YieldContext);\r\n        }\r\n\r\n        function inDisallowInContext() {\r\n            return inContext(NodeFlags.DisallowInContext);\r\n        }\r\n\r\n        function inDecoratorContext() {\r\n            return inContext(NodeFlags.DecoratorContext);\r\n        }\r\n\r\n        function inAwaitContext() {\r\n            return inContext(NodeFlags.AwaitContext);\r\n        }\r\n\r\n        function parseErrorAtCurrentToken(message: DiagnosticMessage, arg0?: any): void {\r\n            const start = scanner.getTokenPos();\r\n            const length = scanner.getTextPos() - start;\r\n\r\n            parseErrorAtPosition(start, length, message, arg0);\r\n        }\r\n\r\n        function parseErrorAtPosition(start: number, length: number, message: DiagnosticMessage, arg0?: any): void {\r\n            // Don't report another error if it would just be at the same position as the last error.\r\n            const lastError = lastOrUndefined(parseDiagnostics);\r\n            if (!lastError || start !== lastError.start) {\r\n                parseDiagnostics.push(createFileDiagnostic(sourceFile, start, length, message, arg0));\r\n            }\r\n\r\n            // Mark that we've encountered an error.  We'll set an appropriate bit on the next\r\n            // node we finish so that it can't be reused incrementally.\r\n            parseErrorBeforeNextFinishedNode = true;\r\n        }\r\n\r\n        function scanError(message: DiagnosticMessage, length?: number) {\r\n            const pos = scanner.getTextPos();\r\n            parseErrorAtPosition(pos, length || 0, message);\r\n        }\r\n\r\n        function getNodePos(): number {\r\n            return scanner.getStartPos();\r\n        }\r\n\r\n        // Use this function to access the current token instead of reading the currentToken\r\n        // variable. Since function results aren't narrowed in control flow analysis, this ensures\r\n        // that the type checker doesn't make wrong assumptions about the type of the current\r\n        // token (e.g. a call to nextToken() changes the current token but the checker doesn't\r\n        // reason about this side effect).  Mainstream VMs inline simple functions like this, so\r\n        // there is no performance penalty.\r\n        function token(): SyntaxKind {\r\n            return currentToken;\r\n        }\r\n\r\n        function nextToken(): SyntaxKind {\r\n            return currentToken = scanner.scan();\r\n        }\r\n\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanGreaterToken();\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanSlashToken();\r\n        }\r\n\r\n        function reScanTemplateToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanTemplateToken();\r\n        }\r\n\r\n        function scanJsxIdentifier(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxIdentifier();\r\n        }\r\n\r\n        function scanJsxText(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxToken();\r\n        }\r\n\r\n        function scanJsxAttributeValue(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxAttributeValue();\r\n        }\r\n\r\n        function speculationHelper<T>(callback: () => T, isLookAhead: boolean): T {\r\n            // Keep track of the state we'll need to rollback to if lookahead fails (or if the\r\n            // caller asked us to always reset our state).\r\n            const saveToken = currentToken;\r\n            const saveParseDiagnosticsLength = parseDiagnostics.length;\r\n            const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\r\n\r\n            // Note: it is not actually necessary to save/restore the context flags here.  That's\r\n            // because the saving/restoring of these flags happens naturally through the recursive\r\n            // descent nature of our parser.  However, we still store this here just so we can\r\n            // assert that invariant holds.\r\n            const saveContextFlags = contextFlags;\r\n\r\n            // If we're only looking ahead, then tell the scanner to only lookahead as well.\r\n            // Otherwise, if we're actually speculatively parsing, then tell the scanner to do the\r\n            // same.\r\n            const result = isLookAhead\r\n                ? scanner.lookAhead(callback)\r\n                : scanner.tryScan(callback);\r\n\r\n            Debug.assert(saveContextFlags === contextFlags);\r\n\r\n            // If our callback returned something 'falsy' or we're just looking ahead,\r\n            // then unconditionally restore us to where we were.\r\n            if (!result || isLookAhead) {\r\n                currentToken = saveToken;\r\n                parseDiagnostics.length = saveParseDiagnosticsLength;\r\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Invokes the provided callback then unconditionally restores the parser to the state it\r\n         * was in immediately prior to invoking the callback.  The result of invoking the callback\r\n         * is returned from this function.\r\n         */\r\n        function lookAhead<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookAhead*/ true);\r\n        }\r\n\r\n        /** Invokes the provided callback.  If the callback returns something falsy, then it restores\r\n         * the parser to the state it was in immediately prior to invoking the callback.  If the\r\n         * callback returns something truthy, then the parser state is not rolled back.  The result\r\n         * of invoking the callback is returned from this function.\r\n         */\r\n        function tryParse<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookAhead*/ false);\r\n        }\r\n\r\n        // Ignore strict mode flag because we will report an error in type checker instead.\r\n        function isIdentifier(): boolean {\r\n            if (token() === SyntaxKind.Identifier) {\r\n                return true;\r\n            }\r\n\r\n            // If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is\r\n            // considered a keyword and is not an identifier.\r\n            if (token() === SyntaxKind.YieldKeyword && inYieldContext()) {\r\n                return false;\r\n            }\r\n\r\n            // If we have a 'await' keyword, and we're in the [Await] context, then 'await' is\r\n            // considered a keyword and is not an identifier.\r\n            if (token() === SyntaxKind.AwaitKeyword && inAwaitContext()) {\r\n                return false;\r\n            }\r\n\r\n            return token() > SyntaxKind.LastReservedWord;\r\n        }\r\n\r\n        function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage, shouldAdvance = true): boolean {\r\n            if (token() === kind) {\r\n                if (shouldAdvance) {\r\n                    nextToken();\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Report specific message if provided with one.  Otherwise, report generic fallback message.\r\n            if (diagnosticMessage) {\r\n                parseErrorAtCurrentToken(diagnosticMessage);\r\n            }\r\n            else {\r\n                parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseOptional(t: SyntaxKind): boolean {\r\n            if (token() === t) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseOptionalToken<TKind extends SyntaxKind>(t: TKind): Token<TKind>;\r\n        function parseOptionalToken(t: SyntaxKind): Node {\r\n            if (token() === t) {\r\n                return parseTokenNode();\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function parseExpectedToken<TKind extends SyntaxKind>(t: TKind, reportAtCurrentPosition: boolean, diagnosticMessage: DiagnosticMessage, arg0?: any): Token<TKind>;\r\n        function parseExpectedToken(t: SyntaxKind, reportAtCurrentPosition: boolean, diagnosticMessage: DiagnosticMessage, arg0?: any): Node {\r\n            return parseOptionalToken(t) ||\r\n                createMissingNode(t, reportAtCurrentPosition, diagnosticMessage, arg0);\r\n        }\r\n\r\n        function parseTokenNode<T extends Node>(): T {\r\n            const node = <T>createNode(token());\r\n            nextToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function canParseSemicolon() {\r\n            // If there's a real semicolon, then we can always parse it out.\r\n            if (token() === SyntaxKind.SemicolonToken) {\r\n                return true;\r\n            }\r\n\r\n            // We can parse out an optional semicolon in ASI cases in the following cases.\r\n            return token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.EndOfFileToken || scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function parseSemicolon(): boolean {\r\n            if (canParseSemicolon()) {\r\n                if (token() === SyntaxKind.SemicolonToken) {\r\n                    // consume the semicolon if it was explicitly provided.\r\n                    nextToken();\r\n                }\r\n\r\n                return true;\r\n            }\r\n            else {\r\n                return parseExpected(SyntaxKind.SemicolonToken);\r\n            }\r\n        }\r\n\r\n        // note: this function creates only node\r\n        function createNode<TKind extends SyntaxKind>(kind: TKind, pos?: number): Node | Token<TKind> | Identifier {\r\n            nodeCount++;\r\n            if (!(pos >= 0)) {\r\n                pos = scanner.getStartPos();\r\n            }\r\n\r\n            return isNodeKind(kind) ? new NodeConstructor(kind, pos, pos) :\r\n                kind === SyntaxKind.Identifier ? new IdentifierConstructor(kind, pos, pos) :\r\n                    new TokenConstructor(kind, pos, pos);\r\n        }\r\n\r\n        function createNodeArray<T extends Node>(elements: T[], pos: number, end?: number): NodeArray<T> {\r\n            // Since the element list of a node array is typically created by starting with an empty array and\r\n            // repeatedly calling push(), the list may not have the optimal memory layout. We invoke slice() for\r\n            // small arrays (1 to 4 elements) to give the VM a chance to allocate an optimal representation.\r\n            const length = elements.length;\r\n            const array = <MutableNodeArray<T>>(length >= 1 && length <= 4 ? elements.slice() : elements);\r\n            array.pos = pos;\r\n            array.end = end === undefined ? scanner.getStartPos() : end;\r\n            return array;\r\n        }\r\n\r\n        function finishNode<T extends Node>(node: T, end?: number): T {\r\n            node.end = end === undefined ? scanner.getStartPos() : end;\r\n\r\n            if (contextFlags) {\r\n                node.flags |= contextFlags;\r\n            }\r\n\r\n            // Keep track on the node if we encountered an error while parsing it.  If we did, then\r\n            // we cannot reuse the node incrementally.  Once we've marked this node, clear out the\r\n            // flag so that we don't mark any subsequent nodes.\r\n            if (parseErrorBeforeNextFinishedNode) {\r\n                parseErrorBeforeNextFinishedNode = false;\r\n                node.flags |= NodeFlags.ThisNodeHasError;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function createMissingNode<T extends Node>(kind: T[\"kind\"], reportAtCurrentPosition: boolean, diagnosticMessage: DiagnosticMessage, arg0?: any): T {\r\n            if (reportAtCurrentPosition) {\r\n                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);\r\n            }\r\n            else {\r\n                parseErrorAtCurrentToken(diagnosticMessage, arg0);\r\n            }\r\n\r\n            const result = createNode(kind, scanner.getStartPos());\r\n\r\n            if (kind === SyntaxKind.Identifier) {\r\n                (result as Identifier).escapedText = \"\" as __String;\r\n            }\r\n            else if (isLiteralKind(kind) || isTemplateLiteralKind(kind)) {\r\n                (result as LiteralLikeNode).text = \"\";\r\n            }\r\n\r\n            return finishNode(result) as T;\r\n        }\r\n\r\n        function internIdentifier(text: string): string {\r\n            let identifier = identifiers.get(text);\r\n            if (identifier === undefined) {\r\n                identifiers.set(text, identifier = text);\r\n            }\r\n            return identifier;\r\n        }\r\n\r\n        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues\r\n        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for\r\n        // each identifier in order to reduce memory consumption.\r\n        function createIdentifier(isIdentifier: boolean, diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            identifierCount++;\r\n            if (isIdentifier) {\r\n                const node = <Identifier>createNode(SyntaxKind.Identifier);\r\n\r\n                // Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker\r\n                if (token() !== SyntaxKind.Identifier) {\r\n                    node.originalKeywordKind = token();\r\n                }\r\n                node.escapedText = escapeLeadingUnderscores(internIdentifier(scanner.getTokenValue()));\r\n                nextToken();\r\n                return finishNode(node);\r\n            }\r\n\r\n            // Only for end of file because the error gets reported incorrectly on embedded script tags.\r\n            const reportAtCurrentPosition = token() === SyntaxKind.EndOfFileToken;\r\n\r\n            return createMissingNode<Identifier>(SyntaxKind.Identifier, reportAtCurrentPosition, diagnosticMessage || Diagnostics.Identifier_expected);\r\n        }\r\n\r\n        function parseIdentifier(diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            return createIdentifier(isIdentifier(), diagnosticMessage);\r\n        }\r\n\r\n        function parseIdentifierName(diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            return createIdentifier(tokenIsIdentifierOrKeyword(token()), diagnosticMessage);\r\n        }\r\n\r\n        function isLiteralPropertyName(): boolean {\r\n            return tokenIsIdentifierOrKeyword(token()) ||\r\n                token() === SyntaxKind.StringLiteral ||\r\n                token() === SyntaxKind.NumericLiteral;\r\n        }\r\n\r\n        function parsePropertyNameWorker(allowComputedPropertyNames: boolean): PropertyName {\r\n            if (token() === SyntaxKind.StringLiteral || token() === SyntaxKind.NumericLiteral) {\r\n                const node = <StringLiteral | NumericLiteral>parseLiteralNode();\r\n                node.text = internIdentifier(node.text);\r\n                return node;\r\n            }\r\n            if (allowComputedPropertyNames && token() === SyntaxKind.OpenBracketToken) {\r\n                return parseComputedPropertyName();\r\n            }\r\n            return parseIdentifierName();\r\n        }\r\n\r\n        function parsePropertyName(): PropertyName {\r\n            return parsePropertyNameWorker(/*allowComputedPropertyNames*/ true);\r\n        }\r\n\r\n        function parseComputedPropertyName(): ComputedPropertyName {\r\n            // PropertyName [Yield]:\r\n            //      LiteralPropertyName\r\n            //      ComputedPropertyName[?Yield]\r\n            const node = <ComputedPropertyName>createNode(SyntaxKind.ComputedPropertyName);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n\r\n            // We parse any expression (including a comma expression). But the grammar\r\n            // says that only an assignment expression is allowed, so the grammar checker\r\n            // will error if it sees a comma expression.\r\n            node.expression = allowInAnd(parseExpression);\r\n\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseContextualModifier(t: SyntaxKind): boolean {\r\n            return token() === t && tryParse(nextTokenCanFollowModifier);\r\n        }\r\n\r\n        function nextTokenIsOnSameLineAndCanFollowModifier() {\r\n            nextToken();\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                return false;\r\n            }\r\n            return canFollowModifier();\r\n        }\r\n\r\n        function nextTokenCanFollowModifier() {\r\n            if (token() === SyntaxKind.ConstKeyword) {\r\n                // 'const' is only a modifier if followed by 'enum'.\r\n                return nextToken() === SyntaxKind.EnumKeyword;\r\n            }\r\n            if (token() === SyntaxKind.ExportKeyword) {\r\n                nextToken();\r\n                if (token() === SyntaxKind.DefaultKeyword) {\r\n                    return lookAhead(nextTokenCanFollowDefaultKeyword);\r\n                }\r\n                return token() !== SyntaxKind.AsteriskToken && token() !== SyntaxKind.AsKeyword && token() !== SyntaxKind.OpenBraceToken && canFollowModifier();\r\n            }\r\n            if (token() === SyntaxKind.DefaultKeyword) {\r\n                return nextTokenCanFollowDefaultKeyword();\r\n            }\r\n            if (token() === SyntaxKind.StaticKeyword) {\r\n                nextToken();\r\n                return canFollowModifier();\r\n            }\r\n\r\n            return nextTokenIsOnSameLineAndCanFollowModifier();\r\n        }\r\n\r\n        function parseAnyContextualModifier(): boolean {\r\n            return isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);\r\n        }\r\n\r\n        function canFollowModifier(): boolean {\r\n            return token() === SyntaxKind.OpenBracketToken\r\n                || token() === SyntaxKind.OpenBraceToken\r\n                || token() === SyntaxKind.AsteriskToken\r\n                || token() === SyntaxKind.DotDotDotToken\r\n                || isLiteralPropertyName();\r\n        }\r\n\r\n        function nextTokenCanFollowDefaultKeyword(): boolean {\r\n            nextToken();\r\n            return token() === SyntaxKind.ClassKeyword || token() === SyntaxKind.FunctionKeyword ||\r\n                token() === SyntaxKind.InterfaceKeyword ||\r\n                (token() === SyntaxKind.AbstractKeyword && lookAhead(nextTokenIsClassKeywordOnSameLine)) ||\r\n                (token() === SyntaxKind.AsyncKeyword && lookAhead(nextTokenIsFunctionKeywordOnSameLine));\r\n        }\r\n\r\n        // True if positioned at the start of a list element\r\n        function isListElement(parsingContext: ParsingContext, inErrorRecovery: boolean): boolean {\r\n            const node = currentNode(parsingContext);\r\n            if (node) {\r\n                return true;\r\n            }\r\n\r\n            switch (parsingContext) {\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.\r\n                    // The problem is that ';' can show up in far too many contexts, and if we see one\r\n                    // and assume it's a statement, then we may bail out inappropriately from whatever\r\n                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then\r\n                    // we really don't want to assume the class is over and we're on a statement in the\r\n                    // outer module.  We just want to consume and move on.\r\n                    return !(token() === SyntaxKind.SemicolonToken && inErrorRecovery) && isStartOfStatement();\r\n                case ParsingContext.SwitchClauses:\r\n                    return token() === SyntaxKind.CaseKeyword || token() === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.TypeMembers:\r\n                    return lookAhead(isTypeMemberStart);\r\n                case ParsingContext.ClassMembers:\r\n                    // We allow semicolons as class elements (as specified by ES6) as long as we're\r\n                    // not in error recovery.  If we're in error recovery, we don't want an errant\r\n                    // semicolon to be treated as a class member (since they're almost always used\r\n                    // for statements.\r\n                    return lookAhead(isClassMemberStart) || (token() === SyntaxKind.SemicolonToken && !inErrorRecovery);\r\n                case ParsingContext.EnumMembers:\r\n                    // Include open bracket computed properties. This technically also lets in indexers,\r\n                    // which would be a candidate for improved error reporting.\r\n                    return token() === SyntaxKind.OpenBracketToken || isLiteralPropertyName();\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                    return token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.AsteriskToken || token() === SyntaxKind.DotDotDotToken || isLiteralPropertyName();\r\n                case ParsingContext.RestProperties:\r\n                    return isLiteralPropertyName();\r\n                case ParsingContext.ObjectBindingElements:\r\n                    return token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.DotDotDotToken || isLiteralPropertyName();\r\n                case ParsingContext.HeritageClauseElement:\r\n                    // If we see `{ ... }` then only consume it as an expression if it is followed by `,` or `{`\r\n                    // That way we won't consume the body of a class in its heritage clause.\r\n                    if (token() === SyntaxKind.OpenBraceToken) {\r\n                        return lookAhead(isValidHeritageClauseObjectLiteral);\r\n                    }\r\n\r\n                    if (!inErrorRecovery) {\r\n                        return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();\r\n                    }\r\n                    else {\r\n                        // If we're in error recovery we tighten up what we're willing to match.\r\n                        // That way we don't treat something like \"this\" as a valid heritage clause\r\n                        // element during recovery.\r\n                        return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword();\r\n                    }\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isIdentifierOrPattern();\r\n                case ParsingContext.ArrayBindingElements:\r\n                    return token() === SyntaxKind.CommaToken || token() === SyntaxKind.DotDotDotToken || isIdentifierOrPattern();\r\n                case ParsingContext.TypeParameters:\r\n                    return isIdentifier();\r\n                case ParsingContext.ArgumentExpressions:\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                    return token() === SyntaxKind.CommaToken || token() === SyntaxKind.DotDotDotToken || isStartOfExpression();\r\n                case ParsingContext.Parameters:\r\n                    return isStartOfParameter();\r\n                case ParsingContext.TypeArguments:\r\n                case ParsingContext.TupleElementTypes:\r\n                    return token() === SyntaxKind.CommaToken || isStartOfType();\r\n                case ParsingContext.HeritageClauses:\r\n                    return isHeritageClause();\r\n                case ParsingContext.ImportOrExportSpecifiers:\r\n                    return tokenIsIdentifierOrKeyword(token());\r\n                case ParsingContext.JsxAttributes:\r\n                    return tokenIsIdentifierOrKeyword(token()) || token() === SyntaxKind.OpenBraceToken;\r\n                case ParsingContext.JsxChildren:\r\n                    return true;\r\n            }\r\n\r\n            Debug.fail(\"Non-exhaustive case in 'isListElement'.\");\r\n        }\r\n\r\n        function isValidHeritageClauseObjectLiteral() {\r\n            Debug.assert(token() === SyntaxKind.OpenBraceToken);\r\n            if (nextToken() === SyntaxKind.CloseBraceToken) {\r\n                // if we see  \"extends {}\" then only treat the {} as what we're extending (and not\r\n                // the class body) if we have:\r\n                //\r\n                //      extends {} {\r\n                //      extends {},\r\n                //      extends {} extends\r\n                //      extends {} implements\r\n\r\n                const next = nextToken();\r\n                return next === SyntaxKind.CommaToken || next === SyntaxKind.OpenBraceToken || next === SyntaxKind.ExtendsKeyword || next === SyntaxKind.ImplementsKeyword;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function nextTokenIsIdentifier() {\r\n            nextToken();\r\n            return isIdentifier();\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeyword() {\r\n            nextToken();\r\n            return tokenIsIdentifierOrKeyword(token());\r\n        }\r\n\r\n        function isHeritageClauseExtendsOrImplementsKeyword(): boolean {\r\n            if (token() === SyntaxKind.ImplementsKeyword ||\r\n                token() === SyntaxKind.ExtendsKeyword) {\r\n\r\n                return lookAhead(nextTokenIsStartOfExpression);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function nextTokenIsStartOfExpression() {\r\n            nextToken();\r\n            return isStartOfExpression();\r\n        }\r\n\r\n        // True if positioned at a list terminator\r\n        function isListTerminator(kind: ParsingContext): boolean {\r\n            if (token() === SyntaxKind.EndOfFileToken) {\r\n                // Being at the end of the file ends all lists.\r\n                return true;\r\n            }\r\n\r\n            switch (kind) {\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauses:\r\n                case ParsingContext.TypeMembers:\r\n                case ParsingContext.ClassMembers:\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                case ParsingContext.ObjectBindingElements:\r\n                case ParsingContext.ImportOrExportSpecifiers:\r\n                    return token() === SyntaxKind.CloseBraceToken;\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.CaseKeyword || token() === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.HeritageClauseElement:\r\n                    return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isVariableDeclaratorListTerminator();\r\n                case ParsingContext.TypeParameters:\r\n                    // Tokens other than '>' are here for better error recovery\r\n                    return token() === SyntaxKind.GreaterThanToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.ArgumentExpressions:\r\n                    // Tokens other than ')' are here for better error recovery\r\n                    return token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.SemicolonToken;\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                case ParsingContext.TupleElementTypes:\r\n                case ParsingContext.ArrayBindingElements:\r\n                    return token() === SyntaxKind.CloseBracketToken;\r\n                case ParsingContext.Parameters:\r\n                case ParsingContext.RestProperties:\r\n                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery\r\n                    return token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.CloseBracketToken /*|| token === SyntaxKind.OpenBraceToken*/;\r\n                case ParsingContext.TypeArguments:\r\n                    // All other tokens should cause the type-argument to terminate except comma token\r\n                    return token() !== SyntaxKind.CommaToken;\r\n                case ParsingContext.HeritageClauses:\r\n                    return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.CloseBraceToken;\r\n                case ParsingContext.JsxAttributes:\r\n                    return token() === SyntaxKind.GreaterThanToken || token() === SyntaxKind.SlashToken;\r\n                case ParsingContext.JsxChildren:\r\n                    return token() === SyntaxKind.LessThanToken && lookAhead(nextTokenIsSlash);\r\n            }\r\n        }\r\n\r\n        function isVariableDeclaratorListTerminator(): boolean {\r\n            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done\r\n            // with parsing the list of  variable declarators.\r\n            if (canParseSemicolon()) {\r\n                return true;\r\n            }\r\n\r\n            // in the case where we're parsing the variable declarator of a 'for-in' statement, we\r\n            // are done if we see an 'in' keyword in front of us. Same with for-of\r\n            if (isInOrOfKeyword(token())) {\r\n                return true;\r\n            }\r\n\r\n            // ERROR RECOVERY TWEAK:\r\n            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an\r\n            // arrow function here and it's going to be very unlikely that we'll resynchronize and get\r\n            // another variable declaration.\r\n            if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                return true;\r\n            }\r\n\r\n            // Keep trying to parse out variable declarators.\r\n            return false;\r\n        }\r\n\r\n        // True if positioned at element or terminator of the current list or any enclosing list\r\n        function isInSomeParsingContext(): boolean {\r\n            for (let kind = 0; kind < ParsingContext.Count; kind++) {\r\n                if (parsingContext & (1 << kind)) {\r\n                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Parses a list of elements\r\n        function parseList<T extends Node>(kind: ParsingContext, parseElement: () => T): NodeArray<T> {\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            while (!isListTerminator(kind)) {\r\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\r\n                    const element = parseListElement(kind, parseElement);\r\n                    list.push(element);\r\n\r\n                    continue;\r\n                }\r\n\r\n                if (abortParsingListOrMoveToNextToken(kind)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n            return createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseListElement<T extends Node>(parsingContext: ParsingContext, parseElement: () => T): T {\r\n            const node = currentNode(parsingContext);\r\n            if (node) {\r\n                return <T>consumeNode(node);\r\n            }\r\n\r\n            return parseElement();\r\n        }\r\n\r\n        function currentNode(parsingContext: ParsingContext): Node {\r\n            // If there is an outstanding parse error that we've encountered, but not attached to\r\n            // some node, then we cannot get a node from the old source tree.  This is because we\r\n            // want to mark the next node we encounter as being unusable.\r\n            //\r\n            // Note: This may be too conservative.  Perhaps we could reuse the node and set the bit\r\n            // on it (or its leftmost child) as having the error.  For now though, being conservative\r\n            // is nice and likely won't ever affect perf.\r\n            if (parseErrorBeforeNextFinishedNode) {\r\n                return undefined;\r\n            }\r\n\r\n            if (!syntaxCursor) {\r\n                // if we don't have a cursor, we could never return a node from the old tree.\r\n                return undefined;\r\n            }\r\n\r\n            const node = syntaxCursor.currentNode(scanner.getStartPos());\r\n\r\n            // Can't reuse a missing node.\r\n            if (nodeIsMissing(node)) {\r\n                return undefined;\r\n            }\r\n\r\n            // Can't reuse a node that intersected the change range.\r\n            if (node.intersectsChange) {\r\n                return undefined;\r\n            }\r\n\r\n            // Can't reuse a node that contains a parse error.  This is necessary so that we\r\n            // produce the same set of errors again.\r\n            if (containsParseError(node)) {\r\n                return undefined;\r\n            }\r\n\r\n            // We can only reuse a node if it was parsed under the same strict mode that we're\r\n            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then\r\n            // the user added 'using strict' at the top of the file, then we can't use that node\r\n            // again as the presence of strict mode may cause us to parse the tokens in the file\r\n            // differently.\r\n            //\r\n            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens\r\n            // are unaffected by strict mode.  It's just the parser will decide what to do with it\r\n            // differently depending on what mode it is in.\r\n            //\r\n            // This also applies to all our other context flags as well.\r\n            const nodeContextFlags = node.flags & NodeFlags.ContextFlags;\r\n            if (nodeContextFlags !== contextFlags) {\r\n                return undefined;\r\n            }\r\n\r\n            // Ok, we have a node that looks like it could be reused.  Now verify that it is valid\r\n            // in the current list parsing context that we're currently at.\r\n            if (!canReuseNode(node, parsingContext)) {\r\n                return undefined;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function consumeNode(node: Node) {\r\n            // Move the scanner so it is after the node we just consumed.\r\n            scanner.setTextPos(node.end);\r\n            nextToken();\r\n            return node;\r\n        }\r\n\r\n        function canReuseNode(node: Node, parsingContext: ParsingContext): boolean {\r\n            switch (parsingContext) {\r\n                case ParsingContext.ClassMembers:\r\n                    return isReusableClassMember(node);\r\n\r\n                case ParsingContext.SwitchClauses:\r\n                    return isReusableSwitchClause(node);\r\n\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return isReusableStatement(node);\r\n\r\n                case ParsingContext.EnumMembers:\r\n                    return isReusableEnumMember(node);\r\n\r\n                case ParsingContext.TypeMembers:\r\n                    return isReusableTypeMember(node);\r\n\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isReusableVariableDeclaration(node);\r\n\r\n                case ParsingContext.Parameters:\r\n                    return isReusableParameter(node);\r\n\r\n                case ParsingContext.RestProperties:\r\n                    return false;\r\n\r\n                // Any other lists we do not care about reusing nodes in.  But feel free to add if\r\n                // you can do so safely.  Danger areas involve nodes that may involve speculative\r\n                // parsing.  If speculative parsing is involved with the node, then the range the\r\n                // parser reached while looking ahead might be in the edited range (see the example\r\n                // in canReuseVariableDeclaratorNode for a good case of this).\r\n                case ParsingContext.HeritageClauses:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // heritage clauses.\r\n\r\n                case ParsingContext.TypeParameters:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // type parameters.  Note that that's because type *parameters* only occur in\r\n                // unambiguous *type* contexts.  While type *arguments* occur in very ambiguous\r\n                // *expression* contexts.\r\n\r\n                case ParsingContext.TupleElementTypes:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // tuple types.\r\n\r\n                // Technically, type argument list types are probably safe to reuse.  While\r\n                // speculative parsing is involved with them (since type argument lists are only\r\n                // produced from speculative parsing a < as a type argument list), we only have\r\n                // the types because speculative parsing succeeded.  Thus, the lookahead never\r\n                // went past the end of the list and rewound.\r\n                case ParsingContext.TypeArguments:\r\n\r\n                // Note: these are almost certainly not safe to ever reuse.  Expressions commonly\r\n                // need a large amount of lookahead, and we should not reuse them as they may\r\n                // have actually intersected the edit.\r\n                case ParsingContext.ArgumentExpressions:\r\n\r\n                // This is not safe to reuse for the same reason as the 'AssignmentExpression'\r\n                // cases.  i.e. a property assignment may end with an expression, and thus might\r\n                // have lookahead far beyond it's old node.\r\n                case ParsingContext.ObjectLiteralMembers:\r\n\r\n                // This is probably not safe to reuse.  There can be speculative parsing with\r\n                // type names in a heritage clause.  There can be generic names in the type\r\n                // name list, and there can be left hand side expressions (which can have type\r\n                // arguments.)\r\n                case ParsingContext.HeritageClauseElement:\r\n\r\n                // Perhaps safe to reuse, but it's unlikely we'd see more than a dozen attributes\r\n                // on any given element. Same for children.\r\n                case ParsingContext.JsxAttributes:\r\n                case ParsingContext.JsxChildren:\r\n\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableClassMember(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.PropertyDeclaration:\r\n                    case SyntaxKind.SemicolonClassElement:\r\n                        return true;\r\n                    case SyntaxKind.MethodDeclaration:\r\n                        // Method declarations are not necessarily reusable.  An object-literal\r\n                        // may have a method calls \"constructor(...)\" and we must reparse that\r\n                        // into an actual .ConstructorDeclaration.\r\n                        const methodDeclaration = <MethodDeclaration>node;\r\n                        const nameIsConstructor = methodDeclaration.name.kind === SyntaxKind.Identifier &&\r\n                            (<Identifier>methodDeclaration.name).originalKeywordKind === SyntaxKind.ConstructorKeyword;\r\n\r\n                        return !nameIsConstructor;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableSwitchClause(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.CaseClause:\r\n                    case SyntaxKind.DefaultClause:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableStatement(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.VariableStatement:\r\n                    case SyntaxKind.Block:\r\n                    case SyntaxKind.IfStatement:\r\n                    case SyntaxKind.ExpressionStatement:\r\n                    case SyntaxKind.ThrowStatement:\r\n                    case SyntaxKind.ReturnStatement:\r\n                    case SyntaxKind.SwitchStatement:\r\n                    case SyntaxKind.BreakStatement:\r\n                    case SyntaxKind.ContinueStatement:\r\n                    case SyntaxKind.ForInStatement:\r\n                    case SyntaxKind.ForOfStatement:\r\n                    case SyntaxKind.ForStatement:\r\n                    case SyntaxKind.WhileStatement:\r\n                    case SyntaxKind.WithStatement:\r\n                    case SyntaxKind.EmptyStatement:\r\n                    case SyntaxKind.TryStatement:\r\n                    case SyntaxKind.LabeledStatement:\r\n                    case SyntaxKind.DoStatement:\r\n                    case SyntaxKind.DebuggerStatement:\r\n                    case SyntaxKind.ImportDeclaration:\r\n                    case SyntaxKind.ImportEqualsDeclaration:\r\n                    case SyntaxKind.ExportDeclaration:\r\n                    case SyntaxKind.ExportAssignment:\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                    case SyntaxKind.TypeAliasDeclaration:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableEnumMember(node: Node) {\r\n            return node.kind === SyntaxKind.EnumMember;\r\n        }\r\n\r\n        function isReusableTypeMember(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.MethodSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.PropertySignature:\r\n                    case SyntaxKind.CallSignature:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableVariableDeclaration(node: Node) {\r\n            if (node.kind !== SyntaxKind.VariableDeclaration) {\r\n                return false;\r\n            }\r\n\r\n            // Very subtle incremental parsing bug.  Consider the following code:\r\n            //\r\n            //      let v = new List < A, B\r\n            //\r\n            // This is actually legal code.  It's a list of variable declarators \"v = new List<A\"\r\n            // on one side and \"B\" on the other. If you then change that to:\r\n            //\r\n            //      let v = new List < A, B >()\r\n            //\r\n            // then we have a problem.  \"v = new List<A\" doesn't intersect the change range, so we\r\n            // start reparsing at \"B\" and we completely fail to handle this properly.\r\n            //\r\n            // In order to prevent this, we do not allow a variable declarator to be reused if it\r\n            // has an initializer.\r\n            const variableDeclarator = <VariableDeclaration>node;\r\n            return variableDeclarator.initializer === undefined;\r\n        }\r\n\r\n        function isReusableParameter(node: Node) {\r\n            if (node.kind !== SyntaxKind.Parameter) {\r\n                return false;\r\n            }\r\n\r\n            // See the comment in isReusableVariableDeclaration for why we do this.\r\n            const parameter = <ParameterDeclaration>node;\r\n            return parameter.initializer === undefined;\r\n        }\r\n\r\n        // Returns true if we should abort parsing.\r\n        function abortParsingListOrMoveToNextToken(kind: ParsingContext) {\r\n            parseErrorAtCurrentToken(parsingContextErrors(kind));\r\n            if (isInSomeParsingContext()) {\r\n                return true;\r\n            }\r\n\r\n            nextToken();\r\n            return false;\r\n        }\r\n\r\n        function parsingContextErrors(context: ParsingContext): DiagnosticMessage {\r\n            switch (context) {\r\n                case ParsingContext.SourceElements: return Diagnostics.Declaration_or_statement_expected;\r\n                case ParsingContext.BlockStatements: return Diagnostics.Declaration_or_statement_expected;\r\n                case ParsingContext.SwitchClauses: return Diagnostics.case_or_default_expected;\r\n                case ParsingContext.SwitchClauseStatements: return Diagnostics.Statement_expected;\r\n                case ParsingContext.RestProperties: // fallthrough\r\n                case ParsingContext.TypeMembers: return Diagnostics.Property_or_signature_expected;\r\n                case ParsingContext.ClassMembers: return Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;\r\n                case ParsingContext.EnumMembers: return Diagnostics.Enum_member_expected;\r\n                case ParsingContext.HeritageClauseElement: return Diagnostics.Expression_expected;\r\n                case ParsingContext.VariableDeclarations: return Diagnostics.Variable_declaration_expected;\r\n                case ParsingContext.ObjectBindingElements: return Diagnostics.Property_destructuring_pattern_expected;\r\n                case ParsingContext.ArrayBindingElements: return Diagnostics.Array_element_destructuring_pattern_expected;\r\n                case ParsingContext.ArgumentExpressions: return Diagnostics.Argument_expression_expected;\r\n                case ParsingContext.ObjectLiteralMembers: return Diagnostics.Property_assignment_expected;\r\n                case ParsingContext.ArrayLiteralMembers: return Diagnostics.Expression_or_comma_expected;\r\n                case ParsingContext.Parameters: return Diagnostics.Parameter_declaration_expected;\r\n                case ParsingContext.TypeParameters: return Diagnostics.Type_parameter_declaration_expected;\r\n                case ParsingContext.TypeArguments: return Diagnostics.Type_argument_expected;\r\n                case ParsingContext.TupleElementTypes: return Diagnostics.Type_expected;\r\n                case ParsingContext.HeritageClauses: return Diagnostics.Unexpected_token_expected;\r\n                case ParsingContext.ImportOrExportSpecifiers: return Diagnostics.Identifier_expected;\r\n                case ParsingContext.JsxAttributes: return Diagnostics.Identifier_expected;\r\n                case ParsingContext.JsxChildren: return Diagnostics.Identifier_expected;\r\n            }\r\n        }\r\n\r\n        // Parses a comma-delimited list of elements\r\n        function parseDelimitedList<T extends Node>(kind: ParsingContext, parseElement: () => T, considerSemicolonAsDelimiter?: boolean): NodeArray<T> {\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            let commaStart = -1; // Meaning the previous token was not a comma\r\n            while (true) {\r\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\r\n                    const startPos = scanner.getStartPos();\r\n                    list.push(parseListElement(kind, parseElement));\r\n                    commaStart = scanner.getTokenPos();\r\n\r\n                    if (parseOptional(SyntaxKind.CommaToken)) {\r\n                        // No need to check for a zero length node since we know we parsed a comma\r\n                        continue;\r\n                    }\r\n\r\n                    commaStart = -1; // Back to the state where the last token was not a comma\r\n                    if (isListTerminator(kind)) {\r\n                        break;\r\n                    }\r\n\r\n                    // We didn't get a comma, and the list wasn't terminated, explicitly parse\r\n                    // out a comma so we give a good error message.\r\n                    parseExpected(SyntaxKind.CommaToken);\r\n\r\n                    // If the token was a semicolon, and the caller allows that, then skip it and\r\n                    // continue.  This ensures we get back on track and don't result in tons of\r\n                    // parse errors.  For example, this can happen when people do things like use\r\n                    // a semicolon to delimit object literal members.   Note: we'll have already\r\n                    // reported an error when we called parseExpected above.\r\n                    if (considerSemicolonAsDelimiter && token() === SyntaxKind.SemicolonToken && !scanner.hasPrecedingLineBreak()) {\r\n                        nextToken();\r\n                    }\r\n                    if (startPos === scanner.getStartPos()) {\r\n                        // What we're parsing isn't actually remotely recognizable as a element and we've consumed no tokens whatsoever\r\n                        // Consume a token to advance the parser in some way and avoid an infinite loop\r\n                        // This can happen when we're speculatively parsing parenthesized expressions which we think may be arrow functions,\r\n                        // or when a modifier keyword which is disallowed as a parameter name (ie, `static` in strict mode) is supplied\r\n                        nextToken();\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (isListTerminator(kind)) {\r\n                    break;\r\n                }\r\n\r\n                if (abortParsingListOrMoveToNextToken(kind)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n            const result = createNodeArray(list, listPos);\r\n            // Recording the trailing comma is deliberately done after the previous\r\n            // loop, and not just if we see a list terminator. This is because the list\r\n            // may have ended incorrectly, but it is still important to know if there\r\n            // was a trailing comma.\r\n            // Check if the last token was a comma.\r\n            if (commaStart >= 0) {\r\n                // Always preserve a trailing comma by marking it on the NodeArray\r\n                result.hasTrailingComma = true;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function createMissingList<T extends Node>(): NodeArray<T> {\r\n            return createNodeArray<T>([], getNodePos());\r\n        }\r\n\r\n        function parseBracketedList<T extends Node>(kind: ParsingContext, parseElement: () => T, open: SyntaxKind, close: SyntaxKind): NodeArray<T> {\r\n            if (parseExpected(open)) {\r\n                const result = parseDelimitedList(kind, parseElement);\r\n                parseExpected(close);\r\n                return result;\r\n            }\r\n\r\n            return createMissingList<T>();\r\n        }\r\n\r\n        function parseEntityName(allowReservedWords: boolean, diagnosticMessage?: DiagnosticMessage): EntityName {\r\n            let entity: EntityName = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);\r\n            let dotPos = scanner.getStartPos();\r\n            while (parseOptional(SyntaxKind.DotToken)) {\r\n                if (token() === SyntaxKind.LessThanToken) {\r\n                    // the entity is part of a JSDoc-style generic, so record the trailing dot for later error reporting\r\n                    entity.jsdocDotPos = dotPos;\r\n                    break;\r\n                }\r\n                dotPos = scanner.getStartPos();\r\n                entity = createQualifiedName(entity, parseRightSideOfDot(allowReservedWords));\r\n            }\r\n            return entity;\r\n        }\r\n\r\n        function createQualifiedName(entity: EntityName, name: Identifier): QualifiedName {\r\n            const node = createNode(SyntaxKind.QualifiedName, entity.pos) as QualifiedName;\r\n            node.left = entity;\r\n            node.right = name;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseRightSideOfDot(allowIdentifierNames: boolean): Identifier {\r\n            // Technically a keyword is valid here as all identifiers and keywords are identifier names.\r\n            // However, often we'll encounter this in error situations when the identifier or keyword\r\n            // is actually starting another valid construct.\r\n            //\r\n            // So, we check for the following specific case:\r\n            //\r\n            //      name.\r\n            //      identifierOrKeyword identifierNameOrKeyword\r\n            //\r\n            // Note: the newlines are important here.  For example, if that above code\r\n            // were rewritten into:\r\n            //\r\n            //      name.identifierOrKeyword\r\n            //      identifierNameOrKeyword\r\n            //\r\n            // Then we would consider it valid.  That's because ASI would take effect and\r\n            // the code would be implicitly: \"name.identifierOrKeyword; identifierNameOrKeyword\".\r\n            // In the first case though, ASI will not take effect because there is not a\r\n            // line terminator after the identifier or keyword.\r\n            if (scanner.hasPrecedingLineBreak() && tokenIsIdentifierOrKeyword(token())) {\r\n                const matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\r\n\r\n                if (matchesPattern) {\r\n                    // Report that we need an identifier.  However, report it right after the dot,\r\n                    // and not on the next token.  This is because the next token might actually\r\n                    // be an identifier and the error would be quite confusing.\r\n                    return createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Identifier_expected);\r\n                }\r\n            }\r\n\r\n            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();\r\n        }\r\n\r\n        function parseTemplateExpression(): TemplateExpression {\r\n            const template = <TemplateExpression>createNode(SyntaxKind.TemplateExpression);\r\n\r\n            template.head = parseTemplateHead();\r\n            Debug.assert(template.head.kind === SyntaxKind.TemplateHead, \"Template head has wrong token kind\");\r\n\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            do {\r\n                list.push(parseTemplateSpan());\r\n            }\r\n            while (lastOrUndefined(list).literal.kind === SyntaxKind.TemplateMiddle);\r\n\r\n            template.templateSpans = createNodeArray(list, listPos);\r\n\r\n            return finishNode(template);\r\n        }\r\n\r\n        function parseTemplateSpan(): TemplateSpan {\r\n            const span = <TemplateSpan>createNode(SyntaxKind.TemplateSpan);\r\n            span.expression = allowInAnd(parseExpression);\r\n\r\n            let literal: TemplateMiddle | TemplateTail;\r\n            if (token() === SyntaxKind.CloseBraceToken) {\r\n                reScanTemplateToken();\r\n                literal = parseTemplateMiddleOrTemplateTail();\r\n            }\r\n            else {\r\n                literal = <TemplateTail>parseExpectedToken(SyntaxKind.TemplateTail, /*reportAtCurrentPosition*/ false, Diagnostics._0_expected, tokenToString(SyntaxKind.CloseBraceToken));\r\n            }\r\n\r\n            span.literal = literal;\r\n            return finishNode(span);\r\n        }\r\n\r\n        function parseLiteralNode(): LiteralExpression {\r\n            return <LiteralExpression>parseLiteralLikeNode(token());\r\n        }\r\n\r\n        function parseTemplateHead(): TemplateHead {\r\n            const fragment = parseLiteralLikeNode(token());\r\n            Debug.assert(fragment.kind === SyntaxKind.TemplateHead, \"Template head has wrong token kind\");\r\n            return <TemplateHead>fragment;\r\n        }\r\n\r\n        function parseTemplateMiddleOrTemplateTail(): TemplateMiddle | TemplateTail {\r\n            const fragment = parseLiteralLikeNode(token());\r\n            Debug.assert(fragment.kind === SyntaxKind.TemplateMiddle || fragment.kind === SyntaxKind.TemplateTail, \"Template fragment has wrong token kind\");\r\n            return <TemplateMiddle | TemplateTail>fragment;\r\n        }\r\n\r\n        function parseLiteralLikeNode(kind: SyntaxKind): LiteralExpression | LiteralLikeNode {\r\n            const node = <LiteralExpression>createNode(kind);\r\n            const text = scanner.getTokenValue();\r\n            node.text = text;\r\n\r\n            if (scanner.hasExtendedUnicodeEscape()) {\r\n                node.hasExtendedUnicodeEscape = true;\r\n            }\r\n\r\n            if (scanner.isUnterminated()) {\r\n                node.isUnterminated = true;\r\n            }\r\n\r\n            // Octal literals are not allowed in strict mode or ES5\r\n            // Note that theoretically the following condition would hold true literals like 009,\r\n            // which is not octal.But because of how the scanner separates the tokens, we would\r\n            // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.\r\n            // We also do not need to check for negatives because any prefix operator would be part of a\r\n            // parent unary expression.\r\n            if (node.kind === SyntaxKind.NumericLiteral) {\r\n                (<NumericLiteral>node).numericLiteralFlags = scanner.getNumericLiteralFlags();\r\n            }\r\n\r\n            nextToken();\r\n            finishNode(node);\r\n\r\n            return node;\r\n        }\r\n\r\n        // TYPES\r\n\r\n        function parseTypeReference(): TypeReferenceNode {\r\n            const node = <TypeReferenceNode>createNode(SyntaxKind.TypeReference);\r\n            node.typeName = parseEntityName(/*allowReservedWords*/ true, Diagnostics.Type_expected);\r\n            if (!scanner.hasPrecedingLineBreak() && token() === SyntaxKind.LessThanToken) {\r\n                node.typeArguments = parseBracketedList(ParsingContext.TypeArguments, parseType, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThisTypePredicate(lhs: ThisTypeNode): TypePredicateNode {\r\n            nextToken();\r\n            const node = createNode(SyntaxKind.TypePredicate, lhs.pos) as TypePredicateNode;\r\n            node.parameterName = lhs;\r\n            node.type = parseType();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThisTypeNode(): ThisTypeNode {\r\n            const node = createNode(SyntaxKind.ThisType) as ThisTypeNode;\r\n            nextToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJSDocAllType(): JSDocAllType {\r\n            const result = <JSDocAllType>createNode(SyntaxKind.JSDocAllType);\r\n            nextToken();\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseJSDocUnknownOrNullableType(): JSDocUnknownType | JSDocNullableType {\r\n            const pos = scanner.getStartPos();\r\n            // skip the ?\r\n            nextToken();\r\n\r\n            // Need to lookahead to decide if this is a nullable or unknown type.\r\n\r\n            // Here are cases where we'll pick the unknown type:\r\n            //\r\n            //      Foo(?,\r\n            //      { a: ? }\r\n            //      Foo(?)\r\n            //      Foo<?>\r\n            //      Foo(?=\r\n            //      (?|\r\n            if (token() === SyntaxKind.CommaToken ||\r\n                token() === SyntaxKind.CloseBraceToken ||\r\n                token() === SyntaxKind.CloseParenToken ||\r\n                token() === SyntaxKind.GreaterThanToken ||\r\n                token() === SyntaxKind.EqualsToken ||\r\n                token() === SyntaxKind.BarToken) {\r\n\r\n                const result = <JSDocUnknownType>createNode(SyntaxKind.JSDocUnknownType, pos);\r\n                return finishNode(result);\r\n            }\r\n            else {\r\n                const result = <JSDocNullableType>createNode(SyntaxKind.JSDocNullableType, pos);\r\n                result.type = parseType();\r\n                return finishNode(result);\r\n            }\r\n        }\r\n\r\n        function parseJSDocFunctionType(): JSDocFunctionType | TypeReferenceNode {\r\n            if (lookAhead(nextTokenIsOpenParen)) {\r\n                const result = <JSDocFunctionType>createNode(SyntaxKind.JSDocFunctionType);\r\n                nextToken();\r\n                fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type | SignatureFlags.JSDoc, result);\r\n                return addJSDocComment(finishNode(result));\r\n            }\r\n            const node = <TypeReferenceNode>createNode(SyntaxKind.TypeReference);\r\n            node.typeName = parseIdentifierName();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJSDocParameter(): ParameterDeclaration {\r\n            const parameter = createNode(SyntaxKind.Parameter) as ParameterDeclaration;\r\n            if (token() === SyntaxKind.ThisKeyword || token() === SyntaxKind.NewKeyword) {\r\n                parameter.name = parseIdentifierName();\r\n                parseExpected(SyntaxKind.ColonToken);\r\n            }\r\n            parameter.type = parseType();\r\n            return finishNode(parameter);\r\n        }\r\n\r\n        function parseJSDocNodeWithType(kind: SyntaxKind.JSDocVariadicType | SyntaxKind.JSDocNonNullableType): TypeNode {\r\n            const result = createNode(kind) as JSDocVariadicType | JSDocNonNullableType;\r\n            nextToken();\r\n            result.type = parseNonArrayType();\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseTypeQuery(): TypeQueryNode {\r\n            const node = <TypeQueryNode>createNode(SyntaxKind.TypeQuery);\r\n            parseExpected(SyntaxKind.TypeOfKeyword);\r\n            node.exprName = parseEntityName(/*allowReservedWords*/ true);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameter(): TypeParameterDeclaration {\r\n            const node = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            node.name = parseIdentifier();\r\n            if (parseOptional(SyntaxKind.ExtendsKeyword)) {\r\n                // It's not uncommon for people to write improper constraints to a generic.  If the\r\n                // user writes a constraint that is an expression and not an actual type, then parse\r\n                // it out as an expression (so we can recover well), but report that a type is needed\r\n                // instead.\r\n                if (isStartOfType() || !isStartOfExpression()) {\r\n                    node.constraint = parseType();\r\n                }\r\n                else {\r\n                    // It was not a type, and it looked like an expression.  Parse out an expression\r\n                    // here so we recover well.  Note: it is important that we call parseUnaryExpression\r\n                    // and not parseExpression here.  If the user has:\r\n                    //\r\n                    //      <T extends \"\">\r\n                    //\r\n                    // We do *not* want to consume the  >  as we're consuming the expression for \"\".\r\n                    node.expression = parseUnaryExpressionOrHigher();\r\n                }\r\n            }\r\n\r\n            if (parseOptional(SyntaxKind.EqualsToken)) {\r\n                node.default = parseType();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameters(): NodeArray<TypeParameterDeclaration> | undefined {\r\n            if (token() === SyntaxKind.LessThanToken) {\r\n                return parseBracketedList(ParsingContext.TypeParameters, parseTypeParameter, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n            }\r\n        }\r\n\r\n        function parseParameterType(): TypeNode {\r\n            if (parseOptional(SyntaxKind.ColonToken)) {\r\n                return parseType();\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function isStartOfParameter(): boolean {\r\n            return token() === SyntaxKind.DotDotDotToken ||\r\n                isIdentifierOrPattern() ||\r\n                isModifierKind(token()) ||\r\n                token() === SyntaxKind.AtToken ||\r\n                isStartOfType(/*inStartOfParameter*/ true);\r\n        }\r\n\r\n        function parseParameter(requireEqualsToken?: boolean): ParameterDeclaration {\r\n            const node = <ParameterDeclaration>createNode(SyntaxKind.Parameter);\r\n            if (token() === SyntaxKind.ThisKeyword) {\r\n                node.name = createIdentifier(/*isIdentifier*/ true);\r\n                node.type = parseParameterType();\r\n                return finishNode(node);\r\n            }\r\n\r\n            node.decorators = parseDecorators();\r\n            node.modifiers = parseModifiers();\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n\r\n            // FormalParameter [Yield,Await]:\r\n            //      BindingElement[?Yield,?Await]\r\n            node.name = parseIdentifierOrPattern();\r\n            if (getFullWidth(node.name) === 0 && !hasModifiers(node) && isModifierKind(token())) {\r\n                // in cases like\r\n                // 'use strict'\r\n                // function foo(static)\r\n                // isParameter('static') === true, because of isModifier('static')\r\n                // however 'static' is not a legal identifier in a strict mode.\r\n                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)\r\n                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)\r\n                // to avoid this we'll advance cursor to the next token.\r\n                nextToken();\r\n            }\r\n\r\n            node.questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            node.type = parseParameterType();\r\n            node.initializer = parseInitializer(/*inParameter*/ true, requireEqualsToken);\r\n\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function fillSignature(\r\n            returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken,\r\n            flags: SignatureFlags,\r\n            signature: SignatureDeclaration): void {\r\n            if (!(flags & SignatureFlags.JSDoc)) {\r\n                signature.typeParameters = parseTypeParameters();\r\n            }\r\n            signature.parameters = parseParameterList(flags);\r\n            signature.type = parseReturnType(returnToken, !!(flags & SignatureFlags.Type));\r\n        }\r\n\r\n        function parseReturnType(returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken, isType: boolean): TypeNode | undefined {\r\n            return shouldParseReturnType(returnToken, isType) ? parseTypeOrTypePredicate() : undefined;\r\n        }\r\n        function shouldParseReturnType(returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken, isType: boolean): boolean {\r\n            if (returnToken === SyntaxKind.EqualsGreaterThanToken) {\r\n                parseExpected(returnToken);\r\n                return true;\r\n            }\r\n            else if (parseOptional(SyntaxKind.ColonToken)) {\r\n                return true;\r\n            }\r\n            else if (isType && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                // This is easy to get backward, especially in type contexts, so parse the type anyway\r\n                parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKind.ColonToken));\r\n                nextToken();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseParameterList(flags: SignatureFlags) {\r\n            // FormalParameters [Yield,Await]: (modified)\r\n            //      [empty]\r\n            //      FormalParameterList[?Yield,Await]\r\n            //\r\n            // FormalParameter[Yield,Await]: (modified)\r\n            //      BindingElement[?Yield,Await]\r\n            //\r\n            // BindingElement [Yield,Await]: (modified)\r\n            //      SingleNameBinding[?Yield,?Await]\r\n            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt\r\n            //\r\n            // SingleNameBinding [Yield,Await]:\r\n            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt\r\n            if (parseExpected(SyntaxKind.OpenParenToken)) {\r\n                const savedYieldContext = inYieldContext();\r\n                const savedAwaitContext = inAwaitContext();\r\n\r\n                setYieldContext(!!(flags & SignatureFlags.Yield));\r\n                setAwaitContext(!!(flags & SignatureFlags.Await));\r\n\r\n                const result = parseDelimitedList(ParsingContext.Parameters,\r\n                    flags & SignatureFlags.JSDoc ? parseJSDocParameter : () => parseParameter(!!(flags & SignatureFlags.RequireCompleteParameterList)));\r\n\r\n                setYieldContext(savedYieldContext);\r\n                setAwaitContext(savedAwaitContext);\r\n\r\n                if (!parseExpected(SyntaxKind.CloseParenToken) && (flags & SignatureFlags.RequireCompleteParameterList)) {\r\n                    // Caller insisted that we had to end with a )   We didn't.  So just return\r\n                    // undefined here.\r\n                    return undefined;\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            // We didn't even have an open paren.  If the caller requires a complete parameter list,\r\n            // we definitely can't provide that.  However, if they're ok with an incomplete one,\r\n            // then just return an empty set of parameters.\r\n            return (flags & SignatureFlags.RequireCompleteParameterList) ? undefined : createMissingList<ParameterDeclaration>();\r\n        }\r\n\r\n        function parseTypeMemberSemicolon() {\r\n            // We allow type members to be separated by commas or (possibly ASI) semicolons.\r\n            // First check if it was a comma.  If so, we're done with the member.\r\n            if (parseOptional(SyntaxKind.CommaToken)) {\r\n                return;\r\n            }\r\n\r\n            // Didn't have a comma.  We must have a (possible ASI) semicolon.\r\n            parseSemicolon();\r\n        }\r\n\r\n        function parseSignatureMember(kind: SyntaxKind.CallSignature | SyntaxKind.ConstructSignature): CallSignatureDeclaration | ConstructSignatureDeclaration {\r\n            const node = <CallSignatureDeclaration | ConstructSignatureDeclaration>createNode(kind);\r\n            if (kind === SyntaxKind.ConstructSignature) {\r\n                parseExpected(SyntaxKind.NewKeyword);\r\n            }\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type, node);\r\n            parseTypeMemberSemicolon();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function isIndexSignature(): boolean {\r\n            if (token() !== SyntaxKind.OpenBracketToken) {\r\n                return false;\r\n            }\r\n\r\n            return lookAhead(isUnambiguouslyIndexSignature);\r\n        }\r\n\r\n        function isUnambiguouslyIndexSignature() {\r\n            // The only allowed sequence is:\r\n            //\r\n            //   [id:\r\n            //\r\n            // However, for error recovery, we also check the following cases:\r\n            //\r\n            //   [...\r\n            //   [id,\r\n            //   [id?,\r\n            //   [id?:\r\n            //   [id?]\r\n            //   [public id\r\n            //   [private id\r\n            //   [protected id\r\n            //   []\r\n            //\r\n            nextToken();\r\n            if (token() === SyntaxKind.DotDotDotToken || token() === SyntaxKind.CloseBracketToken) {\r\n                return true;\r\n            }\r\n\r\n            if (isModifierKind(token())) {\r\n                nextToken();\r\n                if (isIdentifier()) {\r\n                    return true;\r\n                }\r\n            }\r\n            else if (!isIdentifier()) {\r\n                return false;\r\n            }\r\n            else {\r\n                // Skip the identifier\r\n                nextToken();\r\n            }\r\n\r\n            // A colon signifies a well formed indexer\r\n            // A comma should be a badly formed indexer because comma expressions are not allowed\r\n            // in computed properties.\r\n            if (token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken) {\r\n                return true;\r\n            }\r\n\r\n            // Question mark could be an indexer with an optional property,\r\n            // or it could be a conditional expression in a computed property.\r\n            if (token() !== SyntaxKind.QuestionToken) {\r\n                return false;\r\n            }\r\n\r\n            // If any of the following tokens are after the question mark, it cannot\r\n            // be a conditional expression, so treat it as an indexer.\r\n            nextToken();\r\n            return token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken || token() === SyntaxKind.CloseBracketToken;\r\n        }\r\n\r\n        function parseIndexSignatureDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): IndexSignatureDeclaration {\r\n            const node = <IndexSignatureDeclaration>createNode(SyntaxKind.IndexSignature, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            node.parameters = parseBracketedList(ParsingContext.Parameters, parseParameter, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\r\n            node.type = parseTypeAnnotation();\r\n            parseTypeMemberSemicolon();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parsePropertyOrMethodSignature(fullStart: number, modifiers: NodeArray<Modifier>): PropertySignature | MethodSignature {\r\n            const name = parsePropertyName();\r\n            const questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                const method = <MethodSignature>createNode(SyntaxKind.MethodSignature, fullStart);\r\n                method.modifiers = modifiers;\r\n                method.name = name;\r\n                method.questionToken = questionToken;\r\n\r\n                // Method signatures don't exist in expression contexts.  So they have neither\r\n                // [Yield] nor [Await]\r\n                fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type, method);\r\n                parseTypeMemberSemicolon();\r\n                return addJSDocComment(finishNode(method));\r\n            }\r\n            else {\r\n                const property = <PropertySignature>createNode(SyntaxKind.PropertySignature, fullStart);\r\n                property.modifiers = modifiers;\r\n                property.name = name;\r\n                property.questionToken = questionToken;\r\n                property.type = parseTypeAnnotation();\r\n\r\n                if (token() === SyntaxKind.EqualsToken) {\r\n                    // Although type literal properties cannot not have initializers, we attempt\r\n                    // to parse an initializer so we can report in the checker that an interface\r\n                    // property or type literal property cannot have an initializer.\r\n                    property.initializer = parseNonParameterInitializer();\r\n                }\r\n\r\n                parseTypeMemberSemicolon();\r\n                return addJSDocComment(finishNode(property));\r\n            }\r\n        }\r\n\r\n        function isTypeMemberStart(): boolean {\r\n            // Return true if we have the start of a signature member\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return true;\r\n            }\r\n            let idToken: boolean;\r\n            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier\r\n            while (isModifierKind(token())) {\r\n                idToken = true;\r\n                nextToken();\r\n            }\r\n            // Index signatures and computed property names are type members\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return true;\r\n            }\r\n            // Try to get the first property-like token following all modifiers\r\n            if (isLiteralPropertyName()) {\r\n                idToken = true;\r\n                nextToken();\r\n            }\r\n            // If we were able to get any potential identifier, check that it is\r\n            // the start of a member declaration\r\n            if (idToken) {\r\n                return token() === SyntaxKind.OpenParenToken ||\r\n                    token() === SyntaxKind.LessThanToken ||\r\n                    token() === SyntaxKind.QuestionToken ||\r\n                    token() === SyntaxKind.ColonToken ||\r\n                    token() === SyntaxKind.CommaToken ||\r\n                    canParseSemicolon();\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseTypeMember(): TypeElement {\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseSignatureMember(SyntaxKind.CallSignature);\r\n            }\r\n            if (token() === SyntaxKind.NewKeyword && lookAhead(nextTokenIsOpenParenOrLessThan)) {\r\n                return parseSignatureMember(SyntaxKind.ConstructSignature);\r\n            }\r\n            const fullStart = getNodePos();\r\n            const modifiers = parseModifiers();\r\n            if (isIndexSignature()) {\r\n                return parseIndexSignatureDeclaration(fullStart, /*decorators*/ undefined, modifiers);\r\n            }\r\n            return parsePropertyOrMethodSignature(fullStart, modifiers);\r\n        }\r\n\r\n        function nextTokenIsOpenParenOrLessThan() {\r\n            nextToken();\r\n            return token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken;\r\n        }\r\n\r\n        function parseTypeLiteral(): TypeLiteralNode {\r\n            const node = <TypeLiteralNode>createNode(SyntaxKind.TypeLiteral);\r\n            node.members = parseObjectTypeMembers();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectTypeMembers(): NodeArray<TypeElement> {\r\n            let members: NodeArray<TypeElement>;\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                members = parseList(ParsingContext.TypeMembers, parseTypeMember);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                members = createMissingList<TypeElement>();\r\n            }\r\n\r\n            return members;\r\n        }\r\n\r\n        function isStartOfMappedType() {\r\n            nextToken();\r\n            if (token() === SyntaxKind.ReadonlyKeyword) {\r\n                nextToken();\r\n            }\r\n            return token() === SyntaxKind.OpenBracketToken && nextTokenIsIdentifier() && nextToken() === SyntaxKind.InKeyword;\r\n        }\r\n\r\n        function parseMappedTypeParameter() {\r\n            const node = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            node.name = parseIdentifier();\r\n            parseExpected(SyntaxKind.InKeyword);\r\n            node.constraint = parseType();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseMappedType() {\r\n            const node = <MappedTypeNode>createNode(SyntaxKind.MappedType);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            node.readonlyToken = parseOptionalToken(SyntaxKind.ReadonlyKeyword);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            node.typeParameter = parseMappedTypeParameter();\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            node.questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            node.type = parseTypeAnnotation();\r\n            parseSemicolon();\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTupleType(): TupleTypeNode {\r\n            const node = <TupleTypeNode>createNode(SyntaxKind.TupleType);\r\n            node.elementTypes = parseBracketedList(ParsingContext.TupleElementTypes, parseType, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseParenthesizedType(): ParenthesizedTypeNode {\r\n            const node = <ParenthesizedTypeNode>createNode(SyntaxKind.ParenthesizedType);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.type = parseType();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionOrConstructorType(kind: SyntaxKind): FunctionOrConstructorTypeNode {\r\n            const node = <FunctionOrConstructorTypeNode>createNode(kind);\r\n            if (kind === SyntaxKind.ConstructorType) {\r\n                parseExpected(SyntaxKind.NewKeyword);\r\n            }\r\n            fillSignature(SyntaxKind.EqualsGreaterThanToken, SignatureFlags.Type, node);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseKeywordAndNoDot(): TypeNode | undefined {\r\n            const node = parseTokenNode<TypeNode>();\r\n            return token() === SyntaxKind.DotToken ? undefined : node;\r\n        }\r\n\r\n        function parseLiteralTypeNode(negative?: boolean): LiteralTypeNode {\r\n            const node = createNode(SyntaxKind.LiteralType) as LiteralTypeNode;\r\n            let unaryMinusExpression: PrefixUnaryExpression;\r\n            if (negative) {\r\n                unaryMinusExpression = createNode(SyntaxKind.PrefixUnaryExpression) as PrefixUnaryExpression;\r\n                unaryMinusExpression.operator = SyntaxKind.MinusToken;\r\n                nextToken();\r\n            }\r\n            let expression: BooleanLiteral | LiteralExpression | PrefixUnaryExpression = token() === SyntaxKind.TrueKeyword || token() === SyntaxKind.FalseKeyword\r\n                ? parseTokenNode<BooleanLiteral>()\r\n                : parseLiteralLikeNode(token()) as LiteralExpression;\r\n            if (negative) {\r\n                unaryMinusExpression.operand = expression;\r\n                finishNode(unaryMinusExpression);\r\n                expression = unaryMinusExpression;\r\n            }\r\n            node.literal = expression;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function nextTokenIsNumericLiteral() {\r\n            return nextToken() === SyntaxKind.NumericLiteral;\r\n        }\r\n\r\n        function parseNonArrayType(): TypeNode {\r\n            switch (token()) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.SymbolKeyword:\r\n                case SyntaxKind.UndefinedKeyword:\r\n                case SyntaxKind.NeverKeyword:\r\n                case SyntaxKind.ObjectKeyword:\r\n                    // If these are followed by a dot, then parse these out as a dotted type reference instead.\r\n                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();\r\n                case SyntaxKind.AsteriskToken:\r\n                    return parseJSDocAllType();\r\n                case SyntaxKind.QuestionToken:\r\n                    return parseJSDocUnknownOrNullableType();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseJSDocFunctionType();\r\n                case SyntaxKind.DotDotDotToken:\r\n                    return parseJSDocNodeWithType(SyntaxKind.JSDocVariadicType);\r\n                case SyntaxKind.ExclamationToken:\r\n                    return parseJSDocNodeWithType(SyntaxKind.JSDocNonNullableType);\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return parseLiteralTypeNode();\r\n                case SyntaxKind.MinusToken:\r\n                    return lookAhead(nextTokenIsNumericLiteral) ? parseLiteralTypeNode(/*negative*/ true) : parseTypeReference();\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                    return parseTokenNode<TypeNode>();\r\n                case SyntaxKind.ThisKeyword: {\r\n                    const thisKeyword = parseThisTypeNode();\r\n                    if (token() === SyntaxKind.IsKeyword && !scanner.hasPrecedingLineBreak()) {\r\n                        return parseThisTypePredicate(thisKeyword);\r\n                    }\r\n                    else {\r\n                        return thisKeyword;\r\n                    }\r\n                }\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return parseTypeQuery();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseTupleType();\r\n                case SyntaxKind.OpenParenToken:\r\n                    return parseParenthesizedType();\r\n                default:\r\n                    return parseTypeReference();\r\n            }\r\n        }\r\n\r\n        function isStartOfType(inStartOfParameter?: boolean): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.SymbolKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.UndefinedKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.NeverKeyword:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.BarToken:\r\n                case SyntaxKind.AmpersandToken:\r\n                case SyntaxKind.NewKeyword:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.ObjectKeyword:\r\n                case SyntaxKind.AsteriskToken:\r\n                case SyntaxKind.QuestionToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DotDotDotToken:\r\n                    return true;\r\n                case SyntaxKind.MinusToken:\r\n                    return !inStartOfParameter && lookAhead(nextTokenIsNumericLiteral);\r\n                case SyntaxKind.OpenParenToken:\r\n                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,\r\n                    // or something that starts a type. We don't want to consider things like '(1)' a type.\r\n                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfParenthesizedOrFunctionType() {\r\n            nextToken();\r\n            return token() === SyntaxKind.CloseParenToken || isStartOfParameter() || isStartOfType();\r\n        }\r\n\r\n        function parsePostfixTypeOrHigher(): TypeNode {\r\n            let type = parseNonArrayType();\r\n            while (!scanner.hasPrecedingLineBreak()) {\r\n                switch (token()) {\r\n                    case SyntaxKind.EqualsToken:\r\n                        // only parse postfix = inside jsdoc, because it's ambiguous elsewhere\r\n                        if (!(contextFlags & NodeFlags.JSDoc)) {\r\n                            return type;\r\n                        }\r\n                        type = createJSDocPostfixType(SyntaxKind.JSDocOptionalType, type);\r\n                        break;\r\n                    case SyntaxKind.ExclamationToken:\r\n                        type = createJSDocPostfixType(SyntaxKind.JSDocNonNullableType, type);\r\n                        break;\r\n                    case SyntaxKind.QuestionToken:\r\n                        type = createJSDocPostfixType(SyntaxKind.JSDocNullableType, type);\r\n                        break;\r\n                    case SyntaxKind.OpenBracketToken:\r\n                        parseExpected(SyntaxKind.OpenBracketToken);\r\n                        if (isStartOfType()) {\r\n                            const node = createNode(SyntaxKind.IndexedAccessType, type.pos) as IndexedAccessTypeNode;\r\n                            node.objectType = type;\r\n                            node.indexType = parseType();\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                            type = finishNode(node);\r\n                        }\r\n                        else {\r\n                            const node = createNode(SyntaxKind.ArrayType, type.pos) as ArrayTypeNode;\r\n                            node.elementType = type;\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                            type = finishNode(node);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        return type;\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function createJSDocPostfixType(kind: SyntaxKind, type: TypeNode) {\r\n            nextToken();\r\n            const postfix = createNode(kind, type.pos) as JSDocOptionalType | JSDocNonNullableType | JSDocNullableType;\r\n            postfix.type = type;\r\n            return finishNode(postfix);\r\n        }\r\n\r\n        function parseTypeOperator(operator: SyntaxKind.KeyOfKeyword) {\r\n            const node = <TypeOperatorNode>createNode(SyntaxKind.TypeOperator);\r\n            parseExpected(operator);\r\n            node.operator = operator;\r\n            node.type = parseTypeOperatorOrHigher();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeOperatorOrHigher(): TypeNode {\r\n            switch (token()) {\r\n                case SyntaxKind.KeyOfKeyword:\r\n                    return parseTypeOperator(SyntaxKind.KeyOfKeyword);\r\n            }\r\n            return parsePostfixTypeOrHigher();\r\n        }\r\n\r\n        function parseUnionOrIntersectionType(kind: SyntaxKind.UnionType | SyntaxKind.IntersectionType, parseConstituentType: () => TypeNode, operator: SyntaxKind.BarToken | SyntaxKind.AmpersandToken): TypeNode {\r\n            parseOptional(operator);\r\n            let type = parseConstituentType();\r\n            if (token() === operator) {\r\n                const types = [type];\r\n                while (parseOptional(operator)) {\r\n                    types.push(parseConstituentType());\r\n                }\r\n                const node = <UnionOrIntersectionTypeNode>createNode(kind, type.pos);\r\n                node.types = createNodeArray(types, type.pos);\r\n                type = finishNode(node);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function parseIntersectionTypeOrHigher(): TypeNode {\r\n            return parseUnionOrIntersectionType(SyntaxKind.IntersectionType, parseTypeOperatorOrHigher, SyntaxKind.AmpersandToken);\r\n        }\r\n\r\n        function parseUnionTypeOrHigher(): TypeNode {\r\n            return parseUnionOrIntersectionType(SyntaxKind.UnionType, parseIntersectionTypeOrHigher, SyntaxKind.BarToken);\r\n        }\r\n\r\n        function isStartOfFunctionType(): boolean {\r\n            if (token() === SyntaxKind.LessThanToken) {\r\n                return true;\r\n            }\r\n            return token() === SyntaxKind.OpenParenToken && lookAhead(isUnambiguouslyStartOfFunctionType);\r\n        }\r\n\r\n        function skipParameterStart(): boolean {\r\n            if (isModifierKind(token())) {\r\n                // Skip modifiers\r\n                parseModifiers();\r\n            }\r\n            if (isIdentifier() || token() === SyntaxKind.ThisKeyword) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            if (token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.OpenBraceToken) {\r\n                // Return true if we can parse an array or object binding pattern with no errors\r\n                const previousErrorCount = parseDiagnostics.length;\r\n                parseIdentifierOrPattern();\r\n                return previousErrorCount === parseDiagnostics.length;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isUnambiguouslyStartOfFunctionType() {\r\n            nextToken();\r\n            if (token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.DotDotDotToken) {\r\n                // ( )\r\n                // ( ...\r\n                return true;\r\n            }\r\n            if (skipParameterStart()) {\r\n                // We successfully skipped modifiers (if any) and an identifier or binding pattern,\r\n                // now see if we have something that indicates a parameter declaration\r\n                if (token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken ||\r\n                    token() === SyntaxKind.QuestionToken || token() === SyntaxKind.EqualsToken) {\r\n                    // ( xxx :\r\n                    // ( xxx ,\r\n                    // ( xxx ?\r\n                    // ( xxx =\r\n                    return true;\r\n                }\r\n                if (token() === SyntaxKind.CloseParenToken) {\r\n                    nextToken();\r\n                    if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                        // ( xxx ) =>\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseTypeOrTypePredicate(): TypeNode {\r\n            const typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);\r\n            const type = parseType();\r\n            if (typePredicateVariable) {\r\n                const node = <TypePredicateNode>createNode(SyntaxKind.TypePredicate, typePredicateVariable.pos);\r\n                node.parameterName = typePredicateVariable;\r\n                node.type = type;\r\n                return finishNode(node);\r\n            }\r\n            else {\r\n                return type;\r\n            }\r\n        }\r\n\r\n        function parseTypePredicatePrefix() {\r\n            const id = parseIdentifier();\r\n            if (token() === SyntaxKind.IsKeyword && !scanner.hasPrecedingLineBreak()) {\r\n                nextToken();\r\n                return id;\r\n            }\r\n        }\r\n\r\n        function parseType(): TypeNode {\r\n            // The rules about 'yield' only apply to actual code/expression contexts.  They don't\r\n            // apply to 'type' contexts.  So we disable these parameters here before moving on.\r\n            return doOutsideOfContext(NodeFlags.TypeExcludesFlags, parseTypeWorker);\r\n        }\r\n\r\n        function parseTypeWorker(): TypeNode {\r\n            if (isStartOfFunctionType()) {\r\n                return parseFunctionOrConstructorType(SyntaxKind.FunctionType);\r\n            }\r\n            if (token() === SyntaxKind.NewKeyword) {\r\n                return parseFunctionOrConstructorType(SyntaxKind.ConstructorType);\r\n            }\r\n            return parseUnionTypeOrHigher();\r\n        }\r\n\r\n        function parseTypeAnnotation(): TypeNode {\r\n            return parseOptional(SyntaxKind.ColonToken) ? parseType() : undefined;\r\n        }\r\n\r\n        // EXPRESSIONS\r\n        function isStartOfLeftHandSideExpression(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                case SyntaxKind.TemplateHead:\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.NewKeyword:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                case SyntaxKind.Identifier:\r\n                    return true;\r\n                case SyntaxKind.ImportKeyword:\r\n                    return lookAhead(nextTokenIsOpenParenOrLessThan);\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfExpression(): boolean {\r\n            if (isStartOfLeftHandSideExpression()) {\r\n                return true;\r\n            }\r\n\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.PlusPlusToken:\r\n                case SyntaxKind.MinusMinusToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.AwaitKeyword:\r\n                case SyntaxKind.YieldKeyword:\r\n                    // Yield/await always starts an expression.  Either it is an identifier (in which case\r\n                    // it is definitely an expression).  Or it's a keyword (either because we're in\r\n                    // a generator or async function, or in strict mode (or both)) and it started a yield or await expression.\r\n                    return true;\r\n                default:\r\n                    // Error tolerance.  If we see the start of some binary operator, we consider\r\n                    // that the start of an expression.  That way we'll parse out a missing identifier,\r\n                    // give a good message about an identifier being missing, and then consume the\r\n                    // rest of the binary expression.\r\n                    if (isBinaryOperator()) {\r\n                        return true;\r\n                    }\r\n\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfExpressionStatement(): boolean {\r\n            // As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.\r\n            return token() !== SyntaxKind.OpenBraceToken &&\r\n                token() !== SyntaxKind.FunctionKeyword &&\r\n                token() !== SyntaxKind.ClassKeyword &&\r\n                token() !== SyntaxKind.AtToken &&\r\n                isStartOfExpression();\r\n        }\r\n\r\n        function parseExpression(): Expression {\r\n            // Expression[in]:\r\n            //      AssignmentExpression[in]\r\n            //      Expression[in] , AssignmentExpression[in]\r\n\r\n            // clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            let expr = parseAssignmentExpressionOrHigher();\r\n            let operatorToken: BinaryOperatorToken;\r\n            while ((operatorToken = parseOptionalToken(SyntaxKind.CommaToken))) {\r\n                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher());\r\n            }\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        function parseInitializer(inParameter: boolean, requireEqualsToken?: boolean): Expression {\r\n            if (token() !== SyntaxKind.EqualsToken) {\r\n                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if\r\n                // there is no newline after the last token and if we're on an expression.  If so, parse\r\n                // this as an equals-value clause with a missing equals.\r\n                // NOTE: There are two places where we allow equals-value clauses.  The first is in a\r\n                // variable declarator.  The second is with a parameter.  For variable declarators\r\n                // it's more likely that a { would be a allowed (as an object literal).  While this\r\n                // is also allowed for parameters, the risk is that we consume the { as an object\r\n                // literal when it really will be for the block following the parameter.\r\n                if (scanner.hasPrecedingLineBreak() || (inParameter && token() === SyntaxKind.OpenBraceToken) || !isStartOfExpression()) {\r\n                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression -\r\n                    // do not try to parse initializer\r\n                    return undefined;\r\n                }\r\n                if (inParameter && requireEqualsToken) {\r\n                    // = is required when speculatively parsing arrow function parameters,\r\n                    // so return a fake initializer as a signal that the equals token was missing\r\n                    const result = createMissingNode(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics._0_expected, \"=\") as Identifier;\r\n                    result.escapedText = \"= not found\" as __String;\r\n                    return result;\r\n                }\r\n            }\r\n\r\n            // Initializer[In, Yield] :\r\n            //     = AssignmentExpression[?In, ?Yield]\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            return parseAssignmentExpressionOrHigher();\r\n        }\r\n\r\n        function parseAssignmentExpressionOrHigher(): Expression {\r\n            //  AssignmentExpression[in,yield]:\r\n            //      1) ConditionalExpression[?in,?yield]\r\n            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]\r\n            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]\r\n            //      4) ArrowFunctionExpression[?in,?yield]\r\n            //      5) AsyncArrowFunctionExpression[in,yield,await]\r\n            //      6) [+Yield] YieldExpression[?In]\r\n            //\r\n            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.\r\n            // (i.e. they're both BinaryExpressions with an assignment operator in it).\r\n\r\n            // First, do the simple check if we have a YieldExpression (production '6').\r\n            if (isYieldExpression()) {\r\n                return parseYieldExpression();\r\n            }\r\n\r\n            // Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized\r\n            // parameter list or is an async arrow function.\r\n            // AsyncArrowFunctionExpression:\r\n            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            // Production (1) of AsyncArrowFunctionExpression is parsed in \"tryParseAsyncSimpleArrowFunctionExpression\".\r\n            // And production (2) is parsed in \"tryParseParenthesizedArrowFunctionExpression\".\r\n            //\r\n            // If we do successfully parse arrow-function, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is\r\n            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done\r\n            // with AssignmentExpression if we see one.\r\n            const arrowExpression = tryParseParenthesizedArrowFunctionExpression() || tryParseAsyncSimpleArrowFunctionExpression();\r\n            if (arrowExpression) {\r\n                return arrowExpression;\r\n            }\r\n\r\n            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can\r\n            // start with a LogicalOrExpression, while the assignment productions can only start with\r\n            // LeftHandSideExpressions.\r\n            //\r\n            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a\r\n            // LeftHandSide or higher, then we can try to parse out the assignment expression part.\r\n            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any\r\n            // binary expression here, so we pass in the 'lowest' precedence here so that it matches\r\n            // and consumes anything.\r\n            const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n\r\n            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized\r\n            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single\r\n            // identifier and the current token is an arrow.\r\n            if (expr.kind === SyntaxKind.Identifier && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                return parseSimpleArrowFunctionExpression(<Identifier>expr);\r\n            }\r\n\r\n            // Now see if we might be in cases '2' or '3'.\r\n            // If the expression was a LHS expression, and we have an assignment operator, then\r\n            // we're in '2' or '3'. Consume the assignment and return.\r\n            //\r\n            // Note: we call reScanGreaterToken so that we get an appropriately merged token\r\n            // for cases like > > =  becoming >>=\r\n            if (isLeftHandSideExpression(expr) && isAssignmentOperator(reScanGreaterToken())) {\r\n                return makeBinaryExpression(expr, <BinaryOperatorToken>parseTokenNode(), parseAssignmentExpressionOrHigher());\r\n            }\r\n\r\n            // It wasn't an assignment or a lambda.  This is a conditional expression:\r\n            return parseConditionalExpressionRest(expr);\r\n        }\r\n\r\n        function isYieldExpression(): boolean {\r\n            if (token() === SyntaxKind.YieldKeyword) {\r\n                // If we have a 'yield' keyword, and this is a context where yield expressions are\r\n                // allowed, then definitely parse out a yield expression.\r\n                if (inYieldContext()) {\r\n                    return true;\r\n                }\r\n\r\n                // We're in a context where 'yield expr' is not allowed.  However, if we can\r\n                // definitely tell that the user was trying to parse a 'yield expr' and not\r\n                // just a normal expr that start with a 'yield' identifier, then parse out\r\n                // a 'yield expr'.  We can then report an error later that they are only\r\n                // allowed in generator expressions.\r\n                //\r\n                // for example, if we see 'yield(foo)', then we'll have to treat that as an\r\n                // invocation expression of something called 'yield'.  However, if we have\r\n                // 'yield foo' then that is not legal as a normal expression, so we can\r\n                // definitely recognize this as a yield expression.\r\n                //\r\n                // for now we just check if the next token is an identifier.  More heuristics\r\n                // can be added here later as necessary.  We just need to make sure that we\r\n                // don't accidentally consume something legal.\r\n                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function nextTokenIsIdentifierOnSameLine() {\r\n            nextToken();\r\n            return !scanner.hasPrecedingLineBreak() && isIdentifier();\r\n        }\r\n\r\n        function parseYieldExpression(): YieldExpression {\r\n            const node = <YieldExpression>createNode(SyntaxKind.YieldExpression);\r\n\r\n            // YieldExpression[In] :\r\n            //      yield\r\n            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\r\n            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\r\n            nextToken();\r\n\r\n            if (!scanner.hasPrecedingLineBreak() &&\r\n                (token() === SyntaxKind.AsteriskToken || isStartOfExpression())) {\r\n                node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n                node.expression = parseAssignmentExpressionOrHigher();\r\n                return finishNode(node);\r\n            }\r\n            else {\r\n                // if the next token is not on the same line as yield.  or we don't have an '*' or\r\n                // the start of an expression, then this is just a simple \"yield\" expression.\r\n                return finishNode(node);\r\n            }\r\n        }\r\n\r\n        function parseSimpleArrowFunctionExpression(identifier: Identifier, asyncModifier?: NodeArray<Modifier>): ArrowFunction {\r\n            Debug.assert(token() === SyntaxKind.EqualsGreaterThanToken, \"parseSimpleArrowFunctionExpression should only have been called if we had a =>\");\r\n\r\n            let node: ArrowFunction;\r\n            if (asyncModifier) {\r\n                node = <ArrowFunction>createNode(SyntaxKind.ArrowFunction, asyncModifier.pos);\r\n                node.modifiers = asyncModifier;\r\n            }\r\n            else {\r\n                node = <ArrowFunction>createNode(SyntaxKind.ArrowFunction, identifier.pos);\r\n            }\r\n\r\n            const parameter = <ParameterDeclaration>createNode(SyntaxKind.Parameter, identifier.pos);\r\n            parameter.name = identifier;\r\n            finishNode(parameter);\r\n\r\n            node.parameters = createNodeArray<ParameterDeclaration>([parameter], parameter.pos, parameter.end);\r\n\r\n            node.equalsGreaterThanToken = parseExpectedToken(SyntaxKind.EqualsGreaterThanToken, /*reportAtCurrentPosition*/ false, Diagnostics._0_expected, \"=>\");\r\n            node.body = parseArrowFunctionExpressionBody(/*isAsync*/ !!asyncModifier);\r\n\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function tryParseParenthesizedArrowFunctionExpression(): Expression | undefined {\r\n            const triState = isParenthesizedArrowFunctionExpression();\r\n            if (triState === Tristate.False) {\r\n                // It's definitely not a parenthesized arrow function expression.\r\n                return undefined;\r\n            }\r\n\r\n            // If we definitely have an arrow function, then we can just parse one, not requiring a\r\n            // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse\r\n            // it out, but don't allow any ambiguity, and return 'undefined' if this could be an\r\n            // expression instead.\r\n            const arrowFunction = triState === Tristate.True\r\n                ? parseParenthesizedArrowFunctionExpressionHead(/*allowAmbiguity*/ true)\r\n                : tryParse(parsePossibleParenthesizedArrowFunctionExpressionHead);\r\n\r\n            if (!arrowFunction) {\r\n                // Didn't appear to actually be a parenthesized arrow function.  Just bail out.\r\n                return undefined;\r\n            }\r\n\r\n            const isAsync = hasModifier(arrowFunction, ModifierFlags.Async);\r\n\r\n            // If we have an arrow, then try to parse the body. Even if not, try to parse if we\r\n            // have an opening brace, just in case we're in an error state.\r\n            const lastToken = token();\r\n            arrowFunction.equalsGreaterThanToken = parseExpectedToken(SyntaxKind.EqualsGreaterThanToken, /*reportAtCurrentPosition*/ false, Diagnostics._0_expected, \"=>\");\r\n            arrowFunction.body = (lastToken === SyntaxKind.EqualsGreaterThanToken || lastToken === SyntaxKind.OpenBraceToken)\r\n                ? parseArrowFunctionExpressionBody(isAsync)\r\n                : parseIdentifier();\r\n\r\n            return addJSDocComment(finishNode(arrowFunction));\r\n        }\r\n\r\n        //  True        -> We definitely expect a parenthesized arrow function here.\r\n        //  False       -> There *cannot* be a parenthesized arrow function here.\r\n        //  Unknown     -> There *might* be a parenthesized arrow function here.\r\n        //                 Speculatively look ahead to be sure, and rollback if not.\r\n        function isParenthesizedArrowFunctionExpression(): Tristate {\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken || token() === SyntaxKind.AsyncKeyword) {\r\n                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);\r\n            }\r\n\r\n            if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                // ERROR RECOVERY TWEAK:\r\n                // If we see a standalone => try to parse it as an arrow function expression as that's\r\n                // likely what the user intended to write.\r\n                return Tristate.True;\r\n            }\r\n            // Definitely not a parenthesized arrow function.\r\n            return Tristate.False;\r\n        }\r\n\r\n        function isParenthesizedArrowFunctionExpressionWorker() {\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                nextToken();\r\n                if (scanner.hasPrecedingLineBreak()) {\r\n                    return Tristate.False;\r\n                }\r\n                if (token() !== SyntaxKind.OpenParenToken && token() !== SyntaxKind.LessThanToken) {\r\n                    return Tristate.False;\r\n                }\r\n            }\r\n\r\n            const first = token();\r\n            const second = nextToken();\r\n\r\n            if (first === SyntaxKind.OpenParenToken) {\r\n                if (second === SyntaxKind.CloseParenToken) {\r\n                    // Simple cases: \"() =>\", \"(): \", and  \"() {\".\r\n                    // This is an arrow function with no parameters.\r\n                    // The last one is not actually an arrow function,\r\n                    // but this is probably what the user intended.\r\n                    const third = nextToken();\r\n                    switch (third) {\r\n                        case SyntaxKind.EqualsGreaterThanToken:\r\n                        case SyntaxKind.ColonToken:\r\n                        case SyntaxKind.OpenBraceToken:\r\n                            return Tristate.True;\r\n                        default:\r\n                            return Tristate.False;\r\n                    }\r\n                }\r\n\r\n                // If encounter \"([\" or \"({\", this could be the start of a binding pattern.\r\n                // Examples:\r\n                //      ([ x ]) => { }\r\n                //      ({ x }) => { }\r\n                //      ([ x ])\r\n                //      ({ x })\r\n                if (second === SyntaxKind.OpenBracketToken || second === SyntaxKind.OpenBraceToken) {\r\n                    return Tristate.Unknown;\r\n                }\r\n\r\n                // Simple case: \"(...\"\r\n                // This is an arrow function with a rest parameter.\r\n                if (second === SyntaxKind.DotDotDotToken) {\r\n                    return Tristate.True;\r\n                }\r\n\r\n                // If we had \"(\" followed by something that's not an identifier,\r\n                // then this definitely doesn't look like a lambda.\r\n                // Note: we could be a little more lenient and allow\r\n                // \"(public\" or \"(private\". These would not ever actually be allowed,\r\n                // but we could provide a good error message instead of bailing out.\r\n                if (!isIdentifier()) {\r\n                    return Tristate.False;\r\n                }\r\n\r\n                // If we have something like \"(a:\", then we must have a\r\n                // type-annotated parameter in an arrow function expression.\r\n                if (nextToken() === SyntaxKind.ColonToken) {\r\n                    return Tristate.True;\r\n                }\r\n\r\n                // This *could* be a parenthesized arrow function.\r\n                // Return Unknown to let the caller know.\r\n                return Tristate.Unknown;\r\n            }\r\n            else {\r\n                Debug.assert(first === SyntaxKind.LessThanToken);\r\n\r\n                // If we have \"<\" not followed by an identifier,\r\n                // then this definitely is not an arrow function.\r\n                if (!isIdentifier()) {\r\n                    return Tristate.False;\r\n                }\r\n\r\n                // JSX overrides\r\n                if (sourceFile.languageVariant === LanguageVariant.JSX) {\r\n                    const isArrowFunctionInJsx = lookAhead(() => {\r\n                        const third = nextToken();\r\n                        if (third === SyntaxKind.ExtendsKeyword) {\r\n                            const fourth = nextToken();\r\n                            switch (fourth) {\r\n                                case SyntaxKind.EqualsToken:\r\n                                case SyntaxKind.GreaterThanToken:\r\n                                    return false;\r\n                                default:\r\n                                    return true;\r\n                            }\r\n                        }\r\n                        else if (third === SyntaxKind.CommaToken) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    });\r\n\r\n                    if (isArrowFunctionInJsx) {\r\n                        return Tristate.True;\r\n                    }\r\n\r\n                    return Tristate.False;\r\n                }\r\n\r\n                // This *could* be a parenthesized arrow function.\r\n                return Tristate.Unknown;\r\n            }\r\n        }\r\n\r\n        function parsePossibleParenthesizedArrowFunctionExpressionHead(): ArrowFunction {\r\n            return parseParenthesizedArrowFunctionExpressionHead(/*allowAmbiguity*/ false);\r\n        }\r\n\r\n        function tryParseAsyncSimpleArrowFunctionExpression(): ArrowFunction | undefined {\r\n            // We do a check here so that we won't be doing unnecessarily call to \"lookAhead\"\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === Tristate.True) {\r\n                    const asyncModifier = parseModifiersForArrowFunction();\r\n                    const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n                    return parseSimpleArrowFunctionExpression(<Identifier>expr, asyncModifier);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function isUnParenthesizedAsyncArrowFunctionWorker(): Tristate {\r\n            // AsyncArrowFunctionExpression:\r\n            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                nextToken();\r\n                // If the \"async\" is followed by \"=>\" token then it is not a begining of an async arrow-function\r\n                // but instead a simple arrow-function which will be parsed inside \"parseAssignmentExpressionOrHigher\"\r\n                if (scanner.hasPrecedingLineBreak() || token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                    return Tristate.False;\r\n                }\r\n                // Check for un-parenthesized AsyncArrowFunction\r\n                const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n                if (!scanner.hasPrecedingLineBreak() && expr.kind === SyntaxKind.Identifier && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                    return Tristate.True;\r\n                }\r\n            }\r\n\r\n            return Tristate.False;\r\n        }\r\n\r\n        function parseParenthesizedArrowFunctionExpressionHead(allowAmbiguity: boolean): ArrowFunction {\r\n            const node = <ArrowFunction>createNode(SyntaxKind.ArrowFunction);\r\n            node.modifiers = parseModifiersForArrowFunction();\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            // Arrow functions are never generators.\r\n            //\r\n            // If we're speculatively parsing a signature for a parenthesized arrow function, then\r\n            // we have to have a complete parameter list.  Otherwise we might see something like\r\n            // a => (b => c)\r\n            // And think that \"(b =>\" was actually a parenthesized arrow function with a missing\r\n            // close paren.\r\n            fillSignature(SyntaxKind.ColonToken, isAsync | (allowAmbiguity ? SignatureFlags.None : SignatureFlags.RequireCompleteParameterList), node);\r\n\r\n            // If we couldn't get parameters, we definitely could not parse out an arrow function.\r\n            if (!node.parameters) {\r\n                return undefined;\r\n            }\r\n\r\n            // Parsing a signature isn't enough.\r\n            // Parenthesized arrow signatures often look like other valid expressions.\r\n            // For instance:\r\n            //  - \"(x = 10)\" is an assignment expression parsed as a signature with a default parameter value.\r\n            //  - \"(x,y)\" is a comma expression parsed as a signature with two parameters.\r\n            //  - \"a ? (b): c\" will have \"(b):\" parsed as a signature with a return type annotation.\r\n            //\r\n            // So we need just a bit of lookahead to ensure that it can only be a signature.\r\n            if (!allowAmbiguity && ((token() !== SyntaxKind.EqualsGreaterThanToken && token() !== SyntaxKind.OpenBraceToken) ||\r\n                find(node.parameters, p => p.initializer && ts.isIdentifier(p.initializer) && p.initializer.escapedText === \"= not found\"))) {\r\n                // Returning undefined here will cause our caller to rewind to where we started from.\r\n                return undefined;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function parseArrowFunctionExpressionBody(isAsync: boolean): Block | Expression {\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseFunctionBlock(isAsync ? SignatureFlags.Await : SignatureFlags.None);\r\n            }\r\n\r\n            if (token() !== SyntaxKind.SemicolonToken &&\r\n                token() !== SyntaxKind.FunctionKeyword &&\r\n                token() !== SyntaxKind.ClassKeyword &&\r\n                isStartOfStatement() &&\r\n                !isStartOfExpressionStatement()) {\r\n                // Check if we got a plain statement (i.e. no expression-statements, no function/class expressions/declarations)\r\n                //\r\n                // Here we try to recover from a potential error situation in the case where the\r\n                // user meant to supply a block. For example, if the user wrote:\r\n                //\r\n                //  a =>\r\n                //      let v = 0;\r\n                //  }\r\n                //\r\n                // they may be missing an open brace.  Check to see if that's the case so we can\r\n                // try to recover better.  If we don't do this, then the next close curly we see may end\r\n                // up preemptively closing the containing construct.\r\n                //\r\n                // Note: even when 'IgnoreMissingOpenBrace' is passed, parseBody will still error.\r\n                return parseFunctionBlock(SignatureFlags.IgnoreMissingOpenBrace | (isAsync ? SignatureFlags.Await : SignatureFlags.None));\r\n            }\r\n\r\n            return isAsync\r\n                ? doInAwaitContext(parseAssignmentExpressionOrHigher)\r\n                : doOutsideOfAwaitContext(parseAssignmentExpressionOrHigher);\r\n        }\r\n\r\n        function parseConditionalExpressionRest(leftOperand: Expression): Expression {\r\n            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.\r\n            const questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (!questionToken) {\r\n                return leftOperand;\r\n            }\r\n\r\n            // Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and\r\n            // we do not that for the 'whenFalse' part.\r\n            const node = <ConditionalExpression>createNode(SyntaxKind.ConditionalExpression, leftOperand.pos);\r\n            node.condition = leftOperand;\r\n            node.questionToken = questionToken;\r\n            node.whenTrue = doOutsideOfContext(disallowInAndDecoratorContext, parseAssignmentExpressionOrHigher);\r\n            node.colonToken = parseExpectedToken(SyntaxKind.ColonToken, /*reportAtCurrentPosition*/ false,\r\n                Diagnostics._0_expected, tokenToString(SyntaxKind.ColonToken));\r\n            node.whenFalse = parseAssignmentExpressionOrHigher();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseBinaryExpressionOrHigher(precedence: number): Expression {\r\n            const leftOperand = parseUnaryExpressionOrHigher();\r\n            return parseBinaryExpressionRest(precedence, leftOperand);\r\n        }\r\n\r\n        function isInOrOfKeyword(t: SyntaxKind) {\r\n            return t === SyntaxKind.InKeyword || t === SyntaxKind.OfKeyword;\r\n        }\r\n\r\n        function parseBinaryExpressionRest(precedence: number, leftOperand: Expression): Expression {\r\n            while (true) {\r\n                // We either have a binary operator here, or we're finished.  We call\r\n                // reScanGreaterToken so that we merge token sequences like > and = into >=\r\n\r\n                reScanGreaterToken();\r\n                const newPrecedence = getBinaryOperatorPrecedence();\r\n\r\n                // Check the precedence to see if we should \"take\" this operator\r\n                // - For left associative operator (all operator but **), consume the operator,\r\n                //   recursively call the function below, and parse binaryExpression as a rightOperand\r\n                //   of the caller if the new precedence of the operator is greater then or equal to the current precedence.\r\n                //   For example:\r\n                //      a - b - c;\r\n                //            ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                //      a * b - c\r\n                //            ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                //      a - b * c;\r\n                //            ^token; leftOperand = b. Return b * c to the caller as a rightOperand\r\n                // - For right associative operator (**), consume the operator, recursively call the function\r\n                //   and parse binaryExpression as a rightOperand of the caller if the new precedence of\r\n                //   the operator is strictly grater than the current precedence\r\n                //   For example:\r\n                //      a ** b ** c;\r\n                //             ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand\r\n                //      a - b ** c;\r\n                //            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand\r\n                //      a ** b - c\r\n                //             ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                const consumeCurrentOperator = token() === SyntaxKind.AsteriskAsteriskToken ?\r\n                    newPrecedence >= precedence :\r\n                    newPrecedence > precedence;\r\n\r\n                if (!consumeCurrentOperator) {\r\n                    break;\r\n                }\r\n\r\n                if (token() === SyntaxKind.InKeyword && inDisallowInContext()) {\r\n                    break;\r\n                }\r\n\r\n                if (token() === SyntaxKind.AsKeyword) {\r\n                    // Make sure we *do* perform ASI for constructs like this:\r\n                    //    var x = foo\r\n                    //    as (Bar)\r\n                    // This should be parsed as an initialized variable, followed\r\n                    // by a function call to 'as' with the argument 'Bar'\r\n                    if (scanner.hasPrecedingLineBreak()) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        nextToken();\r\n                        leftOperand = makeAsExpression(leftOperand, parseType());\r\n                    }\r\n                }\r\n                else {\r\n                    leftOperand = makeBinaryExpression(leftOperand, <BinaryOperatorToken>parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence));\r\n                }\r\n            }\r\n\r\n            return leftOperand;\r\n        }\r\n\r\n        function isBinaryOperator() {\r\n            if (inDisallowInContext() && token() === SyntaxKind.InKeyword) {\r\n                return false;\r\n            }\r\n\r\n            return getBinaryOperatorPrecedence() > 0;\r\n        }\r\n\r\n        function getBinaryOperatorPrecedence(): number {\r\n            switch (token()) {\r\n                case SyntaxKind.BarBarToken:\r\n                    return 1;\r\n                case SyntaxKind.AmpersandAmpersandToken:\r\n                    return 2;\r\n                case SyntaxKind.BarToken:\r\n                    return 3;\r\n                case SyntaxKind.CaretToken:\r\n                    return 4;\r\n                case SyntaxKind.AmpersandToken:\r\n                    return 5;\r\n                case SyntaxKind.EqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsToken:\r\n                case SyntaxKind.EqualsEqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsEqualsToken:\r\n                    return 6;\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.GreaterThanToken:\r\n                case SyntaxKind.LessThanEqualsToken:\r\n                case SyntaxKind.GreaterThanEqualsToken:\r\n                case SyntaxKind.InstanceOfKeyword:\r\n                case SyntaxKind.InKeyword:\r\n                case SyntaxKind.AsKeyword:\r\n                    return 7;\r\n                case SyntaxKind.LessThanLessThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\r\n                    return 8;\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                    return 9;\r\n                case SyntaxKind.AsteriskToken:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.PercentToken:\r\n                    return 10;\r\n                case SyntaxKind.AsteriskAsteriskToken:\r\n                    return 11;\r\n            }\r\n\r\n            // -1 is lower than all other precedences.  Returning it will cause binary expression\r\n            // parsing to stop.\r\n            return -1;\r\n        }\r\n\r\n        function makeBinaryExpression(left: Expression, operatorToken: BinaryOperatorToken, right: Expression): BinaryExpression {\r\n            const node = <BinaryExpression>createNode(SyntaxKind.BinaryExpression, left.pos);\r\n            node.left = left;\r\n            node.operatorToken = operatorToken;\r\n            node.right = right;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function makeAsExpression(left: Expression, right: TypeNode): AsExpression {\r\n            const node = <AsExpression>createNode(SyntaxKind.AsExpression, left.pos);\r\n            node.expression = left;\r\n            node.type = right;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePrefixUnaryExpression() {\r\n            const node = <PrefixUnaryExpression>createNode(SyntaxKind.PrefixUnaryExpression);\r\n            node.operator = <PrefixUnaryOperator>token();\r\n            nextToken();\r\n            node.operand = parseSimpleUnaryExpression();\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDeleteExpression() {\r\n            const node = <DeleteExpression>createNode(SyntaxKind.DeleteExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeOfExpression() {\r\n            const node = <TypeOfExpression>createNode(SyntaxKind.TypeOfExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseVoidExpression() {\r\n            const node = <VoidExpression>createNode(SyntaxKind.VoidExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isAwaitExpression(): boolean {\r\n            if (token() === SyntaxKind.AwaitKeyword) {\r\n                if (inAwaitContext()) {\r\n                    return true;\r\n                }\r\n\r\n                // here we are using similar heuristics as 'isYieldExpression'\r\n                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseAwaitExpression() {\r\n            const node = <AwaitExpression>createNode(SyntaxKind.AwaitExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 exponential expression and await expression\r\n         *\r\n         * ES7 ExponentiationExpression:\r\n         *      1) UnaryExpression[?Yield]\r\n         *      2) UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]\r\n         *\r\n         */\r\n        function parseUnaryExpressionOrHigher(): UnaryExpression | BinaryExpression {\r\n            /**\r\n             * ES7 UpdateExpression:\r\n             *      1) LeftHandSideExpression[?Yield]\r\n             *      2) LeftHandSideExpression[?Yield][no LineTerminator here]++\r\n             *      3) LeftHandSideExpression[?Yield][no LineTerminator here]--\r\n             *      4) ++UnaryExpression[?Yield]\r\n             *      5) --UnaryExpression[?Yield]\r\n             */\r\n            if (isUpdateExpression()) {\r\n                const updateExpression = parseUpdateExpression();\r\n                return token() === SyntaxKind.AsteriskAsteriskToken ?\r\n                    <BinaryExpression>parseBinaryExpressionRest(getBinaryOperatorPrecedence(), updateExpression) :\r\n                    updateExpression;\r\n            }\r\n\r\n            /**\r\n             * ES7 UnaryExpression:\r\n             *      1) UpdateExpression[?yield]\r\n             *      2) delete UpdateExpression[?yield]\r\n             *      3) void UpdateExpression[?yield]\r\n             *      4) typeof UpdateExpression[?yield]\r\n             *      5) + UpdateExpression[?yield]\r\n             *      6) - UpdateExpression[?yield]\r\n             *      7) ~ UpdateExpression[?yield]\r\n             *      8) ! UpdateExpression[?yield]\r\n             */\r\n            const unaryOperator = token();\r\n            const simpleUnaryExpression = parseSimpleUnaryExpression();\r\n            if (token() === SyntaxKind.AsteriskAsteriskToken) {\r\n                const start = skipTrivia(sourceText, simpleUnaryExpression.pos);\r\n                if (simpleUnaryExpression.kind === SyntaxKind.TypeAssertionExpression) {\r\n                    parseErrorAtPosition(start, simpleUnaryExpression.end - start, Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);\r\n                }\r\n                else {\r\n                    parseErrorAtPosition(start, simpleUnaryExpression.end - start, Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, tokenToString(unaryOperator));\r\n                }\r\n            }\r\n            return simpleUnaryExpression;\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 simple-unary expression or higher:\r\n         *\r\n         * ES7 UnaryExpression:\r\n         *      1) UpdateExpression[?yield]\r\n         *      2) delete UnaryExpression[?yield]\r\n         *      3) void UnaryExpression[?yield]\r\n         *      4) typeof UnaryExpression[?yield]\r\n         *      5) + UnaryExpression[?yield]\r\n         *      6) - UnaryExpression[?yield]\r\n         *      7) ~ UnaryExpression[?yield]\r\n         *      8) ! UnaryExpression[?yield]\r\n         *      9) [+Await] await UnaryExpression[?yield]\r\n         */\r\n        function parseSimpleUnaryExpression(): UnaryExpression {\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                    return parsePrefixUnaryExpression();\r\n                case SyntaxKind.DeleteKeyword:\r\n                    return parseDeleteExpression();\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return parseTypeOfExpression();\r\n                case SyntaxKind.VoidKeyword:\r\n                    return parseVoidExpression();\r\n                case SyntaxKind.LessThanToken:\r\n                    // This is modified UnaryExpression grammar in TypeScript\r\n                    //  UnaryExpression (modified):\r\n                    //      < type > UnaryExpression\r\n                    return parseTypeAssertion();\r\n                case SyntaxKind.AwaitKeyword:\r\n                    if (isAwaitExpression()) {\r\n                        return parseAwaitExpression();\r\n                    }\r\n                // falls through\r\n                default:\r\n                    return parseUpdateExpression();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the current token can possibly be an ES7 increment expression.\r\n         *\r\n         * ES7 UpdateExpression:\r\n         *      LeftHandSideExpression[?Yield]\r\n         *      LeftHandSideExpression[?Yield][no LineTerminator here]++\r\n         *      LeftHandSideExpression[?Yield][no LineTerminator here]--\r\n         *      ++LeftHandSideExpression[?Yield]\r\n         *      --LeftHandSideExpression[?Yield]\r\n         */\r\n        function isUpdateExpression(): boolean {\r\n            // This function is called inside parseUnaryExpression to decide\r\n            // whether to call parseSimpleUnaryExpression or call parseUpdateExpression directly\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.AwaitKeyword:\r\n                    return false;\r\n                case SyntaxKind.LessThanToken:\r\n                    // If we are not in JSX context, we are parsing TypeAssertion which is an UnaryExpression\r\n                    if (sourceFile.languageVariant !== LanguageVariant.JSX) {\r\n                        return false;\r\n                    }\r\n                // We are in JSX context and the token is part of JSXElement.\r\n                // falls through\r\n                default:\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 UpdateExpression. UpdateExpression is used instead of ES6's PostFixExpression.\r\n         *\r\n         * ES7 UpdateExpression[yield]:\r\n         *      1) LeftHandSideExpression[?yield]\r\n         *      2) LeftHandSideExpression[?yield] [[no LineTerminator here]]++\r\n         *      3) LeftHandSideExpression[?yield] [[no LineTerminator here]]--\r\n         *      4) ++LeftHandSideExpression[?yield]\r\n         *      5) --LeftHandSideExpression[?yield]\r\n         * In TypeScript (2), (3) are parsed as PostfixUnaryExpression. (4), (5) are parsed as PrefixUnaryExpression\r\n         */\r\n        function parseUpdateExpression(): UpdateExpression {\r\n            if (token() === SyntaxKind.PlusPlusToken || token() === SyntaxKind.MinusMinusToken) {\r\n                const node = <PrefixUnaryExpression>createNode(SyntaxKind.PrefixUnaryExpression);\r\n                node.operator = <PrefixUnaryOperator>token();\r\n                nextToken();\r\n                node.operand = parseLeftHandSideExpressionOrHigher();\r\n                return finishNode(node);\r\n            }\r\n            else if (sourceFile.languageVariant === LanguageVariant.JSX && token() === SyntaxKind.LessThanToken && lookAhead(nextTokenIsIdentifierOrKeyword)) {\r\n                // JSXElement is part of primaryExpression\r\n                return parseJsxElementOrSelfClosingElement(/*inExpressionContext*/ true);\r\n            }\r\n\r\n            const expression = parseLeftHandSideExpressionOrHigher();\r\n\r\n            Debug.assert(isLeftHandSideExpression(expression));\r\n            if ((token() === SyntaxKind.PlusPlusToken || token() === SyntaxKind.MinusMinusToken) && !scanner.hasPrecedingLineBreak()) {\r\n                const node = <PostfixUnaryExpression>createNode(SyntaxKind.PostfixUnaryExpression, expression.pos);\r\n                node.operand = expression;\r\n                node.operator = <PostfixUnaryOperator>token();\r\n                nextToken();\r\n                return finishNode(node);\r\n            }\r\n\r\n            return expression;\r\n        }\r\n\r\n        function parseLeftHandSideExpressionOrHigher(): LeftHandSideExpression {\r\n            // Original Ecma:\r\n            // LeftHandSideExpression: See 11.2\r\n            //      NewExpression\r\n            //      CallExpression\r\n            //\r\n            // Our simplification:\r\n            //\r\n            // LeftHandSideExpression: See 11.2\r\n            //      MemberExpression\r\n            //      CallExpression\r\n            //\r\n            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with\r\n            // MemberExpression to make our lives easier.\r\n            //\r\n            // to best understand the below code, it's important to see how CallExpression expands\r\n            // out into its own productions:\r\n            //\r\n            // CallExpression:\r\n            //      MemberExpression Arguments\r\n            //      CallExpression Arguments\r\n            //      CallExpression[Expression]\r\n            //      CallExpression.IdentifierName\r\n            //      import (AssignmentExpression)\r\n            //      super Arguments\r\n            //      super.IdentifierName\r\n            //\r\n            // Because of the recursion in these calls, we need to bottom out first. There are three\r\n            // bottom out states we can run into: 1) We see 'super' which must start either of\r\n            // the last two CallExpression productions. 2) We see 'import' which must start import call.\r\n            // 3)we have a MemberExpression which either completes the LeftHandSideExpression,\r\n            // or starts the beginning of the first four CallExpression productions.\r\n            let expression: MemberExpression;\r\n            if (token() === SyntaxKind.ImportKeyword && lookAhead(nextTokenIsOpenParenOrLessThan)) {\r\n                // We don't want to eagerly consume all import keyword as import call expression so we look a head to find \"(\"\r\n                // For example:\r\n                //      var foo3 = require(\"subfolder\r\n                //      import * as foo1 from \"module-from-node  -> we want this import to be a statement rather than import call expression\r\n                sourceFile.flags |= NodeFlags.PossiblyContainsDynamicImport;\r\n                expression = parseTokenNode<PrimaryExpression>();\r\n            }\r\n            else {\r\n                expression = token() === SyntaxKind.SuperKeyword ? parseSuperExpression() : parseMemberExpressionOrHigher();\r\n            }\r\n\r\n            // Now, we *may* be complete.  However, we might have consumed the start of a\r\n            // CallExpression.  As such, we need to consume the rest of it here to be complete.\r\n            return parseCallExpressionRest(expression);\r\n        }\r\n\r\n        function parseMemberExpressionOrHigher(): MemberExpression {\r\n            // Note: to make our lives simpler, we decompose the NewExpression productions and\r\n            // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.\r\n            // like so:\r\n            //\r\n            //   PrimaryExpression : See 11.1\r\n            //      this\r\n            //      Identifier\r\n            //      Literal\r\n            //      ArrayLiteral\r\n            //      ObjectLiteral\r\n            //      (Expression)\r\n            //      FunctionExpression\r\n            //      new MemberExpression Arguments?\r\n            //\r\n            //   MemberExpression : See 11.2\r\n            //      PrimaryExpression\r\n            //      MemberExpression[Expression]\r\n            //      MemberExpression.IdentifierName\r\n            //\r\n            //   CallExpression : See 11.2\r\n            //      MemberExpression\r\n            //      CallExpression Arguments\r\n            //      CallExpression[Expression]\r\n            //      CallExpression.IdentifierName\r\n            //\r\n            // Technically this is ambiguous.  i.e. CallExpression defines:\r\n            //\r\n            //   CallExpression:\r\n            //      CallExpression Arguments\r\n            //\r\n            // If you see: \"new Foo()\"\r\n            //\r\n            // Then that could be treated as a single ObjectCreationExpression, or it could be\r\n            // treated as the invocation of \"new Foo\".  We disambiguate that in code (to match\r\n            // the original grammar) by making sure that if we see an ObjectCreationExpression\r\n            // we always consume arguments if they are there. So we treat \"new Foo()\" as an\r\n            // object creation only, and not at all as an invocation)  Another way to think\r\n            // about this is that for every \"new\" that we see, we will consume an argument list if\r\n            // it is there as part of the *associated* object creation node.  Any additional\r\n            // argument lists we see, will become invocation expressions.\r\n            //\r\n            // Because there are no other places in the grammar now that refer to FunctionExpression\r\n            // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression\r\n            // production.\r\n            //\r\n            // Because CallExpression and MemberExpression are left recursive, we need to bottom out\r\n            // of the recursion immediately.  So we parse out a primary expression to start with.\r\n            const expression = parsePrimaryExpression();\r\n            return parseMemberExpressionRest(expression);\r\n        }\r\n\r\n        function parseSuperExpression(): MemberExpression {\r\n            const expression = parseTokenNode<PrimaryExpression>();\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.DotToken || token() === SyntaxKind.OpenBracketToken) {\r\n                return expression;\r\n            }\r\n\r\n            // If we have seen \"super\" it must be followed by '(' or '.'.\r\n            // If it wasn't then just try to parse out a '.' and report an error.\r\n            const node = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n            node.expression = expression;\r\n            parseExpectedToken(SyntaxKind.DotToken, /*reportAtCurrentPosition*/ false, Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);\r\n            node.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function tagNamesAreEquivalent(lhs: JsxTagNameExpression, rhs: JsxTagNameExpression): boolean {\r\n            if (lhs.kind !== rhs.kind) {\r\n                return false;\r\n            }\r\n\r\n            if (lhs.kind === SyntaxKind.Identifier) {\r\n                return (<Identifier>lhs).escapedText === (<Identifier>rhs).escapedText;\r\n            }\r\n\r\n            if (lhs.kind === SyntaxKind.ThisKeyword) {\r\n                return true;\r\n            }\r\n\r\n            // If we are at this statement then we must have PropertyAccessExpression and because tag name in Jsx element can only\r\n            // take forms of JsxTagNameExpression which includes an identifier, \"this\" expression, or another propertyAccessExpression\r\n            // it is safe to case the expression property as such. See parseJsxElementName for how we parse tag name in Jsx element\r\n            return (<PropertyAccessExpression>lhs).name.escapedText === (<PropertyAccessExpression>rhs).name.escapedText &&\r\n                tagNamesAreEquivalent((<PropertyAccessExpression>lhs).expression as JsxTagNameExpression, (<PropertyAccessExpression>rhs).expression as JsxTagNameExpression);\r\n        }\r\n\r\n\r\n        function parseJsxElementOrSelfClosingElement(inExpressionContext: boolean): JsxElement | JsxSelfClosingElement {\r\n            const opening = parseJsxOpeningOrSelfClosingElement(inExpressionContext);\r\n            let result: JsxElement | JsxSelfClosingElement;\r\n            if (opening.kind === SyntaxKind.JsxOpeningElement) {\r\n                const node = <JsxElement>createNode(SyntaxKind.JsxElement, opening.pos);\r\n                node.openingElement = opening;\r\n\r\n                node.children = parseJsxChildren(node.openingElement.tagName);\r\n                node.closingElement = parseJsxClosingElement(inExpressionContext);\r\n\r\n                if (!tagNamesAreEquivalent(node.openingElement.tagName, node.closingElement.tagName)) {\r\n                    parseErrorAtPosition(node.closingElement.pos, node.closingElement.end - node.closingElement.pos, Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, getTextOfNodeFromSourceText(sourceText, node.openingElement.tagName));\r\n                }\r\n\r\n                result = finishNode(node);\r\n            }\r\n            else {\r\n                Debug.assert(opening.kind === SyntaxKind.JsxSelfClosingElement);\r\n                // Nothing else to do for self-closing elements\r\n                result = <JsxSelfClosingElement>opening;\r\n            }\r\n\r\n            // If the user writes the invalid code '<div></div><div></div>' in an expression context (i.e. not wrapped in\r\n            // an enclosing tag), we'll naively try to parse   ^ this as a 'less than' operator and the remainder of the tag\r\n            // as garbage, which will cause the formatter to badly mangle the JSX. Perform a speculative parse of a JSX\r\n            // element if we see a < token so that we can wrap it in a synthetic binary expression so the formatter\r\n            // does less damage and we can report a better error.\r\n            // Since JSX elements are invalid < operands anyway, this lookahead parse will only occur in error scenarios\r\n            // of one sort or another.\r\n            if (inExpressionContext && token() === SyntaxKind.LessThanToken) {\r\n                const invalidElement = tryParse(() => parseJsxElementOrSelfClosingElement(/*inExpressionContext*/ true));\r\n                if (invalidElement) {\r\n                    parseErrorAtCurrentToken(Diagnostics.JSX_expressions_must_have_one_parent_element);\r\n                    const badNode = <BinaryExpression>createNode(SyntaxKind.BinaryExpression, result.pos);\r\n                    badNode.end = invalidElement.end;\r\n                    badNode.left = result;\r\n                    badNode.right = invalidElement;\r\n                    badNode.operatorToken = <BinaryOperatorToken>createMissingNode(SyntaxKind.CommaToken, /*reportAtCurrentPosition*/ false, /*diagnosticMessage*/ undefined);\r\n                    badNode.operatorToken.pos = badNode.operatorToken.end = badNode.right.pos;\r\n                    return <JsxElement><Node>badNode;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function parseJsxText(): JsxText {\r\n            const node = <JsxText>createNode(SyntaxKind.JsxText, scanner.getStartPos());\r\n            node.containsOnlyWhiteSpaces = currentToken === SyntaxKind.JsxTextAllWhiteSpaces;\r\n            currentToken = scanner.scanJsxToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxChild(): JsxChild {\r\n            switch (token()) {\r\n                case SyntaxKind.JsxText:\r\n                case SyntaxKind.JsxTextAllWhiteSpaces:\r\n                    return parseJsxText();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseJsxExpression(/*inExpressionContext*/ false);\r\n                case SyntaxKind.LessThanToken:\r\n                    return parseJsxElementOrSelfClosingElement(/*inExpressionContext*/ false);\r\n            }\r\n            Debug.fail(\"Unknown JSX child kind \" + token());\r\n        }\r\n\r\n        function parseJsxChildren(openingTagName: LeftHandSideExpression): NodeArray<JsxChild> {\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << ParsingContext.JsxChildren;\r\n\r\n            while (true) {\r\n                currentToken = scanner.reScanJsxToken();\r\n                if (token() === SyntaxKind.LessThanSlashToken) {\r\n                    // Closing tag\r\n                    break;\r\n                }\r\n                else if (token() === SyntaxKind.EndOfFileToken) {\r\n                    // If we hit EOF, issue the error at the tag that lacks the closing element\r\n                    // rather than at the end of the file (which is useless)\r\n                    parseErrorAtPosition(openingTagName.pos, openingTagName.end - openingTagName.pos, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, openingTagName));\r\n                    break;\r\n                }\r\n                else if (token() === SyntaxKind.ConflictMarkerTrivia) {\r\n                    break;\r\n                }\r\n                const child = parseJsxChild();\r\n                if (child) {\r\n                    list.push(child);\r\n                }\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n\r\n            return createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseJsxAttributes(): JsxAttributes {\r\n            const jsxAttributes = <JsxAttributes>createNode(SyntaxKind.JsxAttributes);\r\n            jsxAttributes.properties = parseList(ParsingContext.JsxAttributes, parseJsxAttribute);\r\n            return finishNode(jsxAttributes);\r\n        }\r\n\r\n        function parseJsxOpeningOrSelfClosingElement(inExpressionContext: boolean): JsxOpeningElement | JsxSelfClosingElement {\r\n            const fullStart = scanner.getStartPos();\r\n\r\n            parseExpected(SyntaxKind.LessThanToken);\r\n\r\n            const tagName = parseJsxElementName();\r\n            const attributes = parseJsxAttributes();\r\n\r\n            let node: JsxOpeningLikeElement;\r\n\r\n            if (token() === SyntaxKind.GreaterThanToken) {\r\n                // Closing tag, so scan the immediately-following text with the JSX scanning instead\r\n                // of regular scanning to avoid treating illegal characters (e.g. '#') as immediate\r\n                // scanning errors\r\n                node = <JsxOpeningElement>createNode(SyntaxKind.JsxOpeningElement, fullStart);\r\n                scanJsxText();\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.SlashToken);\r\n                if (inExpressionContext) {\r\n                    parseExpected(SyntaxKind.GreaterThanToken);\r\n                }\r\n                else {\r\n                    parseExpected(SyntaxKind.GreaterThanToken, /*diagnostic*/ undefined, /*shouldAdvance*/ false);\r\n                    scanJsxText();\r\n                }\r\n                node = <JsxSelfClosingElement>createNode(SyntaxKind.JsxSelfClosingElement, fullStart);\r\n            }\r\n\r\n            node.tagName = tagName;\r\n            node.attributes = attributes;\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxElementName(): JsxTagNameExpression {\r\n            scanJsxIdentifier();\r\n            // JsxElement can have name in the form of\r\n            //      propertyAccessExpression\r\n            //      primaryExpression in the form of an identifier and \"this\" keyword\r\n            // We can't just simply use parseLeftHandSideExpressionOrHigher because then we will start consider class,function etc as a keyword\r\n            // We only want to consider \"this\" as a primaryExpression\r\n            let expression: JsxTagNameExpression = token() === SyntaxKind.ThisKeyword ?\r\n                parseTokenNode<PrimaryExpression>() : parseIdentifierName();\r\n            while (parseOptional(SyntaxKind.DotToken)) {\r\n                const propertyAccess: PropertyAccessExpression = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n                propertyAccess.expression = expression;\r\n                propertyAccess.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n                expression = finishNode(propertyAccess);\r\n            }\r\n            return expression;\r\n        }\r\n\r\n        function parseJsxExpression(inExpressionContext: boolean): JsxExpression {\r\n            const node = <JsxExpression>createNode(SyntaxKind.JsxExpression);\r\n\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            if (token() !== SyntaxKind.CloseBraceToken) {\r\n                node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n                node.expression = parseAssignmentExpressionOrHigher();\r\n            }\r\n            if (inExpressionContext) {\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.CloseBraceToken, /*message*/ undefined, /*shouldAdvance*/ false);\r\n                scanJsxText();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxAttribute(): JsxAttribute | JsxSpreadAttribute {\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseJsxSpreadAttribute();\r\n            }\r\n\r\n            scanJsxIdentifier();\r\n            const node = <JsxAttribute>createNode(SyntaxKind.JsxAttribute);\r\n            node.name = parseIdentifierName();\r\n            if (token() === SyntaxKind.EqualsToken) {\r\n                switch (scanJsxAttributeValue()) {\r\n                    case SyntaxKind.StringLiteral:\r\n                        node.initializer = <StringLiteral>parseLiteralNode();\r\n                        break;\r\n                    default:\r\n                        node.initializer = parseJsxExpression(/*inExpressionContext*/ true);\r\n                        break;\r\n                }\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxSpreadAttribute(): JsxSpreadAttribute {\r\n            const node = <JsxSpreadAttribute>createNode(SyntaxKind.JsxSpreadAttribute);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            parseExpected(SyntaxKind.DotDotDotToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxClosingElement(inExpressionContext: boolean): JsxClosingElement {\r\n            const node = <JsxClosingElement>createNode(SyntaxKind.JsxClosingElement);\r\n            parseExpected(SyntaxKind.LessThanSlashToken);\r\n            node.tagName = parseJsxElementName();\r\n            if (inExpressionContext) {\r\n                parseExpected(SyntaxKind.GreaterThanToken);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.GreaterThanToken, /*diagnostic*/ undefined, /*shouldAdvance*/ false);\r\n                scanJsxText();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeAssertion(): TypeAssertion {\r\n            const node = <TypeAssertion>createNode(SyntaxKind.TypeAssertionExpression);\r\n            parseExpected(SyntaxKind.LessThanToken);\r\n            node.type = parseType();\r\n            parseExpected(SyntaxKind.GreaterThanToken);\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseMemberExpressionRest(expression: LeftHandSideExpression): MemberExpression {\r\n            while (true) {\r\n                const dotToken = parseOptionalToken(SyntaxKind.DotToken);\r\n                if (dotToken) {\r\n                    const propertyAccess = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n                    propertyAccess.expression = expression;\r\n                    propertyAccess.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n                    expression = finishNode(propertyAccess);\r\n                    continue;\r\n                }\r\n\r\n                if (token() === SyntaxKind.ExclamationToken && !scanner.hasPrecedingLineBreak()) {\r\n                    nextToken();\r\n                    const nonNullExpression = <NonNullExpression>createNode(SyntaxKind.NonNullExpression, expression.pos);\r\n                    nonNullExpression.expression = expression;\r\n                    expression = finishNode(nonNullExpression);\r\n                    continue;\r\n                }\r\n\r\n                // when in the [Decorator] context, we do not parse ElementAccess as it could be part of a ComputedPropertyName\r\n                if (!inDecoratorContext() && parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                    const indexedAccess = <ElementAccessExpression>createNode(SyntaxKind.ElementAccessExpression, expression.pos);\r\n                    indexedAccess.expression = expression;\r\n\r\n                    // It's not uncommon for a user to write: \"new Type[]\".\r\n                    // Check for that common pattern and report a better error message.\r\n                    if (token() !== SyntaxKind.CloseBracketToken) {\r\n                        indexedAccess.argumentExpression = allowInAnd(parseExpression);\r\n                        if (indexedAccess.argumentExpression.kind === SyntaxKind.StringLiteral || indexedAccess.argumentExpression.kind === SyntaxKind.NumericLiteral) {\r\n                            const literal = <LiteralExpression>indexedAccess.argumentExpression;\r\n                            literal.text = internIdentifier(literal.text);\r\n                        }\r\n                    }\r\n\r\n                    parseExpected(SyntaxKind.CloseBracketToken);\r\n                    expression = finishNode(indexedAccess);\r\n                    continue;\r\n                }\r\n\r\n                if (token() === SyntaxKind.NoSubstitutionTemplateLiteral || token() === SyntaxKind.TemplateHead) {\r\n                    const tagExpression = <TaggedTemplateExpression>createNode(SyntaxKind.TaggedTemplateExpression, expression.pos);\r\n                    tagExpression.tag = expression;\r\n                    tagExpression.template = token() === SyntaxKind.NoSubstitutionTemplateLiteral\r\n                        ? <NoSubstitutionTemplateLiteral>parseLiteralNode()\r\n                        : parseTemplateExpression();\r\n                    expression = finishNode(tagExpression);\r\n                    continue;\r\n                }\r\n\r\n                return <MemberExpression>expression;\r\n            }\r\n        }\r\n\r\n        function parseCallExpressionRest(expression: LeftHandSideExpression): LeftHandSideExpression {\r\n            while (true) {\r\n                expression = parseMemberExpressionRest(expression);\r\n                if (token() === SyntaxKind.LessThanToken) {\r\n                    // See if this is the start of a generic invocation.  If so, consume it and\r\n                    // keep checking for postfix expressions.  Otherwise, it's just a '<' that's\r\n                    // part of an arithmetic expression.  Break out so we consume it higher in the\r\n                    // stack.\r\n                    const typeArguments = tryParse(parseTypeArgumentsInExpression);\r\n                    if (!typeArguments) {\r\n                        return expression;\r\n                    }\r\n\r\n                    const callExpr = <CallExpression>createNode(SyntaxKind.CallExpression, expression.pos);\r\n                    callExpr.expression = expression;\r\n                    callExpr.typeArguments = typeArguments;\r\n                    callExpr.arguments = parseArgumentList();\r\n                    expression = finishNode(callExpr);\r\n                    continue;\r\n                }\r\n                else if (token() === SyntaxKind.OpenParenToken) {\r\n                    const callExpr = <CallExpression>createNode(SyntaxKind.CallExpression, expression.pos);\r\n                    callExpr.expression = expression;\r\n                    callExpr.arguments = parseArgumentList();\r\n                    expression = finishNode(callExpr);\r\n                    continue;\r\n                }\r\n\r\n                return expression;\r\n            }\r\n        }\r\n\r\n        function parseArgumentList() {\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            const result = parseDelimitedList(ParsingContext.ArgumentExpressions, parseArgumentExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return result;\r\n        }\r\n\r\n        function parseTypeArgumentsInExpression() {\r\n            if (!parseOptional(SyntaxKind.LessThanToken)) {\r\n                return undefined;\r\n            }\r\n\r\n            const typeArguments = parseDelimitedList(ParsingContext.TypeArguments, parseType);\r\n            if (!parseExpected(SyntaxKind.GreaterThanToken)) {\r\n                // If it doesn't have the closing >  then it's definitely not an type argument list.\r\n                return undefined;\r\n            }\r\n\r\n            // If we have a '<', then only parse this as a argument list if the type arguments\r\n            // are complete and we have an open paren.  if we don't, rewind and return nothing.\r\n            return typeArguments && canFollowTypeArgumentsInExpression()\r\n                ? typeArguments\r\n                : undefined;\r\n        }\r\n\r\n        function canFollowTypeArgumentsInExpression(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.OpenParenToken:                 // foo<x>(\r\n                // this case are the only case where this token can legally follow a type argument\r\n                // list.  So we definitely want to treat this as a type arg list.\r\n\r\n                case SyntaxKind.DotToken:                       // foo<x>.\r\n                case SyntaxKind.CloseParenToken:                // foo<x>)\r\n                case SyntaxKind.CloseBracketToken:              // foo<x>]\r\n                case SyntaxKind.ColonToken:                     // foo<x>:\r\n                case SyntaxKind.SemicolonToken:                 // foo<x>;\r\n                case SyntaxKind.QuestionToken:                  // foo<x>?\r\n                case SyntaxKind.EqualsEqualsToken:              // foo<x> ==\r\n                case SyntaxKind.EqualsEqualsEqualsToken:        // foo<x> ===\r\n                case SyntaxKind.ExclamationEqualsToken:         // foo<x> !=\r\n                case SyntaxKind.ExclamationEqualsEqualsToken:   // foo<x> !==\r\n                case SyntaxKind.AmpersandAmpersandToken:        // foo<x> &&\r\n                case SyntaxKind.BarBarToken:                    // foo<x> ||\r\n                case SyntaxKind.CaretToken:                     // foo<x> ^\r\n                case SyntaxKind.AmpersandToken:                 // foo<x> &\r\n                case SyntaxKind.BarToken:                       // foo<x> |\r\n                case SyntaxKind.CloseBraceToken:                // foo<x> }\r\n                case SyntaxKind.EndOfFileToken:                 // foo<x>\r\n                    // these cases can't legally follow a type arg list.  However, they're not legal\r\n                    // expressions either.  The user is probably in the middle of a generic type. So\r\n                    // treat it as such.\r\n                    return true;\r\n\r\n                case SyntaxKind.CommaToken:                     // foo<x>,\r\n                case SyntaxKind.OpenBraceToken:                 // foo<x> {\r\n                // We don't want to treat these as type arguments.  Otherwise we'll parse this\r\n                // as an invocation expression.  Instead, we want to parse out the expression\r\n                // in isolation from the type arguments.\r\n\r\n                default:\r\n                    // Anything else treat as an expression.\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        function parsePrimaryExpression(): PrimaryExpression {\r\n            switch (token()) {\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                    return parseLiteralNode();\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return parseTokenNode<PrimaryExpression>();\r\n                case SyntaxKind.OpenParenToken:\r\n                    return parseParenthesizedExpression();\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseArrayLiteralExpression();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseObjectLiteralExpression();\r\n                case SyntaxKind.AsyncKeyword:\r\n                    // Async arrow functions are parsed earlier in parseAssignmentExpressionOrHigher.\r\n                    // If we encounter `async [no LineTerminator here] function` then this is an async\r\n                    // function; otherwise, its an identifier.\r\n                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {\r\n                        break;\r\n                    }\r\n\r\n                    return parseFunctionExpression();\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassExpression();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionExpression();\r\n                case SyntaxKind.NewKeyword:\r\n                    return parseNewExpression();\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                    if (reScanSlashToken() === SyntaxKind.RegularExpressionLiteral) {\r\n                        return parseLiteralNode();\r\n                    }\r\n                    break;\r\n                case SyntaxKind.TemplateHead:\r\n                    return parseTemplateExpression();\r\n            }\r\n\r\n            return parseIdentifier(Diagnostics.Expression_expected);\r\n        }\r\n\r\n        function parseParenthesizedExpression(): ParenthesizedExpression {\r\n            const node = <ParenthesizedExpression>createNode(SyntaxKind.ParenthesizedExpression);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseSpreadElement(): Expression {\r\n            const node = <SpreadElement>createNode(SyntaxKind.SpreadElement);\r\n            parseExpected(SyntaxKind.DotDotDotToken);\r\n            node.expression = parseAssignmentExpressionOrHigher();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseArgumentOrArrayLiteralElement(): Expression {\r\n            return token() === SyntaxKind.DotDotDotToken ? parseSpreadElement() :\r\n                token() === SyntaxKind.CommaToken ? <Expression>createNode(SyntaxKind.OmittedExpression) :\r\n                    parseAssignmentExpressionOrHigher();\r\n        }\r\n\r\n        function parseArgumentExpression(): Expression {\r\n            return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);\r\n        }\r\n\r\n        function parseArrayLiteralExpression(): ArrayLiteralExpression {\r\n            const node = <ArrayLiteralExpression>createNode(SyntaxKind.ArrayLiteralExpression);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                node.multiLine = true;\r\n            }\r\n            node.elements = parseDelimitedList(ParsingContext.ArrayLiteralMembers, parseArgumentOrArrayLiteralElement);\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function tryParseAccessorDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): AccessorDeclaration | undefined {\r\n            if (parseContextualModifier(SyntaxKind.GetKeyword)) {\r\n                return parseAccessorDeclaration(SyntaxKind.GetAccessor, fullStart, decorators, modifiers);\r\n            }\r\n            else if (parseContextualModifier(SyntaxKind.SetKeyword)) {\r\n                return parseAccessorDeclaration(SyntaxKind.SetAccessor, fullStart, decorators, modifiers);\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function parseObjectLiteralElement(): ObjectLiteralElementLike {\r\n            const fullStart = scanner.getStartPos();\r\n            const dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            if (dotDotDotToken) {\r\n                const spreadElement = <SpreadAssignment>createNode(SyntaxKind.SpreadAssignment, fullStart);\r\n                spreadElement.expression = parseAssignmentExpressionOrHigher();\r\n                return addJSDocComment(finishNode(spreadElement));\r\n            }\r\n            const decorators = parseDecorators();\r\n            const modifiers = parseModifiers();\r\n\r\n            const accessor = tryParseAccessorDeclaration(fullStart, decorators, modifiers);\r\n            if (accessor) {\r\n                return accessor;\r\n            }\r\n\r\n            const asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            const tokenIsIdentifier = isIdentifier();\r\n            const propertyName = parsePropertyName();\r\n\r\n            // Disallowing of optional property assignments happens in the grammar checker.\r\n            const questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (asteriskToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseMethodDeclaration(fullStart, decorators, modifiers, asteriskToken, propertyName, questionToken);\r\n            }\r\n\r\n            // check if it is short-hand property assignment or normal property assignment\r\n            // NOTE: if token is EqualsToken it is interpreted as CoverInitializedName production\r\n            // CoverInitializedName[Yield] :\r\n            //     IdentifierReference[?Yield] Initializer[In, ?Yield]\r\n            // this is necessary because ObjectLiteral productions are also used to cover grammar for ObjectAssignmentPattern\r\n            const isShorthandPropertyAssignment =\r\n                tokenIsIdentifier && (token() === SyntaxKind.CommaToken || token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.EqualsToken);\r\n\r\n            if (isShorthandPropertyAssignment) {\r\n                const shorthandDeclaration = <ShorthandPropertyAssignment>createNode(SyntaxKind.ShorthandPropertyAssignment, fullStart);\r\n                shorthandDeclaration.name = <Identifier>propertyName;\r\n                shorthandDeclaration.questionToken = questionToken;\r\n                const equalsToken = parseOptionalToken(SyntaxKind.EqualsToken);\r\n                if (equalsToken) {\r\n                    shorthandDeclaration.equalsToken = equalsToken;\r\n                    shorthandDeclaration.objectAssignmentInitializer = allowInAnd(parseAssignmentExpressionOrHigher);\r\n                }\r\n                return addJSDocComment(finishNode(shorthandDeclaration));\r\n            }\r\n            else {\r\n                const propertyAssignment = <PropertyAssignment>createNode(SyntaxKind.PropertyAssignment, fullStart);\r\n                propertyAssignment.modifiers = modifiers;\r\n                propertyAssignment.name = propertyName;\r\n                propertyAssignment.questionToken = questionToken;\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                propertyAssignment.initializer = allowInAnd(parseAssignmentExpressionOrHigher);\r\n                return addJSDocComment(finishNode(propertyAssignment));\r\n            }\r\n        }\r\n\r\n        function parseObjectLiteralExpression(): ObjectLiteralExpression {\r\n            const node = <ObjectLiteralExpression>createNode(SyntaxKind.ObjectLiteralExpression);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                node.multiLine = true;\r\n            }\r\n\r\n            node.properties = parseDelimitedList(ParsingContext.ObjectLiteralMembers, parseObjectLiteralElement, /*considerSemicolonAsDelimiter*/ true);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionExpression(): FunctionExpression {\r\n            // GeneratorExpression:\r\n            //      function* BindingIdentifier [Yield][opt](FormalParameters[Yield]){ GeneratorBody }\r\n            //\r\n            // FunctionExpression:\r\n            //      function BindingIdentifier[opt](FormalParameters){ FunctionBody }\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            const node = <FunctionExpression>createNode(SyntaxKind.FunctionExpression);\r\n            node.modifiers = parseModifiers();\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n\r\n            const isGenerator = node.asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            node.name =\r\n                isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalIdentifier) :\r\n                    isGenerator ? doInYieldContext(parseOptionalIdentifier) :\r\n                        isAsync ? doInAwaitContext(parseOptionalIdentifier) :\r\n                            parseOptionalIdentifier();\r\n\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, node);\r\n            node.body = parseFunctionBlock(isGenerator | isAsync);\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseOptionalIdentifier(): Identifier | undefined {\r\n            return isIdentifier() ? parseIdentifier() : undefined;\r\n        }\r\n\r\n        function parseNewExpression(): NewExpression | MetaProperty {\r\n            const fullStart = scanner.getStartPos();\r\n            parseExpected(SyntaxKind.NewKeyword);\r\n            if (parseOptional(SyntaxKind.DotToken)) {\r\n                const node = <MetaProperty>createNode(SyntaxKind.MetaProperty, fullStart);\r\n                node.keywordToken = SyntaxKind.NewKeyword;\r\n                node.name = parseIdentifierName();\r\n                return finishNode(node);\r\n            }\r\n\r\n            const node = <NewExpression>createNode(SyntaxKind.NewExpression, fullStart);\r\n            node.expression = parseMemberExpressionOrHigher();\r\n            node.typeArguments = tryParse(parseTypeArgumentsInExpression);\r\n            if (node.typeArguments || token() === SyntaxKind.OpenParenToken) {\r\n                node.arguments = parseArgumentList();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        // STATEMENTS\r\n        function parseBlock(ignoreMissingOpenBrace: boolean, diagnosticMessage?: DiagnosticMessage): Block {\r\n            const node = <Block>createNode(SyntaxKind.Block);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken, diagnosticMessage) || ignoreMissingOpenBrace) {\r\n                if (scanner.hasPrecedingLineBreak()) {\r\n                    node.multiLine = true;\r\n                }\r\n\r\n                node.statements = parseList(ParsingContext.BlockStatements, parseStatement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionBlock(flags: SignatureFlags, diagnosticMessage?: DiagnosticMessage): Block {\r\n            const savedYieldContext = inYieldContext();\r\n            setYieldContext(!!(flags & SignatureFlags.Yield));\r\n\r\n            const savedAwaitContext = inAwaitContext();\r\n            setAwaitContext(!!(flags & SignatureFlags.Await));\r\n\r\n            // We may be in a [Decorator] context when parsing a function expression or\r\n            // arrow function. The body of the function is not in [Decorator] context.\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            const block = parseBlock(!!(flags & SignatureFlags.IgnoreMissingOpenBrace), diagnosticMessage);\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n\r\n            setYieldContext(savedYieldContext);\r\n            setAwaitContext(savedAwaitContext);\r\n\r\n            return block;\r\n        }\r\n\r\n        function parseEmptyStatement(): Statement {\r\n            const node = <Statement>createNode(SyntaxKind.EmptyStatement);\r\n            parseExpected(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseIfStatement(): IfStatement {\r\n            const node = <IfStatement>createNode(SyntaxKind.IfStatement);\r\n            parseExpected(SyntaxKind.IfKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.thenStatement = parseStatement();\r\n            node.elseStatement = parseOptional(SyntaxKind.ElseKeyword) ? parseStatement() : undefined;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDoStatement(): DoStatement {\r\n            const node = <DoStatement>createNode(SyntaxKind.DoStatement);\r\n            parseExpected(SyntaxKind.DoKeyword);\r\n            node.statement = parseStatement();\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n\r\n            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html\r\n            // 157 min --- All allen at wirfs-brock.com CONF --- \"do{;}while(false)false\" prohibited in\r\n            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby\r\n            //  do;while(0)x will have a semicolon inserted before x.\r\n            parseOptional(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWhileStatement(): WhileStatement {\r\n            const node = <WhileStatement>createNode(SyntaxKind.WhileStatement);\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.statement = parseStatement();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseForOrForInOrForOfStatement(): Statement {\r\n            const pos = getNodePos();\r\n            parseExpected(SyntaxKind.ForKeyword);\r\n            const awaitToken = parseOptionalToken(SyntaxKind.AwaitKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n\r\n            let initializer: VariableDeclarationList | Expression = undefined;\r\n            if (token() !== SyntaxKind.SemicolonToken) {\r\n                if (token() === SyntaxKind.VarKeyword || token() === SyntaxKind.LetKeyword || token() === SyntaxKind.ConstKeyword) {\r\n                    initializer = parseVariableDeclarationList(/*inForStatementInitializer*/ true);\r\n                }\r\n                else {\r\n                    initializer = disallowInAnd(parseExpression);\r\n                }\r\n            }\r\n            let forOrForInOrForOfStatement: IterationStatement;\r\n            if (awaitToken ? parseExpected(SyntaxKind.OfKeyword) : parseOptional(SyntaxKind.OfKeyword)) {\r\n                const forOfStatement = <ForOfStatement>createNode(SyntaxKind.ForOfStatement, pos);\r\n                forOfStatement.awaitModifier = awaitToken;\r\n                forOfStatement.initializer = initializer;\r\n                forOfStatement.expression = allowInAnd(parseAssignmentExpressionOrHigher);\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forOfStatement;\r\n            }\r\n            else if (parseOptional(SyntaxKind.InKeyword)) {\r\n                const forInStatement = <ForInStatement>createNode(SyntaxKind.ForInStatement, pos);\r\n                forInStatement.initializer = initializer;\r\n                forInStatement.expression = allowInAnd(parseExpression);\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forInStatement;\r\n            }\r\n            else {\r\n                const forStatement = <ForStatement>createNode(SyntaxKind.ForStatement, pos);\r\n                forStatement.initializer = initializer;\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token() !== SyntaxKind.SemicolonToken && token() !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.condition = allowInAnd(parseExpression);\r\n                }\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token() !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.incrementor = allowInAnd(parseExpression);\r\n                }\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forStatement;\r\n            }\r\n\r\n            forOrForInOrForOfStatement.statement = parseStatement();\r\n\r\n            return finishNode(forOrForInOrForOfStatement);\r\n        }\r\n\r\n        function parseBreakOrContinueStatement(kind: SyntaxKind): BreakOrContinueStatement {\r\n            const node = <BreakOrContinueStatement>createNode(kind);\r\n\r\n            parseExpected(kind === SyntaxKind.BreakStatement ? SyntaxKind.BreakKeyword : SyntaxKind.ContinueKeyword);\r\n            if (!canParseSemicolon()) {\r\n                node.label = parseIdentifier();\r\n            }\r\n\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseReturnStatement(): ReturnStatement {\r\n            const node = <ReturnStatement>createNode(SyntaxKind.ReturnStatement);\r\n\r\n            parseExpected(SyntaxKind.ReturnKeyword);\r\n            if (!canParseSemicolon()) {\r\n                node.expression = allowInAnd(parseExpression);\r\n            }\r\n\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWithStatement(): WithStatement {\r\n            const node = <WithStatement>createNode(SyntaxKind.WithStatement);\r\n            parseExpected(SyntaxKind.WithKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.statement = parseStatement();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCaseClause(): CaseClause {\r\n            const node = <CaseClause>createNode(SyntaxKind.CaseClause);\r\n            parseExpected(SyntaxKind.CaseKeyword);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDefaultClause(): DefaultClause {\r\n            const node = <DefaultClause>createNode(SyntaxKind.DefaultClause);\r\n            parseExpected(SyntaxKind.DefaultKeyword);\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCaseOrDefaultClause(): CaseOrDefaultClause {\r\n            return token() === SyntaxKind.CaseKeyword ? parseCaseClause() : parseDefaultClause();\r\n        }\r\n\r\n        function parseSwitchStatement(): SwitchStatement {\r\n            const node = <SwitchStatement>createNode(SyntaxKind.SwitchStatement);\r\n            parseExpected(SyntaxKind.SwitchKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            const caseBlock = <CaseBlock>createNode(SyntaxKind.CaseBlock, scanner.getStartPos());\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            caseBlock.clauses = parseList(ParsingContext.SwitchClauses, parseCaseOrDefaultClause);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            node.caseBlock = finishNode(caseBlock);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThrowStatement(): ThrowStatement {\r\n            // ThrowStatement[Yield] :\r\n            //      throw [no LineTerminator here]Expression[In, ?Yield];\r\n\r\n            // Because of automatic semicolon insertion, we need to report error if this\r\n            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'\r\n            // directly as that might consume an expression on the following line.\r\n            // We just return 'undefined' in that case.  The actual error will be reported in the\r\n            // grammar walker.\r\n            const node = <ThrowStatement>createNode(SyntaxKind.ThrowStatement);\r\n            parseExpected(SyntaxKind.ThrowKeyword);\r\n            node.expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        // TODO: Review for error recovery\r\n        function parseTryStatement(): TryStatement {\r\n            const node = <TryStatement>createNode(SyntaxKind.TryStatement);\r\n\r\n            parseExpected(SyntaxKind.TryKeyword);\r\n            node.tryBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            node.catchClause = token() === SyntaxKind.CatchKeyword ? parseCatchClause() : undefined;\r\n\r\n            // If we don't have a catch clause, then we must have a finally clause.  Try to parse\r\n            // one out no matter what.\r\n            if (!node.catchClause || token() === SyntaxKind.FinallyKeyword) {\r\n                parseExpected(SyntaxKind.FinallyKeyword);\r\n                node.finallyBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCatchClause(): CatchClause {\r\n            const result = <CatchClause>createNode(SyntaxKind.CatchClause);\r\n            parseExpected(SyntaxKind.CatchKeyword);\r\n\r\n            if (parseOptional(SyntaxKind.OpenParenToken)) {\r\n                result.variableDeclaration = parseVariableDeclaration();\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n            }\r\n            else {\r\n                // Keep shape of node to avoid degrading performance.\r\n                result.variableDeclaration = undefined;\r\n            }\r\n\r\n            result.block = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseDebuggerStatement(): Statement {\r\n            const node = <Statement>createNode(SyntaxKind.DebuggerStatement);\r\n            parseExpected(SyntaxKind.DebuggerKeyword);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExpressionOrLabeledStatement(): ExpressionStatement | LabeledStatement {\r\n            // Avoiding having to do the lookahead for a labeled statement by just trying to parse\r\n            // out an expression, seeing if it is identifier and then seeing if it is followed by\r\n            // a colon.\r\n            const fullStart = scanner.getStartPos();\r\n            const expression = allowInAnd(parseExpression);\r\n\r\n            if (expression.kind === SyntaxKind.Identifier && parseOptional(SyntaxKind.ColonToken)) {\r\n                const labeledStatement = <LabeledStatement>createNode(SyntaxKind.LabeledStatement, fullStart);\r\n                labeledStatement.label = <Identifier>expression;\r\n                labeledStatement.statement = parseStatement();\r\n                return addJSDocComment(finishNode(labeledStatement));\r\n            }\r\n            else {\r\n                const expressionStatement = <ExpressionStatement>createNode(SyntaxKind.ExpressionStatement, fullStart);\r\n                expressionStatement.expression = expression;\r\n                parseSemicolon();\r\n                return addJSDocComment(finishNode(expressionStatement));\r\n            }\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeywordOnSameLine() {\r\n            nextToken();\r\n            return tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsClassKeywordOnSameLine() {\r\n            nextToken();\r\n            return token() === SyntaxKind.ClassKeyword && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsFunctionKeywordOnSameLine() {\r\n            nextToken();\r\n            return token() === SyntaxKind.FunctionKeyword && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {\r\n            nextToken();\r\n            return (tokenIsIdentifierOrKeyword(token()) || token() === SyntaxKind.NumericLiteral || token() === SyntaxKind.StringLiteral) && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function isDeclaration(): boolean {\r\n            while (true) {\r\n                switch (token()) {\r\n                    case SyntaxKind.VarKeyword:\r\n                    case SyntaxKind.LetKeyword:\r\n                    case SyntaxKind.ConstKeyword:\r\n                    case SyntaxKind.FunctionKeyword:\r\n                    case SyntaxKind.ClassKeyword:\r\n                    case SyntaxKind.EnumKeyword:\r\n                        return true;\r\n\r\n                    // 'declare', 'module', 'namespace', 'interface'* and 'type' are all legal JavaScript identifiers;\r\n                    // however, an identifier cannot be followed by another identifier on the same line. This is what we\r\n                    // count on to parse out the respective declarations. For instance, we exploit this to say that\r\n                    //\r\n                    //    namespace n\r\n                    //\r\n                    // can be none other than the beginning of a namespace declaration, but need to respect that JavaScript sees\r\n                    //\r\n                    //    namespace\r\n                    //    n\r\n                    //\r\n                    // as the identifier 'namespace' on one line followed by the identifier 'n' on another.\r\n                    // We need to look one token ahead to see if it permissible to try parsing a declaration.\r\n                    //\r\n                    // *Note*: 'interface' is actually a strict mode reserved word. So while\r\n                    //\r\n                    //   \"use strict\"\r\n                    //   interface\r\n                    //   I {}\r\n                    //\r\n                    // could be legal, it would add complexity for very little gain.\r\n                    case SyntaxKind.InterfaceKeyword:\r\n                    case SyntaxKind.TypeKeyword:\r\n                        return nextTokenIsIdentifierOnSameLine();\r\n                    case SyntaxKind.ModuleKeyword:\r\n                    case SyntaxKind.NamespaceKeyword:\r\n                        return nextTokenIsIdentifierOrStringLiteralOnSameLine();\r\n                    case SyntaxKind.AbstractKeyword:\r\n                    case SyntaxKind.AsyncKeyword:\r\n                    case SyntaxKind.DeclareKeyword:\r\n                    case SyntaxKind.PrivateKeyword:\r\n                    case SyntaxKind.ProtectedKeyword:\r\n                    case SyntaxKind.PublicKeyword:\r\n                    case SyntaxKind.ReadonlyKeyword:\r\n                        nextToken();\r\n                        // ASI takes effect for this modifier.\r\n                        if (scanner.hasPrecedingLineBreak()) {\r\n                            return false;\r\n                        }\r\n                        continue;\r\n\r\n                    case SyntaxKind.GlobalKeyword:\r\n                        nextToken();\r\n                        return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.Identifier || token() === SyntaxKind.ExportKeyword;\r\n\r\n                    case SyntaxKind.ImportKeyword:\r\n                        nextToken();\r\n                        return token() === SyntaxKind.StringLiteral || token() === SyntaxKind.AsteriskToken ||\r\n                            token() === SyntaxKind.OpenBraceToken || tokenIsIdentifierOrKeyword(token());\r\n                    case SyntaxKind.ExportKeyword:\r\n                        nextToken();\r\n                        if (token() === SyntaxKind.EqualsToken || token() === SyntaxKind.AsteriskToken ||\r\n                            token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.DefaultKeyword ||\r\n                            token() === SyntaxKind.AsKeyword) {\r\n                            return true;\r\n                        }\r\n                        continue;\r\n\r\n                    case SyntaxKind.StaticKeyword:\r\n                        nextToken();\r\n                        continue;\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        function isStartOfDeclaration(): boolean {\r\n            return lookAhead(isDeclaration);\r\n        }\r\n\r\n        function isStartOfStatement(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.AtToken:\r\n                case SyntaxKind.SemicolonToken:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.LetKeyword:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                case SyntaxKind.IfKeyword:\r\n                case SyntaxKind.DoKeyword:\r\n                case SyntaxKind.WhileKeyword:\r\n                case SyntaxKind.ForKeyword:\r\n                case SyntaxKind.ContinueKeyword:\r\n                case SyntaxKind.BreakKeyword:\r\n                case SyntaxKind.ReturnKeyword:\r\n                case SyntaxKind.WithKeyword:\r\n                case SyntaxKind.SwitchKeyword:\r\n                case SyntaxKind.ThrowKeyword:\r\n                case SyntaxKind.TryKeyword:\r\n                case SyntaxKind.DebuggerKeyword:\r\n                // 'catch' and 'finally' do not actually indicate that the code is part of a statement,\r\n                // however, we say they are here so that we may gracefully parse them and error later.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return true;\r\n\r\n                case SyntaxKind.ImportKeyword:\r\n                    return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThan);\r\n\r\n                case SyntaxKind.ConstKeyword:\r\n                case SyntaxKind.ExportKeyword:\r\n                    return isStartOfDeclaration();\r\n\r\n                case SyntaxKind.AsyncKeyword:\r\n                case SyntaxKind.DeclareKeyword:\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                case SyntaxKind.TypeKeyword:\r\n                case SyntaxKind.GlobalKeyword:\r\n                    // When these don't start a declaration, they're an identifier in an expression statement\r\n                    return true;\r\n\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.ProtectedKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ReadonlyKeyword:\r\n                    // When these don't start a declaration, they may be the start of a class member if an identifier\r\n                    // immediately follows. Otherwise they're an identifier in an expression statement.\r\n                    return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\r\n\r\n                default:\r\n                    return isStartOfExpression();\r\n            }\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrStartOfDestructuring() {\r\n            nextToken();\r\n            return isIdentifier() || token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.OpenBracketToken;\r\n        }\r\n\r\n        function isLetDeclaration() {\r\n            // In ES6 'let' always starts a lexical declaration if followed by an identifier or {\r\n            // or [.\r\n            return lookAhead(nextTokenIsIdentifierOrStartOfDestructuring);\r\n        }\r\n\r\n        function parseStatement(): Statement {\r\n            switch (token()) {\r\n                case SyntaxKind.SemicolonToken:\r\n                    return parseEmptyStatement();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n                case SyntaxKind.VarKeyword:\r\n                    return parseVariableStatement(scanner.getStartPos(), /*decorators*/ undefined, /*modifiers*/ undefined);\r\n                case SyntaxKind.LetKeyword:\r\n                    if (isLetDeclaration()) {\r\n                        return parseVariableStatement(scanner.getStartPos(), /*decorators*/ undefined, /*modifiers*/ undefined);\r\n                    }\r\n                    break;\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionDeclaration(scanner.getStartPos(), /*decorators*/ undefined, /*modifiers*/ undefined);\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassDeclaration(scanner.getStartPos(), /*decorators*/ undefined, /*modifiers*/ undefined);\r\n                case SyntaxKind.IfKeyword:\r\n                    return parseIfStatement();\r\n                case SyntaxKind.DoKeyword:\r\n                    return parseDoStatement();\r\n                case SyntaxKind.WhileKeyword:\r\n                    return parseWhileStatement();\r\n                case SyntaxKind.ForKeyword:\r\n                    return parseForOrForInOrForOfStatement();\r\n                case SyntaxKind.ContinueKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.ContinueStatement);\r\n                case SyntaxKind.BreakKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.BreakStatement);\r\n                case SyntaxKind.ReturnKeyword:\r\n                    return parseReturnStatement();\r\n                case SyntaxKind.WithKeyword:\r\n                    return parseWithStatement();\r\n                case SyntaxKind.SwitchKeyword:\r\n                    return parseSwitchStatement();\r\n                case SyntaxKind.ThrowKeyword:\r\n                    return parseThrowStatement();\r\n                case SyntaxKind.TryKeyword:\r\n                // Include 'catch' and 'finally' for error recovery.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return parseTryStatement();\r\n                case SyntaxKind.DebuggerKeyword:\r\n                    return parseDebuggerStatement();\r\n                case SyntaxKind.AtToken:\r\n                    return parseDeclaration();\r\n                case SyntaxKind.AsyncKeyword:\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.TypeKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                case SyntaxKind.DeclareKeyword:\r\n                case SyntaxKind.ConstKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                case SyntaxKind.ExportKeyword:\r\n                case SyntaxKind.ImportKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.ProtectedKeyword:\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.AbstractKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ReadonlyKeyword:\r\n                case SyntaxKind.GlobalKeyword:\r\n                    if (isStartOfDeclaration()) {\r\n                        return parseDeclaration();\r\n                    }\r\n                    break;\r\n            }\r\n            return parseExpressionOrLabeledStatement();\r\n        }\r\n\r\n        function parseDeclaration(): Statement {\r\n            const fullStart = getNodePos();\r\n            const decorators = parseDecorators();\r\n            const modifiers = parseModifiers();\r\n            switch (token()) {\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.LetKeyword:\r\n                case SyntaxKind.ConstKeyword:\r\n                    return parseVariableStatement(fullStart, decorators, modifiers);\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.InterfaceKeyword:\r\n                    return parseInterfaceDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.TypeKeyword:\r\n                    return parseTypeAliasDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.EnumKeyword:\r\n                    return parseEnumDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.GlobalKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                    return parseModuleDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.ImportKeyword:\r\n                    return parseImportDeclarationOrImportEqualsDeclaration(fullStart, decorators, modifiers);\r\n                case SyntaxKind.ExportKeyword:\r\n                    nextToken();\r\n                    switch (token()) {\r\n                        case SyntaxKind.DefaultKeyword:\r\n                        case SyntaxKind.EqualsToken:\r\n                            return parseExportAssignment(fullStart, decorators, modifiers);\r\n                        case SyntaxKind.AsKeyword:\r\n                            return parseNamespaceExportDeclaration(fullStart, decorators, modifiers);\r\n                        default:\r\n                            return parseExportDeclaration(fullStart, decorators, modifiers);\r\n                    }\r\n                default:\r\n                    if (decorators || modifiers) {\r\n                        // We reached this point because we encountered decorators and/or modifiers and assumed a declaration\r\n                        // would follow. For recovery and error reporting purposes, return an incomplete declaration.\r\n                        const node = <Statement>createMissingNode(SyntaxKind.MissingDeclaration, /*reportAtCurrentPosition*/ true, Diagnostics.Declaration_expected);\r\n                        node.pos = fullStart;\r\n                        node.decorators = decorators;\r\n                        node.modifiers = modifiers;\r\n                        return finishNode(node);\r\n                    }\r\n            }\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrStringLiteralOnSameLine() {\r\n            nextToken();\r\n            return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() === SyntaxKind.StringLiteral);\r\n        }\r\n\r\n        function parseFunctionBlockOrSemicolon(flags: SignatureFlags, diagnosticMessage?: DiagnosticMessage): Block {\r\n            if (token() !== SyntaxKind.OpenBraceToken && canParseSemicolon()) {\r\n                parseSemicolon();\r\n                return;\r\n            }\r\n\r\n            return parseFunctionBlock(flags, diagnosticMessage);\r\n        }\r\n\r\n        // DECLARATIONS\r\n\r\n        function parseArrayBindingElement(): ArrayBindingElement {\r\n            if (token() === SyntaxKind.CommaToken) {\r\n                return <OmittedExpression>createNode(SyntaxKind.OmittedExpression);\r\n            }\r\n            const node = <BindingElement>createNode(SyntaxKind.BindingElement);\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            node.name = parseIdentifierOrPattern();\r\n            node.initializer = parseInitializer(/*inParameter*/ false);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectBindingElement(): BindingElement {\r\n            const node = <BindingElement>createNode(SyntaxKind.BindingElement);\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            const tokenIsIdentifier = isIdentifier();\r\n            const propertyName = parsePropertyName();\r\n            if (tokenIsIdentifier && token() !== SyntaxKind.ColonToken) {\r\n                node.name = <Identifier>propertyName;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                node.propertyName = propertyName;\r\n                node.name = parseIdentifierOrPattern();\r\n            }\r\n            node.initializer = parseInitializer(/*inParameter*/ false);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectBindingPattern(): ObjectBindingPattern {\r\n            const node = <ObjectBindingPattern>createNode(SyntaxKind.ObjectBindingPattern);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            node.elements = parseDelimitedList(ParsingContext.ObjectBindingElements, parseObjectBindingElement);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseArrayBindingPattern(): ArrayBindingPattern {\r\n            const node = <ArrayBindingPattern>createNode(SyntaxKind.ArrayBindingPattern);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            node.elements = parseDelimitedList(ParsingContext.ArrayBindingElements, parseArrayBindingElement);\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isIdentifierOrPattern() {\r\n            return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.OpenBracketToken || isIdentifier();\r\n        }\r\n\r\n        function parseIdentifierOrPattern(): Identifier | BindingPattern {\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return parseArrayBindingPattern();\r\n            }\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseObjectBindingPattern();\r\n            }\r\n            return parseIdentifier();\r\n        }\r\n\r\n        function parseVariableDeclaration(): VariableDeclaration {\r\n            const node = <VariableDeclaration>createNode(SyntaxKind.VariableDeclaration);\r\n            node.name = parseIdentifierOrPattern();\r\n            node.type = parseTypeAnnotation();\r\n            if (!isInOrOfKeyword(token())) {\r\n                node.initializer = parseNonParameterInitializer();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseVariableDeclarationList(inForStatementInitializer: boolean): VariableDeclarationList {\r\n            const node = <VariableDeclarationList>createNode(SyntaxKind.VariableDeclarationList);\r\n\r\n            switch (token()) {\r\n                case SyntaxKind.VarKeyword:\r\n                    break;\r\n                case SyntaxKind.LetKeyword:\r\n                    node.flags |= NodeFlags.Let;\r\n                    break;\r\n                case SyntaxKind.ConstKeyword:\r\n                    node.flags |= NodeFlags.Const;\r\n                    break;\r\n                default:\r\n                    Debug.fail();\r\n            }\r\n\r\n            nextToken();\r\n\r\n            // The user may have written the following:\r\n            //\r\n            //    for (let of X) { }\r\n            //\r\n            // In this case, we want to parse an empty declaration list, and then parse 'of'\r\n            // as a keyword. The reason this is not automatic is that 'of' is a valid identifier.\r\n            // So we need to look ahead to determine if 'of' should be treated as a keyword in\r\n            // this context.\r\n            // The checker will then give an error that there is an empty declaration list.\r\n            if (token() === SyntaxKind.OfKeyword && lookAhead(canFollowContextualOfKeyword)) {\r\n                node.declarations = createMissingList<VariableDeclaration>();\r\n            }\r\n            else {\r\n                const savedDisallowIn = inDisallowInContext();\r\n                setDisallowInContext(inForStatementInitializer);\r\n\r\n                node.declarations = parseDelimitedList(ParsingContext.VariableDeclarations, parseVariableDeclaration);\r\n\r\n                setDisallowInContext(savedDisallowIn);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function canFollowContextualOfKeyword(): boolean {\r\n            return nextTokenIsIdentifier() && nextToken() === SyntaxKind.CloseParenToken;\r\n        }\r\n\r\n        function parseVariableStatement(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): VariableStatement {\r\n            const node = <VariableStatement>createNode(SyntaxKind.VariableStatement, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            node.declarationList = parseVariableDeclarationList(/*inForStatementInitializer*/ false);\r\n            parseSemicolon();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseFunctionDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): FunctionDeclaration {\r\n            const node = <FunctionDeclaration>createNode(SyntaxKind.FunctionDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            node.name = hasModifier(node, ModifierFlags.Default) ? parseOptionalIdentifier() : parseIdentifier();\r\n            const isGenerator = node.asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, node);\r\n            node.body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, Diagnostics.or_expected);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseConstructorDeclaration(pos: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ConstructorDeclaration {\r\n            const node = <ConstructorDeclaration>createNode(SyntaxKind.Constructor, pos);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.ConstructorKeyword);\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.None, node);\r\n            node.body = parseFunctionBlockOrSemicolon(SignatureFlags.None, Diagnostics.or_expected);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseMethodDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>, asteriskToken: AsteriskToken, name: PropertyName, questionToken: QuestionToken, diagnosticMessage?: DiagnosticMessage): MethodDeclaration {\r\n            const method = <MethodDeclaration>createNode(SyntaxKind.MethodDeclaration, fullStart);\r\n            method.decorators = decorators;\r\n            method.modifiers = modifiers;\r\n            method.asteriskToken = asteriskToken;\r\n            method.name = name;\r\n            method.questionToken = questionToken;\r\n            const isGenerator = asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(method, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, method);\r\n            method.body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);\r\n            return addJSDocComment(finishNode(method));\r\n        }\r\n\r\n        function parsePropertyDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>, name: PropertyName, questionToken: QuestionToken): ClassElement {\r\n            const property = <PropertyDeclaration>createNode(SyntaxKind.PropertyDeclaration, fullStart);\r\n            property.decorators = decorators;\r\n            property.modifiers = modifiers;\r\n            property.name = name;\r\n            property.questionToken = questionToken;\r\n            property.type = parseTypeAnnotation();\r\n\r\n            // For instance properties specifically, since they are evaluated inside the constructor,\r\n            // we do *not * want to parse yield expressions, so we specifically turn the yield context\r\n            // off. The grammar would look something like this:\r\n            //\r\n            //    MemberVariableDeclaration[Yield]:\r\n            //        AccessibilityModifier_opt   PropertyName   TypeAnnotation_opt   Initializer_opt[In];\r\n            //        AccessibilityModifier_opt  static_opt  PropertyName   TypeAnnotation_opt   Initializer_opt[In, ?Yield];\r\n            //\r\n            // The checker may still error in the static case to explicitly disallow the yield expression.\r\n            property.initializer = hasModifier(property, ModifierFlags.Static)\r\n                ? allowInAnd(parseNonParameterInitializer)\r\n                : doOutsideOfContext(NodeFlags.YieldContext | NodeFlags.DisallowInContext, parseNonParameterInitializer);\r\n\r\n            parseSemicolon();\r\n            return addJSDocComment(finishNode(property));\r\n        }\r\n\r\n        function parsePropertyOrMethodDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ClassElement {\r\n            const asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            const name = parsePropertyName();\r\n\r\n            // Note: this is not legal as per the grammar.  But we allow it in the parser and\r\n            // report an error in the grammar checker.\r\n            const questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (asteriskToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseMethodDeclaration(fullStart, decorators, modifiers, asteriskToken, name, questionToken, Diagnostics.or_expected);\r\n            }\r\n            else {\r\n                return parsePropertyDeclaration(fullStart, decorators, modifiers, name, questionToken);\r\n            }\r\n        }\r\n\r\n        function parseNonParameterInitializer() {\r\n            return parseInitializer(/*inParameter*/ false);\r\n        }\r\n\r\n        function parseAccessorDeclaration(kind: SyntaxKind, fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): AccessorDeclaration {\r\n            const node = <AccessorDeclaration>createNode(kind, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            node.name = parsePropertyName();\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.None, node);\r\n            node.body = parseFunctionBlockOrSemicolon(SignatureFlags.None);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function isClassMemberModifier(idToken: SyntaxKind) {\r\n            switch (idToken) {\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.ProtectedKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ReadonlyKeyword:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        function isClassMemberStart(): boolean {\r\n            let idToken: SyntaxKind;\r\n\r\n            if (token() === SyntaxKind.AtToken) {\r\n                return true;\r\n            }\r\n\r\n            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier.\r\n            while (isModifierKind(token())) {\r\n                idToken = token();\r\n                // If the idToken is a class modifier (protected, private, public, and static), it is\r\n                // certain that we are starting to parse class member. This allows better error recovery\r\n                // Example:\r\n                //      public foo() ...     // true\r\n                //      public @dec blah ... // true; we will then report an error later\r\n                //      export public ...    // true; we will then report an error later\r\n                if (isClassMemberModifier(idToken)) {\r\n                    return true;\r\n                }\r\n\r\n                nextToken();\r\n            }\r\n\r\n            if (token() === SyntaxKind.AsteriskToken) {\r\n                return true;\r\n            }\r\n\r\n            // Try to get the first property-like token following all modifiers.\r\n            // This can either be an identifier or the 'get' or 'set' keywords.\r\n            if (isLiteralPropertyName()) {\r\n                idToken = token();\r\n                nextToken();\r\n            }\r\n\r\n            // Index signatures and computed properties are class members; we can parse.\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return true;\r\n            }\r\n\r\n            // If we were able to get any potential identifier...\r\n            if (idToken !== undefined) {\r\n                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.\r\n                if (!isKeyword(idToken) || idToken === SyntaxKind.SetKeyword || idToken === SyntaxKind.GetKeyword) {\r\n                    return true;\r\n                }\r\n\r\n                // If it *is* a keyword, but not an accessor, check a little farther along\r\n                // to see if it should actually be parsed as a class member.\r\n                switch (token()) {\r\n                    case SyntaxKind.OpenParenToken:     // Method declaration\r\n                    case SyntaxKind.LessThanToken:      // Generic Method declaration\r\n                    case SyntaxKind.ColonToken:         // Type Annotation for declaration\r\n                    case SyntaxKind.EqualsToken:        // Initializer for declaration\r\n                    case SyntaxKind.QuestionToken:      // Not valid, but permitted so that it gets caught later on.\r\n                        return true;\r\n                    default:\r\n                        // Covers\r\n                        //  - Semicolons     (declaration termination)\r\n                        //  - Closing braces (end-of-class, must be declaration)\r\n                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)\r\n                        //  - Line-breaks    (enabling *automatic semicolon insertion*)\r\n                        return canParseSemicolon();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseDecorators(): NodeArray<Decorator> {\r\n            let list: Decorator[];\r\n            const listPos = getNodePos();\r\n            while (true) {\r\n                const decoratorStart = getNodePos();\r\n                if (!parseOptional(SyntaxKind.AtToken)) {\r\n                    break;\r\n                }\r\n                const decorator = <Decorator>createNode(SyntaxKind.Decorator, decoratorStart);\r\n                decorator.expression = doInDecoratorContext(parseLeftHandSideExpressionOrHigher);\r\n                finishNode(decorator);\r\n                (list || (list = [])).push(decorator);\r\n            }\r\n            return list && createNodeArray(list, listPos);\r\n        }\r\n\r\n        /*\r\n         * There are situations in which a modifier like 'const' will appear unexpectedly, such as on a class member.\r\n         * In those situations, if we are entirely sure that 'const' is not valid on its own (such as when ASI takes effect\r\n         * and turns it into a standalone declaration), then it is better to parse it and report an error later.\r\n         *\r\n         * In such situations, 'permitInvalidConstAsModifier' should be set to true.\r\n         */\r\n        function parseModifiers(permitInvalidConstAsModifier?: boolean): NodeArray<Modifier> | undefined {\r\n            let list: Modifier[];\r\n            const listPos = getNodePos();\r\n            while (true) {\r\n                const modifierStart = scanner.getStartPos();\r\n                const modifierKind = token();\r\n\r\n                if (token() === SyntaxKind.ConstKeyword && permitInvalidConstAsModifier) {\r\n                    // We need to ensure that any subsequent modifiers appear on the same line\r\n                    // so that when 'const' is a standalone declaration, we don't issue an error.\r\n                    if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (!parseAnyContextualModifier()) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                const modifier = finishNode(<Modifier>createNode(modifierKind, modifierStart));\r\n                (list || (list = [])).push(modifier);\r\n            }\r\n            return list && createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseModifiersForArrowFunction(): NodeArray<Modifier> {\r\n            let modifiers: NodeArray<Modifier>;\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                const modifierStart = scanner.getStartPos();\r\n                const modifierKind = token();\r\n                nextToken();\r\n                const modifier = finishNode(<Modifier>createNode(modifierKind, modifierStart));\r\n                modifiers = createNodeArray<Modifier>([modifier], modifierStart);\r\n            }\r\n            return modifiers;\r\n        }\r\n\r\n        function parseClassElement(): ClassElement {\r\n            if (token() === SyntaxKind.SemicolonToken) {\r\n                const result = <SemicolonClassElement>createNode(SyntaxKind.SemicolonClassElement);\r\n                nextToken();\r\n                return finishNode(result);\r\n            }\r\n\r\n            const fullStart = getNodePos();\r\n            const decorators = parseDecorators();\r\n            const modifiers = parseModifiers(/*permitInvalidConstAsModifier*/ true);\r\n\r\n            const accessor = tryParseAccessorDeclaration(fullStart, decorators, modifiers);\r\n            if (accessor) {\r\n                return accessor;\r\n            }\r\n\r\n            if (token() === SyntaxKind.ConstructorKeyword) {\r\n                return parseConstructorDeclaration(fullStart, decorators, modifiers);\r\n            }\r\n\r\n            if (isIndexSignature()) {\r\n                return parseIndexSignatureDeclaration(fullStart, decorators, modifiers);\r\n            }\r\n\r\n            // It is very important that we check this *after* checking indexers because\r\n            // the [ token can start an index signature or a computed property name\r\n            if (tokenIsIdentifierOrKeyword(token()) ||\r\n                token() === SyntaxKind.StringLiteral ||\r\n                token() === SyntaxKind.NumericLiteral ||\r\n                token() === SyntaxKind.AsteriskToken ||\r\n                token() === SyntaxKind.OpenBracketToken) {\r\n\r\n                return parsePropertyOrMethodDeclaration(fullStart, decorators, modifiers);\r\n            }\r\n\r\n            if (decorators || modifiers) {\r\n                // treat this as a property declaration with a missing name.\r\n                const name = createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Declaration_expected);\r\n                return parsePropertyDeclaration(fullStart, decorators, modifiers, name, /*questionToken*/ undefined);\r\n            }\r\n\r\n            // 'isClassMemberStart' should have hinted not to attempt parsing.\r\n            Debug.fail(\"Should not have attempted to parse class member declaration.\");\r\n        }\r\n\r\n        function parseClassExpression(): ClassExpression {\r\n            return <ClassExpression>parseClassDeclarationOrExpression(\r\n                /*fullStart*/ scanner.getStartPos(),\r\n                /*decorators*/ undefined,\r\n                /*modifiers*/ undefined,\r\n                SyntaxKind.ClassExpression);\r\n        }\r\n\r\n        function parseClassDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ClassDeclaration {\r\n            return <ClassDeclaration>parseClassDeclarationOrExpression(fullStart, decorators, modifiers, SyntaxKind.ClassDeclaration);\r\n        }\r\n\r\n        function parseClassDeclarationOrExpression(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>, kind: SyntaxKind): ClassLikeDeclaration {\r\n            const node = <ClassLikeDeclaration>createNode(kind, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.ClassKeyword);\r\n            node.name = parseNameOfClassDeclarationOrExpression();\r\n            node.typeParameters = parseTypeParameters();\r\n            node.heritageClauses = parseHeritageClauses();\r\n\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                // ClassTail[Yield,Await] : (Modified) See 14.5\r\n                //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }\r\n                node.members = parseClassMembers();\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<ClassElement>();\r\n            }\r\n\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseNameOfClassDeclarationOrExpression(): Identifier | undefined {\r\n            // implements is a future reserved word so\r\n            // 'class implements' might mean either\r\n            // - class expression with omitted name, 'implements' starts heritage clause\r\n            // - class with name 'implements'\r\n            // 'isImplementsClause' helps to disambiguate between these two cases\r\n            return isIdentifier() && !isImplementsClause()\r\n                ? parseIdentifier()\r\n                : undefined;\r\n        }\r\n\r\n        function isImplementsClause() {\r\n            return token() === SyntaxKind.ImplementsKeyword && lookAhead(nextTokenIsIdentifierOrKeyword);\r\n        }\r\n\r\n        function parseHeritageClauses(): NodeArray<HeritageClause> | undefined {\r\n            // ClassTail[Yield,Await] : (Modified) See 14.5\r\n            //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }\r\n\r\n            if (isHeritageClause()) {\r\n                return parseList(ParsingContext.HeritageClauses, parseHeritageClause);\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function parseHeritageClause(): HeritageClause | undefined {\r\n            const tok = token();\r\n            if (tok === SyntaxKind.ExtendsKeyword || tok === SyntaxKind.ImplementsKeyword) {\r\n                const node = <HeritageClause>createNode(SyntaxKind.HeritageClause);\r\n                node.token = tok;\r\n                nextToken();\r\n                node.types = parseDelimitedList(ParsingContext.HeritageClauseElement, parseExpressionWithTypeArguments);\r\n                return finishNode(node);\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function parseExpressionWithTypeArguments(): ExpressionWithTypeArguments {\r\n            const node = <ExpressionWithTypeArguments>createNode(SyntaxKind.ExpressionWithTypeArguments);\r\n            node.expression = parseLeftHandSideExpressionOrHigher();\r\n            node.typeArguments = tryParseTypeArguments();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function tryParseTypeArguments(): NodeArray<TypeNode> | undefined {\r\n            return token() === SyntaxKind.LessThanToken\r\n                ? parseBracketedList(ParsingContext.TypeArguments, parseType, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken)\r\n                : undefined;\r\n        }\r\n\r\n        function isHeritageClause(): boolean {\r\n            return token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n        }\r\n\r\n        function parseClassMembers(): NodeArray<ClassElement> {\r\n            return parseList(ParsingContext.ClassMembers, parseClassElement);\r\n        }\r\n\r\n        function parseInterfaceDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): InterfaceDeclaration {\r\n            const node = <InterfaceDeclaration>createNode(SyntaxKind.InterfaceDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.InterfaceKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            node.heritageClauses = parseHeritageClauses();\r\n            node.members = parseObjectTypeMembers();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseTypeAliasDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): TypeAliasDeclaration {\r\n            const node = <TypeAliasDeclaration>createNode(SyntaxKind.TypeAliasDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.TypeKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            node.type = parseType();\r\n            parseSemicolon();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        // In an ambient declaration, the grammar only allows integer literals as initializers.\r\n        // In a non-ambient declaration, the grammar allows uninitialized members only in a\r\n        // ConstantEnumMemberSection, which starts at the beginning of an enum declaration\r\n        // or any time an integer literal initializer is encountered.\r\n        function parseEnumMember(): EnumMember {\r\n            const node = <EnumMember>createNode(SyntaxKind.EnumMember, scanner.getStartPos());\r\n            node.name = parsePropertyName();\r\n            node.initializer = allowInAnd(parseNonParameterInitializer);\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseEnumDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): EnumDeclaration {\r\n            const node = <EnumDeclaration>createNode(SyntaxKind.EnumDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.EnumKeyword);\r\n            node.name = parseIdentifier();\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.members = parseDelimitedList(ParsingContext.EnumMembers, parseEnumMember);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<EnumMember>();\r\n            }\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseModuleBlock(): ModuleBlock {\r\n            const node = <ModuleBlock>createNode(SyntaxKind.ModuleBlock, scanner.getStartPos());\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.statements = parseList(ParsingContext.BlockStatements, parseStatement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleOrNamespaceDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>, flags: NodeFlags): ModuleDeclaration {\r\n            const node = <ModuleDeclaration>createNode(SyntaxKind.ModuleDeclaration, fullStart);\r\n            // If we are parsing a dotted namespace name, we want to\r\n            // propagate the 'Namespace' flag across the names if set.\r\n            const namespaceFlag = flags & NodeFlags.Namespace;\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            node.flags |= flags;\r\n            node.name = parseIdentifier();\r\n            node.body = parseOptional(SyntaxKind.DotToken)\r\n                ? <NamespaceDeclaration>parseModuleOrNamespaceDeclaration(getNodePos(), /*decorators*/ undefined, /*modifiers*/ undefined, NodeFlags.NestedNamespace | namespaceFlag)\r\n                : parseModuleBlock();\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function parseAmbientExternalModuleDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ModuleDeclaration {\r\n            const node = <ModuleDeclaration>createNode(SyntaxKind.ModuleDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            if (token() === SyntaxKind.GlobalKeyword) {\r\n                // parse 'global' as name of global scope augmentation\r\n                node.name = parseIdentifier();\r\n                node.flags |= NodeFlags.GlobalAugmentation;\r\n            }\r\n            else {\r\n                node.name = <StringLiteral>parseLiteralNode();\r\n                node.name.text = internIdentifier(node.name.text);\r\n            }\r\n\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                node.body = parseModuleBlock();\r\n            }\r\n            else {\r\n                parseSemicolon();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ModuleDeclaration {\r\n            let flags: NodeFlags = 0;\r\n            if (token() === SyntaxKind.GlobalKeyword) {\r\n                // global augmentation\r\n                return parseAmbientExternalModuleDeclaration(fullStart, decorators, modifiers);\r\n            }\r\n            else if (parseOptional(SyntaxKind.NamespaceKeyword)) {\r\n                flags |= NodeFlags.Namespace;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.ModuleKeyword);\r\n                if (token() === SyntaxKind.StringLiteral) {\r\n                    return parseAmbientExternalModuleDeclaration(fullStart, decorators, modifiers);\r\n                }\r\n            }\r\n            return parseModuleOrNamespaceDeclaration(fullStart, decorators, modifiers, flags);\r\n        }\r\n\r\n        function isExternalModuleReference() {\r\n            return token() === SyntaxKind.RequireKeyword &&\r\n                lookAhead(nextTokenIsOpenParen);\r\n        }\r\n\r\n        function nextTokenIsOpenParen() {\r\n            return nextToken() === SyntaxKind.OpenParenToken;\r\n        }\r\n\r\n        function nextTokenIsSlash() {\r\n            return nextToken() === SyntaxKind.SlashToken;\r\n        }\r\n\r\n        function parseNamespaceExportDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): NamespaceExportDeclaration {\r\n            const exportDeclaration = <NamespaceExportDeclaration>createNode(SyntaxKind.NamespaceExportDeclaration, fullStart);\r\n            exportDeclaration.decorators = decorators;\r\n            exportDeclaration.modifiers = modifiers;\r\n            parseExpected(SyntaxKind.AsKeyword);\r\n            parseExpected(SyntaxKind.NamespaceKeyword);\r\n\r\n            exportDeclaration.name = parseIdentifier();\r\n\r\n            parseSemicolon();\r\n\r\n            return finishNode(exportDeclaration);\r\n        }\r\n\r\n        function parseImportDeclarationOrImportEqualsDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ImportEqualsDeclaration | ImportDeclaration {\r\n            parseExpected(SyntaxKind.ImportKeyword);\r\n            const afterImportPos = scanner.getStartPos();\r\n\r\n            let identifier: Identifier;\r\n            if (isIdentifier()) {\r\n                identifier = parseIdentifier();\r\n                if (token() !== SyntaxKind.CommaToken && token() !== SyntaxKind.FromKeyword) {\r\n                    return parseImportEqualsDeclaration(fullStart, decorators, modifiers, identifier);\r\n                }\r\n            }\r\n\r\n            // Import statement\r\n            const importDeclaration = <ImportDeclaration>createNode(SyntaxKind.ImportDeclaration, fullStart);\r\n            importDeclaration.decorators = decorators;\r\n            importDeclaration.modifiers = modifiers;\r\n\r\n            // ImportDeclaration:\r\n            //  import ImportClause from ModuleSpecifier ;\r\n            //  import ModuleSpecifier;\r\n            if (identifier || // import id\r\n                token() === SyntaxKind.AsteriskToken || // import *\r\n                token() === SyntaxKind.OpenBraceToken) { // import {\r\n                importDeclaration.importClause = parseImportClause(identifier, afterImportPos);\r\n                parseExpected(SyntaxKind.FromKeyword);\r\n            }\r\n\r\n            importDeclaration.moduleSpecifier = parseModuleSpecifier();\r\n            parseSemicolon();\r\n            return finishNode(importDeclaration);\r\n        }\r\n\r\n        function parseImportEqualsDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>, identifier: ts.Identifier): ImportEqualsDeclaration {\r\n            const importEqualsDeclaration = <ImportEqualsDeclaration>createNode(SyntaxKind.ImportEqualsDeclaration, fullStart);\r\n            importEqualsDeclaration.decorators = decorators;\r\n            importEqualsDeclaration.modifiers = modifiers;\r\n            importEqualsDeclaration.name = identifier;\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            importEqualsDeclaration.moduleReference = parseModuleReference();\r\n            parseSemicolon();\r\n            return addJSDocComment(finishNode(importEqualsDeclaration));\r\n        }\r\n\r\n        function parseImportClause(identifier: Identifier, fullStart: number) {\r\n            // ImportClause:\r\n            //  ImportedDefaultBinding\r\n            //  NameSpaceImport\r\n            //  NamedImports\r\n            //  ImportedDefaultBinding, NameSpaceImport\r\n            //  ImportedDefaultBinding, NamedImports\r\n\r\n            const importClause = <ImportClause>createNode(SyntaxKind.ImportClause, fullStart);\r\n            if (identifier) {\r\n                // ImportedDefaultBinding:\r\n                //  ImportedBinding\r\n                importClause.name = identifier;\r\n            }\r\n\r\n            // If there was no default import or if there is comma token after default import\r\n            // parse namespace or named imports\r\n            if (!importClause.name ||\r\n                parseOptional(SyntaxKind.CommaToken)) {\r\n                importClause.namedBindings = token() === SyntaxKind.AsteriskToken ? parseNamespaceImport() : parseNamedImportsOrExports(SyntaxKind.NamedImports);\r\n            }\r\n\r\n            return finishNode(importClause);\r\n        }\r\n\r\n        function parseModuleReference() {\r\n            return isExternalModuleReference()\r\n                ? parseExternalModuleReference()\r\n                : parseEntityName(/*allowReservedWords*/ false);\r\n        }\r\n\r\n        function parseExternalModuleReference() {\r\n            const node = <ExternalModuleReference>createNode(SyntaxKind.ExternalModuleReference);\r\n            parseExpected(SyntaxKind.RequireKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseModuleSpecifier();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleSpecifier(): Expression {\r\n            if (token() === SyntaxKind.StringLiteral) {\r\n                const result = parseLiteralNode();\r\n                result.text = internIdentifier(result.text);\r\n                return result;\r\n            }\r\n            else {\r\n                // We allow arbitrary expressions here, even though the grammar only allows string\r\n                // literals.  We check to ensure that it is only a string literal later in the grammar\r\n                // check pass.\r\n                return parseExpression();\r\n            }\r\n        }\r\n\r\n        function parseNamespaceImport(): NamespaceImport {\r\n            // NameSpaceImport:\r\n            //  * as ImportedBinding\r\n            const namespaceImport = <NamespaceImport>createNode(SyntaxKind.NamespaceImport);\r\n            parseExpected(SyntaxKind.AsteriskToken);\r\n            parseExpected(SyntaxKind.AsKeyword);\r\n            namespaceImport.name = parseIdentifier();\r\n            return finishNode(namespaceImport);\r\n        }\r\n\r\n        function parseNamedImportsOrExports(kind: SyntaxKind.NamedImports): NamedImports;\r\n        function parseNamedImportsOrExports(kind: SyntaxKind.NamedExports): NamedExports;\r\n        function parseNamedImportsOrExports(kind: SyntaxKind): NamedImportsOrExports {\r\n            const node = <NamedImports | NamedExports>createNode(kind);\r\n\r\n            // NamedImports:\r\n            //  { }\r\n            //  { ImportsList }\r\n            //  { ImportsList, }\r\n\r\n            // ImportsList:\r\n            //  ImportSpecifier\r\n            //  ImportsList, ImportSpecifier\r\n            node.elements = <NodeArray<ImportSpecifier> | NodeArray<ExportSpecifier>>parseBracketedList(ParsingContext.ImportOrExportSpecifiers,\r\n                kind === SyntaxKind.NamedImports ? parseImportSpecifier : parseExportSpecifier,\r\n                SyntaxKind.OpenBraceToken, SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportSpecifier() {\r\n            return parseImportOrExportSpecifier(SyntaxKind.ExportSpecifier);\r\n        }\r\n\r\n        function parseImportSpecifier() {\r\n            return parseImportOrExportSpecifier(SyntaxKind.ImportSpecifier);\r\n        }\r\n\r\n        function parseImportOrExportSpecifier(kind: SyntaxKind): ImportOrExportSpecifier {\r\n            const node = <ImportSpecifier>createNode(kind);\r\n            // ImportSpecifier:\r\n            //   BindingIdentifier\r\n            //   IdentifierName as BindingIdentifier\r\n            // ExportSpecifier:\r\n            //   IdentifierName\r\n            //   IdentifierName as IdentifierName\r\n            let checkIdentifierIsKeyword = isKeyword(token()) && !isIdentifier();\r\n            let checkIdentifierStart = scanner.getTokenPos();\r\n            let checkIdentifierEnd = scanner.getTextPos();\r\n            const identifierName = parseIdentifierName();\r\n            if (token() === SyntaxKind.AsKeyword) {\r\n                node.propertyName = identifierName;\r\n                parseExpected(SyntaxKind.AsKeyword);\r\n                checkIdentifierIsKeyword = isKeyword(token()) && !isIdentifier();\r\n                checkIdentifierStart = scanner.getTokenPos();\r\n                checkIdentifierEnd = scanner.getTextPos();\r\n                node.name = parseIdentifierName();\r\n            }\r\n            else {\r\n                node.name = identifierName;\r\n            }\r\n            if (kind === SyntaxKind.ImportSpecifier && checkIdentifierIsKeyword) {\r\n                // Report error identifier expected\r\n                parseErrorAtPosition(checkIdentifierStart, checkIdentifierEnd - checkIdentifierStart, Diagnostics.Identifier_expected);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportDeclaration(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ExportDeclaration {\r\n            const node = <ExportDeclaration>createNode(SyntaxKind.ExportDeclaration, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            if (parseOptional(SyntaxKind.AsteriskToken)) {\r\n                parseExpected(SyntaxKind.FromKeyword);\r\n                node.moduleSpecifier = parseModuleSpecifier();\r\n            }\r\n            else {\r\n                node.exportClause = parseNamedImportsOrExports(SyntaxKind.NamedExports);\r\n\r\n                // It is not uncommon to accidentally omit the 'from' keyword. Additionally, in editing scenarios,\r\n                // the 'from' keyword can be parsed as a named export when the export clause is unterminated (i.e. `export { from \"moduleName\";`)\r\n                // If we don't have a 'from' keyword, see if we have a string literal such that ASI won't take effect.\r\n                if (token() === SyntaxKind.FromKeyword || (token() === SyntaxKind.StringLiteral && !scanner.hasPrecedingLineBreak())) {\r\n                    parseExpected(SyntaxKind.FromKeyword);\r\n                    node.moduleSpecifier = parseModuleSpecifier();\r\n                }\r\n            }\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportAssignment(fullStart: number, decorators: NodeArray<Decorator>, modifiers: NodeArray<Modifier>): ExportAssignment {\r\n            const node = <ExportAssignment>createNode(SyntaxKind.ExportAssignment, fullStart);\r\n            node.decorators = decorators;\r\n            node.modifiers = modifiers;\r\n            if (parseOptional(SyntaxKind.EqualsToken)) {\r\n                node.isExportEquals = true;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.DefaultKeyword);\r\n            }\r\n            node.expression = parseAssignmentExpressionOrHigher();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function processReferenceComments(sourceFile: SourceFile): void {\r\n            const triviaScanner = createScanner(sourceFile.languageVersion, /*skipTrivia*/ false, LanguageVariant.Standard, sourceText);\r\n            const referencedFiles: FileReference[] = [];\r\n            const typeReferenceDirectives: FileReference[] = [];\r\n            const amdDependencies: { path: string; name: string }[] = [];\r\n            let amdModuleName: string;\r\n            let checkJsDirective: CheckJsDirective = undefined;\r\n\r\n            // Keep scanning all the leading trivia in the file until we get to something that\r\n            // isn't trivia.  Any single line comment will be analyzed to see if it is a\r\n            // reference comment.\r\n            while (true) {\r\n                const kind = triviaScanner.scan();\r\n                if (kind !== SyntaxKind.SingleLineCommentTrivia) {\r\n                    if (isTrivia(kind)) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                const range = {\r\n                    kind: <SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia>triviaScanner.getToken(),\r\n                    pos: triviaScanner.getTokenPos(),\r\n                    end: triviaScanner.getTextPos(),\r\n                };\r\n\r\n                const comment = sourceText.substring(range.pos, range.end);\r\n                const referencePathMatchResult = getFileReferenceFromReferencePath(comment, range);\r\n                if (referencePathMatchResult) {\r\n                    const fileReference = referencePathMatchResult.fileReference;\r\n                    sourceFile.hasNoDefaultLib = referencePathMatchResult.isNoDefaultLib;\r\n                    const diagnosticMessage = referencePathMatchResult.diagnosticMessage;\r\n                    if (fileReference) {\r\n                        if (referencePathMatchResult.isTypeReferenceDirective) {\r\n                            typeReferenceDirectives.push(fileReference);\r\n                        }\r\n                        else {\r\n                            referencedFiles.push(fileReference);\r\n                        }\r\n                    }\r\n                    if (diagnosticMessage) {\r\n                        parseDiagnostics.push(createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, diagnosticMessage));\r\n                    }\r\n                }\r\n                else {\r\n                    const amdModuleNameRegEx = /^\\/\\/\\/\\s*<amd-module\\s+name\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const amdModuleNameRegExCH = /^\\/\\/\\/\\s*<AMD模块\\s+名称\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const amdModuleNameMatchResult = amdModuleNameRegEx.exec(comment) || amdModuleNameRegExCH.exec(comment);\r\n                    if (amdModuleNameMatchResult) {\r\n                        if (amdModuleName) {\r\n                            parseDiagnostics.push(createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments));\r\n                        }\r\n                        amdModuleName = amdModuleNameMatchResult[2];\r\n                    }\r\n\r\n                    const amdDependencyRegEx = /^\\/\\/\\/\\s*<amd-dependency\\s/gim;\r\n                    const amdDependencyRegExCH = /^\\/\\/\\/\\s*<AMD附件\\s/gim;\r\n                    const pathRegex = /\\spath\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const nameRegex = /\\sname\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const pathRegexCH = /\\s路径\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const nameRegexCH = /\\s名称\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    const amdDependencyMatchResult = amdDependencyRegEx.exec(comment) || amdDependencyRegExCH.exec(comment);\r\n                    if (amdDependencyMatchResult) {\r\n                        const pathMatchResult = pathRegex.exec(comment) || pathRegexCH.exec(comment);\r\n                        const nameMatchResult = nameRegex.exec(comment) || nameRegexCH.exec(comment);\r\n                        if (pathMatchResult) {\r\n                            const amdDependency = { path: pathMatchResult[2], name: nameMatchResult ? nameMatchResult[2] : undefined };\r\n                            amdDependencies.push(amdDependency);\r\n                        }\r\n                    }\r\n\r\n                    const checkJsDirectiveRegEx = /^\\/\\/\\/?\\s*(@ts-check|@ts-nocheck)\\s*$/gim;\r\n                    const checkJsDirectiveRegExCH = /^\\/\\/\\/?\\s*(@Cts-检查|@Cts-不检查)\\s*$/gim;\r\n                    const checkJsDirectiveMatchResult = checkJsDirectiveRegEx.exec(comment) || checkJsDirectiveRegExCH.exec(comment);\r\n                    if (checkJsDirectiveMatchResult) {\r\n                        checkJsDirective = {\r\n                            enabled: compareStrings(checkJsDirectiveMatchResult[1], \"@ts-check\", /*ignoreCase*/ true) === Comparison.EqualTo ? compareStrings(checkJsDirectiveMatchResult[1], \"@ts-check\", /*ignoreCase*/ true) === Comparison.EqualTo : compareStrings(checkJsDirectiveMatchResult[1], \"@Cts-检查\", /*ignoreCase*/ true) === Comparison.EqualTo,\r\n                            end: range.end,\r\n                            pos: range.pos\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            sourceFile.referencedFiles = referencedFiles;\r\n            sourceFile.typeReferenceDirectives = typeReferenceDirectives;\r\n            sourceFile.amdDependencies = amdDependencies;\r\n            sourceFile.moduleName = amdModuleName;\r\n            sourceFile.checkJsDirective = checkJsDirective;\r\n        }\r\n\r\n        function setExternalModuleIndicator(sourceFile: SourceFile) {\r\n            sourceFile.externalModuleIndicator = forEach(sourceFile.statements, node =>\r\n                hasModifier(node, ModifierFlags.Export)\r\n                    || node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind === SyntaxKind.ExternalModuleReference\r\n                    || node.kind === SyntaxKind.ImportDeclaration\r\n                    || node.kind === SyntaxKind.ExportAssignment\r\n                    || node.kind === SyntaxKind.ExportDeclaration\r\n                    ? node\r\n                    : undefined);\r\n        }\r\n\r\n        const enum ParsingContext {\r\n            SourceElements,            // Elements in source file\r\n            BlockStatements,           // Statements in block\r\n            SwitchClauses,             // Clauses in switch statement\r\n            SwitchClauseStatements,    // Statements in switch clause\r\n            TypeMembers,               // Members in interface or type literal\r\n            ClassMembers,              // Members in class declaration\r\n            EnumMembers,               // Members in enum declaration\r\n            HeritageClauseElement,     // Elements in a heritage clause\r\n            VariableDeclarations,      // Variable declarations in variable statement\r\n            ObjectBindingElements,     // Binding elements in object binding list\r\n            ArrayBindingElements,      // Binding elements in array binding list\r\n            ArgumentExpressions,       // Expressions in argument list\r\n            ObjectLiteralMembers,      // Members in object literal\r\n            JsxAttributes,             // Attributes in jsx element\r\n            JsxChildren,               // Things between opening and closing JSX tags\r\n            ArrayLiteralMembers,       // Members in array literal\r\n            Parameters,                // Parameters in parameter list\r\n            RestProperties,            // Property names in a rest type list\r\n            TypeParameters,            // Type parameters in type parameter list\r\n            TypeArguments,             // Type arguments in type argument list\r\n            TupleElementTypes,         // Element types in tuple element type list\r\n            HeritageClauses,           // Heritage clauses for a class or interface declaration.\r\n            ImportOrExportSpecifiers,  // Named import clause's import specifier list\r\n            Count                      // Number of parsing contexts\r\n        }\r\n\r\n        const enum Tristate {\r\n            False,\r\n            True,\r\n            Unknown\r\n        }\r\n\r\n        export namespace JSDocParser {\r\n            export function parseJSDocTypeExpressionForTests(content: string, start: number, length: number): { jsDocTypeExpression: JSDocTypeExpression, diagnostics: Diagnostic[] } | undefined {\r\n                initializeState(content, ScriptTarget.Latest, /*_syntaxCursor:*/ undefined, ScriptKind.JS);\r\n                sourceFile = createSourceFile(\"file.js\", ScriptTarget.Latest, ScriptKind.JS);\r\n                scanner.setText(content, start, length);\r\n                currentToken = scanner.scan();\r\n                const jsDocTypeExpression = parseJSDocTypeExpression();\r\n                const diagnostics = parseDiagnostics;\r\n                clearState();\r\n\r\n                return jsDocTypeExpression ? { jsDocTypeExpression, diagnostics } : undefined;\r\n            }\r\n\r\n            // Parses out a JSDoc type expression.\r\n            export function parseJSDocTypeExpression(): JSDocTypeExpression;\r\n            export function parseJSDocTypeExpression(requireBraces: true): JSDocTypeExpression | undefined;\r\n            export function parseJSDocTypeExpression(requireBraces?: boolean): JSDocTypeExpression | undefined {\r\n                const result = <JSDocTypeExpression>createNode(SyntaxKind.JSDocTypeExpression, scanner.getTokenPos());\r\n\r\n                if (!parseExpected(SyntaxKind.OpenBraceToken) && requireBraces) {\r\n                    return undefined;\r\n                }\r\n                result.type = doInsideOfContext(NodeFlags.JSDoc, parseType);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n\r\n                fixupParentReferences(result);\r\n                return finishNode(result);\r\n            }\r\n\r\n            export function parseIsolatedJSDocComment(content: string, start: number, length: number): { jsDoc: JSDoc, diagnostics: Diagnostic[] } | undefined {\r\n                initializeState(content, ScriptTarget.Latest, /*_syntaxCursor:*/ undefined, ScriptKind.JS);\r\n                sourceFile = <SourceFile>{ languageVariant: LanguageVariant.Standard, text: content }; // tslint:disable-line no-object-literal-type-assertion\r\n                const jsDoc = parseJSDocCommentWorker(start, length);\r\n                const diagnostics = parseDiagnostics;\r\n                clearState();\r\n\r\n                return jsDoc ? { jsDoc, diagnostics } : undefined;\r\n            }\r\n\r\n            export function parseJSDocComment(parent: HasJSDoc, start: number, length: number): JSDoc {\r\n                const saveToken = currentToken;\r\n                const saveParseDiagnosticsLength = parseDiagnostics.length;\r\n                const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\r\n\r\n                const comment = parseJSDocCommentWorker(start, length);\r\n                if (comment) {\r\n                    comment.parent = parent;\r\n                }\r\n\r\n                if (isInJavaScriptFile(parent)) {\r\n                    if (!sourceFile.jsDocDiagnostics) {\r\n                        sourceFile.jsDocDiagnostics = [];\r\n                    }\r\n                    sourceFile.jsDocDiagnostics.push(...parseDiagnostics);\r\n                }\r\n                currentToken = saveToken;\r\n                parseDiagnostics.length = saveParseDiagnosticsLength;\r\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\r\n\r\n                return comment;\r\n            }\r\n\r\n            const enum JSDocState {\r\n                BeginningOfLine,\r\n                SawAsterisk,\r\n                SavingComments,\r\n            }\r\n\r\n            const enum PropertyLikeParse {\r\n                Property,\r\n                Parameter,\r\n            }\r\n\r\n            export function parseJSDocCommentWorker(start: number, length: number): JSDoc {\r\n                const content = sourceText;\r\n                start = start || 0;\r\n                const end = length === undefined ? content.length : start + length;\r\n                length = end - start;\r\n\r\n                Debug.assert(start >= 0);\r\n                Debug.assert(start <= end);\r\n                Debug.assert(end <= content.length);\r\n\r\n                let tags: JSDocTag[];\r\n                let tagsPos: number;\r\n                let tagsEnd: number;\r\n                const comments: string[] = [];\r\n                let result: JSDoc;\r\n\r\n                // Check for /** (JSDoc opening part)\r\n                if (!isJsDocStart(content, start)) {\r\n                    return result;\r\n                }\r\n\r\n                // + 3 for leading /**, - 5 in total for /** */\r\n                scanner.scanRange(start + 3, length - 5, () => {\r\n                    // Initially we can parse out a tag.  We also have seen a starting asterisk.\r\n                    // This is so that /** * @type */ doesn't parse.\r\n                    let advanceToken = true;\r\n                    let state = JSDocState.SawAsterisk;\r\n                    let margin: number | undefined = undefined;\r\n                    // + 4 for leading '/** '\r\n                    let indent = start - Math.max(content.lastIndexOf(\"\\n\", start), 0) + 4;\r\n                    function pushComment(text: string) {\r\n                        if (!margin) {\r\n                            margin = indent;\r\n                        }\r\n                        comments.push(text);\r\n                        indent += text.length;\r\n                    }\r\n\r\n                    nextJSDocToken();\r\n                    while (token() === SyntaxKind.WhitespaceTrivia) {\r\n                        nextJSDocToken();\r\n                    }\r\n                    if (token() === SyntaxKind.NewLineTrivia) {\r\n                        state = JSDocState.BeginningOfLine;\r\n                        indent = 0;\r\n                        nextJSDocToken();\r\n                    }\r\n                    while (token() !== SyntaxKind.EndOfFileToken) {\r\n                        switch (token()) {\r\n                            case SyntaxKind.AtToken:\r\n                                if (state === JSDocState.BeginningOfLine || state === JSDocState.SawAsterisk) {\r\n                                    removeTrailingNewlines(comments);\r\n                                    parseTag(indent);\r\n                                    // NOTE: According to usejsdoc.org, a tag goes to end of line, except the last tag.\r\n                                    // Real-world comments may break this rule, so \"BeginningOfLine\" will not be a real line beginning\r\n                                    // for malformed examples like `/** @param {string} x @returns {number} the length */`\r\n                                    state = JSDocState.BeginningOfLine;\r\n                                    advanceToken = false;\r\n                                    margin = undefined;\r\n                                    indent++;\r\n                                }\r\n                                else {\r\n                                    pushComment(scanner.getTokenText());\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                comments.push(scanner.getTokenText());\r\n                                state = JSDocState.BeginningOfLine;\r\n                                indent = 0;\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                const asterisk = scanner.getTokenText();\r\n                                if (state === JSDocState.SawAsterisk || state === JSDocState.SavingComments) {\r\n                                    // If we've already seen an asterisk, then we can no longer parse a tag on this line\r\n                                    state = JSDocState.SavingComments;\r\n                                    pushComment(asterisk);\r\n                                }\r\n                                else {\r\n                                    // Ignore the first asterisk on a line\r\n                                    state = JSDocState.SawAsterisk;\r\n                                    indent += asterisk.length;\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.Identifier:\r\n                                // Anything else is doc comment text. We just save it. Because it\r\n                                // wasn't a tag, we can no longer parse a tag on this line until we hit the next\r\n                                // line break.\r\n                                pushComment(scanner.getTokenText());\r\n                                state = JSDocState.SavingComments;\r\n                                break;\r\n                            case SyntaxKind.WhitespaceTrivia:\r\n                                // only collect whitespace if we're already saving comments or have just crossed the comment indent margin\r\n                                const whitespace = scanner.getTokenText();\r\n                                if (state === JSDocState.SavingComments) {\r\n                                    comments.push(whitespace);\r\n                                }\r\n                                else if (margin !== undefined && indent + whitespace.length > margin) {\r\n                                    comments.push(whitespace.slice(margin - indent - 1));\r\n                                }\r\n                                indent += whitespace.length;\r\n                                break;\r\n                            case SyntaxKind.EndOfFileToken:\r\n                                break;\r\n                            default:\r\n                                // anything other than whitespace or asterisk at the beginning of the line starts the comment text\r\n                                state = JSDocState.SavingComments;\r\n                                pushComment(scanner.getTokenText());\r\n                                break;\r\n                        }\r\n                        if (advanceToken) {\r\n                            nextJSDocToken();\r\n                        }\r\n                        else {\r\n                            advanceToken = true;\r\n                        }\r\n                    }\r\n                    removeLeadingNewlines(comments);\r\n                    removeTrailingNewlines(comments);\r\n                    result = createJSDocComment();\r\n\r\n                });\r\n\r\n                return result;\r\n\r\n                function removeLeadingNewlines(comments: string[]) {\r\n                    while (comments.length && (comments[0] === \"\\n\" || comments[0] === \"\\r\")) {\r\n                        comments.shift();\r\n                    }\r\n                }\r\n\r\n                function removeTrailingNewlines(comments: string[]) {\r\n                    while (comments.length && (comments[comments.length - 1] === \"\\n\" || comments[comments.length - 1] === \"\\r\")) {\r\n                        comments.pop();\r\n                    }\r\n                }\r\n\r\n                function isJsDocStart(content: string, start: number) {\r\n                    return content.charCodeAt(start) === CharacterCodes.slash &&\r\n                        content.charCodeAt(start + 1) === CharacterCodes.asterisk &&\r\n                        content.charCodeAt(start + 2) === CharacterCodes.asterisk &&\r\n                        content.charCodeAt(start + 3) !== CharacterCodes.asterisk;\r\n                }\r\n\r\n                function createJSDocComment(): JSDoc {\r\n                    const result = <JSDoc>createNode(SyntaxKind.JSDocComment, start);\r\n                    result.tags = tags && createNodeArray(tags, tagsPos, tagsEnd);\r\n                    result.comment = comments.length ? comments.join(\"\") : undefined;\r\n                    return finishNode(result, end);\r\n                }\r\n\r\n                function skipWhitespace(): void {\r\n                    while (token() === SyntaxKind.WhitespaceTrivia || token() === SyntaxKind.NewLineTrivia) {\r\n                        nextJSDocToken();\r\n                    }\r\n                }\r\n\r\n                function parseTag(indent: number) {\r\n                    Debug.assert(token() === SyntaxKind.AtToken);\r\n                    const atToken = <AtToken>createNode(SyntaxKind.AtToken, scanner.getTokenPos());\r\n                    atToken.end = scanner.getTextPos();\r\n                    nextJSDocToken();\r\n\r\n                    const tagName = parseJSDocIdentifierName();\r\n                    skipWhitespace();\r\n                    if (!tagName) {\r\n                        return;\r\n                    }\r\n\r\n                    let tag: JSDocTag;\r\n                    if (tagName) {\r\n                        switch (tagName.escapedText) {\r\n                            case \"augments\":\r\n                            case \"extends\":\r\n                                tag = parseAugmentsTag(atToken, tagName);\r\n                                break;\r\n                            case \"class\":\r\n                            case \"constructor\":\r\n                                tag = parseClassTag(atToken, tagName);\r\n                                break;\r\n                            case \"arg\":\r\n                            case \"argument\":\r\n                            case \"param\":\r\n                                tag = parseParameterOrPropertyTag(atToken, tagName, PropertyLikeParse.Parameter);\r\n                                break;\r\n                            case \"return\":\r\n                            case \"returns\":\r\n                                tag = parseReturnTag(atToken, tagName);\r\n                                break;\r\n                            case \"template\":\r\n                                tag = parseTemplateTag(atToken, tagName);\r\n                                break;\r\n                            case \"type\":\r\n                                tag = parseTypeTag(atToken, tagName);\r\n                                break;\r\n                            case \"typedef\":\r\n                                tag = parseTypedefTag(atToken, tagName);\r\n                                break;\r\n                            default:\r\n                                tag = parseUnknownTag(atToken, tagName);\r\n                                break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tag = parseUnknownTag(atToken, tagName);\r\n                    }\r\n\r\n                    if (!tag) {\r\n                        // a badly malformed tag should not be added to the list of tags\r\n                        return;\r\n                    }\r\n                    addTag(tag, parseTagComments(indent + tag.end - tag.pos));\r\n                }\r\n\r\n                function parseTagComments(indent: number) {\r\n                    const comments: string[] = [];\r\n                    let state = JSDocState.BeginningOfLine;\r\n                    let margin: number | undefined;\r\n                    function pushComment(text: string) {\r\n                        if (!margin) {\r\n                            margin = indent;\r\n                        }\r\n                        comments.push(text);\r\n                        indent += text.length;\r\n                    }\r\n                    while (token() !== SyntaxKind.AtToken && token() !== SyntaxKind.EndOfFileToken) {\r\n                        switch (token()) {\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                if (state >= JSDocState.SawAsterisk) {\r\n                                    state = JSDocState.BeginningOfLine;\r\n                                    comments.push(scanner.getTokenText());\r\n                                }\r\n                                indent = 0;\r\n                                break;\r\n                            case SyntaxKind.AtToken:\r\n                                // Done\r\n                                break;\r\n                            case SyntaxKind.WhitespaceTrivia:\r\n                                if (state === JSDocState.SavingComments) {\r\n                                    pushComment(scanner.getTokenText());\r\n                                }\r\n                                else {\r\n                                    const whitespace = scanner.getTokenText();\r\n                                    // if the whitespace crosses the margin, take only the whitespace that passes the margin\r\n                                    if (margin !== undefined && indent + whitespace.length > margin) {\r\n                                        comments.push(whitespace.slice(margin - indent - 1));\r\n                                    }\r\n                                    indent += whitespace.length;\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                if (state === JSDocState.BeginningOfLine) {\r\n                                    // leading asterisks start recording on the *next* (non-whitespace) token\r\n                                    state = JSDocState.SawAsterisk;\r\n                                    indent += scanner.getTokenText().length;\r\n                                    break;\r\n                                }\r\n                            // record the * as a comment\r\n                            // falls through\r\n                            default:\r\n                                state = JSDocState.SavingComments; // leading identifiers start recording as well\r\n                                pushComment(scanner.getTokenText());\r\n                                break;\r\n                        }\r\n                        if (token() === SyntaxKind.AtToken) {\r\n                            // Done\r\n                            break;\r\n                        }\r\n                        nextJSDocToken();\r\n                    }\r\n\r\n                    removeLeadingNewlines(comments);\r\n                    removeTrailingNewlines(comments);\r\n                    return comments;\r\n                }\r\n\r\n                function parseUnknownTag(atToken: AtToken, tagName: Identifier) {\r\n                    const result = <JSDocTag>createNode(SyntaxKind.JSDocTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function addTag(tag: JSDocTag, comments: string[]): void {\r\n                    tag.comment = comments.join(\"\");\r\n\r\n                    if (!tags) {\r\n                        tags = [tag];\r\n                        tagsPos = tag.pos;\r\n                    }\r\n                    else {\r\n                        tags.push(tag);\r\n                    }\r\n                    tagsEnd = tag.end;\r\n                }\r\n\r\n                function tryParseTypeExpression(): JSDocTypeExpression | undefined {\r\n                    skipWhitespace();\r\n                    return token() === SyntaxKind.OpenBraceToken ? parseJSDocTypeExpression() : undefined;\r\n                }\r\n\r\n                function parseBracketNameInPropertyAndParamTag(): { name: EntityName, isBracketed: boolean } {\r\n                    // Looking for something like '[foo]', 'foo', '[foo.bar]' or 'foo.bar'\r\n                    const isBracketed = parseOptional(SyntaxKind.OpenBracketToken);\r\n                    const name = parseJSDocEntityName();\r\n                    if (isBracketed) {\r\n                        skipWhitespace();\r\n\r\n                        // May have an optional default, e.g. '[foo = 42]'\r\n                        if (parseOptionalToken(SyntaxKind.EqualsToken)) {\r\n                            parseExpression();\r\n                        }\r\n\r\n                        parseExpected(SyntaxKind.CloseBracketToken);\r\n                    }\r\n\r\n                    return { name, isBracketed };\r\n                }\r\n\r\n                function isObjectOrObjectArrayTypeReference(node: TypeNode): boolean {\r\n                    switch (node.kind) {\r\n                        case SyntaxKind.ObjectKeyword:\r\n                            return true;\r\n                        case SyntaxKind.ArrayType:\r\n                            return isObjectOrObjectArrayTypeReference((node as ArrayTypeNode).elementType);\r\n                        default:\r\n                            return isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === \"Object\";\r\n                    }\r\n                }\r\n\r\n                function parseParameterOrPropertyTag(atToken: AtToken, tagName: Identifier, target: PropertyLikeParse.Parameter): JSDocParameterTag;\r\n                function parseParameterOrPropertyTag(atToken: AtToken, tagName: Identifier, target: PropertyLikeParse.Property): JSDocPropertyTag;\r\n                function parseParameterOrPropertyTag(atToken: AtToken, tagName: Identifier, target: PropertyLikeParse): JSDocPropertyLikeTag {\r\n                    let typeExpression = tryParseTypeExpression();\r\n                    let isNameFirst = !typeExpression;\r\n                    skipWhitespace();\r\n\r\n                    const { name, isBracketed } = parseBracketNameInPropertyAndParamTag();\r\n                    skipWhitespace();\r\n\r\n                    if (isNameFirst) {\r\n                        typeExpression = tryParseTypeExpression();\r\n                    }\r\n\r\n                    const result: JSDocPropertyLikeTag = target === PropertyLikeParse.Parameter ?\r\n                        <JSDocParameterTag>createNode(SyntaxKind.JSDocParameterTag, atToken.pos) :\r\n                        <JSDocPropertyTag>createNode(SyntaxKind.JSDocPropertyTag, atToken.pos);\r\n                    const nestedTypeLiteral = parseNestedTypeLiteral(typeExpression, name);\r\n                    if (nestedTypeLiteral) {\r\n                        typeExpression = nestedTypeLiteral;\r\n                        isNameFirst = true;\r\n                    }\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = typeExpression;\r\n                    result.name = name;\r\n                    result.isNameFirst = isNameFirst;\r\n                    result.isBracketed = isBracketed;\r\n                    return finishNode(result);\r\n\r\n                }\r\n\r\n                function parseNestedTypeLiteral(typeExpression: JSDocTypeExpression, name: EntityName) {\r\n                    if (typeExpression && isObjectOrObjectArrayTypeReference(typeExpression.type)) {\r\n                        const typeLiteralExpression = <JSDocTypeExpression>createNode(SyntaxKind.JSDocTypeExpression, scanner.getTokenPos());\r\n                        let child: JSDocParameterTag | false;\r\n                        let jsdocTypeLiteral: JSDocTypeLiteral;\r\n                        const start = scanner.getStartPos();\r\n                        let children: JSDocParameterTag[];\r\n                        while (child = tryParse(() => parseChildParameterOrPropertyTag(PropertyLikeParse.Parameter, name))) {\r\n                            if (!children) {\r\n                                children = [];\r\n                            }\r\n                            children.push(child);\r\n                        }\r\n                        if (children) {\r\n                            jsdocTypeLiteral = <JSDocTypeLiteral>createNode(SyntaxKind.JSDocTypeLiteral, start);\r\n                            jsdocTypeLiteral.jsDocPropertyTags = children;\r\n                            if (typeExpression.type.kind === SyntaxKind.ArrayType) {\r\n                                jsdocTypeLiteral.isArrayType = true;\r\n                            }\r\n                            typeLiteralExpression.type = finishNode(jsdocTypeLiteral);\r\n                            return finishNode(typeLiteralExpression);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function parseReturnTag(atToken: AtToken, tagName: Identifier): JSDocReturnTag {\r\n                    if (forEach(tags, t => t.kind === SyntaxKind.JSDocReturnTag)) {\r\n                        parseErrorAtPosition(tagName.pos, scanner.getTokenPos() - tagName.pos, Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    const result = <JSDocReturnTag>createNode(SyntaxKind.JSDocReturnTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = tryParseTypeExpression();\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseTypeTag(atToken: AtToken, tagName: Identifier): JSDocTypeTag {\r\n                    if (forEach(tags, t => t.kind === SyntaxKind.JSDocTypeTag)) {\r\n                        parseErrorAtPosition(tagName.pos, scanner.getTokenPos() - tagName.pos, Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    const result = <JSDocTypeTag>createNode(SyntaxKind.JSDocTypeTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = parseJSDocTypeExpression(/*requireBraces*/ true);\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseAugmentsTag(atToken: AtToken, tagName: Identifier): JSDocAugmentsTag {\r\n                    const result = <JSDocAugmentsTag>createNode(SyntaxKind.JSDocAugmentsTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.class = parseExpressionWithTypeArgumentsForAugments();\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseExpressionWithTypeArgumentsForAugments(): ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression } {\r\n                    const usedBrace = parseOptional(SyntaxKind.OpenBraceToken);\r\n                    const node = createNode(SyntaxKind.ExpressionWithTypeArguments) as ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression };\r\n                    node.expression = parsePropertyAccessEntityNameExpression();\r\n                    node.typeArguments = tryParseTypeArguments();\r\n                    const res = finishNode(node);\r\n                    if (usedBrace) {\r\n                        parseExpected(SyntaxKind.CloseBraceToken);\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                function parsePropertyAccessEntityNameExpression() {\r\n                    let node: Identifier | PropertyAccessEntityNameExpression = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                    while (parseOptional(SyntaxKind.DotToken)) {\r\n                        const prop: PropertyAccessEntityNameExpression = createNode(SyntaxKind.PropertyAccessExpression, node.pos) as PropertyAccessEntityNameExpression;\r\n                        prop.expression = node;\r\n                        prop.name = parseJSDocIdentifierName();\r\n                        node = finishNode(prop);\r\n                    }\r\n                    return node;\r\n                }\r\n\r\n                function parseClassTag(atToken: AtToken, tagName: Identifier): JSDocClassTag {\r\n                    const tag = <JSDocClassTag>createNode(SyntaxKind.JSDocClassTag, atToken.pos);\r\n                    tag.atToken = atToken;\r\n                    tag.tagName = tagName;\r\n                    return finishNode(tag);\r\n                }\r\n\r\n                function parseTypedefTag(atToken: AtToken, tagName: Identifier): JSDocTypedefTag {\r\n                    const typeExpression = tryParseTypeExpression();\r\n                    skipWhitespace();\r\n\r\n                    const typedefTag = <JSDocTypedefTag>createNode(SyntaxKind.JSDocTypedefTag, atToken.pos);\r\n                    typedefTag.atToken = atToken;\r\n                    typedefTag.tagName = tagName;\r\n                    typedefTag.fullName = parseJSDocTypeNameWithNamespace(/*flags*/ 0);\r\n                    if (typedefTag.fullName) {\r\n                        let rightNode = typedefTag.fullName;\r\n                        while (true) {\r\n                            if (rightNode.kind === SyntaxKind.Identifier || !rightNode.body) {\r\n                                // if node is identifier - use it as name\r\n                                // otherwise use name of the rightmost part that we were able to parse\r\n                                typedefTag.name = rightNode.kind === SyntaxKind.Identifier ? rightNode : rightNode.name;\r\n                                break;\r\n                            }\r\n                            rightNode = rightNode.body;\r\n                        }\r\n                    }\r\n                    skipWhitespace();\r\n\r\n                    typedefTag.typeExpression = typeExpression;\r\n                    if (!typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type)) {\r\n                        let child: JSDocTypeTag | JSDocPropertyTag | false;\r\n                        let jsdocTypeLiteral: JSDocTypeLiteral;\r\n                        let childTypeTag: JSDocTypeTag;\r\n                        const start = scanner.getStartPos();\r\n                        while (child = tryParse(() => parseChildParameterOrPropertyTag(PropertyLikeParse.Property))) {\r\n                            if (!jsdocTypeLiteral) {\r\n                                jsdocTypeLiteral = <JSDocTypeLiteral>createNode(SyntaxKind.JSDocTypeLiteral, start);\r\n                            }\r\n                            if (child.kind === SyntaxKind.JSDocTypeTag) {\r\n                                if (childTypeTag) {\r\n                                    break;\r\n                                }\r\n                                else {\r\n                                    childTypeTag = child;\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (!jsdocTypeLiteral.jsDocPropertyTags) {\r\n                                    jsdocTypeLiteral.jsDocPropertyTags = [] as MutableNodeArray<JSDocPropertyTag>;\r\n                                }\r\n                                (jsdocTypeLiteral.jsDocPropertyTags as MutableNodeArray<JSDocPropertyTag>).push(child);\r\n                            }\r\n                        }\r\n                        if (jsdocTypeLiteral) {\r\n                            if (typeExpression && typeExpression.type.kind === SyntaxKind.ArrayType) {\r\n                                jsdocTypeLiteral.isArrayType = true;\r\n                            }\r\n                            typedefTag.typeExpression = childTypeTag && childTypeTag.typeExpression && !isObjectOrObjectArrayTypeReference(childTypeTag.typeExpression.type) ?\r\n                                childTypeTag.typeExpression :\r\n                                finishNode(jsdocTypeLiteral);\r\n                        }\r\n                    }\r\n\r\n                    return finishNode(typedefTag);\r\n\r\n                    function parseJSDocTypeNameWithNamespace(flags: NodeFlags) {\r\n                        const pos = scanner.getTokenPos();\r\n                        const typeNameOrNamespaceName = parseJSDocIdentifierName();\r\n\r\n                        if (typeNameOrNamespaceName && parseOptional(SyntaxKind.DotToken)) {\r\n                            const jsDocNamespaceNode = <JSDocNamespaceDeclaration>createNode(SyntaxKind.ModuleDeclaration, pos);\r\n                            jsDocNamespaceNode.flags |= flags;\r\n                            jsDocNamespaceNode.name = typeNameOrNamespaceName;\r\n                            jsDocNamespaceNode.body = parseJSDocTypeNameWithNamespace(NodeFlags.NestedNamespace);\r\n                            return finishNode(jsDocNamespaceNode);\r\n                        }\r\n\r\n                        if (typeNameOrNamespaceName && flags & NodeFlags.NestedNamespace) {\r\n                            typeNameOrNamespaceName.isInJSDocNamespace = true;\r\n                        }\r\n                        return typeNameOrNamespaceName;\r\n                    }\r\n                }\r\n\r\n                function escapedTextsEqual(a: EntityName, b: EntityName): boolean {\r\n                    while (!ts.isIdentifier(a) || !ts.isIdentifier(b)) {\r\n                        if (!ts.isIdentifier(a) && !ts.isIdentifier(b) && a.right.escapedText === b.right.escapedText) {\r\n                            a = a.left;\r\n                            b = b.left;\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return a.escapedText === b.escapedText;\r\n                }\r\n\r\n                function parseChildParameterOrPropertyTag(target: PropertyLikeParse.Property): JSDocTypeTag | JSDocPropertyTag | false;\r\n                function parseChildParameterOrPropertyTag(target: PropertyLikeParse.Parameter, name: EntityName): JSDocParameterTag | false;\r\n                function parseChildParameterOrPropertyTag(target: PropertyLikeParse, name?: EntityName): JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | false {\r\n                    let canParseTag = true;\r\n                    let seenAsterisk = false;\r\n                    while (true) {\r\n                        nextJSDocToken();\r\n                        switch (token()) {\r\n                            case SyntaxKind.AtToken:\r\n                                if (canParseTag) {\r\n                                    const child = tryParseChildTag(target);\r\n                                    if (child && child.kind === SyntaxKind.JSDocParameterTag &&\r\n                                        (ts.isIdentifier(child.name) || !escapedTextsEqual(name, child.name.left))) {\r\n                                        return false;\r\n                                    }\r\n                                    return child;\r\n                                }\r\n                                seenAsterisk = false;\r\n                                break;\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                canParseTag = true;\r\n                                seenAsterisk = false;\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                if (seenAsterisk) {\r\n                                    canParseTag = false;\r\n                                }\r\n                                seenAsterisk = true;\r\n                                break;\r\n                            case SyntaxKind.Identifier:\r\n                                canParseTag = false;\r\n                                break;\r\n                            case SyntaxKind.EndOfFileToken:\r\n                                return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function tryParseChildTag(target: PropertyLikeParse): JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | false {\r\n                    Debug.assert(token() === SyntaxKind.AtToken);\r\n                    const atToken = <AtToken>createNode(SyntaxKind.AtToken, scanner.getStartPos());\r\n                    atToken.end = scanner.getTextPos();\r\n                    nextJSDocToken();\r\n\r\n                    const tagName = parseJSDocIdentifierName();\r\n                    skipWhitespace();\r\n                    if (!tagName) {\r\n                        return false;\r\n                    }\r\n                    switch (tagName.escapedText) {\r\n                        case \"type\":\r\n                            return target === PropertyLikeParse.Property && parseTypeTag(atToken, tagName);\r\n                        case \"prop\":\r\n                        case \"property\":\r\n                            return target === PropertyLikeParse.Property && parseParameterOrPropertyTag(atToken, tagName, target);\r\n                        case \"arg\":\r\n                        case \"argument\":\r\n                        case \"param\":\r\n                            return target === PropertyLikeParse.Parameter && parseParameterOrPropertyTag(atToken, tagName, target);\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                function parseTemplateTag(atToken: AtToken, tagName: Identifier): JSDocTemplateTag | undefined {\r\n                    if (forEach(tags, t => t.kind === SyntaxKind.JSDocTemplateTag)) {\r\n                        parseErrorAtPosition(tagName.pos, scanner.getTokenPos() - tagName.pos, Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    // Type parameter list looks like '@template T,U,V'\r\n                    const typeParameters = [];\r\n                    const typeParametersPos = getNodePos();\r\n\r\n                    while (true) {\r\n                        const name = parseJSDocIdentifierName();\r\n                        skipWhitespace();\r\n                        if (!name) {\r\n                            parseErrorAtPosition(scanner.getStartPos(), 0, Diagnostics.Identifier_expected);\r\n                            return undefined;\r\n                        }\r\n\r\n                        const typeParameter = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter, name.pos);\r\n                        typeParameter.name = name;\r\n                        finishNode(typeParameter);\r\n\r\n                        typeParameters.push(typeParameter);\r\n\r\n                        if (token() === SyntaxKind.CommaToken) {\r\n                            nextJSDocToken();\r\n                            skipWhitespace();\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    const result = <JSDocTemplateTag>createNode(SyntaxKind.JSDocTemplateTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeParameters = createNodeArray(typeParameters, typeParametersPos);\r\n                    finishNode(result);\r\n                    return result;\r\n                }\r\n\r\n                function nextJSDocToken(): SyntaxKind {\r\n                    return currentToken = scanner.scanJSDocToken();\r\n                }\r\n\r\n                function parseJSDocEntityName(): EntityName {\r\n                    let entity: EntityName = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                    if (parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                        parseExpected(SyntaxKind.CloseBracketToken);\r\n                        // Note that y[] is accepted as an entity name, but the postfix brackets are not saved for checking.\r\n                        // Technically usejsdoc.org requires them for specifying a property of a type equivalent to Array<{ x: ...}>\r\n                        // but it's not worth it to enforce that restriction.\r\n                    }\r\n                    while (parseOptional(SyntaxKind.DotToken)) {\r\n                        const name = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                        if (parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                        }\r\n                        entity = createQualifiedName(entity, name);\r\n                    }\r\n                    return entity;\r\n                }\r\n\r\n                function parseJSDocIdentifierName(): Identifier | undefined;\r\n                function parseJSDocIdentifierName(createIfMissing: true): Identifier;\r\n                function parseJSDocIdentifierName(createIfMissing = false): Identifier | undefined {\r\n                    if (!tokenIsIdentifierOrKeyword(token())) {\r\n                        if (createIfMissing) {\r\n                            return createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Identifier_expected);\r\n                        }\r\n                        else {\r\n                            parseErrorAtCurrentToken(Diagnostics.Identifier_expected);\r\n                            return undefined;\r\n                        }\r\n                    }\r\n\r\n                    const pos = scanner.getTokenPos();\r\n                    const end = scanner.getTextPos();\r\n                    const result = <Identifier>createNode(SyntaxKind.Identifier, pos);\r\n                    result.escapedText = escapeLeadingUnderscores(content.substring(pos, end));\r\n                    finishNode(result, end);\r\n\r\n                    nextJSDocToken();\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        export namespace 编译词典标签 {\r\n\r\n            export function 编译词典(start: number, length: number, 词典头部长度 = 4, 父节点?: Node) {\r\n                const saveToken = currentToken;\r\n                const saveParseDiagnosticsLength = parseDiagnostics.length;\r\n                const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\r\n                const 词典语句 = 编译词典语句(start, length, 词典头部长度);\r\n                if (词典语句) {\r\n                    词典语句.parent = 父节点;\r\n                }\r\n                currentToken = saveToken;\r\n                parseDiagnostics.length = saveParseDiagnosticsLength;\r\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\r\n                return 词典语句;\r\n            }\r\n            function 编译词典语句(start: number, 长度: number, 词典头部长度: number) {\r\n                const content = sourceText;\r\n                start = start || 0;\r\n                const end = 长度 === undefined ? content.length : start + 长度;\r\n                let 语句种类: SyntaxKind\r\n                长度 = end - start;\r\n                Debug.assert(start >= 0);\r\n                Debug.assert(start <= end);\r\n                Debug.assert(end <= content.length);\r\n                if (是局部词典头(content, start)) {\r\n                    语句种类 = SyntaxKind.局部词典语句\r\n                } else {\r\n                    语句种类 = SyntaxKind.全局词典语句\r\n                }\r\n                let 返回值: 词典语句;\r\n                let 编译键 = false;\r\n                const 表达式: 词典[] = [];\r\n                //词典头部长度: 局部词典为 3 , 全局词典为 4\r\n                scanner.scanRange(start + 词典头部长度, 长度, () => {\r\n                    下个();\r\n                    返回值 = <词典语句>createNode(语句种类, scanner.getStartPos());\r\n                    跳出循环: while (true) {\r\n                        switch (token()) {\r\n                            case SyntaxKind.OpenBraceToken:\r\n                            case SyntaxKind.CommaToken:\r\n                                编译键 = true;\r\n                                下个();\r\n                                break;\r\n                            case SyntaxKind.Identifier:\r\n                            case SyntaxKind.StringLiteral:\r\n                                const 词典表达式 = 编译词典表达式(编译键, 语句种类);\r\n                                if (词典表达式) {\r\n                                    表达式.push(词典表达式);\r\n                                }\r\n                                编译键 = false;\r\n                                continue;\r\n                            case SyntaxKind.CloseBraceToken:\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                break 跳出循环;\r\n                            case SyntaxKind.Unknown:\r\n                                continue;\r\n                            default:\r\n                                下个();\r\n                                continue;\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                返回值.表达式 = createNodeArray(表达式, 返回值.pos);\r\n                return finishNode(返回值, 返回值.pos + 长度 - 3);\r\n            }\r\n            function 编译词典表达式(编译键: boolean, 语句种类: SyntaxKind) {\r\n                let 键, 值;\r\n                let 文本字面量标识符 = false;\r\n                const 返回值 = <词典>createNode(SyntaxKind.词典表达式);\r\n                if (编译键) {\r\n                    if (token() === SyntaxKind.StringLiteral) {\r\n                        文本字面量标识符 = true;\r\n                        键 = <词典键>createNode(SyntaxKind.词典键);\r\n                        键.name = 创建字面量词典标识符(是词典字面量标识符(), /** 诊断信息 */ undefined);\r\n                        键 = finishNode(键);\r\n                    }\r\n                    else {\r\n                        键 = <词典键>createNode(SyntaxKind.词典键);\r\n                        键.name = 创建词典标识符(是词典标识符(), /** 诊断信息 */ undefined);\r\n                        键 = finishNode(键);\r\n                    }\r\n                }\r\n                if (token() === SyntaxKind.ColonToken) {\r\n                    下个();\r\n                    if (文本字面量标识符 && token() === SyntaxKind.StringLiteral) {\r\n                        值 = <词典值>createNode(SyntaxKind.词典值);\r\n                        值.name = 创建字面量词典标识符(是词典字面量标识符(), /** 诊断信息 */ undefined);\r\n                        值 = finishNode(值);\r\n                    }\r\n                    else if (!文本字面量标识符 && token() === SyntaxKind.StringLiteral) {\r\n                        值 = <词典值>createNode(SyntaxKind.词典值);\r\n                        值.name = 创建字面量词典标识符( /** 是字面量标识符 */ false, /** 诊断信息 */ undefined);\r\n                        值 = finishNode(值);\r\n                    } else {\r\n                        值 = <词典值>createNode(SyntaxKind.词典值);\r\n                        值.name = 创建词典标识符(是词典标识符(), /** 诊断信息 */ undefined);\r\n                        值 = finishNode(值);\r\n                    }\r\n                }\r\n                if (键 && 值) {\r\n                    返回值.键 = 键;\r\n                    返回值.值 = 值;\r\n                    if (语句种类 === SyntaxKind.局部词典语句) {\r\n                        返回值.是局部词典 = 别名旗帜.局部词典;\r\n\r\n                    } else {\r\n                        返回值.是全局词典 = 别名旗帜.全局词典;\r\n                    }\r\n\r\n                    if (文本字面量标识符) {\r\n                        返回值.是文本字面量词典 = 别名旗帜.字面量;\r\n                        文本字面量标识符 = false;\r\n                    }\r\n                    返回值.词典类别 = 取词典类别(返回值.键);\r\n                    while (!(token() === SyntaxKind.EndOfFileToken || token() === SyntaxKind.NewLineTrivia || token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.CommaToken)) {\r\n                        parseErrorBeforeNextFinishedNode = true;\r\n                        下个();\r\n                    }\r\n                    return finishNode(返回值);\r\n                }\r\n                else {\r\n                    parseErrorBeforeNextFinishedNode = true;\r\n                    return finishNode(返回值);\r\n                }\r\n            }\r\n\r\n            function 取词典类别(键: 词典键) {\r\n                let text = \"\"\r\n                if (ts.isIdentifier(键.name)) {\r\n                    text = idText(键.name)\r\n                }\r\n                else {\r\n                    text = 键.name.text\r\n                }\r\n                for (let i = 0; text.length; i++) {\r\n                    if (text.charCodeAt(i) > 0xff) {\r\n                        return 别名旗帜.汉英\r\n                    }\r\n                }\r\n                return 别名旗帜.英汉\r\n            }\r\n\r\n            function 创建词典标识符(是标识符: boolean, 诊断信息: DiagnosticMessage) {\r\n                if (是标识符) {\r\n                    const 标识符 = <Identifier>createNode(SyntaxKind.Identifier);\r\n                    标识符.escapedText = escapeLeadingUnderscores(internIdentifier(scanner.getTokenValue()));\r\n                    下个();\r\n                    return finishNode(标识符);\r\n                }\r\n                下个();\r\n                return <Identifier>创建词典失踪节点(SyntaxKind.Identifier, 诊断信息 || Diagnostics.有与关键字冲突的词典标识符_名称为_0, scanner.getTokenValue());\r\n\r\n            }\r\n\r\n            function 创建字面量词典标识符(是字面量词典标识符: boolean, 诊断信息: DiagnosticMessage) {\r\n                if (是字面量词典标识符) {\r\n                    const 标识符 = <StringLiteral>createNode(SyntaxKind.StringLiteral);\r\n                    标识符.text = internIdentifier(scanner.getTokenValue());\r\n                    下个();\r\n                    return finishNode(标识符);\r\n                }\r\n                下个();\r\n                return <StringLiteral>创建词典失踪节点(SyntaxKind.StringLiteral, 诊断信息 || Diagnostics.字典的键为文字字面量值必须为文字字面量_错误名称为_0, scanner.getTokenValue());\r\n\r\n            }\r\n\r\n            function 是局部词典头(content: string, start: number) {\r\n                return content.charCodeAt(start) === CharacterCodes.slash &&\r\n                    content.charCodeAt(start + 1) === CharacterCodes.slash &&\r\n                    content.charCodeAt(start + 2) === CharacterCodes.at &&\r\n                    content.charCodeAt(start + 3) === CharacterCodes.openBrace;\r\n            }\r\n\r\n            function 下个() {\r\n                return currentToken = scanner.扫描词典主体();\r\n            }\r\n\r\n            function 是词典标识符() {\r\n                if (token() === SyntaxKind.Identifier) return true;\r\n                return token() > SyntaxKind.LastKeyword;\r\n\r\n            }\r\n\r\n            function 是词典字面量标识符() {\r\n                if (token() === SyntaxKind.StringLiteral) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            function 创建词典失踪节点(kind: SyntaxKind, diagnosticMessage: DiagnosticMessage, arg0?: any): Node {\r\n                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);\r\n                const result = createNode(kind, scanner.getStartPos());\r\n                (<Identifier>result).escapedText = \"\" as __String;\r\n                return finishNode(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    namespace IncrementalParser {\r\n        export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks: boolean): SourceFile {\r\n            aggressiveChecks = aggressiveChecks || Debug.shouldAssert(AssertionLevel.Aggressive);\r\n\r\n            checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks);\r\n            if (textChangeRangeIsUnchanged(textChangeRange)) {\r\n                // if the text didn't change, then we can just return our current source file as-is.\r\n                return sourceFile;\r\n            }\r\n\r\n            if (sourceFile.statements.length === 0) {\r\n                // If we don't have any statements in the current source file, then there's no real\r\n                // way to incrementally parse.  So just do a full parse instead.\r\n                return Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, /*syntaxCursor*/ undefined, /*setParentNodes*/ true, sourceFile.scriptKind);\r\n            }\r\n\r\n            // Make sure we're not trying to incrementally update a source file more than once.  Once\r\n            // we do an update the original source file is considered unusable from that point onwards.\r\n            //\r\n            // This is because we do incremental parsing in-place.  i.e. we take nodes from the old\r\n            // tree and give them new positions and parents.  From that point on, trusting the old\r\n            // tree at all is not possible as far too much of it may violate invariants.\r\n            const incrementalSourceFile = <IncrementalNode><Node>sourceFile;\r\n            Debug.assert(!incrementalSourceFile.hasBeenIncrementallyParsed);\r\n            incrementalSourceFile.hasBeenIncrementallyParsed = true;\r\n\r\n            const oldText = sourceFile.text;\r\n            const syntaxCursor = createSyntaxCursor(sourceFile);\r\n\r\n            // Make the actual change larger so that we know to reparse anything whose lookahead\r\n            // might have intersected the change.\r\n            const changeRange = extendToAffectedRange(sourceFile, textChangeRange);\r\n            checkChangeRange(sourceFile, newText, changeRange, aggressiveChecks);\r\n\r\n            // Ensure that extending the affected range only moved the start of the change range\r\n            // earlier in the file.\r\n            Debug.assert(changeRange.span.start <= textChangeRange.span.start);\r\n            Debug.assert(textSpanEnd(changeRange.span) === textSpanEnd(textChangeRange.span));\r\n            Debug.assert(textSpanEnd(textChangeRangeNewSpan(changeRange)) === textSpanEnd(textChangeRangeNewSpan(textChangeRange)));\r\n\r\n            // The is the amount the nodes after the edit range need to be adjusted.  It can be\r\n            // positive (if the edit added characters), negative (if the edit deleted characters)\r\n            // or zero (if this was a pure overwrite with nothing added/removed).\r\n            const delta = textChangeRangeNewSpan(changeRange).length - changeRange.span.length;\r\n\r\n            // If we added or removed characters during the edit, then we need to go and adjust all\r\n            // the nodes after the edit.  Those nodes may move forward (if we inserted chars) or they\r\n            // may move backward (if we deleted chars).\r\n            //\r\n            // Doing this helps us out in two ways.  First, it means that any nodes/tokens we want\r\n            // to reuse are already at the appropriate position in the new text.  That way when we\r\n            // reuse them, we don't have to figure out if they need to be adjusted.  Second, it makes\r\n            // it very easy to determine if we can reuse a node.  If the node's position is at where\r\n            // we are in the text, then we can reuse it.  Otherwise we can't.  If the node's position\r\n            // is ahead of us, then we'll need to rescan tokens.  If the node's position is behind\r\n            // us, then we'll need to skip it or crumble it as appropriate\r\n            //\r\n            // We will also adjust the positions of nodes that intersect the change range as well.\r\n            // By doing this, we ensure that all the positions in the old tree are consistent, not\r\n            // just the positions of nodes entirely before/after the change range.  By being\r\n            // consistent, we can then easily map from positions to nodes in the old tree easily.\r\n            //\r\n            // Also, mark any syntax elements that intersect the changed span.  We know, up front,\r\n            // that we cannot reuse these elements.\r\n            updateTokenPositionsAndMarkElements(incrementalSourceFile,\r\n                changeRange.span.start, textSpanEnd(changeRange.span), textSpanEnd(textChangeRangeNewSpan(changeRange)), delta, oldText, newText, aggressiveChecks);\r\n\r\n            // Now that we've set up our internal incremental state just proceed and parse the\r\n            // source file in the normal fashion.  When possible the parser will retrieve and\r\n            // reuse nodes from the old tree.\r\n            //\r\n            // Note: passing in 'true' for setNodeParents is very important.  When incrementally\r\n            // parsing, we will be reusing nodes from the old tree, and placing it into new\r\n            // parents.  If we don't set the parents now, we'll end up with an observably\r\n            // inconsistent tree.  Setting the parents on the new tree should be very fast.  We\r\n            // will immediately bail out of walking any subtrees when we can see that their parents\r\n            // are already correct.\r\n            const result = Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, syntaxCursor, /*setParentNodes*/ true, sourceFile.scriptKind);\r\n\r\n            return result;\r\n        }\r\n\r\n        function moveElementEntirelyPastChangeRange(element: IncrementalElement, isArray: boolean, delta: number, oldText: string, newText: string, aggressiveChecks: boolean) {\r\n            if (isArray) {\r\n                visitArray(<IncrementalNodeArray>element);\r\n            }\r\n            else {\r\n                visitNode(<IncrementalNode>element);\r\n            }\r\n            return;\r\n\r\n            function visitNode(node: IncrementalNode) {\r\n                let text = \"\";\r\n                if (aggressiveChecks && shouldCheckNode(node)) {\r\n                    text = oldText.substring(node.pos, node.end);\r\n                }\r\n\r\n                // Ditch any existing LS children we may have created.  This way we can avoid\r\n                // moving them forward.\r\n                if (node._children) {\r\n                    node._children = undefined;\r\n                }\r\n\r\n                node.pos += delta;\r\n                node.end += delta;\r\n\r\n                if (aggressiveChecks && shouldCheckNode(node)) {\r\n                    Debug.assert(text === newText.substring(node.pos, node.end));\r\n                }\r\n\r\n                forEachChild(node, visitNode, visitArray);\r\n                if (hasJSDocNodes(node)) {\r\n                    for (const jsDocComment of node.jsDoc) {\r\n                        forEachChild(jsDocComment, visitNode, visitArray);\r\n                    }\r\n                }\r\n                checkNodePositions(node, aggressiveChecks);\r\n            }\r\n\r\n            function visitArray(array: IncrementalNodeArray) {\r\n                array._children = undefined;\r\n                array.pos += delta;\r\n                array.end += delta;\r\n\r\n                for (const node of array) {\r\n                    visitNode(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        function shouldCheckNode(node: Node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.Identifier:\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function adjustIntersectingElement(element: IncrementalElement, changeStart: number, changeRangeOldEnd: number, changeRangeNewEnd: number, delta: number) {\r\n            Debug.assert(element.end >= changeStart, \"Adjusting an element that was entirely before the change range\");\r\n            Debug.assert(element.pos <= changeRangeOldEnd, \"Adjusting an element that was entirely after the change range\");\r\n            Debug.assert(element.pos <= element.end);\r\n\r\n            // We have an element that intersects the change range in some way.  It may have its\r\n            // start, or its end (or both) in the changed range.  We want to adjust any part\r\n            // that intersects such that the final tree is in a consistent state.  i.e. all\r\n            // children have spans within the span of their parent, and all siblings are ordered\r\n            // properly.\r\n\r\n            // We may need to update both the 'pos' and the 'end' of the element.\r\n\r\n            // If the 'pos' is before the start of the change, then we don't need to touch it.\r\n            // If it isn't, then the 'pos' must be inside the change.  How we update it will\r\n            // depend if delta is  positive or negative.  If delta is positive then we have\r\n            // something like:\r\n            //\r\n            //  -------------------AAA-----------------\r\n            //  -------------------BBBCCCCCCC-----------------\r\n            //\r\n            // In this case, we consider any node that started in the change range to still be\r\n            // starting at the same position.\r\n            //\r\n            // however, if the delta is negative, then we instead have something like this:\r\n            //\r\n            //  -------------------XXXYYYYYYY-----------------\r\n            //  -------------------ZZZ-----------------\r\n            //\r\n            // In this case, any element that started in the 'X' range will keep its position.\r\n            // However any element that started after that will have their pos adjusted to be\r\n            // at the end of the new range.  i.e. any node that started in the 'Y' range will\r\n            // be adjusted to have their start at the end of the 'Z' range.\r\n            //\r\n            // The element will keep its position if possible.  Or Move backward to the new-end\r\n            // if it's in the 'Y' range.\r\n            element.pos = Math.min(element.pos, changeRangeNewEnd);\r\n\r\n            // If the 'end' is after the change range, then we always adjust it by the delta\r\n            // amount.  However, if the end is in the change range, then how we adjust it\r\n            // will depend on if delta is  positive or negative.  If delta is positive then we\r\n            // have something like:\r\n            //\r\n            //  -------------------AAA-----------------\r\n            //  -------------------BBBCCCCCCC-----------------\r\n            //\r\n            // In this case, we consider any node that ended inside the change range to keep its\r\n            // end position.\r\n            //\r\n            // however, if the delta is negative, then we instead have something like this:\r\n            //\r\n            //  -------------------XXXYYYYYYY-----------------\r\n            //  -------------------ZZZ-----------------\r\n            //\r\n            // In this case, any element that ended in the 'X' range will keep its position.\r\n            // However any element that ended after that will have their pos adjusted to be\r\n            // at the end of the new range.  i.e. any node that ended in the 'Y' range will\r\n            // be adjusted to have their end at the end of the 'Z' range.\r\n            if (element.end >= changeRangeOldEnd) {\r\n                // Element ends after the change range.  Always adjust the end pos.\r\n                element.end += delta;\r\n            }\r\n            else {\r\n                // Element ends in the change range.  The element will keep its position if\r\n                // possible. Or Move backward to the new-end if it's in the 'Y' range.\r\n                element.end = Math.min(element.end, changeRangeNewEnd);\r\n            }\r\n\r\n            Debug.assert(element.pos <= element.end);\r\n            if (element.parent) {\r\n                Debug.assert(element.pos >= element.parent.pos);\r\n                Debug.assert(element.end <= element.parent.end);\r\n            }\r\n        }\r\n\r\n        function checkNodePositions(node: Node, aggressiveChecks: boolean) {\r\n            if (aggressiveChecks) {\r\n                let pos = node.pos;\r\n                forEachChild(node, child => {\r\n                    Debug.assert(child.pos >= pos);\r\n                    pos = child.end;\r\n                });\r\n                Debug.assert(pos <= node.end);\r\n            }\r\n        }\r\n\r\n        function updateTokenPositionsAndMarkElements(\r\n            sourceFile: IncrementalNode,\r\n            changeStart: number,\r\n            changeRangeOldEnd: number,\r\n            changeRangeNewEnd: number,\r\n            delta: number,\r\n            oldText: string,\r\n            newText: string,\r\n            aggressiveChecks: boolean): void {\r\n\r\n            visitNode(sourceFile);\r\n            return;\r\n\r\n            function visitNode(child: IncrementalNode) {\r\n                Debug.assert(child.pos <= child.end);\r\n                if (child.pos > changeRangeOldEnd) {\r\n                    // Node is entirely past the change range.  We need to move both its pos and\r\n                    // end, forward or backward appropriately.\r\n                    moveElementEntirelyPastChangeRange(child, /*isArray*/ false, delta, oldText, newText, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Check if the element intersects the change range.  If it does, then it is not\r\n                // reusable.  Also, we'll need to recurse to see what constituent portions we may\r\n                // be able to use.\r\n                const fullEnd = child.end;\r\n                if (fullEnd >= changeStart) {\r\n                    child.intersectsChange = true;\r\n                    child._children = undefined;\r\n\r\n                    // Adjust the pos or end (or both) of the intersecting element accordingly.\r\n                    adjustIntersectingElement(child, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);\r\n                    forEachChild(child, visitNode, visitArray);\r\n\r\n                    checkNodePositions(child, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Otherwise, the node is entirely before the change range.  No need to do anything with it.\r\n                Debug.assert(fullEnd < changeStart);\r\n            }\r\n\r\n            function visitArray(array: IncrementalNodeArray) {\r\n                Debug.assert(array.pos <= array.end);\r\n                if (array.pos > changeRangeOldEnd) {\r\n                    // Array is entirely after the change range.  We need to move it, and move any of\r\n                    // its children.\r\n                    moveElementEntirelyPastChangeRange(array, /*isArray*/ true, delta, oldText, newText, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Check if the element intersects the change range.  If it does, then it is not\r\n                // reusable.  Also, we'll need to recurse to see what constituent portions we may\r\n                // be able to use.\r\n                const fullEnd = array.end;\r\n                if (fullEnd >= changeStart) {\r\n                    array.intersectsChange = true;\r\n                    array._children = undefined;\r\n\r\n                    // Adjust the pos or end (or both) of the intersecting array accordingly.\r\n                    adjustIntersectingElement(array, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);\r\n                    for (const node of array) {\r\n                        visitNode(node);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // Otherwise, the array is entirely before the change range.  No need to do anything with it.\r\n                Debug.assert(fullEnd < changeStart);\r\n            }\r\n        }\r\n\r\n        function extendToAffectedRange(sourceFile: SourceFile, changeRange: TextChangeRange): TextChangeRange {\r\n            // Consider the following code:\r\n            //      void foo() { /; }\r\n            //\r\n            // If the text changes with an insertion of / just before the semicolon then we end up with:\r\n            //      void foo() { //; }\r\n            //\r\n            // If we were to just use the changeRange a is, then we would not rescan the { token\r\n            // (as it does not intersect the actual original change range).  Because an edit may\r\n            // change the token touching it, we actually need to look back *at least* one token so\r\n            // that the prior token sees that change.\r\n            const maxLookahead = 1;\r\n\r\n            let start = changeRange.span.start;\r\n\r\n            // the first iteration aligns us with the change start. subsequent iteration move us to\r\n            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the\r\n            // start of the tree.\r\n            for (let i = 0; start > 0 && i <= maxLookahead; i++) {\r\n                const nearestNode = findNearestNodeStartingBeforeOrAtPosition(sourceFile, start);\r\n                Debug.assert(nearestNode.pos <= start);\r\n                const position = nearestNode.pos;\r\n\r\n                start = Math.max(0, position - 1);\r\n            }\r\n\r\n            const finalSpan = createTextSpanFromBounds(start, textSpanEnd(changeRange.span));\r\n            const finalLength = changeRange.newLength + (changeRange.span.start - start);\r\n\r\n            return createTextChangeRange(finalSpan, finalLength);\r\n        }\r\n\r\n        function findNearestNodeStartingBeforeOrAtPosition(sourceFile: SourceFile, position: number): Node {\r\n            let bestResult: Node = sourceFile;\r\n            let lastNodeEntirelyBeforePosition: Node;\r\n\r\n            forEachChild(sourceFile, visit);\r\n\r\n            if (lastNodeEntirelyBeforePosition) {\r\n                const lastChildOfLastEntireNodeBeforePosition = getLastChild(lastNodeEntirelyBeforePosition);\r\n                if (lastChildOfLastEntireNodeBeforePosition.pos > bestResult.pos) {\r\n                    bestResult = lastChildOfLastEntireNodeBeforePosition;\r\n                }\r\n            }\r\n\r\n            return bestResult;\r\n\r\n            function getLastChild(node: Node): Node {\r\n                while (true) {\r\n                    const lastChild = getLastChildWorker(node);\r\n                    if (lastChild) {\r\n                        node = lastChild;\r\n                    }\r\n                    else {\r\n                        return node;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getLastChildWorker(node: Node): Node | undefined {\r\n                let last: Node = undefined;\r\n                forEachChild(node, child => {\r\n                    if (nodeIsPresent(child)) {\r\n                        last = child;\r\n                    }\r\n                });\r\n                return last;\r\n            }\r\n\r\n            function visit(child: Node) {\r\n                if (nodeIsMissing(child)) {\r\n                    // Missing nodes are effectively invisible to us.  We never even consider them\r\n                    // When trying to find the nearest node before us.\r\n                    return;\r\n                }\r\n\r\n                // If the child intersects this position, then this node is currently the nearest\r\n                // node that starts before the position.\r\n                if (child.pos <= position) {\r\n                    if (child.pos >= bestResult.pos) {\r\n                        // This node starts before the position, and is closer to the position than\r\n                        // the previous best node we found.  It is now the new best node.\r\n                        bestResult = child;\r\n                    }\r\n\r\n                    // Now, the node may overlap the position, or it may end entirely before the\r\n                    // position.  If it overlaps with the position, then either it, or one of its\r\n                    // children must be the nearest node before the position.  So we can just\r\n                    // recurse into this child to see if we can find something better.\r\n                    if (position < child.end) {\r\n                        // The nearest node is either this child, or one of the children inside\r\n                        // of it.  We've already marked this child as the best so far.  Recurse\r\n                        // in case one of the children is better.\r\n                        forEachChild(child, visit);\r\n\r\n                        // Once we look at the children of this node, then there's no need to\r\n                        // continue any further.\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        Debug.assert(child.end <= position);\r\n                        // The child ends entirely before this position.  Say you have the following\r\n                        // (where $ is the position)\r\n                        //\r\n                        //      <complex expr 1> ? <complex expr 2> $ : <...> <...>\r\n                        //\r\n                        // We would want to find the nearest preceding node in \"complex expr 2\".\r\n                        // To support that, we keep track of this node, and once we're done searching\r\n                        // for a best node, we recurse down this node to see if we can find a good\r\n                        // result in it.\r\n                        //\r\n                        // This approach allows us to quickly skip over nodes that are entirely\r\n                        // before the position, while still allowing us to find any nodes in the\r\n                        // last one that might be what we want.\r\n                        lastNodeEntirelyBeforePosition = child;\r\n                    }\r\n                }\r\n                else {\r\n                    Debug.assert(child.pos > position);\r\n                    // We're now at a node that is entirely past the position we're searching for.\r\n                    // This node (and all following nodes) could never contribute to the result,\r\n                    // so just skip them by returning 'true' here.\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkChangeRange(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks: boolean) {\r\n            const oldText = sourceFile.text;\r\n            if (textChangeRange) {\r\n                Debug.assert((oldText.length - textChangeRange.span.length + textChangeRange.newLength) === newText.length);\r\n\r\n                if (aggressiveChecks || Debug.shouldAssert(AssertionLevel.VeryAggressive)) {\r\n                    const oldTextPrefix = oldText.substr(0, textChangeRange.span.start);\r\n                    const newTextPrefix = newText.substr(0, textChangeRange.span.start);\r\n                    Debug.assert(oldTextPrefix === newTextPrefix);\r\n\r\n                    const oldTextSuffix = oldText.substring(textSpanEnd(textChangeRange.span), oldText.length);\r\n                    const newTextSuffix = newText.substring(textSpanEnd(textChangeRangeNewSpan(textChangeRange)), newText.length);\r\n                    Debug.assert(oldTextSuffix === newTextSuffix);\r\n                }\r\n            }\r\n        }\r\n\r\n        interface IncrementalElement extends TextRange {\r\n            parent?: Node;\r\n            intersectsChange: boolean;\r\n            length?: number;\r\n            _children: Node[];\r\n        }\r\n\r\n        export interface IncrementalNode extends Node, IncrementalElement {\r\n            hasBeenIncrementallyParsed: boolean;\r\n        }\r\n\r\n        interface IncrementalNodeArray extends NodeArray<IncrementalNode>, IncrementalElement {\r\n            length: number;\r\n        }\r\n\r\n        // Allows finding nodes in the source file at a certain position in an efficient manner.\r\n        // The implementation takes advantage of the calling pattern it knows the parser will\r\n        // make in order to optimize finding nodes as quickly as possible.\r\n        export interface SyntaxCursor {\r\n            currentNode(position: number): IncrementalNode;\r\n        }\r\n\r\n        function createSyntaxCursor(sourceFile: SourceFile): SyntaxCursor {\r\n            let currentArray: NodeArray<Node> = sourceFile.statements;\r\n            let currentArrayIndex = 0;\r\n\r\n            Debug.assert(currentArrayIndex < currentArray.length);\r\n            let current = currentArray[currentArrayIndex];\r\n            let lastQueriedPosition = InvalidPosition.Value;\r\n\r\n            return {\r\n                currentNode(position: number) {\r\n                    // Only compute the current node if the position is different than the last time\r\n                    // we were asked.  The parser commonly asks for the node at the same position\r\n                    // twice.  Once to know if can read an appropriate list element at a certain point,\r\n                    // and then to actually read and consume the node.\r\n                    if (position !== lastQueriedPosition) {\r\n                        // Much of the time the parser will need the very next node in the array that\r\n                        // we just returned a node from.So just simply check for that case and move\r\n                        // forward in the array instead of searching for the node again.\r\n                        if (current && current.end === position && currentArrayIndex < (currentArray.length - 1)) {\r\n                            currentArrayIndex++;\r\n                            current = currentArray[currentArrayIndex];\r\n                        }\r\n\r\n                        // If we don't have a node, or the node we have isn't in the right position,\r\n                        // then try to find a viable node at the position requested.\r\n                        if (!current || current.pos !== position) {\r\n                            findHighestListElementThatStartsAtPosition(position);\r\n                        }\r\n                    }\r\n\r\n                    // Cache this query so that we don't do any extra work if the parser calls back\r\n                    // into us.  Note: this is very common as the parser will make pairs of calls like\r\n                    // 'isListElement -> parseListElement'.  If we were unable to find a node when\r\n                    // called with 'isListElement', we don't want to redo the work when parseListElement\r\n                    // is called immediately after.\r\n                    lastQueriedPosition = position;\r\n\r\n                    // Either we don'd have a node, or we have a node at the position being asked for.\r\n                    Debug.assert(!current || current.pos === position);\r\n                    return <IncrementalNode>current;\r\n                }\r\n            };\r\n\r\n            // Finds the highest element in the tree we can find that starts at the provided position.\r\n            // The element must be a direct child of some node list in the tree.  This way after we\r\n            // return it, we can easily return its next sibling in the list.\r\n            function findHighestListElementThatStartsAtPosition(position: number) {\r\n                // Clear out any cached state about the last node we found.\r\n                currentArray = undefined;\r\n                currentArrayIndex = InvalidPosition.Value;\r\n                current = undefined;\r\n\r\n                // Recurse into the source file to find the highest node at this position.\r\n                forEachChild(sourceFile, visitNode, visitArray);\r\n                return;\r\n\r\n                function visitNode(node: Node) {\r\n                    if (position >= node.pos && position < node.end) {\r\n                        // Position was within this node.  Keep searching deeper to find the node.\r\n                        forEachChild(node, visitNode, visitArray);\r\n\r\n                        // don't proceed any further in the search.\r\n                        return true;\r\n                    }\r\n\r\n                    // position wasn't in this node, have to keep searching.\r\n                    return false;\r\n                }\r\n\r\n                function visitArray(array: NodeArray<Node>) {\r\n                    if (position >= array.pos && position < array.end) {\r\n                        // position was in this array.  Search through this array to see if we find a\r\n                        // viable element.\r\n                        for (let i = 0; i < array.length; i++) {\r\n                            const child = array[i];\r\n                            if (child) {\r\n                                if (child.pos === position) {\r\n                                    // Found the right node.  We're done.\r\n                                    currentArray = array;\r\n                                    currentArrayIndex = i;\r\n                                    current = child;\r\n                                    return true;\r\n                                }\r\n                                else {\r\n                                    if (child.pos < position && position < child.end) {\r\n                                        // Position in somewhere within this child.  Search in it and\r\n                                        // stop searching in this array.\r\n                                        forEachChild(child, visitNode, visitArray);\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // position wasn't in this array, have to keep searching.\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        const enum InvalidPosition {\r\n            Value = -1\r\n        }\r\n    }\r\n}\r\n","/// <reference path=\"sys.ts\"/>\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"diagnosticInformationMap.generated.ts\"/>\r\n/// <reference path=\"parser.ts\"/>\r\n\r\nnamespace ts {\r\n    /* @internal */\r\n    export const compileOnSaveCommandLineOption: CommandLineOption = { name: \"compileOnSave\", 别名: \"保存时编译\", type: \"boolean\" };\r\n\r\n\r\n    export const 编译选项别名对照表 = createMapFromTemplate({\r\n        \"编译选项\": \"compilerOptions\",\r\n        \"保存时编译\": \"compileOnSave\",\r\n        \"帮助\": \"help\",\r\n        \"usingChineseLib\":\"使用中文支持库\",\r\n        \"compileToCts\": \"转译Cts\",\r\n        \"chineseKeywords\": \"中文关键字\",\r\n        \"compileToTs\": \"转译Ts\",\r\n        \"compileToDcts\": \"转译声明\",\r\n        \"emitNoDictionaryIdentifiers\": \"输出无词典标识符\",\r\n        \"dictionaryOnFileEnd\": \"词典在文件尾\",\r\n        \"dictionaryNoRepeat\": \"词典不重复输出\",\r\n        \"所有\": \"all\",\r\n        \"版本\": \"version\",\r\n        \"初始化\": \"init\",\r\n        \"项目\": \"project\",\r\n        \"错误样式\": \"pretty\",\r\n        \"监控\": \"watch\",\r\n        \"目标\": \"target\",\r\n        \"模块\": \"module\",\r\n        \"支持库\": \"lib\",\r\n        \"允许JS\": \"allowJs\",\r\n        \"检查JS\": \"checkJs\",\r\n        \"输出声明文件\": \"declaration\",\r\n        \"源码映射\": \"sourceMap\",\r\n        \"输出文件\": \"outFile\",\r\n        \"输出目录\": \"outDir\",\r\n        \"根目录\": \"rootDir\",\r\n        \"删除注释\": \"removeComments\",\r\n        \"不输出\": \"noEmit\",\r\n        \"引入帮助\": \"importHelpers\",\r\n        \"低级迭代\": \"downlevelIteration\",\r\n        \"是隔离模块\": \"isolatedModules\",\r\n        \"严格\": \"strict\",\r\n        \"有隐性通用型不输出\": \"noImplicitAny\",\r\n        \"严格空检查\": \"strictNullChecks\",\r\n        \"有隐性本对象不输出\": \"noImplicitThis\",\r\n        \"严格模式\": \"alwaysStrict\",\r\n        \"不允许未使用变量\": \"noUnusedLocals\",\r\n        \"不允许未使用参数\": \"noUnusedParameters\",\r\n        \"不允许无返回\": \"noImplicitReturns\",\r\n        \"不允许贯穿\": \"noFallthroughCasesInSwitch\",\r\n        \"模块解析\": \"moduleResolution\",\r\n        \"基URL\": \"baseUrl\",\r\n        \"路径集\": \"paths\",\r\n        \"根目录集\": \"rootDirs\",\r\n        \"类型根集\": \"typeRoots\",\r\n        \"类型集\": \"types\",\r\n        \"允许从未设置默认导出模块默认导入\": \"allowSyntheticDefaultImports\",\r\n        \"源码根\": \"sourceRoot\",\r\n        \"映射根\": \"mapRoot\",\r\n        \"内联源映射\": \"inlineSourceMap\",\r\n        \"内联源\": \"inlineSources\",\r\n        \"试验装饰器\": \"experimentalDecorators\",\r\n        \"试验装饰器元数据\": \"emitDecoratorMetadata\",\r\n        \"JSX工厂\": \"jsxFactory\",\r\n        \"诊断\": \"diagnostics\",\r\n        \"详细诊断\": \"extendedDiagnostics\",\r\n        \"生成模块解析日志\": \"traceResolution\",\r\n        \"打印列表\": \"listFiles\",\r\n        \"打印发射文件列表\": \"listEmittedFiles\",\r\n        \"输出\": \"out\",\r\n        \"REACT名称空间\": \"reactNamespace\",\r\n        \"忽略默认库类型检查\": \"skipDefaultLibCheck\",\r\n        \"设置编码\": \"charset\",\r\n        \"输出BOM\": \"emitBOM\",\r\n        \"本地化\": \"locale\",\r\n        \"换行符\": \"newLine\",\r\n        \"有错误截断\": \"noErrorTruncation\",\r\n        \"不包含默认库\": \"noLib\",\r\n        \"不包含引用\": \"noResolve\",\r\n        \"不生成内部标签\": \"stripInternal\",\r\n        \"禁用大小限制\": \"disableSizeLimit\",\r\n        \"不隐式严格模式\": \"noImplicitUseStrict\",\r\n        \"不输出助手\": \"noEmitHelpers\",\r\n        \"有错误不输出\": \"noEmitOnError\",\r\n        \"保留常量及枚举\": \"preserveConstEnums\",\r\n        \"声明目录\": \"declarationDir\",\r\n        \"忽略库类型检查\": \"skipLibCheck\",\r\n        \"允许检测不到\": \"allowUnusedLabels\",\r\n        \"允许未使用\": \"allowUnreachableCode\",\r\n        \"阻止过度属性错误检查\": \"suppressExcessPropertyErrors\",\r\n        \"阻止隐性通用型索引错误检查\": \"suppressImplicitAnyIndexErrors\",\r\n        \"不允许不一致引用\": \"forceConsistentCasingInFileNames\",\r\n        \"依赖最大深度\": \"maxNodeModuleJsDepth\",\r\n        \"不使用严格通用检查\": \"noStrictGenericChecks\",\r\n        \"插件\": \"plugins\",\r\n        \"启用自动发现\": \"enableAutoDiscovery\",\r\n        \"启用\": \"enable\",\r\n        \"包含\": \"include\",\r\n        \"排除\": \"exclude\",\r\n        \"分类选项\": \"typingOptions\",\r\n        \"类型收集\": \"typeAcquisition\",\r\n        \"外部扩展\": \"extends\",\r\n        \"文件集\": \"files\",\r\n        \"严格函数类型集\": \"strictFunctionTypes\",\r\n        \"保持符号连接\": \"preserveSymlinks\"\r\n    });\r\n\r\n    /* @internal */\r\n    export const optionDeclarations: CommandLineOption[] = [\r\n        // CommandLine only options\r\n        {\r\n            name: \"help\",\r\n            别名: \"帮助\",\r\n            shortName: \"h\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Print_this_message,\r\n        },\r\n        {\r\n            name: \"help\",\r\n            别名: \"帮助\",\r\n            shortName: \"?\",\r\n            type: \"boolean\"\r\n        },\r\n        {\r\n            name: \"使用中文支持库\",\r\n            别名: \"usingChineseLib\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"转译Cts\",\r\n            别名: \"compileToCts\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"中文关键字\",\r\n            别名: \"chineseKeywords\",\r\n            type: \"boolean\",\r\n\r\n        },\r\n        {\r\n            name: \"转译Ts\",\r\n            别名: \"compileToTs\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"转译声明\",\r\n            别名: \"compileToDcts\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"输出无词典标识符\",\r\n            别名: \"emitNoDictionaryIdentifiers\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"词典在文件尾\",\r\n            别名: \"dictionaryOnFileEnd\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"词典不重复输出\",\r\n            别名: \"dictionaryNoRepeat\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"all\",\r\n            别名: \"所有\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Show_all_compiler_options,\r\n        },\r\n        {\r\n            name: \"version\",\r\n            别名: \"版本\",\r\n            shortName: \"v\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Print_the_compiler_s_version,\r\n        },\r\n        {\r\n            name: \"init\",\r\n            别名: \"初始化\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file,\r\n        },\r\n        {\r\n            name: \"project\",\r\n            别名: \"项目\",\r\n            shortName: \"p\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            paramType: Diagnostics.FILE_OR_DIRECTORY,\r\n            description: Diagnostics.Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json,\r\n        },\r\n        {\r\n            name: \"pretty\",\r\n            别名: \"错误样式\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Stylize_errors_and_messages_using_color_and_context_experimental\r\n        },\r\n        {\r\n            name: \"watch\",\r\n            别名: \"监控\",\r\n            shortName: \"w\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Watch_input_files,\r\n        },\r\n\r\n        // Basic\r\n        {\r\n            name: \"target\",\r\n            别名: \"目标\",\r\n            shortName: \"t\",\r\n            type: createMapFromTemplate({\r\n                \"es3\": ScriptTarget.ES3,\r\n                \"es5\": ScriptTarget.ES5,\r\n                \"es6\": ScriptTarget.ES2015,\r\n                \"es2015\": ScriptTarget.ES2015,\r\n                \"es2016\": ScriptTarget.ES2016,\r\n                \"es2017\": ScriptTarget.ES2017,\r\n                \"esnext\": ScriptTarget.ESNext,\r\n            }),\r\n            paramType: Diagnostics.VERSION,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_or_ESNEXT,\r\n        },\r\n        {\r\n            name: \"module\",\r\n            别名: \"模块\",\r\n            shortName: \"m\",\r\n            type: createMapFromTemplate({\r\n                \"none\": ModuleKind.None,\r\n                \"commonjs\": ModuleKind.CommonJS,\r\n                \"amd\": ModuleKind.AMD,\r\n                \"system\": ModuleKind.System,\r\n                \"umd\": ModuleKind.UMD,\r\n                \"es6\": ModuleKind.ES2015,\r\n                \"es2015\": ModuleKind.ES2015,\r\n                \"esnext\": ModuleKind.ESNext\r\n            }),\r\n            paramType: Diagnostics.KIND,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext,\r\n        },\r\n        {\r\n            name: \"lib\",\r\n            别名: \"支持库\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"lib\",\r\n                别名: \"支持库\",\r\n                type: createMapFromTemplate({\r\n                    // JavaScript only\r\n                    \"es5\": \"lib.es5.d.ts\",\r\n                    \"es6\": \"lib.es2015.d.ts\",\r\n                    \"es2015\": \"lib.es2015.d.ts\",\r\n                    \"es7\": \"lib.es2016.d.ts\",\r\n                    \"es2016\": \"lib.es2016.d.ts\",\r\n                    \"es2017\": \"lib.es2017.d.ts\",\r\n                    \"esnext\": \"lib.esnext.d.ts\",\r\n                    // Host only\r\n                    \"dom\": \"lib.dom.d.ts\",\r\n                    \"dom.iterable\": \"lib.dom.iterable.d.ts\",\r\n                    \"webworker\": \"lib.webworker.d.ts\",\r\n                    \"scripthost\": \"lib.scripthost.d.ts\",\r\n                    // ES2015 Or ESNext By-feature options\r\n                    \"es2015.core\": \"lib.es2015.core.d.ts\",\r\n                    \"es2015.collection\": \"lib.es2015.collection.d.ts\",\r\n                    \"es2015.generator\": \"lib.es2015.generator.d.ts\",\r\n                    \"es2015.iterable\": \"lib.es2015.iterable.d.ts\",\r\n                    \"es2015.promise\": \"lib.es2015.promise.d.ts\",\r\n                    \"es2015.proxy\": \"lib.es2015.proxy.d.ts\",\r\n                    \"es2015.reflect\": \"lib.es2015.reflect.d.ts\",\r\n                    \"es2015.symbol\": \"lib.es2015.symbol.d.ts\",\r\n                    \"es2015.symbol.wellknown\": \"lib.es2015.symbol.wellknown.d.ts\",\r\n                    \"es2016.array.include\": \"lib.es2016.array.include.d.ts\",\r\n                    \"es2017.object\": \"lib.es2017.object.d.ts\",\r\n                    \"es2017.sharedmemory\": \"lib.es2017.sharedmemory.d.ts\",\r\n                    \"es2017.string\": \"lib.es2017.string.d.ts\",\r\n                    \"es2017.intl\": \"lib.es2017.intl.d.ts\",\r\n                    \"esnext.asynciterable\": \"lib.esnext.asynciterable.d.ts\",\r\n                }),\r\n            },\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_library_files_to_be_included_in_the_compilation_Colon\r\n        },\r\n        {\r\n            name: \"allowJs\",\r\n            别名: \"允许JS\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Allow_javascript_files_to_be_compiled\r\n        },\r\n        {\r\n            name: \"checkJs\",\r\n            别名: \"检查JS\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Report_errors_in_js_files\r\n        },\r\n        {\r\n            name: \"jsx\",\r\n            type: createMapFromTemplate({\r\n                \"preserve\": JsxEmit.Preserve,\r\n                \"react-native\": JsxEmit.ReactNative,\r\n                \"react\": JsxEmit.React\r\n            }),\r\n            paramType: Diagnostics.KIND,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_JSX_code_generation_Colon_preserve_react_native_or_react,\r\n        },\r\n        {\r\n            name: \"declaration\",\r\n            别名: \"输出声明文件\",\r\n            shortName: \"d\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Generates_corresponding_d_ts_file,\r\n        },\r\n        {\r\n            name: \"sourceMap\",\r\n            别名: \"源码映射\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Generates_corresponding_map_file,\r\n        },\r\n        {\r\n            name: \"outFile\",\r\n            别名: \"输出文件\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.FILE,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Concatenate_and_emit_output_to_single_file,\r\n        },\r\n        {\r\n            name: \"outDir\",\r\n            别名: \"输出目录\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.DIRECTORY,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Redirect_output_structure_to_the_directory,\r\n        },\r\n        {\r\n            name: \"rootDir\",\r\n            别名: \"根目录\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir,\r\n        },\r\n        {\r\n            name: \"removeComments\",\r\n            别名: \"删除注释\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Do_not_emit_comments_to_output,\r\n        },\r\n        {\r\n            name: \"noEmit\",\r\n            别名: \"不输出\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Do_not_emit_outputs,\r\n        },\r\n        {\r\n            name: \"importHelpers\",\r\n            别名: \"引入帮助\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Import_emit_helpers_from_tslib\r\n        },\r\n        {\r\n            name: \"downlevelIteration\",\r\n            别名: \"低级迭代\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3\r\n        },\r\n        {\r\n            name: \"isolatedModules\",\r\n            别名: \"是隔离模块\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule\r\n        },\r\n\r\n        // Strict Type Checks\r\n        {\r\n            name: \"strict\",\r\n            别名: \"严格\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_all_strict_type_checking_options\r\n        },\r\n        {\r\n            name: \"noImplicitAny\",\r\n            别名: \"有隐性通用型不输出\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Raise_error_on_expressions_and_declarations_with_an_implied_any_type,\r\n        },\r\n        {\r\n            name: \"strictNullChecks\",\r\n            别名: \"严格空检查\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_strict_null_checks\r\n        },\r\n        {\r\n            name: \"strictFunctionTypes\",\r\n            别名: \"严格函数类型集\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_strict_checking_of_function_types\r\n        },\r\n        {\r\n            name: \"noImplicitThis\",\r\n            别名: \"有隐性本对象不输出\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Raise_error_on_this_expressions_with_an_implied_any_type,\r\n        },\r\n        {\r\n            name: \"alwaysStrict\",\r\n            别名: \"严格模式\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Parse_in_strict_mode_and_emit_use_strict_for_each_source_file\r\n        },\r\n\r\n        // Additional Checks\r\n        {\r\n            name: \"noUnusedLocals\",\r\n            别名: \"不允许未使用变量\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_on_unused_locals,\r\n        },\r\n        {\r\n            name: \"noUnusedParameters\",\r\n            别名: \"不允许未使用参数\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_on_unused_parameters,\r\n        },\r\n        {\r\n            name: \"noImplicitReturns\",\r\n            别名: \"不允许无返回\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_error_when_not_all_code_paths_in_function_return_a_value\r\n        },\r\n        {\r\n            name: \"noFallthroughCasesInSwitch\",\r\n            别名: \"不允许贯穿\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_for_fallthrough_cases_in_switch_statement\r\n        },\r\n\r\n        // Module Resolution\r\n        {\r\n            name: \"moduleResolution\",\r\n            别名: \"模块解析\",\r\n            type: createMapFromTemplate({\r\n                \"node\": ModuleResolutionKind.NodeJs,\r\n                \"classic\": ModuleResolutionKind.Classic,\r\n            }),\r\n            paramType: Diagnostics.STRATEGY,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6,\r\n        },\r\n        {\r\n            name: \"baseUrl\",\r\n            别名: \"基URL\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Base_directory_to_resolve_non_absolute_module_names\r\n        },\r\n        {\r\n            // this option can only be specified in tsconfig.json\r\n            // use type = object to copy the value as-is\r\n            name: \"paths\",\r\n            别名: \"路径集\",\r\n            type: \"object\",\r\n            isTSConfigOnly: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl\r\n\r\n        },\r\n        {\r\n            // this option can only be specified in tsconfig.json\r\n            // use type = object to copy the value as-is\r\n            name: \"rootDirs\",\r\n            别名: \"根目录集\",\r\n            type: \"list\",\r\n            isTSConfigOnly: true,\r\n            element: {\r\n                name: \"rootDirs\",\r\n                别名: \"根目录集\",\r\n                type: \"string\",\r\n                isFilePath: true\r\n            },\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime\r\n        },\r\n        {\r\n            name: \"typeRoots\",\r\n            别名: \"类型根集\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"typeRoots\",\r\n                别名: \"类型根集\",\r\n                type: \"string\",\r\n                isFilePath: true\r\n            },\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.List_of_folders_to_include_type_definitions_from\r\n        },\r\n        {\r\n            name: \"types\",\r\n            别名: \"类型集\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"types\",\r\n                别名: \"类型集\",\r\n                type: \"string\"\r\n            },\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Type_declaration_files_to_be_included_in_compilation\r\n        },\r\n        {\r\n            name: \"allowSyntheticDefaultImports\",\r\n            别名: \"允许从未设置默认导出模块默认导入\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking\r\n        },\r\n        {\r\n            name: \"preserveSymlinks\",\r\n            别名: \"保持符号连接\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Do_not_resolve_the_real_path_of_symlinks,\r\n        },\r\n\r\n        // Source Maps\r\n        {\r\n            name: \"sourceRoot\",\r\n            别名: \"源码根\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,\r\n        },\r\n        {\r\n            name: \"mapRoot\",\r\n            别名: \"映射根\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,\r\n        },\r\n        {\r\n            name: \"inlineSourceMap\",\r\n            别名: \"内联源映射\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file\r\n        },\r\n        {\r\n            name: \"inlineSources\",\r\n            别名: \"内联源\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set\r\n        },\r\n\r\n        // Experimental\r\n        {\r\n            name: \"experimentalDecorators\",\r\n            别名: \"试验装饰器\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Experimental_Options,\r\n            description: Diagnostics.Enables_experimental_support_for_ES7_decorators\r\n        },\r\n        {\r\n            name: \"emitDecoratorMetadata\",\r\n            别名: \"试验装饰器元数据\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Experimental_Options,\r\n            description: Diagnostics.Enables_experimental_support_for_emitting_type_metadata_for_decorators\r\n        },\r\n\r\n        // Advanced\r\n        {\r\n            name: \"jsxFactory\",\r\n            别名: \"JSX工厂\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h\r\n        },\r\n        {\r\n            name: \"diagnostics\",\r\n            别名: \"诊断\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Show_diagnostic_information\r\n        },\r\n        {\r\n            name: \"extendedDiagnostics\",\r\n            别名: \"详细诊断\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Show_verbose_diagnostic_information\r\n        },\r\n        {\r\n            name: \"traceResolution\",\r\n            别名: \"生成模块解析日志\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Enable_tracing_of_the_name_resolution_process\r\n        },\r\n        {\r\n            name: \"listFiles\",\r\n            别名: \"打印列表\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Print_names_of_files_part_of_the_compilation\r\n        },\r\n        {\r\n            name: \"listEmittedFiles\",\r\n            别名: \"打印发射文件列表\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Print_names_of_generated_files_part_of_the_compilation\r\n        },\r\n\r\n        {\r\n            name: \"out\",\r\n            别名: \"输出\",\r\n            type: \"string\",\r\n            isFilePath: false, // This is intentionally broken to support compatability with existing tsconfig files\r\n            // for correct behaviour, please use outFile\r\n            category: Diagnostics.Advanced_Options,\r\n            paramType: Diagnostics.FILE,\r\n            description: Diagnostics.Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file,\r\n        },\r\n        {\r\n            name: \"reactNamespace\",\r\n            别名: \"REACT名称空间\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit\r\n        },\r\n        {\r\n            name: \"skipDefaultLibCheck\",\r\n            别名: \"忽略默认库类型检查\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files\r\n        },\r\n        {\r\n            name: \"charset\",\r\n            别名: \"设置编码\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_character_set_of_the_input_files\r\n        },\r\n        {\r\n            name: \"emitBOM\",\r\n            别名: \"输出BOM\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files\r\n        },\r\n        {\r\n            name: \"locale\",\r\n            别名: \"本地化\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_locale_used_when_displaying_messages_to_the_user_e_g_en_us\r\n        },\r\n        {\r\n            name: \"newLine\",\r\n            别名: \"换行符\",\r\n            type: createMapFromTemplate({\r\n                \"crlf\": NewLineKind.CarriageReturnLineFeed,\r\n                \"lf\": NewLineKind.LineFeed\r\n            }),\r\n            paramType: Diagnostics.NEWLINE,\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix,\r\n        },\r\n        {\r\n            name: \"noErrorTruncation\",\r\n            别名: \"有错误截断\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_truncate_error_messages\r\n        },\r\n        {\r\n            name: \"noLib\",\r\n            别名: \"不包含默认库\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_include_the_default_library_file_lib_d_ts\r\n        },\r\n        {\r\n            name: \"noResolve\",\r\n            别名: \"不包含引用\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files\r\n        },\r\n        {\r\n            name: \"stripInternal\",\r\n            别名: \"不生成内部标签\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_declarations_for_code_that_has_an_internal_annotation,\r\n        },\r\n        {\r\n            name: \"disableSizeLimit\",\r\n            别名: \"禁用大小限制\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disable_size_limitations_on_JavaScript_projects\r\n        },\r\n        {\r\n            name: \"noImplicitUseStrict\",\r\n            别名: \"不隐式严格模式\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_use_strict_directives_in_module_output\r\n        },\r\n        {\r\n            name: \"noEmitHelpers\",\r\n            别名: \"不输出助手\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_generate_custom_helper_functions_like_extends_in_compiled_output\r\n        },\r\n        {\r\n            name: \"noEmitOnError\",\r\n            别名: \"有错误不输出\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_outputs_if_any_errors_were_reported,\r\n        },\r\n        {\r\n            name: \"preserveConstEnums\",\r\n            别名: \"保留常量及枚举\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_erase_const_enum_declarations_in_generated_code\r\n        },\r\n        {\r\n            name: \"declarationDir\",\r\n            别名: \"声明目录\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.DIRECTORY,\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Output_directory_for_generated_declaration_files\r\n        },\r\n        {\r\n            name: \"skipLibCheck\",\r\n            别名: \"忽略库类型检查\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Skip_type_checking_of_declaration_files,\r\n        },\r\n        {\r\n            name: \"allowUnusedLabels\",\r\n            别名: \"允许检测不到\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_report_errors_on_unused_labels\r\n        },\r\n        {\r\n            name: \"allowUnreachableCode\",\r\n            别名: \"允许未使用\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_report_errors_on_unreachable_code\r\n        },\r\n        {\r\n            name: \"suppressExcessPropertyErrors\",\r\n            别名: \"阻止过度属性错误检查\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Suppress_excess_property_checks_for_object_literals,\r\n        },\r\n        {\r\n            name: \"suppressImplicitAnyIndexErrors\",\r\n            别名: \"阻止隐性通用型索引错误检查\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures,\r\n        },\r\n        {\r\n            name: \"forceConsistentCasingInFileNames\",\r\n            别名: \"不允许不一致引用\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disallow_inconsistently_cased_references_to_the_same_file\r\n        },\r\n        {\r\n            name: \"maxNodeModuleJsDepth\",\r\n            别名: \"依赖最大深度\",\r\n            type: \"number\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files\r\n        },\r\n        {\r\n            name: \"noStrictGenericChecks\",\r\n            别名: \"不使用严格通用检查\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disable_strict_checking_of_generic_signatures_in_function_types,\r\n        },\r\n        {\r\n            // A list of plugins to load in the language service\r\n            name: \"plugins\",\r\n            别名: \"插件\",\r\n            type: \"list\",\r\n            isTSConfigOnly: true,\r\n            element: {\r\n                name: \"plugin\",\r\n                别名: \"插件\",\r\n                type: \"object\"\r\n            },\r\n            description: Diagnostics.List_of_language_service_plugins\r\n        }\r\n    ];\r\n\r\n    /* @internal */\r\n    export const typeAcquisitionDeclarations: CommandLineOption[] = [\r\n        {\r\n            /* @deprecated typingOptions.enableAutoDiscovery\r\n             * Use typeAcquisition.enable instead.\r\n             */\r\n            name: \"enableAutoDiscovery\",\r\n            别名: \"启用自动发现\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"enable\",\r\n            别名: \"启用\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"include\",\r\n            别名: \"包含\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"include\",\r\n                别名: \"包含\",\r\n                type: \"string\"\r\n            }\r\n        },\r\n        {\r\n            name: \"exclude\",\r\n            别名: \"排除\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"exclude\",\r\n                别名: \"排除\",\r\n                type: \"string\"\r\n            }\r\n        }\r\n    ];\r\n\r\n    /* @internal */\r\n    export interface OptionNameMap {\r\n        optionNameMap: Map<CommandLineOption>;\r\n        shortOptionNames: Map<string>;\r\n        别名集: Map<string>;\r\n    }\r\n\r\n    /* @internal */\r\n    export const defaultInitCompilerOptions: CompilerOptions = {\r\n        module: ModuleKind.CommonJS,\r\n        target: ScriptTarget.ES5,\r\n        strict: true\r\n    };\r\n\r\n    let optionNameMapCache: OptionNameMap;\r\n\r\n    /* @internal */\r\n    export function convertEnableAutoDiscoveryToEnable(typeAcquisition: TypeAcquisition): TypeAcquisition {\r\n        // Convert deprecated typingOptions.enableAutoDiscovery to typeAcquisition.enable\r\n        if (typeAcquisition && typeAcquisition.enableAutoDiscovery !== undefined && typeAcquisition.enable === undefined) {\r\n            const result: TypeAcquisition = {\r\n                enable: typeAcquisition.enableAutoDiscovery,\r\n                include: typeAcquisition.include || [],\r\n                exclude: typeAcquisition.exclude || []\r\n            };\r\n            return result;\r\n        }\r\n        return typeAcquisition;\r\n    }\r\n\r\n    function getOptionNameMap(): OptionNameMap {\r\n        if (optionNameMapCache) {\r\n            return optionNameMapCache;\r\n        }\r\n\r\n        const optionNameMap = createMap<CommandLineOption>();\r\n        const shortOptionNames = createMap<string>();\r\n        const 别名集 = createMap<string>();\r\n        forEach(optionDeclarations, option => {\r\n            optionNameMap.set(option.name.toLowerCase(), option);\r\n            if (option.别名) {\r\n                别名集.set(option.别名.toLowerCase(), option.name.toLowerCase());\r\n            }\r\n            if (option.shortName) {\r\n                shortOptionNames.set(option.shortName, option.name);\r\n            }\r\n        });\r\n\r\n        optionNameMapCache = { optionNameMap, shortOptionNames, 别名集 };\r\n        return optionNameMapCache;\r\n    }\r\n    /* @internal */\r\n    export function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic {\r\n        return createDiagnosticForInvalidCustomType(opt, createCompilerDiagnostic);\r\n    }\r\n\r\n    function createDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType, createDiagnostic: (message: DiagnosticMessage, arg0: string, arg1: string) => Diagnostic): Diagnostic {\r\n        const namesOfType = arrayFrom(opt.type.keys()).map(key => `'${key}'`).join(\", \");\r\n        return createDiagnostic(Diagnostics.Argument_for_0_option_must_be_Colon_1, `--${opt.name}`, namesOfType);\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>) {\r\n        return convertJsonOptionOfCustomType(opt, trimString(value || \"\"), errors);\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseListTypeOption(opt: CommandLineOptionOfListType, value = \"\", errors: Push<Diagnostic>): (string | number)[] | undefined {\r\n        value = trimString(value);\r\n        if (startsWith(value, \"-\")) {\r\n            return undefined;\r\n        }\r\n        if (value === \"\") {\r\n            return [];\r\n        }\r\n        const values = value.split(\",\");\r\n        switch (opt.element.type) {\r\n            case \"number\":\r\n                return map(values, parseInt);\r\n            case \"string\":\r\n                return map(values, v => v || \"\");\r\n            default:\r\n                return filter(map(values, v => parseCustomTypeOption(<CommandLineOptionOfCustomType>opt.element, v, errors)), v => !!v);\r\n        }\r\n    }\r\n\r\n    export function parseCommandLine(commandLine: ReadonlyArray<string>, readFile?: (path: string) => string | undefined): ParsedCommandLine {\r\n        const options: CompilerOptions = {};\r\n        const fileNames: string[] = [];\r\n        const errors: Diagnostic[] = [];\r\n\r\n        parseStrings(commandLine);\r\n        return {\r\n            options,\r\n            fileNames,\r\n            errors\r\n        };\r\n\r\n        function parseStrings(args: ReadonlyArray<string>) {\r\n            let i = 0;\r\n            while (i < args.length) {\r\n                const s = args[i];\r\n                i++;\r\n                if (s.charCodeAt(0) === CharacterCodes.at) {\r\n                    parseResponseFile(s.slice(1));\r\n                }\r\n                else if (s.charCodeAt(0) === CharacterCodes.minus) {\r\n                    const opt = getOptionFromName(s.slice(s.charCodeAt(1) === CharacterCodes.minus ? 2 : 1), /*allowShort*/ true);\r\n                    if (opt) {\r\n                        if (opt.isTSConfigOnly) {\r\n                            errors.push(createCompilerDiagnostic(Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file, opt.name));\r\n                        }\r\n                        else {\r\n                            // Check to see if no argument was provided (e.g. \"--locale\" is the last command-line argument).\r\n                            if (!args[i] && opt.type !== \"boolean\") {\r\n                                errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_expects_an_argument, opt.name));\r\n                            }\r\n\r\n                            switch (opt.type) {\r\n                                case \"number\":\r\n                                    options[opt.name] = parseInt(args[i]);\r\n                                    i++;\r\n                                    break;\r\n                                case \"boolean\":\r\n                                    // boolean flag has optional value true, false, others\r\n                                    const optValue = args[i];\r\n                                    options[opt.name] = optValue !== \"false\" && optValue !== \"假\";\r\n                                    // consume next argument as boolean flag value\r\n                                    if (optValue === \"false\" || optValue === \"假\" || optValue === \"true\" || optValue === \"真\") {\r\n                                        i++;\r\n                                    }\r\n                                    break;\r\n                                case \"string\":\r\n                                    options[opt.name] = args[i] || \"\";\r\n                                    i++;\r\n                                    break;\r\n                                case \"list\":\r\n                                    const result = parseListTypeOption(<CommandLineOptionOfListType>opt, args[i], errors);\r\n                                    options[opt.name] = result || [];\r\n                                    if (result) {\r\n                                        i++;\r\n                                    }\r\n                                    break;\r\n                                // If not a primitive, the possible types are specified in what is effectively a map of options.\r\n                                default:\r\n                                    options[opt.name] = parseCustomTypeOption(<CommandLineOptionOfCustomType>opt, args[i], errors);\r\n                                    i++;\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unknown_compiler_option_0, s));\r\n                    }\r\n                }\r\n                else {\r\n                    fileNames.push(s);\r\n                }\r\n            }\r\n        }\r\n\r\n        function parseResponseFile(fileName: string) {\r\n            const text = readFile ? readFile(fileName) : sys.readFile(fileName);\r\n\r\n            if (!text) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.File_0_not_found, fileName));\r\n                return;\r\n            }\r\n\r\n            const args: string[] = [];\r\n            let pos = 0;\r\n            while (true) {\r\n                while (pos < text.length && text.charCodeAt(pos) <= CharacterCodes.space) pos++;\r\n                if (pos >= text.length) break;\r\n                const start = pos;\r\n                if (text.charCodeAt(start) === CharacterCodes.doubleQuote) {\r\n                    pos++;\r\n                    while (pos < text.length && text.charCodeAt(pos) !== CharacterCodes.doubleQuote) pos++;\r\n                    if (pos < text.length) {\r\n                        args.push(text.substring(start + 1, pos));\r\n                        pos++;\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unterminated_quoted_string_in_response_file_0, fileName));\r\n                    }\r\n                }\r\n                else {\r\n                    while (text.charCodeAt(pos) > CharacterCodes.space) pos++;\r\n                    args.push(text.substring(start, pos));\r\n                }\r\n            }\r\n            parseStrings(args);\r\n        }\r\n    }\r\n\r\n    function getOptionFromName(optionName: string, allowShort = false): CommandLineOption | undefined {\r\n        optionName = optionName.toLowerCase();\r\n        const { optionNameMap, shortOptionNames, 别名集 } = getOptionNameMap();\r\n        // Try to translate short option names to their full equivalents.\r\n        if (allowShort) {\r\n            let short = shortOptionNames.get(optionName);\r\n            const 别名 = 别名集.get(optionName);\r\n            if (别名 !== undefined) {\r\n                short = 别名;\r\n            }\r\n            if (short !== undefined) {\r\n                short = short;\r\n            }\r\n            if (short !== undefined) {\r\n                optionName = short;\r\n            }\r\n        }\r\n        return optionNameMap.get(optionName);\r\n    }\r\n\r\n    /**\r\n     * Read tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     */\r\n    export function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): { config?: any; error?: Diagnostic } {\r\n        const textOrDiagnostic = tryReadFile(fileName, readFile);\r\n        return isString(textOrDiagnostic) ? parseConfigFileTextToJson(fileName, textOrDiagnostic) : { config: {}, error: textOrDiagnostic };\r\n    }\r\n\r\n    /**\r\n     * Parse the text of the tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     * @param jsonText The text of the config file\r\n     */\r\n    export function parseConfigFileTextToJson(fileName: string, jsonText: string): { config?: any; error?: Diagnostic } {\r\n        const jsonSourceFile = parseJsonText(fileName, jsonText);\r\n        return {\r\n            config: convertToObject(jsonSourceFile, jsonSourceFile.parseDiagnostics),\r\n            error: jsonSourceFile.parseDiagnostics.length ? jsonSourceFile.parseDiagnostics[0] : undefined\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     */\r\n    export function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): JsonSourceFile {\r\n        const textOrDiagnostic = tryReadFile(fileName, readFile);\r\n        return isString(textOrDiagnostic) ? parseJsonText(fileName, textOrDiagnostic) : <JsonSourceFile>{ parseDiagnostics: [textOrDiagnostic] };\r\n    }\r\n\r\n    function tryReadFile(fileName: string, readFile: (path: string) => string | undefined): string | Diagnostic {\r\n        let text: string | undefined;\r\n        try {\r\n            text = readFile(fileName);\r\n        }\r\n        catch (e) {\r\n            return createCompilerDiagnostic(Diagnostics.Cannot_read_file_0_Colon_1, fileName, e.message);\r\n        }\r\n        return text === undefined ? createCompilerDiagnostic(Diagnostics.The_specified_path_does_not_exist_Colon_0, fileName) : text;\r\n    }\r\n\r\n    function commandLineOptionsToMap(options: ReadonlyArray<CommandLineOption>) {\r\n        return arrayToMap(options, option => option.name);\r\n    }\r\n\r\n    let _tsconfigRootOptions: Map<CommandLineOption>;\r\n    function getTsconfigRootOptionsMap() {\r\n        if (_tsconfigRootOptions === undefined) {\r\n            _tsconfigRootOptions = commandLineOptionsToMap([\r\n                {\r\n                    name: \"compilerOptions\",\r\n                    别名: \"编译选项\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(optionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_compiler_option_0\r\n                },\r\n                {\r\n                    name: \"typingOptions\",\r\n                    别名: \"分类选项\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(typeAcquisitionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_type_acquisition_option_0\r\n                },\r\n                {\r\n                    name: \"typeAcquisition\",\r\n                    别名: \"类型收集\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(typeAcquisitionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_type_acquisition_option_0\r\n                },\r\n                {\r\n                    name: \"extends\",\r\n                    别名: \"外部扩展\",\r\n                    type: \"string\"\r\n                },\r\n                {\r\n                    name: \"files\",\r\n                    别名: \"文件集\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"files\",\r\n                        别名: \"文件集\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                {\r\n                    name: \"include\",\r\n                    别名: \"包含\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"include\",\r\n\r\n                        别名: \"包含\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                {\r\n                    name: \"exclude\",\r\n                    别名: \"排除\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"exclude\",\r\n                        别名: \"排除\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                compileOnSaveCommandLineOption\r\n            ]);\r\n        }\r\n        return _tsconfigRootOptions;\r\n    }\r\n\r\n    interface JsonConversionNotifier {\r\n        /**\r\n         * Notifies parent option object is being set with the optionKey and a valid optionValue\r\n         * Currently it notifies only if there is element with type object (parentOption) and\r\n         * has element's option declarations map associated with it\r\n         * @param parentOption parent option name in which the option and value are being set\r\n         * @param option option declaration which is being set with the value\r\n         * @param value value of the option\r\n         */\r\n        onSetValidOptionKeyValueInParent(parentOption: string, option: CommandLineOption, value: CompilerOptionsValue): void;\r\n        /**\r\n         * Notify when valid root key value option is being set\r\n         * @param key option key\r\n         * @param keyNode node corresponding to node in the source file\r\n         * @param value computed value of the key\r\n         * @param ValueNode node corresponding to value in the source file\r\n         */\r\n        onSetValidOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;\r\n        /**\r\n         * Notify when unknown root key value option is being set\r\n         * @param key option key\r\n         * @param keyNode node corresponding to node in the source file\r\n         * @param value computed value of the key\r\n         * @param ValueNode node corresponding to value in the source file\r\n         */\r\n        onSetUnknownOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;\r\n    }\r\n\r\n    /**\r\n     * Convert the json syntax tree into the json value\r\n     */\r\n    export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnostic>): any {\r\n        return convertToObjectWorker(sourceFile, errors, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined);\r\n    }\r\n\r\n    /**\r\n     * Convert the json syntax tree into the json value\r\n     */\r\n    function convertToObjectWorker(\r\n        sourceFile: JsonSourceFile,\r\n        errors: Push<Diagnostic>,\r\n        knownRootOptions: Map<CommandLineOption> | undefined,\r\n        jsonConversionNotifier: JsonConversionNotifier | undefined): any {\r\n        if (!sourceFile.jsonObject) {\r\n            return {};\r\n        }\r\n\r\n        return convertObjectLiteralExpressionToJson(sourceFile.jsonObject, knownRootOptions,\r\n            /*extraKeyDiagnosticMessage*/ undefined, /*parentOption*/ undefined);\r\n\r\n        function convertObjectLiteralExpressionToJson(\r\n            node: ObjectLiteralExpression,\r\n            knownOptions: Map<CommandLineOption> | undefined,\r\n            extraKeyDiagnosticMessage: DiagnosticMessage | undefined,\r\n            parentOption: string | undefined\r\n        ): any {\r\n            const result: any = {};\r\n            for (const element of node.properties) {\r\n                if (element.kind !== SyntaxKind.PropertyAssignment) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element, Diagnostics.Property_assignment_expected));\r\n                    continue;\r\n                }\r\n\r\n                if (element.questionToken) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.questionToken, Diagnostics._0_can_only_be_used_in_a_ts_file, \"?\"));\r\n                }\r\n                if (!isDoubleQuotedString(element.name)) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.name, Diagnostics.String_literal_with_double_quotes_expected));\r\n                }\r\n\r\n                let keyText = unescapeLeadingUnderscores(getTextOfPropertyName(element.name));\r\n                const 别名 = 编译选项别名对照表.get(keyText);\r\n                if (别名) {\r\n                    keyText = 别名;\r\n                }\r\n                const option = knownOptions ? knownOptions.get(keyText) : undefined;\r\n                if (extraKeyDiagnosticMessage && !option) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.name, extraKeyDiagnosticMessage, keyText));\r\n                }\r\n                const value = convertPropertyValueToJson(element.initializer, option);\r\n                if (typeof keyText !== \"undefined\") {\r\n                    result[keyText] = value;\r\n                    // Notify key value set, if user asked for it\r\n                    if (jsonConversionNotifier &&\r\n                        // Current callbacks are only on known parent option or if we are setting values in the root\r\n                        (parentOption || knownOptions === knownRootOptions)) {\r\n                        const isValidOptionValue = isCompilerOptionsValue(option, value);\r\n                        if (parentOption) {\r\n                            if (isValidOptionValue) {\r\n                                // Notify option set in the parent if its a valid option value\r\n                                jsonConversionNotifier.onSetValidOptionKeyValueInParent(parentOption, option, value);\r\n                            }\r\n                        }\r\n                        else if (knownOptions === knownRootOptions) {\r\n                            if (isValidOptionValue) {\r\n                                // Notify about the valid root key value being set\r\n                                jsonConversionNotifier.onSetValidOptionKeyValueInRoot(keyText, element.name, value, element.initializer);\r\n                            }\r\n                            else if (!option) {\r\n                                // Notify about the unknown root key value being set\r\n                                jsonConversionNotifier.onSetUnknownOptionKeyValueInRoot(keyText, element.name, value, element.initializer);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function convertArrayLiteralExpressionToJson(\r\n            elements: NodeArray<Expression>,\r\n            elementOption: CommandLineOption | undefined\r\n        ): any[] {\r\n            return elements.map(element => convertPropertyValueToJson(element, elementOption));\r\n        }\r\n\r\n        function convertPropertyValueToJson(valueExpression: Expression, option: CommandLineOption): any {\r\n            switch (valueExpression.kind) {\r\n                case SyntaxKind.TrueKeyword:\r\n                    reportInvalidOptionValue(option && option.type !== \"boolean\");\r\n                    return true;\r\n\r\n                case SyntaxKind.FalseKeyword:\r\n                    reportInvalidOptionValue(option && option.type !== \"boolean\");\r\n                    return false;\r\n\r\n                case SyntaxKind.NullKeyword:\r\n                    reportInvalidOptionValue(option && option.name === \"extends\"); // \"extends\" is the only option we don't allow null/undefined for\r\n                    return null; // tslint:disable-line:no-null-keyword\r\n\r\n                case SyntaxKind.StringLiteral:\r\n                    if (!isDoubleQuotedString(valueExpression)) {\r\n                        errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.String_literal_with_double_quotes_expected));\r\n                    }\r\n                    reportInvalidOptionValue(option && (isString(option.type) && option.type !== \"string\"));\r\n                    const text = (<StringLiteral>valueExpression).text;\r\n                    if (option && !isString(option.type)) {\r\n                        const customOption = <CommandLineOptionOfCustomType>option;\r\n                        // Validate custom option type\r\n                        if (!customOption.type.has(text.toLowerCase())) {\r\n                            errors.push(\r\n                                createDiagnosticForInvalidCustomType(\r\n                                    customOption,\r\n                                    (message, arg0, arg1) => createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, message, arg0, arg1)\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                    return text;\r\n\r\n                case SyntaxKind.NumericLiteral:\r\n                    reportInvalidOptionValue(option && option.type !== \"number\");\r\n                    return Number((<NumericLiteral>valueExpression).text);\r\n\r\n                case SyntaxKind.ObjectLiteralExpression:\r\n                    reportInvalidOptionValue(option && option.type !== \"object\");\r\n                    const objectLiteralExpression = <ObjectLiteralExpression>valueExpression;\r\n\r\n                    // Currently having element option declaration in the tsconfig with type \"object\"\r\n                    // determines if it needs onSetValidOptionKeyValueInParent callback or not\r\n                    // At moment there are only \"compilerOptions\", \"typeAcquisition\" and \"typingOptions\"\r\n                    // that satifies it and need it to modify options set in them (for normalizing file paths)\r\n                    // vs what we set in the json\r\n                    // If need arises, we can modify this interface and callbacks as needed\r\n                    if (option) {\r\n                        const { elementOptions, extraKeyDiagnosticMessage, name: optionName } = <TsConfigOnlyOption>option;\r\n                        return convertObjectLiteralExpressionToJson(objectLiteralExpression,\r\n                            elementOptions, extraKeyDiagnosticMessage, optionName);\r\n                    }\r\n                    else {\r\n                        return convertObjectLiteralExpressionToJson(\r\n                            objectLiteralExpression, /* knownOptions*/ undefined,\r\n                            /*extraKeyDiagnosticMessage */ undefined, /*parentOption*/ undefined);\r\n                    }\r\n\r\n                case SyntaxKind.ArrayLiteralExpression:\r\n                    reportInvalidOptionValue(option && option.type !== \"list\");\r\n                    return convertArrayLiteralExpressionToJson(\r\n                        (<ArrayLiteralExpression>valueExpression).elements,\r\n                        option && (<CommandLineOptionOfListType>option).element);\r\n            }\r\n\r\n            // Not in expected format\r\n            if (option) {\r\n                reportInvalidOptionValue(/*isError*/ true);\r\n            }\r\n            else {\r\n                errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal));\r\n            }\r\n\r\n            return undefined;\r\n\r\n            function reportInvalidOptionValue(isError: boolean) {\r\n                if (isError) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.Compiler_option_0_requires_a_value_of_type_1, option.name, getCompilerOptionValueTypeString(option)));\r\n                }\r\n            }\r\n        }\r\n\r\n        function isDoubleQuotedString(node: Node): boolean {\r\n            return isStringLiteral(node) && isStringDoubleQuoted(node, sourceFile);\r\n        }\r\n    }\r\n\r\n    function getCompilerOptionValueTypeString(option: CommandLineOption) {\r\n        return option.type === \"list\" ?\r\n            \"Array\" :\r\n            isString(option.type) ? option.type : \"string\";\r\n    }\r\n\r\n    function isCompilerOptionsValue(option: CommandLineOption, value: any): value is CompilerOptionsValue {\r\n        if (option) {\r\n            if (isNullOrUndefined(value)) return true; // All options are undefinable/nullable\r\n            if (option.type === \"list\") {\r\n                return isArray(value);\r\n            }\r\n            const expectedType = isString(option.type) ? option.type : \"string\";\r\n            return typeof value === expectedType;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate tsconfig configuration when running command line \"--init\"\r\n     * @param options commandlineOptions to be generated into tsconfig.json\r\n     * @param fileNames array of filenames to be generated into tsconfig.json\r\n     */\r\n    /* @internal */\r\n    export function generateTSConfig(options: CompilerOptions, fileNames: ReadonlyArray<string>, newLine: string): string {\r\n        const compilerOptions = extend(options, defaultInitCompilerOptions);\r\n        const compilerOptionsMap = serializeCompilerOptions(compilerOptions);\r\n        return writeConfigurations();\r\n\r\n        function getCustomTypeMapOfCommandLineOption(optionDefinition: CommandLineOption): Map<string | number> | undefined {\r\n            if (optionDefinition.type === \"string\" || optionDefinition.type === \"number\" || optionDefinition.type === \"boolean\") {\r\n                // this is of a type CommandLineOptionOfPrimitiveType\r\n                return undefined;\r\n            }\r\n            else if (optionDefinition.type === \"list\") {\r\n                return getCustomTypeMapOfCommandLineOption((<CommandLineOptionOfListType>optionDefinition).element);\r\n            }\r\n            else {\r\n                return (<CommandLineOptionOfCustomType>optionDefinition).type;\r\n            }\r\n        }\r\n\r\n        function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: Map<string | number>): string | undefined {\r\n            // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n            return forEachEntry(customTypeMap, (mapValue, key) => {\r\n                if (mapValue === value) {\r\n                    return key;\r\n                }\r\n            });\r\n        }\r\n\r\n        function serializeCompilerOptions(options: CompilerOptions): Map<CompilerOptionsValue> {\r\n            const result = createMap<CompilerOptionsValue>();\r\n            const optionsNameMap = getOptionNameMap().optionNameMap;\r\n            const 别名集 = getOptionNameMap().别名集\r\n\r\n            for (let name in options) {\r\n                name = 别名集.get(name) || name\r\n                if (hasProperty(options, name)) {\r\n                    // tsconfig only options cannot be specified via command line,\r\n                    // so we can assume that only types that can appear here string | number | boolean\r\n                    if (optionsNameMap.has(name) && optionsNameMap.get(name).category === Diagnostics.Command_line_Options) {\r\n                        continue;\r\n                    }\r\n                    const value = <CompilerOptionsValue>options[name];\r\n                    const optionDefinition = optionsNameMap.get(name.toLowerCase());\r\n                    if (optionDefinition) {\r\n                        const customTypeMap = getCustomTypeMapOfCommandLineOption(optionDefinition);\r\n                        if (!customTypeMap) {\r\n                            // There is no map associated with this compiler option then use the value as-is\r\n                            // This is the case if the value is expect to be string, number, boolean or list of string\r\n                            result.set(name, value);\r\n                        }\r\n                        else {\r\n                            if (optionDefinition.type === \"list\") {\r\n                                result.set(name, (value as ReadonlyArray<string | number>).map(element => getNameOfCompilerOptionValue(element, customTypeMap)));\r\n                            }\r\n                            else {\r\n                                // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n                                result.set(name, getNameOfCompilerOptionValue(value, customTypeMap));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function getDefaultValueForOption(option: CommandLineOption) {\r\n            switch (option.type) {\r\n                case \"number\":\r\n                    return 1;\r\n                case \"boolean\":\r\n                    return true;\r\n                case \"string\":\r\n                    return option.isFilePath ? \"./\" : \"\";\r\n                case \"list\":\r\n                    return [];\r\n                case \"object\":\r\n                    return {};\r\n                default:\r\n                    return (option as CommandLineOptionOfCustomType).type.keys().next().value;\r\n            }\r\n        }\r\n\r\n        function makePadding(paddingLength: number): string {\r\n            return Array(paddingLength + 1).join(\" \");\r\n        }\r\n\r\n        function writeConfigurations() {\r\n            // Filter applicable options to place in the file\r\n            const categorizedOptions = createMultiMap<CommandLineOption>();\r\n            for (const option of optionDeclarations) {\r\n                const { category } = option;\r\n                if (category !== undefined && category !== Diagnostics.Command_line_Options && category !== Diagnostics.Advanced_Options) {\r\n                    categorizedOptions.add(getLocaleSpecificMessage(category), option);\r\n                }\r\n            }\r\n\r\n            // Serialize all options and their descriptions\r\n            let marginLength = 0;\r\n            let seenKnownKeys = 0;\r\n            const nameColumn: string[] = [];\r\n            const descriptionColumn: string[] = [];\r\n            categorizedOptions.forEach((options, category) => {\r\n                if (nameColumn.length !== 0) {\r\n                    nameColumn.push(\"\");\r\n                    descriptionColumn.push(\"\");\r\n                }\r\n                nameColumn.push(`/* ${category} */`);\r\n                descriptionColumn.push(\"\");\r\n                for (const option of options) {\r\n                    let optionName;\r\n                    if (compilerOptionsMap.has(option.name)) {\r\n                        optionName = `\"${option.name}\": ${JSON.stringify(compilerOptionsMap.get(option.name))}${(seenKnownKeys += 1) === compilerOptionsMap.size ? \"\" : \",\"}`;\r\n                    }\r\n                    else {\r\n                        optionName = `// \"${option.name}\": ${JSON.stringify(getDefaultValueForOption(option))},`;\r\n                    }\r\n                    nameColumn.push(optionName);\r\n                    descriptionColumn.push(`/* ${option.description && getLocaleSpecificMessage(option.description) || option.name} */`);\r\n                    marginLength = Math.max(optionName.length, marginLength);\r\n                }\r\n            });\r\n\r\n            // Write the output\r\n            const tab = makePadding(2);\r\n            const result: string[] = [];\r\n            result.push(`{`);\r\n            result.push(`${tab}\"compilerOptions\": {`);\r\n            // Print out each row, aligning all the descriptions on the same column.\r\n            for (let i = 0; i < nameColumn.length; i++) {\r\n                const optionName = nameColumn[i];\r\n                const description = descriptionColumn[i];\r\n                result.push(optionName && `${tab}${tab}${optionName}${ description && (makePadding(marginLength - optionName.length + 2) + description)}`);\r\n            }\r\n            if (fileNames.length) {\r\n                result.push(`${tab}},`);\r\n                result.push(`${tab}\"files\": [`);\r\n                for (let i = 0; i < fileNames.length; i++) {\r\n                    result.push(`${tab}${tab}${JSON.stringify(fileNames[i])}${i === fileNames.length - 1 ? \"\" : \",\"}`);\r\n                }\r\n                result.push(`${tab}]`);\r\n            }\r\n            else {\r\n                result.push(`${tab}}`);\r\n            }\r\n            result.push(`}`);\r\n\r\n            return result.join(newLine);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file (tsconfig.json).\r\n     * @param json The contents of the config file to parse\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     */\r\n    export function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ParsedCommandLine {\r\n        return parseJsonConfigFileContentWorker(json, /*sourceFile*/ undefined, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions);\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file (tsconfig.json).\r\n     * @param jsonNode The contents of the config file to parse\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     */\r\n    export function parseJsonSourceFileConfigFileContent(sourceFile: JsonSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ParsedCommandLine {\r\n        return parseJsonConfigFileContentWorker(/*json*/ undefined, sourceFile, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions);\r\n    }\r\n\r\n    /*@internal*/\r\n    export function setConfigFileInOptions(options: CompilerOptions, configFile: JsonSourceFile) {\r\n        if (configFile) {\r\n            Object.defineProperty(options, \"configFile\", { enumerable: false, writable: false, value: configFile });\r\n        }\r\n    }\r\n\r\n    function isNullOrUndefined(x: any): x is null | undefined {\r\n        // tslint:disable-next-line:no-null-keyword\r\n        return x === undefined || x === null;\r\n    }\r\n\r\n    function directoryOfCombinedPath(fileName: string, basePath: string) {\r\n        // Use the `identity` function to avoid canonicalizing the path, as it must remain noncanonical\r\n        // until consistient casing errors are reported\r\n        return getDirectoryPath(toPath(fileName, basePath, identity));\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file from json or json source file (tsconfig.json).\r\n     * @param json The contents of the config file to parse\r\n     * @param sourceFile sourceFile corresponding to the Json\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     * @param resolutionStack Only present for backwards-compatibility. Should be empty.\r\n     */\r\n    function parseJsonConfigFileContentWorker(\r\n        json: any,\r\n        sourceFile: JsonSourceFile,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        existingOptions: CompilerOptions = {},\r\n        configFileName?: string,\r\n        resolutionStack: Path[] = [],\r\n        extraFileExtensions: ReadonlyArray<JsFileExtensionInfo> = [],\r\n    ): ParsedCommandLine {\r\n        Debug.assert((json === undefined && sourceFile !== undefined) || (json !== undefined && sourceFile === undefined));\r\n        const errors: Diagnostic[] = [];\r\n\r\n        const getCanonicalFileName = createGetCanonicalFileName(host.useCaseSensitiveFileNames);\r\n        const parsedConfig = parseConfig(json, sourceFile, host, basePath, configFileName, getCanonicalFileName, resolutionStack, errors);\r\n        const { raw } = parsedConfig;\r\n        const options = extend(existingOptions, parsedConfig.options || {});\r\n        options.configFilePath = configFileName;\r\n        setConfigFileInOptions(options, sourceFile);\r\n        const { fileNames, wildcardDirectories, spec } = getFileNames();\r\n        return {\r\n            options,\r\n            fileNames,\r\n            typeAcquisition: parsedConfig.typeAcquisition || getDefaultTypeAcquisition(),\r\n            raw,\r\n            errors,\r\n            wildcardDirectories,\r\n            compileOnSave: !!raw.compileOnSave,\r\n            configFileSpecs: spec\r\n        };\r\n\r\n        function getFileNames(): ExpandResult {\r\n            let filesSpecs: ReadonlyArray<string>;\r\n            if ((hasProperty(raw, \"files\") || hasProperty(raw, \"文件集\")) && !isNullOrUndefined(raw.files)) {\r\n                if (isArray(raw.files) || isArray(raw.文件集)) {\r\n                    filesSpecs = hasProperty(raw, \"files\") ? <ReadonlyArray<string>>raw.files : <ReadonlyArray<string>>raw.文件集;\r\n                    if (filesSpecs.length === 0) {\r\n                        createCompilerDiagnosticOnlyIfJson(Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || \"tsconfig.json\");\r\n                    }\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"文件集\", \"数组类\");\r\n                }\r\n            }\r\n\r\n            let includeSpecs: ReadonlyArray<string>;\r\n            if ((hasProperty(raw, \"include\") || hasProperty(raw, \"包含\")) && !isNullOrUndefined(raw.include)) {\r\n                if (isArray(raw.include) || isArray(raw.包含)) {\r\n                    includeSpecs = hasProperty(raw, \"include\") ? <ReadonlyArray<string>>raw.include : <ReadonlyArray<string>>raw.包含;\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"包含\", \"数组类\");\r\n                }\r\n            }\r\n\r\n            let excludeSpecs: ReadonlyArray<string>;\r\n            if ((hasProperty(raw, \"exclude\") || hasProperty(raw, \"排除\")) && !isNullOrUndefined(raw.exclude)) {\r\n                if (isArray(raw.exclude) || isArray(raw.排除)) {\r\n                    excludeSpecs = hasProperty(raw, \"exclude\") ? <ReadonlyArray<string>>raw.exclude : <ReadonlyArray<string>>raw.排除;\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"排除\", \"数组类\");\r\n                }\r\n            }\r\n            else {\r\n                const outDir = raw.compilerOptions && raw.compilerOptions.outDir;\r\n                if (outDir) {\r\n                    excludeSpecs = [outDir];\r\n                }\r\n            }\r\n\r\n            if (filesSpecs === undefined && includeSpecs === undefined) {\r\n                includeSpecs = [\"**/*\"];\r\n            }\r\n\r\n            const result = matchFileNames(filesSpecs, includeSpecs, excludeSpecs, configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath, options, host, errors, extraFileExtensions, sourceFile);\r\n            if (result.fileNames.length === 0 && (!hasProperty(raw, \"files\") && !hasProperty(raw, \"文件集\")) && resolutionStack.length === 0) {\r\n                errors.push(getErrorForNoInputFiles(result.spec, configFileName));\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function createCompilerDiagnosticOnlyIfJson(message: DiagnosticMessage, arg0?: string, arg1?: string) {\r\n            if (!sourceFile) {\r\n                errors.push(createCompilerDiagnostic(message, arg0, arg1));\r\n            }\r\n        }\r\n    }\r\n\r\n    /*@internal*/\r\n    export function isErrorNoInputFiles(error: Diagnostic) {\r\n        return error.code === Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code;\r\n    }\r\n\r\n    /*@internal*/\r\n    export function getErrorForNoInputFiles({ includeSpecs, excludeSpecs }: ConfigFileSpecs, configFileName: string | undefined) {\r\n        return createCompilerDiagnostic(\r\n            Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2,\r\n            configFileName || \"tsconfig.json\",\r\n            JSON.stringify(includeSpecs || []),\r\n            JSON.stringify(excludeSpecs || []));\r\n    }\r\n\r\n    interface ParsedTsconfig {\r\n        raw: any;\r\n        options?: CompilerOptions;\r\n        typeAcquisition?: TypeAcquisition;\r\n        extendedConfigPath?: Path;\r\n    }\r\n\r\n    function isSuccessfulParsedTsconfig(value: ParsedTsconfig) {\r\n        return !!value.options;\r\n    }\r\n\r\n    /**\r\n     * This *just* extracts options/include/exclude/files out of a config file.\r\n     * It does *not* resolve the included files.\r\n     */\r\n    function parseConfig(\r\n            json: any,\r\n            sourceFile: JsonSourceFile,\r\n            host: ParseConfigHost,\r\n            basePath: string,\r\n            configFileName: string,\r\n            getCanonicalFileName: (fileName: string) => string,\r\n            resolutionStack: Path[],\r\n            errors: Push<Diagnostic>,\r\n    ): ParsedTsconfig {\r\n        basePath = normalizeSlashes(basePath);\r\n        const resolvedPath = toPath(configFileName || \"\", basePath, getCanonicalFileName);\r\n\r\n        if (resolutionStack.indexOf(resolvedPath) >= 0) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Circularity_detected_while_resolving_configuration_Colon_0, [...resolutionStack, resolvedPath].join(\" -> \")));\r\n            return { raw: json || convertToObject(sourceFile, errors) };\r\n        }\r\n\r\n        const ownConfig = json ?\r\n            parseOwnConfigOfJson(json, host, basePath, getCanonicalFileName, configFileName, errors) :\r\n            parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, getCanonicalFileName, configFileName, errors);\r\n\r\n        if (ownConfig.extendedConfigPath) {\r\n            // copy the resolution stack so it is never reused between branches in potential diamond-problem scenarios.\r\n            resolutionStack = resolutionStack.concat([resolvedPath]);\r\n            const extendedConfig = getExtendedConfig(sourceFile, ownConfig.extendedConfigPath, host, basePath, getCanonicalFileName,\r\n                resolutionStack, errors);\r\n            if (extendedConfig && isSuccessfulParsedTsconfig(extendedConfig)) {\r\n                const baseRaw = extendedConfig.raw;\r\n                const raw = ownConfig.raw;\r\n                const setPropertyInRawIfNotUndefined = (propertyName: string) => {\r\n                    const value = raw[propertyName] || baseRaw[propertyName];\r\n                    if (value) {\r\n                        raw[propertyName] = value;\r\n                    }\r\n                };\r\n                setPropertyInRawIfNotUndefined(\"include\");\r\n                setPropertyInRawIfNotUndefined(\"exclude\");\r\n                setPropertyInRawIfNotUndefined(\"files\");\r\n                setPropertyInRawIfNotUndefined(\"包含\");\r\n                setPropertyInRawIfNotUndefined(\"排除\");\r\n                setPropertyInRawIfNotUndefined(\"文件集\");\r\n                if (raw.compileOnSave === undefined) {\r\n                    raw.compileOnSave = baseRaw.compileOnSave;\r\n                }\r\n                ownConfig.options = assign({}, extendedConfig.options, ownConfig.options);\r\n                // TODO extend type typeAcquisition\r\n            }\r\n        }\r\n\r\n        return ownConfig;\r\n    }\r\n\r\n    function parseOwnConfigOfJson(\r\n        json: any,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        getCanonicalFileName: (fileName: string) => string,\r\n        configFileName: string | undefined,\r\n        errors: Push<Diagnostic>\r\n    ): ParsedTsconfig {\r\n        if (hasProperty(json, \"excludes\") || hasProperty(json, \"排除集\")) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));\r\n        }\r\n\r\n        const options = convertCompilerOptionsFromJsonWorker(json.compilerOptions, basePath, errors, configFileName);\r\n        // typingOptions has been deprecated and is only supported for backward compatibility purposes.\r\n        // It should be removed in future releases - use typeAcquisition instead.\r\n        const typeAcquisition = convertTypeAcquisitionFromJsonWorker(json.typeAcquisition || json.typingOptions, basePath, errors, configFileName);\r\n        json.compileOnSave = convertCompileOnSaveOptionFromJson(json, basePath, errors);\r\n        let extendedConfigPath: Path;\r\n\r\n        if (json.extends) {\r\n            if (!isString(json.extends)) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"extends\", \"string\"));\r\n            }\r\n            else {\r\n                const newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;\r\n                extendedConfigPath = getExtendsConfigPath(json.extends, host, newBase, getCanonicalFileName, errors, createCompilerDiagnostic);\r\n            }\r\n        }\r\n        return { raw: json, options, typeAcquisition, extendedConfigPath };\r\n    }\r\n\r\n    function parseOwnConfigOfJsonSourceFile(\r\n        sourceFile: JsonSourceFile,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        getCanonicalFileName: (fileName: string) => string,\r\n        configFileName: string | undefined,\r\n        errors: Push<Diagnostic>\r\n    ): ParsedTsconfig {\r\n        const options = getDefaultCompilerOptions(configFileName);\r\n        let typeAcquisition: TypeAcquisition, typingOptionstypeAcquisition: TypeAcquisition;\r\n        let extendedConfigPath: Path;\r\n\r\n        const optionsIterator: JsonConversionNotifier = {\r\n            onSetValidOptionKeyValueInParent(parentOption: string, option: CommandLineOption, value: CompilerOptionsValue) {\r\n                Debug.assert(parentOption === \"编译选项\" || parentOption === \"compilerOptions\" || parentOption === \"类型收集\" || parentOption === \"typeAcquisition\" || parentOption === \"分类选项\" || parentOption === \"typingOptions\");\r\n                const currentOption = parentOption === \"compilerOptions\" || parentOption === \"编译选项\" ?\r\n                    options :\r\n                    parentOption === \"typeAcquisition\" || parentOption === \"类型收集\" ?\r\n                        (typeAcquisition || (typeAcquisition = getDefaultTypeAcquisition(configFileName))) :\r\n                        (typingOptionstypeAcquisition || (typingOptionstypeAcquisition = getDefaultTypeAcquisition(configFileName)));\r\n\r\n                currentOption[option.name] = normalizeOptionValue(option, basePath, value);\r\n            },\r\n            onSetValidOptionKeyValueInRoot(key: string, _keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression) {\r\n                switch (key) {\r\n                    case \"extends\":\r\n                    case \"外部扩展\":\r\n                        const newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;\r\n                        extendedConfigPath = getExtendsConfigPath(\r\n                            <string>value,\r\n                            host,\r\n                            newBase,\r\n                            getCanonicalFileName,\r\n                            errors,\r\n                            (message, arg0) =>\r\n                                createDiagnosticForNodeInSourceFile(sourceFile, valueNode, message, arg0)\r\n                        );\r\n                        return;\r\n                    case \"files\":\r\n                    case \"文件集\":\r\n                        if ((<ReadonlyArray<string>>value).length === 0) {\r\n                            errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueNode, Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || \"tsconfig.json\"));\r\n                        }\r\n                        return;\r\n                }\r\n            },\r\n            onSetUnknownOptionKeyValueInRoot(key: string, keyNode: PropertyName, _value: CompilerOptionsValue, _valueNode: Expression) {\r\n                if (key === \"excludes\" || key === \"排除集\") {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, keyNode, Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));\r\n                }\r\n            }\r\n        };\r\n        const json = convertToObjectWorker(sourceFile, errors, getTsconfigRootOptionsMap(), optionsIterator);\r\n        if (!typeAcquisition) {\r\n            if (typingOptionstypeAcquisition) {\r\n                typeAcquisition = (typingOptionstypeAcquisition.enableAutoDiscovery !== undefined) ?\r\n                    {\r\n                        enable: typingOptionstypeAcquisition.enableAutoDiscovery,\r\n                        include: typingOptionstypeAcquisition.include,\r\n                        exclude: typingOptionstypeAcquisition.exclude\r\n                    } :\r\n                    typingOptionstypeAcquisition;\r\n            }\r\n            else {\r\n                typeAcquisition = getDefaultTypeAcquisition(configFileName);\r\n            }\r\n        }\r\n\r\n        return { raw: json, options, typeAcquisition, extendedConfigPath };\r\n    }\r\n\r\n    function getExtendsConfigPath(\r\n        extendedConfig: string,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        getCanonicalFileName: (fileName: string) => string,\r\n        errors: Push<Diagnostic>,\r\n        createDiagnostic: (message: DiagnosticMessage, arg1?: string) => Diagnostic) {\r\n        extendedConfig = normalizeSlashes(extendedConfig);\r\n        // If the path isn't a rooted or relative path, don't try to resolve it (we reserve the right to special case module-id like paths in the future)\r\n        if (!(isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, \"./\") || startsWith(extendedConfig, \"../\"))) {\r\n            errors.push(createDiagnostic(Diagnostics.A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not, extendedConfig));\r\n            return undefined;\r\n        }\r\n        let extendedConfigPath = toPath(extendedConfig, basePath, getCanonicalFileName);\r\n        if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, Extension.Json)) {\r\n            extendedConfigPath = `${extendedConfigPath}.json` as Path;\r\n            if (!host.fileExists(extendedConfigPath)) {\r\n                errors.push(createDiagnostic(Diagnostics.File_0_does_not_exist, extendedConfig));\r\n                return undefined;\r\n            }\r\n        }\r\n        return extendedConfigPath;\r\n    }\r\n\r\n    function getExtendedConfig(\r\n        sourceFile: JsonSourceFile,\r\n        extendedConfigPath: Path,\r\n        host: ts.ParseConfigHost,\r\n        basePath: string,\r\n        getCanonicalFileName: (fileName: string) => string,\r\n        resolutionStack: Path[],\r\n        errors: Push<Diagnostic>,\r\n    ): ParsedTsconfig | undefined {\r\n        const extendedResult = readJsonConfigFile(extendedConfigPath, path => host.readFile(path));\r\n        if (sourceFile) {\r\n            (sourceFile.extendedSourceFiles || (sourceFile.extendedSourceFiles = [])).push(extendedResult.fileName);\r\n        }\r\n        if (extendedResult.parseDiagnostics.length) {\r\n            errors.push(...extendedResult.parseDiagnostics);\r\n            return undefined;\r\n        }\r\n\r\n        const extendedDirname = getDirectoryPath(extendedConfigPath);\r\n        const extendedConfig = parseConfig(/*json*/ undefined, extendedResult, host, extendedDirname,\r\n            getBaseFileName(extendedConfigPath), getCanonicalFileName, resolutionStack, errors);\r\n        if (sourceFile) {\r\n            sourceFile.extendedSourceFiles.push(...extendedResult.extendedSourceFiles);\r\n        }\r\n\r\n        if (isSuccessfulParsedTsconfig(extendedConfig)) {\r\n            // Update the paths to reflect base path\r\n            const relativeDifference = convertToRelativePath(extendedDirname, basePath, getCanonicalFileName);\r\n            const updatePath = (path: string) => isRootedDiskPath(path) ? path : combinePaths(relativeDifference, path);\r\n            const mapPropertiesInRawIfNotUndefined = (propertyName: string) => {\r\n                if (raw[propertyName]) {\r\n                    raw[propertyName] = map(raw[propertyName], updatePath);\r\n                }\r\n            };\r\n\r\n            const { raw } = extendedConfig;\r\n            mapPropertiesInRawIfNotUndefined(\"include\");\r\n            mapPropertiesInRawIfNotUndefined(\"包含\");\r\n            mapPropertiesInRawIfNotUndefined(\"exclude\");\r\n            mapPropertiesInRawIfNotUndefined(\"排除\");\r\n            mapPropertiesInRawIfNotUndefined(\"files\");\r\n            mapPropertiesInRawIfNotUndefined(\"文件集\");\r\n        }\r\n\r\n        return extendedConfig;\r\n    }\r\n\r\n    function convertCompileOnSaveOptionFromJson(jsonOption: any, basePath: string, errors: Push<Diagnostic>): boolean {\r\n        if (!hasProperty(jsonOption, compileOnSaveCommandLineOption.name) && !hasProperty(jsonOption, compileOnSaveCommandLineOption.别名)) {\r\n            return undefined;\r\n        }\r\n        const result = convertJsonOption(compileOnSaveCommandLineOption, jsonOption.compileOnSave, basePath, errors);\r\n        if (typeof result === \"boolean\" && result) {\r\n            return result;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): { options: CompilerOptions, errors: Diagnostic[] } {\r\n        const errors: Diagnostic[] = [];\r\n        const options = convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName);\r\n        return { options, errors };\r\n    }\r\n\r\n    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): { options: TypeAcquisition, errors: Diagnostic[] } {\r\n        const errors: Diagnostic[] = [];\r\n        const options = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);\r\n        return { options, errors };\r\n    }\r\n\r\n    function getDefaultCompilerOptions(configFileName?: string) {\r\n        const options: CompilerOptions = getBaseFileName(configFileName) === \"jsconfig.json\"\r\n            ? { allowJs: true, maxNodeModuleJsDepth: 2, allowSyntheticDefaultImports: true, skipLibCheck: true }\r\n            : {};\r\n        return options;\r\n    }\r\n\r\n    function convertCompilerOptionsFromJsonWorker(jsonOptions: any,\r\n        basePath: string, errors: Push<Diagnostic>, configFileName?: string): CompilerOptions {\r\n\r\n        const options = getDefaultCompilerOptions(configFileName);\r\n        convertOptionsFromJson(optionDeclarations, jsonOptions, basePath, options, Diagnostics.Unknown_compiler_option_0, errors);\r\n        return options;\r\n    }\r\n\r\n    function getDefaultTypeAcquisition(configFileName?: string) {\r\n        const options: TypeAcquisition = { enable: getBaseFileName(configFileName) === \"jsconfig.json\", include: [], exclude: [] };\r\n        return options;\r\n    }\r\n\r\n    function convertTypeAcquisitionFromJsonWorker(jsonOptions: any,\r\n        basePath: string, errors: Push<Diagnostic>, configFileName?: string): TypeAcquisition {\r\n\r\n        const options = getDefaultTypeAcquisition(configFileName);\r\n        const typeAcquisition = convertEnableAutoDiscoveryToEnable(jsonOptions);\r\n        convertOptionsFromJson(typeAcquisitionDeclarations, typeAcquisition, basePath, options, Diagnostics.Unknown_type_acquisition_option_0, errors);\r\n\r\n        return options;\r\n    }\r\n\r\n    function convertOptionsFromJson(optionDeclarations: ReadonlyArray<CommandLineOption>, jsonOptions: any, basePath: string,\r\n        defaultOptions: CompilerOptions | TypeAcquisition, diagnosticMessage: DiagnosticMessage, errors: Push<Diagnostic>) {\r\n\r\n        if (!jsonOptions) {\r\n            return;\r\n        }\r\n\r\n        const optionNameMap = commandLineOptionsToMap(optionDeclarations);\r\n\r\n        for (const id in jsonOptions) {\r\n            const opt = optionNameMap.get(id);\r\n            if (opt) {\r\n                defaultOptions[opt.name] = convertJsonOption(opt, jsonOptions[id], basePath, errors);\r\n            }\r\n            else {\r\n                errors.push(createCompilerDiagnostic(diagnosticMessage, id));\r\n            }\r\n        }\r\n    }\r\n\r\n    function convertJsonOption(opt: CommandLineOption, value: any, basePath: string, errors: Push<Diagnostic>): CompilerOptionsValue {\r\n        if (isCompilerOptionsValue(opt, value)) {\r\n            const optType = opt.type;\r\n            if (optType === \"list\" && isArray(value)) {\r\n                return convertJsonOptionOfListType(<CommandLineOptionOfListType>opt, value, basePath, errors);\r\n            }\r\n            else if (!isString(optType)) {\r\n                return convertJsonOptionOfCustomType(<CommandLineOptionOfCustomType>opt, <string>value, errors);\r\n            }\r\n            return normalizeNonListOptionValue(opt, basePath, value);\r\n        }\r\n        else {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, opt.name, getCompilerOptionValueTypeString(opt)));\r\n        }\r\n    }\r\n\r\n    function normalizeOptionValue(option: CommandLineOption, basePath: string, value: any): CompilerOptionsValue {\r\n        if (isNullOrUndefined(value)) return undefined;\r\n        if (option.type === \"list\") {\r\n            const listOption = <CommandLineOptionOfListType>option;\r\n            if (listOption.element.isFilePath || !isString(listOption.element.type)) {\r\n                return <CompilerOptionsValue>filter(map(value, v => normalizeOptionValue(listOption.element, basePath, v)), v => !!v);\r\n            }\r\n            return value;\r\n        }\r\n        else if (!isString(option.type)) {\r\n            return option.type.get(isString(value) ? value.toLowerCase() : value);\r\n        }\r\n        return normalizeNonListOptionValue(option, basePath, value);\r\n    }\r\n\r\n    function normalizeNonListOptionValue(option: CommandLineOption, basePath: string, value: any): CompilerOptionsValue  {\r\n        if (option.isFilePath) {\r\n            value = normalizePath(combinePaths(basePath, value));\r\n            if (value === \"\") {\r\n                value = \".\";\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function convertJsonOptionOfCustomType(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>) {\r\n        if (isNullOrUndefined(value)) return undefined;\r\n        const key = value.toLowerCase();\r\n        const val = opt.type.get(key);\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n        else {\r\n            errors.push(createCompilerDiagnosticForInvalidCustomType(opt));\r\n        }\r\n    }\r\n\r\n    function convertJsonOptionOfListType(option: CommandLineOptionOfListType, values: ReadonlyArray<any>, basePath: string, errors: Push<Diagnostic>): any[] {\r\n        return filter(map(values, v => convertJsonOption(option.element, v, basePath, errors)), v => !!v);\r\n    }\r\n\r\n    function trimString(s: string) {\r\n        return typeof s.trim === \"function\" ? s.trim() : s.replace(/^[\\s]+|[\\s]+$/g, \"\");\r\n    }\r\n\r\n    /**\r\n     * Tests for a path that ends in a recursive directory wildcard.\r\n     * Matches **, \\**, **\\, and \\**\\, but not a**b.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  (^|\\/)      # matches either the beginning of the string or a directory separator.\r\n     *  \\*\\*        # matches the recursive directory wildcard \"**\".\r\n     *  \\/?$        # matches an optional trailing directory separator at the end of the string.\r\n     */\r\n    const invalidTrailingRecursionPattern = /(^|\\/)\\*\\*\\/?$/;\r\n\r\n    /**\r\n     * Tests for a path with multiple recursive directory wildcards.\r\n     * Matches **\\** and **\\a\\**, but not **\\a**b.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  (^|\\/)      # matches either the beginning of the string or a directory separator.\r\n     *  \\*\\*\\/      # matches a recursive directory wildcard \"**\" followed by a directory separator.\r\n     *  (.*\\/)?     # optionally matches any number of characters followed by a directory separator.\r\n     *  \\*\\*        # matches a recursive directory wildcard \"**\"\r\n     *  ($|\\/)      # matches either the end of the string or a directory separator.\r\n     */\r\n    const invalidMultipleRecursionPatterns = /(^|\\/)\\*\\*\\/(.*\\/)?\\*\\*($|\\/)/;\r\n\r\n    /**\r\n     * Tests for a path where .. appears after a recursive directory wildcard.\r\n     * Matches **\\..\\*, **\\a\\..\\*, and **\\.., but not ..\\**\\*\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  (^|\\/)      # matches either the beginning of the string or a directory separator.\r\n     *  \\*\\*\\/      # matches a recursive directory wildcard \"**\" followed by a directory separator.\r\n     *  (.*\\/)?     # optionally matches any number of characters followed by a directory separator.\r\n     *  \\.\\.        # matches a parent directory path component \"..\"\r\n     *  ($|\\/)      # matches either the end of the string or a directory separator.\r\n     */\r\n    const invalidDotDotAfterRecursiveWildcardPattern = /(^|\\/)\\*\\*\\/(.*\\/)?\\.\\.($|\\/)/;\r\n\r\n    /**\r\n     * Tests for a path containing a wildcard character in a directory component of the path.\r\n     * Matches \\*\\, \\?\\, and \\a*b\\, but not \\a\\ or \\a\\*.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  \\/          # matches a directory separator.\r\n     *  [^/]*?      # matches any number of characters excluding directory separators (non-greedy).\r\n     *  [*?]        # matches either a wildcard character (* or ?)\r\n     *  [^/]*       # matches any number of characters excluding directory separators (greedy).\r\n     *  \\/          # matches a directory separator.\r\n     */\r\n    const watchRecursivePattern = /\\/[^/]*?[*?][^/]*\\//;\r\n\r\n    /**\r\n     * Matches the portion of a wildcard path that does not contain wildcards.\r\n     * Matches \\a of \\a\\*, or \\a\\b\\c of \\a\\b\\c\\?\\d.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  ^                   # matches the beginning of the string\r\n     *  [^*?]*              # matches any number of non-wildcard characters\r\n     *  (?=\\/[^/]*[*?])     # lookahead that matches a directory separator followed by\r\n     *                      # a path component that contains at least one wildcard character (* or ?).\r\n     */\r\n    const wildcardDirectoryPattern = /^[^*?]*(?=\\/[^/]*[*?])/;\r\n\r\n    /**\r\n     * Expands an array of file specifications.\r\n     *\r\n     * @param filesSpecs The literal file names to include.\r\n     * @param includeSpecs The wildcard file specifications to include.\r\n     * @param excludeSpecs The wildcard file specifications to exclude.\r\n     * @param basePath The base path for any relative file specifications.\r\n     * @param options Compiler options.\r\n     * @param host The host used to resolve files and directories.\r\n     * @param errors An array for diagnostic reporting.\r\n     */\r\n    function matchFileNames(\r\n        filesSpecs: ReadonlyArray<string>,\r\n        includeSpecs: ReadonlyArray<string>,\r\n        excludeSpecs: ReadonlyArray<string>,\r\n        basePath: string,\r\n        options: CompilerOptions,\r\n        host: ParseConfigHost,\r\n        errors: Push<Diagnostic>,\r\n        extraFileExtensions: ReadonlyArray<JsFileExtensionInfo>,\r\n        jsonSourceFile: JsonSourceFile\r\n    ): ExpandResult {\r\n        basePath = normalizePath(basePath);\r\n        let validatedIncludeSpecs: ReadonlyArray<string>, validatedExcludeSpecs: ReadonlyArray<string>;\r\n\r\n        // The exclude spec list is converted into a regular expression, which allows us to quickly\r\n        // test whether a file or directory should be excluded before recursively traversing the\r\n        // file system.\r\n\r\n        if (includeSpecs) {\r\n            validatedIncludeSpecs = validateSpecs(includeSpecs, errors, /*allowTrailingRecursion*/ false, jsonSourceFile,  \"include\", \"包含\");\r\n        }\r\n\r\n        if (excludeSpecs) {\r\n            validatedExcludeSpecs = validateSpecs(excludeSpecs, errors, /*allowTrailingRecursion*/ true, jsonSourceFile,\"exclude\", \"排除\");\r\n        }\r\n\r\n        // Wildcard directories (provided as part of a wildcard path) are stored in a\r\n        // file map that marks whether it was a regular wildcard match (with a `*` or `?` token),\r\n        // or a recursive directory. This information is used by filesystem watchers to monitor for\r\n        // new entries in these paths.\r\n        const wildcardDirectories = getWildcardDirectories(validatedIncludeSpecs, validatedExcludeSpecs, basePath, host.useCaseSensitiveFileNames);\r\n\r\n        const spec: ConfigFileSpecs = { filesSpecs, includeSpecs, excludeSpecs, validatedIncludeSpecs, validatedExcludeSpecs, wildcardDirectories };\r\n        return getFileNamesFromConfigSpecs(spec, basePath, options, host, extraFileExtensions);\r\n    }\r\n\r\n    /**\r\n     * Gets the file names from the provided config file specs that contain, files, include, exclude and\r\n     * other properties needed to resolve the file names\r\n     * @param spec The config file specs extracted with file names to include, wildcards to include/exclude and other details\r\n     * @param basePath The base path for any relative file specifications.\r\n     * @param options Compiler options.\r\n     * @param host The host used to resolve files and directories.\r\n     * @param extraFileExtensions optionaly file extra file extension information from host\r\n     */\r\n    /* @internal */\r\n    export function getFileNamesFromConfigSpecs(spec: ConfigFileSpecs, basePath: string, options: CompilerOptions, host: ParseConfigHost, extraFileExtensions: ReadonlyArray<JsFileExtensionInfo> = []): ExpandResult {\r\n        basePath = normalizePath(basePath);\r\n\r\n        const keyMapper = host.useCaseSensitiveFileNames ? caseSensitiveKeyMapper : caseInsensitiveKeyMapper;\r\n\r\n        // Literal file names (provided via the \"files\" array in tsconfig.json) are stored in a\r\n        // file map with a possibly case insensitive key. We use this map later when when including\r\n        // wildcard paths.\r\n        const literalFileMap = createMap<string>();\r\n\r\n        // Wildcard paths (provided via the \"includes\" array in tsconfig.json) are stored in a\r\n        // file map with a possibly case insensitive key. We use this map to store paths matched\r\n        // via wildcard, and to handle extension priority.\r\n        const wildcardFileMap = createMap<string>();\r\n\r\n        const { filesSpecs, validatedIncludeSpecs, validatedExcludeSpecs, wildcardDirectories } = spec;\r\n\r\n        // Rather than requery this for each file and filespec, we query the supported extensions\r\n        // once and store it on the expansion context.\r\n        const supportedExtensions = getSupportedExtensions(options, extraFileExtensions);\r\n\r\n        // Literal files are always included verbatim. An \"include\" or \"exclude\" specification cannot\r\n        // remove a literal file.\r\n        if (filesSpecs) {\r\n            for (const fileName of filesSpecs) {\r\n                const file = getNormalizedAbsolutePath(fileName, basePath);\r\n                literalFileMap.set(keyMapper(file), file);\r\n            }\r\n        }\r\n\r\n        if (validatedIncludeSpecs && validatedIncludeSpecs.length > 0) {\r\n            for (const file of host.readDirectory(basePath, supportedExtensions, validatedExcludeSpecs, validatedIncludeSpecs, /*depth*/ undefined)) {\r\n                // If we have already included a literal or wildcard path with a\r\n                // higher priority extension, we should skip this file.\r\n                //\r\n                // This handles cases where we may encounter both <file>.ts and\r\n                // <file>.d.ts (or <file>.js if \"allowJs\" is enabled) in the same\r\n                // directory when they are compilation outputs.\r\n                if (hasFileWithHigherPriorityExtension(file, literalFileMap, wildcardFileMap, supportedExtensions, keyMapper)) {\r\n                    continue;\r\n                }\r\n\r\n                // We may have included a wildcard path with a lower priority\r\n                // extension due to the user-defined order of entries in the\r\n                // \"include\" array. If there is a lower priority extension in the\r\n                // same directory, we should remove it.\r\n                removeWildcardFilesWithLowerPriorityExtension(file, wildcardFileMap, supportedExtensions, keyMapper);\r\n\r\n                const key = keyMapper(file);\r\n                if (!literalFileMap.has(key) && !wildcardFileMap.has(key)) {\r\n                    wildcardFileMap.set(key, file);\r\n                }\r\n            }\r\n        }\r\n\r\n        const literalFiles = arrayFrom(literalFileMap.values());\r\n        const wildcardFiles = arrayFrom(wildcardFileMap.values());\r\n        return {\r\n            fileNames: literalFiles.concat(wildcardFiles),\r\n            wildcardDirectories,\r\n            spec\r\n        };\r\n    }\r\n\r\n    function validateSpecs(specs: ReadonlyArray<string>, errors: Push<Diagnostic>, allowTrailingRecursion: boolean, jsonSourceFile: JsonSourceFile, specKey: string, specKey2: string): ReadonlyArray<string> {\r\n        return specs.filter(spec => {\r\n            const diag = specToDiagnostic(spec, allowTrailingRecursion);\r\n            if (diag !== undefined) {\r\n                errors.push(createDiagnostic(diag, spec));\r\n            }\r\n            return diag === undefined;\r\n        });\r\n\r\n        function createDiagnostic(message: DiagnosticMessage, spec: string): Diagnostic {\r\n            if (jsonSourceFile && jsonSourceFile.jsonObject) {\r\n                for (const property of getPropertyAssignment(jsonSourceFile.jsonObject, specKey, specKey2)) {\r\n                    if (isArrayLiteralExpression(property.initializer)) {\r\n                        for (const element of property.initializer.elements) {\r\n                            if (isStringLiteral(element) && element.text === spec) {\r\n                                return createDiagnosticForNodeInSourceFile(jsonSourceFile, element, message, spec);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return createCompilerDiagnostic(message, spec);\r\n        }\r\n    }\r\n\r\n    function specToDiagnostic(spec: string, allowTrailingRecursion: boolean): ts.DiagnosticMessage | undefined {\r\n        if (!allowTrailingRecursion && invalidTrailingRecursionPattern.test(spec)) {\r\n            return Diagnostics.File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0;\r\n        }\r\n        else if (invalidMultipleRecursionPatterns.test(spec)) {\r\n            return Diagnostics.File_specification_cannot_contain_multiple_recursive_directory_wildcards_Asterisk_Asterisk_Colon_0;\r\n        }\r\n        else if (invalidDotDotAfterRecursiveWildcardPattern.test(spec)) {\r\n            return Diagnostics.File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets directories in a set of include patterns that should be watched for changes.\r\n     */\r\n    function getWildcardDirectories(include: ReadonlyArray<string>, exclude: ReadonlyArray<string>, path: string, useCaseSensitiveFileNames: boolean): MapLike<WatchDirectoryFlags> {\r\n        // We watch a directory recursively if it contains a wildcard anywhere in a directory segment\r\n        // of the pattern:\r\n        //\r\n        //  /a/b/**/d   - Watch /a/b recursively to catch changes to any d in any subfolder recursively\r\n        //  /a/b/*/d    - Watch /a/b recursively to catch any d in any immediate subfolder, even if a new subfolder is added\r\n        //  /a/b        - Watch /a/b recursively to catch changes to anything in any recursive subfoler\r\n        //\r\n        // We watch a directory without recursion if it contains a wildcard in the file segment of\r\n        // the pattern:\r\n        //\r\n        //  /a/b/*      - Watch /a/b directly to catch any new file\r\n        //  /a/b/a?z    - Watch /a/b directly to catch any new file matching a?z\r\n        const rawExcludeRegex = getRegularExpressionForWildcard(exclude, path, \"exclude\");\r\n        const excludeRegex = rawExcludeRegex && new RegExp(rawExcludeRegex, useCaseSensitiveFileNames ? \"\" : \"i\");\r\n\r\n        const rawExcludeRegexCH = getRegularExpressionForWildcard(exclude, path, \"排除\");\r\n        const excludeRegexCH = rawExcludeRegex && new RegExp(rawExcludeRegexCH, useCaseSensitiveFileNames ? \"\" : \"i\");\r\n\r\n        const wildcardDirectories: ts.MapLike<WatchDirectoryFlags> = {};\r\n        if (include !== undefined) {\r\n            const recursiveKeys: string[] = [];\r\n            for (const file of include) {\r\n                const spec = normalizePath(combinePaths(path, file));\r\n                if (excludeRegex && excludeRegex.test(spec) || excludeRegexCH && excludeRegexCH.test(spec)) {\r\n                    continue;\r\n                }\r\n\r\n\r\n                const match = getWildcardDirectoryFromSpec(spec, useCaseSensitiveFileNames);\r\n                if (match) {\r\n                    const { key, flags } = match;\r\n                    const existingFlags = wildcardDirectories[key];\r\n                    if (existingFlags === undefined || existingFlags < flags) {\r\n                        wildcardDirectories[key] = flags;\r\n                        if (flags === WatchDirectoryFlags.Recursive) {\r\n                            recursiveKeys.push(key);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove any subpaths under an existing recursively watched directory.\r\n            for (const key in wildcardDirectories) {\r\n                if (hasProperty(wildcardDirectories, key)) {\r\n                    for (const recursiveKey of recursiveKeys) {\r\n                        if (key !== recursiveKey && containsPath(recursiveKey, key, path, !useCaseSensitiveFileNames)) {\r\n                            delete wildcardDirectories[key];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return wildcardDirectories;\r\n    }\r\n\r\n    function getWildcardDirectoryFromSpec(spec: string, useCaseSensitiveFileNames: boolean): { key: string, flags: WatchDirectoryFlags } | undefined {\r\n        const match = wildcardDirectoryPattern.exec(spec);\r\n        if (match) {\r\n            return {\r\n                key: useCaseSensitiveFileNames ? match[0] : match[0].toLowerCase(),\r\n                flags: watchRecursivePattern.test(spec) ? WatchDirectoryFlags.Recursive : WatchDirectoryFlags.None\r\n            };\r\n        }\r\n        if (isImplicitGlob(spec)) {\r\n            return { key: spec, flags: WatchDirectoryFlags.Recursive };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a literal or wildcard file has already been included that has a higher\r\n     * extension priority.\r\n     *\r\n     * @param file The path to the file.\r\n     * @param extensionPriority The priority of the extension.\r\n     * @param context The expansion context.\r\n     */\r\n    function hasFileWithHigherPriorityExtension(file: string, literalFiles: Map<string>, wildcardFiles: Map<string>, extensions: ReadonlyArray<string>, keyMapper: (value: string) => string) {\r\n        const extensionPriority = getExtensionPriority(file, extensions);\r\n        const adjustedExtensionPriority = adjustExtensionPriority(extensionPriority, extensions);\r\n        for (let i = ExtensionPriority.Highest; i < adjustedExtensionPriority; i++) {\r\n            const higherPriorityExtension = extensions[i];\r\n            const higherPriorityPath = keyMapper(changeExtension(file, higherPriorityExtension));\r\n            if (literalFiles.has(higherPriorityPath) || wildcardFiles.has(higherPriorityPath)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Removes files included via wildcard expansion with a lower extension priority that have\r\n     * already been included.\r\n     *\r\n     * @param file The path to the file.\r\n     * @param extensionPriority The priority of the extension.\r\n     * @param context The expansion context.\r\n     */\r\n    function removeWildcardFilesWithLowerPriorityExtension(file: string, wildcardFiles: Map<string>, extensions: ReadonlyArray<string>, keyMapper: (value: string) => string) {\r\n        const extensionPriority = getExtensionPriority(file, extensions);\r\n        const nextExtensionPriority = getNextLowestExtensionPriority(extensionPriority, extensions);\r\n        for (let i = nextExtensionPriority; i < extensions.length; i++) {\r\n            const lowerPriorityExtension = extensions[i];\r\n            const lowerPriorityPath = keyMapper(changeExtension(file, lowerPriorityExtension));\r\n            wildcardFiles.delete(lowerPriorityPath);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a case sensitive key.\r\n     *\r\n     * @param key The original key.\r\n     */\r\n    function caseSensitiveKeyMapper(key: string) {\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Gets a case insensitive key.\r\n     *\r\n     * @param key The original key.\r\n     */\r\n    function caseInsensitiveKeyMapper(key: string) {\r\n        return key.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Produces a cleaned version of compiler options with personally identifiying info (aka, paths) removed.\r\n     * Also converts enum values back to strings.\r\n     */\r\n    /* @internal */\r\n    export function convertCompilerOptionsForTelemetry(opts: ts.CompilerOptions): ts.CompilerOptions {\r\n        const out: ts.CompilerOptions = {};\r\n        for (const key in opts) {\r\n            if (opts.hasOwnProperty(key)) {\r\n                const type = getOptionFromName(key);\r\n                if (type !== undefined) { // Ignore unknown options\r\n                    out[key] = getOptionValueWithEmptyStrings(opts[key], type);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function getOptionValueWithEmptyStrings(value: any, option: CommandLineOption): {} {\r\n        switch (option.type) {\r\n            case \"object\": // \"paths\". Can't get any useful information from the value since we blank out strings, so just return \"\".\r\n                return \"\";\r\n            case \"string\": // Could be any arbitrary string -- use empty string instead.\r\n                return \"\";\r\n            case \"number\": // Allow numbers, but be sure to check it's actually a number.\r\n                return typeof value === \"number\" ? value : \"\";\r\n            case \"boolean\":\r\n                return typeof value === \"boolean\" ? value : \"\";\r\n            case \"list\":\r\n                const elementType = (option as CommandLineOptionOfListType).element;\r\n                return ts.isArray(value) ? value.map(v => getOptionValueWithEmptyStrings(v, elementType)) : \"\";\r\n            default:\r\n                return ts.forEachEntry(option.type, (optionEnumValue, optionStringValue) => {\r\n                    if (optionEnumValue === value) {\r\n                        return optionStringValue;\r\n                    }\r\n                });\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0.\r\n// See LICENSE.txt in the project root for complete license information.\r\n\r\n/// <reference path='../compiler/types.ts' />\r\n/// <reference path='../compiler/core.ts' />\r\n/// <reference path='../compiler/commandLineParser.ts' />\r\n\r\n/* @internal */\r\nnamespace ts.JsTyping {\r\n\r\n    export interface TypingResolutionHost {\r\n        directoryExists(path: string): boolean;\r\n        fileExists(fileName: string): boolean;\r\n        readFile(path: string, encoding?: string): string | undefined;\r\n        readDirectory(rootDir: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, depth?: number): string[];\r\n    }\r\n\r\n    interface PackageJson {\r\n        _requiredBy?: string[];\r\n        dependencies?: MapLike<string>;\r\n        devDependencies?: MapLike<string>;\r\n        name?: string;\r\n        optionalDependencies?: MapLike<string>;\r\n        peerDependencies?: MapLike<string>;\r\n        types?: string;\r\n        typings?: string;\r\n    }\r\n\r\n    /* @internal */\r\n    export const nodeCoreModuleList: ReadonlyArray<string> = [\r\n        \"buffer\", \"querystring\", \"events\", \"http\", \"cluster\",\r\n        \"zlib\", \"os\", \"https\", \"punycode\", \"repl\", \"readline\",\r\n        \"vm\", \"child_process\", \"url\", \"dns\", \"net\",\r\n        \"dgram\", \"fs\", \"path\", \"string_decoder\", \"tls\",\r\n        \"crypto\", \"stream\", \"util\", \"assert\", \"tty\", \"domain\",\r\n        \"constants\", \"process\", \"v8\", \"timers\", \"console\"];\r\n\r\n    const nodeCoreModules = arrayToSet(nodeCoreModuleList);\r\n\r\n    /**\r\n     * A map of loose file names to library names that we are confident require typings\r\n     */\r\n    export type SafeList = ReadonlyMap<string>;\r\n\r\n    export function loadSafeList(host: TypingResolutionHost, safeListPath: Path): SafeList {\r\n        const result = readConfigFile(safeListPath, path => host.readFile(path));\r\n        return createMapFromTemplate<string>(result.config);\r\n    }\r\n\r\n    export function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): SafeList | undefined {\r\n        const result = readConfigFile(typesMapPath, path => host.readFile(path));\r\n        if (result.config) {\r\n            return createMapFromTemplate<string>(result.config.simpleMap);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * @param host is the object providing I/O related operations.\r\n     * @param fileNames are the file names that belong to the same project\r\n     * @param projectRootPath is the path to the project root directory\r\n     * @param safeListPath is the path used to retrieve the safe list\r\n     * @param packageNameToTypingLocation is the map of package names to their cached typing locations\r\n     * @param typeAcquisition is used to customize the typing acquisition process\r\n     * @param compilerOptions are used as a source for typing inference\r\n     */\r\n    export function discoverTypings(\r\n        host: TypingResolutionHost,\r\n        log: ((message: string) => void) | undefined,\r\n        fileNames: string[],\r\n        projectRootPath: Path,\r\n        safeList: SafeList,\r\n        packageNameToTypingLocation: ReadonlyMap<string>,\r\n        typeAcquisition: TypeAcquisition,\r\n        unresolvedImports: ReadonlyArray<string>):\r\n        { cachedTypingPaths: string[], newTypingNames: string[], filesToWatch: string[] } {\r\n\r\n        if (!typeAcquisition || !typeAcquisition.enable) {\r\n            return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };\r\n        }\r\n\r\n        // A typing name to typing file path mapping\r\n        const inferredTypings = createMap<string>();\r\n\r\n        // Only infer typings for .js and .jsx files\r\n        fileNames = mapDefined(fileNames, fileName => {\r\n            const path = normalizePath(fileName);\r\n            if (hasJavaScriptFileExtension(path)) {\r\n                return path;\r\n            }\r\n        });\r\n\r\n        const filesToWatch: string[] = [];\r\n\r\n        if (typeAcquisition.include) addInferredTypings(typeAcquisition.include, \"Explicitly included types\");\r\n        const exclude = typeAcquisition.exclude || [];\r\n\r\n        // Directories to search for package.json, bower.json and other typing information\r\n        const possibleSearchDirs = arrayToSet(fileNames, getDirectoryPath);\r\n        possibleSearchDirs.set(projectRootPath, true);\r\n        possibleSearchDirs.forEach((_true, searchDir) => {\r\n            const packageJsonPath = combinePaths(searchDir, \"package.json\");\r\n            getTypingNamesFromJson(packageJsonPath, filesToWatch);\r\n\r\n            const bowerJsonPath = combinePaths(searchDir, \"bower.json\");\r\n            getTypingNamesFromJson(bowerJsonPath, filesToWatch);\r\n\r\n            const bowerComponentsPath = combinePaths(searchDir, \"bower_components\");\r\n            getTypingNamesFromPackagesFolder(bowerComponentsPath, filesToWatch);\r\n\r\n            const nodeModulesPath = combinePaths(searchDir, \"node_modules\");\r\n            getTypingNamesFromPackagesFolder(nodeModulesPath, filesToWatch);\r\n        });\r\n        getTypingNamesFromSourceFileNames(fileNames);\r\n\r\n        // add typings for unresolved imports\r\n        if (unresolvedImports) {\r\n            const module = deduplicate(unresolvedImports.map(moduleId => nodeCoreModules.has(moduleId) ? \"node\" : moduleId));\r\n            addInferredTypings(module, \"Inferred typings from unresolved imports\");\r\n        }\r\n        // Add the cached typing locations for inferred typings that are already installed\r\n        packageNameToTypingLocation.forEach((typingLocation, name) => {\r\n            if (inferredTypings.has(name) && inferredTypings.get(name) === undefined) {\r\n                inferredTypings.set(name, typingLocation);\r\n            }\r\n        });\r\n\r\n        // Remove typings that the user has added to the exclude list\r\n        for (const excludeTypingName of exclude) {\r\n            const didDelete = inferredTypings.delete(excludeTypingName);\r\n            if (didDelete && log) log(`Typing for ${excludeTypingName} is in exclude list, will be ignored.`);\r\n        }\r\n\r\n        const newTypingNames: string[] = [];\r\n        const cachedTypingPaths: string[] = [];\r\n        inferredTypings.forEach((inferred, typing) => {\r\n            if (inferred !== undefined) {\r\n                cachedTypingPaths.push(inferred);\r\n            }\r\n            else {\r\n                newTypingNames.push(typing);\r\n            }\r\n        });\r\n        const result = { cachedTypingPaths, newTypingNames, filesToWatch };\r\n        if (log) log(`Result: ${JSON.stringify(result)}`);\r\n        return result;\r\n\r\n        function addInferredTyping(typingName: string) {\r\n            if (!inferredTypings.has(typingName)) {\r\n                inferredTypings.set(typingName, undefined);\r\n            }\r\n        }\r\n        function addInferredTypings(typingNames: ReadonlyArray<string>, message: string) {\r\n            if (log) log(`${message}: ${JSON.stringify(typingNames)}`);\r\n            forEach(typingNames, addInferredTyping);\r\n        }\r\n\r\n        /**\r\n         * Get the typing info from common package manager json files like package.json or bower.json\r\n         */\r\n        function getTypingNamesFromJson(jsonPath: string, filesToWatch: Push<string>) {\r\n            if (!host.fileExists(jsonPath)) {\r\n                return;\r\n            }\r\n\r\n            filesToWatch.push(jsonPath);\r\n            const jsonConfig: PackageJson = readConfigFile(jsonPath, path => host.readFile(path)).config;\r\n            const jsonTypingNames = flatMap([jsonConfig.dependencies, jsonConfig.devDependencies, jsonConfig.optionalDependencies, jsonConfig.peerDependencies], getOwnKeys);\r\n            addInferredTypings(jsonTypingNames, `Typing names in '${jsonPath}' dependencies`);\r\n        }\r\n\r\n        /**\r\n         * Infer typing names from given file names. For example, the file name \"jquery-min.2.3.4.js\"\r\n         * should be inferred to the 'jquery' typing name; and \"angular-route.1.2.3.js\" should be inferred\r\n         * to the 'angular-route' typing name.\r\n         * @param fileNames are the names for source files in the project\r\n         */\r\n        function getTypingNamesFromSourceFileNames(fileNames: string[]) {\r\n            const fromFileNames = mapDefined(fileNames, j => {\r\n                if (!hasJavaScriptFileExtension(j)) return undefined;\r\n\r\n                const inferredTypingName = removeFileExtension(getBaseFileName(j.toLowerCase()));\r\n                const cleanedTypingName = inferredTypingName.replace(/((?:\\.|-)min(?=\\.|$))|((?:-|\\.)\\d+)/g, \"\");\r\n                return safeList.get(cleanedTypingName);\r\n            });\r\n            if (fromFileNames.length) {\r\n                addInferredTypings(fromFileNames, \"Inferred typings from file names\");\r\n            }\r\n\r\n            const hasJsxFile = some(fileNames, f => fileExtensionIs(f, Extension.Jsx));\r\n            if (hasJsxFile) {\r\n                if (log) log(`Inferred 'react' typings due to presence of '.jsx' extension`);\r\n                addInferredTyping(\"react\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Infer typing names from packages folder (ex: node_module, bower_components)\r\n         * @param packagesFolderPath is the path to the packages folder\r\n         */\r\n        function getTypingNamesFromPackagesFolder(packagesFolderPath: string, filesToWatch: Push<string>) {\r\n            filesToWatch.push(packagesFolderPath);\r\n\r\n            // Todo: add support for ModuleResolutionHost too\r\n            if (!host.directoryExists(packagesFolderPath)) {\r\n                return;\r\n            }\r\n\r\n            // depth of 2, so we access `node_modules/foo` but not `node_modules/foo/bar`\r\n            const fileNames = host.readDirectory(packagesFolderPath, [Extension.Json], /*excludes*/ undefined, /*includes*/ undefined, /*depth*/ 2);\r\n            if (log) log(`Searching for typing names in ${packagesFolderPath}; all files: ${JSON.stringify(fileNames)}`);\r\n            const packageNames: string[] = [];\r\n            for (const fileName of fileNames) {\r\n                const normalizedFileName = normalizePath(fileName);\r\n                const baseFileName = getBaseFileName(normalizedFileName);\r\n                if (baseFileName !== \"package.json\" && baseFileName !== \"bower.json\") {\r\n                    continue;\r\n                }\r\n                const result = readConfigFile(normalizedFileName, (path: string) => host.readFile(path));\r\n                const packageJson: PackageJson = result.config;\r\n\r\n                // npm 3's package.json contains a \"_requiredBy\" field\r\n                // we should include all the top level module names for npm 2, and only module names whose\r\n                // \"_requiredBy\" field starts with \"#\" or equals \"/\" for npm 3.\r\n                if (baseFileName === \"package.json\" && packageJson._requiredBy &&\r\n                    filter(packageJson._requiredBy, (r: string) => r[0] === \"#\" || r === \"/\").length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                // If the package has its own d.ts typings, those will take precedence. Otherwise the package name will be used\r\n                // to download d.ts files from DefinitelyTyped\r\n                if (!packageJson.name) {\r\n                    continue;\r\n                }\r\n                const ownTypes = packageJson.types || packageJson.typings;\r\n                if (ownTypes) {\r\n                    const absolutePath = getNormalizedAbsolutePath(ownTypes, getDirectoryPath(normalizedFileName));\r\n                    if (log) log(`    Package '${packageJson.name}' provides its own types.`);\r\n                    inferredTypings.set(packageJson.name, absolutePath);\r\n                }\r\n                else {\r\n                    packageNames.push(packageJson.name);\r\n                }\r\n            }\r\n            addInferredTypings(packageNames, \"    Found package names\");\r\n        }\r\n\r\n    }\r\n\r\n    export const enum PackageNameValidationResult {\r\n        Ok,\r\n        ScopedPackagesNotSupported,\r\n        EmptyName,\r\n        NameTooLong,\r\n        NameStartsWithDot,\r\n        NameStartsWithUnderscore,\r\n        NameContainsNonURISafeCharacters\r\n    }\r\n\r\n    const MaxPackageNameLength = 214;\r\n\r\n    /**\r\n     * Validates package name using rules defined at https://docs.npmjs.com/files/package.json\r\n     */\r\n    export function validatePackageName(packageName: string): PackageNameValidationResult {\r\n        if (!packageName) {\r\n            return PackageNameValidationResult.EmptyName;\r\n        }\r\n        if (packageName.length > MaxPackageNameLength) {\r\n            return PackageNameValidationResult.NameTooLong;\r\n        }\r\n        if (packageName.charCodeAt(0) === CharacterCodes.dot) {\r\n            return PackageNameValidationResult.NameStartsWithDot;\r\n        }\r\n        if (packageName.charCodeAt(0) === CharacterCodes._) {\r\n            return PackageNameValidationResult.NameStartsWithUnderscore;\r\n        }\r\n        // check if name is scope package like: starts with @ and has one '/' in the middle\r\n        // scoped packages are not currently supported\r\n        // TODO: when support will be added we'll need to split and check both scope and package name\r\n        if (/^@[^/]+\\/[^/]+$/.test(packageName)) {\r\n            return PackageNameValidationResult.ScopedPackagesNotSupported;\r\n        }\r\n        if (encodeURIComponent(packageName) !== packageName) {\r\n            return PackageNameValidationResult.NameContainsNonURISafeCharacters;\r\n        }\r\n        return PackageNameValidationResult.Ok;\r\n    }\r\n\r\n    export function renderPackageNameValidationFailure(result: PackageNameValidationResult, typing: string): string {\r\n        switch (result) {\r\n            case PackageNameValidationResult.EmptyName:\r\n                return `Package name '${typing}' cannot be empty`;\r\n            case PackageNameValidationResult.NameTooLong:\r\n                return `Package name '${typing}' should be less than ${MaxPackageNameLength} characters`;\r\n            case PackageNameValidationResult.NameStartsWithDot:\r\n                return `Package name '${typing}' cannot start with '.'`;\r\n            case PackageNameValidationResult.NameStartsWithUnderscore:\r\n                return `Package name '${typing}' cannot start with '_'`;\r\n            case PackageNameValidationResult.ScopedPackagesNotSupported:\r\n                return `Package '${typing}' is scoped and currently is not supported`;\r\n            case PackageNameValidationResult.NameContainsNonURISafeCharacters:\r\n                return `Package name '${typing}' contains non URI safe characters`;\r\n            case PackageNameValidationResult.Ok:\r\n                throw Debug.fail(); // Shouldn't have called this.\r\n            default:\r\n                Debug.assertNever(result);\r\n        }\r\n    }\r\n}\r\n","/// <reference path=\"types.ts\" />\r\n\r\nnamespace ts.server {\r\n    export const ActionSet: ActionSet = \"action::set\";\r\n    export const ActionInvalidate: ActionInvalidate = \"action::invalidate\";\r\n    export const EventTypesRegistry: EventTypesRegistry = \"event::typesRegistry\";\r\n    export const EventPackageInstalled: EventPackageInstalled = \"event::packageInstalled\";\r\n    export const EventBeginInstallTypes: EventBeginInstallTypes = \"event::beginInstallTypes\";\r\n    export const EventEndInstallTypes: EventEndInstallTypes = \"event::endInstallTypes\";\r\n    export const EventInitializationFailed: EventInitializationFailed = \"event::initializationFailed\";\r\n\r\n    export namespace Arguments {\r\n        export const GlobalCacheLocation = \"--globalTypingsCacheLocation\";\r\n        export const LogFile = \"--logFile\";\r\n        export const EnableTelemetry = \"--enableTelemetry\";\r\n        export const TypingSafeListLocation = \"--typingSafeListLocation\";\r\n        export const TypesMapLocation = \"--typesMapLocation\";\r\n        /**\r\n         * This argument specifies the location of the NPM executable.\r\n         * typingsInstaller will run the command with `${npmLocation} install ...`.\r\n         */\r\n        export const NpmLocation = \"--npmLocation\";\r\n    }\r\n\r\n    export function hasArgument(argumentName: string) {\r\n        return sys.args.indexOf(argumentName) >= 0;\r\n    }\r\n\r\n    export function findArgument(argumentName: string): string | undefined {\r\n        const index = sys.args.indexOf(argumentName);\r\n        return index >= 0 && index < sys.args.length - 1\r\n            ? sys.args[index + 1]\r\n            : undefined;\r\n    }\r\n}","/// <reference path=\"core.ts\" />\r\n/// <reference path=\"diagnosticInformationMap.generated.ts\" />\r\n\r\nnamespace ts {\r\n    /* @internal */\r\n    export function trace(host: ModuleResolutionHost, message: DiagnosticMessage, ...args: any[]): void;\r\n    export function trace(host: ModuleResolutionHost): void {\r\n        host.trace(formatMessage.apply(undefined, arguments));\r\n    }\r\n\r\n    /* @internal */\r\n    export function isTraceEnabled(compilerOptions: CompilerOptions, host: ModuleResolutionHost): boolean {\r\n        return compilerOptions.traceResolution && host.trace !== undefined;\r\n    }\r\n\r\n    /** Array that is only intended to be pushed to, never read. */\r\n    /* @internal */\r\n    export interface Push<T> {\r\n        push(value: T): void;\r\n    }\r\n\r\n    function withPackageId(packageId: PackageId | undefined, r: PathAndExtension | undefined): Resolved {\r\n        return r && { path: r.path, extension: r.ext, packageId };\r\n    }\r\n\r\n    function noPackageId(r: PathAndExtension | undefined): Resolved {\r\n        return withPackageId(/*packageId*/ undefined, r);\r\n    }\r\n\r\n    /** Result of trying to resolve a module. */\r\n    interface Resolved {\r\n        path: string;\r\n        extension: Extension;\r\n        packageId: PackageId | undefined;\r\n    }\r\n\r\n    /** Result of trying to resolve a module at a file. Needs to have 'packageId' added later. */\r\n    interface PathAndExtension {\r\n        path: string;\r\n        // (Use a different name than `extension` to make sure Resolved isn't assignable to PathAndExtension.)\r\n        ext: Extension;\r\n    }\r\n\r\n    /**\r\n     * Kinds of file that we are currently looking for.\r\n     * Typically there is one pass with Extensions.TypeScript, then a second pass with Extensions.JavaScript.\r\n     */\r\n    enum Extensions {\r\n        TypeScript, /** '.ts', '.tsx', or '.d.ts' */\r\n        JavaScript, /** '.js' or '.jsx' */\r\n        DtsOnly /** Only '.d.ts' */\r\n    }\r\n\r\n    interface PathAndPackageId {\r\n        readonly fileName: string;\r\n        readonly packageId: PackageId;\r\n    }\r\n    /** Used with `Extensions.DtsOnly` to extract the path from TypeScript results. */\r\n    function resolvedTypeScriptOnly(resolved: Resolved | undefined): PathAndPackageId | undefined {\r\n        if (!resolved) {\r\n            return undefined;\r\n        }\r\n        Debug.assert(extensionIsTypeScript(resolved.extension));\r\n        return { fileName: resolved.path, packageId: resolved.packageId };\r\n    }\r\n\r\n    function createResolvedModuleWithFailedLookupLocations(resolved: Resolved | undefined, isExternalLibraryImport: boolean, failedLookupLocations: string[]): ResolvedModuleWithFailedLookupLocations {\r\n        return {\r\n            resolvedModule: resolved && { resolvedFileName: resolved.path, extension: resolved.extension, isExternalLibraryImport, packageId: resolved.packageId },\r\n            failedLookupLocations\r\n        };\r\n    }\r\n\r\n    interface ModuleResolutionState {\r\n        host: ModuleResolutionHost;\r\n        compilerOptions: CompilerOptions;\r\n        traceEnabled: boolean;\r\n    }\r\n\r\n    /** Just the fields that we use for module resolution. */\r\n    interface PackageJsonPathFields {\r\n        typings?: string;\r\n        types?: string;\r\n        main?: string;\r\n    }\r\n\r\n    interface PackageJson extends PackageJsonPathFields {\r\n        name?: string;\r\n        version?: string;\r\n    }\r\n\r\n    /** Reads from \"main\" or \"types\"/\"typings\" depending on `extensions`. */\r\n    function tryReadPackageJsonFields(readTypes: boolean, jsonContent: PackageJsonPathFields, baseDirectory: string, state: ModuleResolutionState): string | undefined {\r\n        return readTypes ? tryReadFromField(\"typings\") || tryReadFromField(\"types\") : tryReadFromField(\"main\");\r\n\r\n        function tryReadFromField(fieldName: \"typings\" | \"types\" | \"main\"): string | undefined {\r\n            if (!hasProperty(jsonContent, fieldName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.package_json_does_not_have_a_0_field, fieldName);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const fileName = jsonContent[fieldName];\r\n            if (!isString(fileName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Expected_type_of_0_field_in_package_json_to_be_string_got_1, fieldName, typeof fileName);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const path = normalizePath(combinePaths(baseDirectory, fileName));\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.package_json_has_0_field_1_that_references_2, fieldName, fileName, path);\r\n            }\r\n            return path;\r\n        }\r\n    }\r\n\r\n    function readJson(path: string, host: ModuleResolutionHost): PackageJson {\r\n        try {\r\n            const jsonText = host.readFile(path);\r\n            return jsonText ? JSON.parse(jsonText) : {};\r\n        }\r\n        catch (e) {\r\n            // gracefully handle if readFile fails or returns not JSON\r\n            return {};\r\n        }\r\n    }\r\n\r\n    export interface GetEffectiveTypeRootsHost {\r\n        directoryExists?(directoryName: string): boolean;\r\n        getCurrentDirectory?(): string;\r\n    }\r\n    export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined {\r\n        if (options.typeRoots) {\r\n            return options.typeRoots;\r\n        }\r\n\r\n        let currentDirectory: string;\r\n        if (options.configFilePath) {\r\n            currentDirectory = getDirectoryPath(options.configFilePath);\r\n        }\r\n        else if (host.getCurrentDirectory) {\r\n            currentDirectory = host.getCurrentDirectory();\r\n        }\r\n\r\n        if (currentDirectory !== undefined) {\r\n            return getDefaultTypeRoots(currentDirectory, host);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the path to every node_modules/@types directory from some ancestor directory.\r\n     * Returns undefined if there are none.\r\n     */\r\n    function getDefaultTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }): string[] | undefined {\r\n        if (!host.directoryExists) {\r\n            return [combinePaths(currentDirectory, nodeModulesAtTypes)];\r\n            // And if it doesn't exist, tough.\r\n        }\r\n\r\n        let typeRoots: string[];\r\n        forEachAncestorDirectory(ts.normalizePath(currentDirectory), directory => {\r\n            const atTypes = combinePaths(directory, nodeModulesAtTypes);\r\n            const atTypesch = combinePaths(directory, nodeModulesAtTypesch);\r\n            if (host.directoryExists(atTypesch)) {\r\n                (typeRoots || (typeRoots = [])).push(atTypesch);\r\n            }\r\n            if (host.directoryExists(atTypes)) {\r\n                (typeRoots || (typeRoots = [])).push(atTypes);\r\n            }\r\n            return undefined;\r\n        });\r\n        return typeRoots;\r\n    }\r\n    const nodeModulesAtTypes = combinePaths(\"node_modules\", \"@types\");\r\n    const nodeModulesAtTypesch = combinePaths(\"node_modules\", \"@typesch\");\r\n\r\n    /**\r\n     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\r\n     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\r\n     * is assumed to be the same as root directory of the project.\r\n     */\r\n    export function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost): ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(options, host);\r\n        const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled };\r\n\r\n        const typeRoots = getEffectiveTypeRoots(options, host);\r\n        if (traceEnabled) {\r\n            if (containingFile === undefined) {\r\n                if (typeRoots === undefined) {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set, typeReferenceDirectiveName);\r\n                }\r\n                else {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1, typeReferenceDirectiveName, typeRoots);\r\n                }\r\n            }\r\n            else {\r\n                if (typeRoots === undefined) {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set, typeReferenceDirectiveName, containingFile);\r\n                }\r\n                else {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_2, typeReferenceDirectiveName, containingFile, typeRoots);\r\n                }\r\n            }\r\n        }\r\n\r\n        const failedLookupLocations: string[] = [];\r\n\r\n        let resolved = primaryLookup();\r\n        let primary = true;\r\n        if (!resolved) {\r\n            resolved = secondaryLookup();\r\n            primary = false;\r\n        }\r\n\r\n        let resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;\r\n        if (resolved) {\r\n            if (!options.preserveSymlinks) {\r\n                resolved = { ...resolved, fileName: realPath(resolved.fileName, host, traceEnabled) };\r\n            }\r\n\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2, typeReferenceDirectiveName, resolved.fileName, primary);\r\n            }\r\n            resolvedTypeReferenceDirective = { primary, resolvedFileName: resolved.fileName, packageId: resolved.packageId };\r\n        }\r\n\r\n        return { resolvedTypeReferenceDirective, failedLookupLocations };\r\n\r\n        function primaryLookup(): PathAndPackageId | undefined {\r\n            // Check primary library paths\r\n            if (typeRoots && typeRoots.length) {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Resolving_with_primary_search_path_0, typeRoots.join(\", \"));\r\n                }\r\n                return forEach(typeRoots, typeRoot => {\r\n                    const candidate = combinePaths(typeRoot, typeReferenceDirectiveName);\r\n                    const candidateDirectory = getDirectoryPath(candidate);\r\n                    const directoryExists = directoryProbablyExists(candidateDirectory, host);\r\n                    if (!directoryExists && traceEnabled) {\r\n                        trace(host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);\r\n                    }\r\n                    return resolvedTypeScriptOnly(\r\n                        loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, failedLookupLocations,\r\n                            !directoryExists, moduleResolutionState));\r\n                });\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Root_directory_cannot_be_determined_skipping_primary_search_paths);\r\n                }\r\n            }\r\n        }\r\n\r\n        function secondaryLookup(): PathAndPackageId | undefined {\r\n            let resolvedFile: PathAndPackageId;\r\n            const initialLocationForSecondaryLookup = containingFile && getDirectoryPath(containingFile);\r\n\r\n            if (initialLocationForSecondaryLookup !== undefined) {\r\n                // check secondary locations\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Looking_up_in_node_modules_folder_initial_location_0, initialLocationForSecondaryLookup);\r\n                }\r\n                const result = loadModuleFromNodeModules(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, failedLookupLocations, moduleResolutionState, /*cache*/ undefined);\r\n                resolvedFile = resolvedTypeScriptOnly(result && result.value);\r\n                if (!resolvedFile && traceEnabled) {\r\n                    trace(host, Diagnostics.Type_reference_directive_0_was_not_resolved, typeReferenceDirectiveName);\r\n                }\r\n                return resolvedFile;\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a set of options, returns the set of type directive names\r\n     *   that should be included for this program automatically.\r\n     * This list could either come from the config file,\r\n     *   or from enumerating the types root + initial secondary types lookup location.\r\n     * More type directives might appear in the program later as a result of loading actual source files;\r\n     *   this list is only the set of defaults that are implicitly included.\r\n     */\r\n    export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[] {\r\n        // Use explicit type list from tsconfig.json\r\n        if (options.types) {\r\n            return options.types;\r\n        }\r\n\r\n        // Walk the primary type lookup locations\r\n        const result: string[] = [];\r\n        if (host.directoryExists && host.getDirectories) {\r\n            const typeRoots = getEffectiveTypeRoots(options, host);\r\n            if (typeRoots) {\r\n                for (const root of typeRoots) {\r\n                    if (host.directoryExists(root)) {\r\n                        for (const typeDirectivePath of host.getDirectories(root)) {\r\n                            const normalized = normalizePath(typeDirectivePath);\r\n                            const packageJsonPath = pathToPackageJson(combinePaths(root, normalized));\r\n                            // `types-publisher` sometimes creates packages with `\"typings\": null` for packages that don't provide their own types.\r\n                            // See `createNotNeededPackageJSON` in the types-publisher` repo.\r\n                            // tslint:disable-next-line:no-null-keyword\r\n                            const isNotNeededPackage = host.fileExists(packageJsonPath) && readJson(packageJsonPath, host).typings === null;\r\n                            if (!isNotNeededPackage) {\r\n                                // Return just the type directive names\r\n                                result.push(getBaseFileName(normalized));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Cached module resolutions per containing directory.\r\n     * This assumes that any module id will have the same resolution for sibling files located in the same folder.\r\n     */\r\n    export interface ModuleResolutionCache extends NonRelativeModuleNameResolutionCache {\r\n        getOrCreateCacheForDirectory(directoryName: string): Map<ResolvedModuleWithFailedLookupLocations>;\r\n    }\r\n\r\n    /**\r\n     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory\r\n     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.\r\n     */\r\n    export interface NonRelativeModuleNameResolutionCache {\r\n        getOrCreateCacheForModuleName(nonRelativeModuleName: string): PerModuleNameCache;\r\n    }\r\n\r\n    export interface PerModuleNameCache {\r\n        get(directory: string): ResolvedModuleWithFailedLookupLocations;\r\n        set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;\r\n    }\r\n\r\n    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string): ModuleResolutionCache {\r\n        const directoryToModuleNameMap = createMap<Map<ResolvedModuleWithFailedLookupLocations>>();\r\n        const moduleNameToDirectoryMap = createMap<PerModuleNameCache>();\r\n\r\n        return { getOrCreateCacheForDirectory, getOrCreateCacheForModuleName };\r\n\r\n        function getOrCreateCacheForDirectory(directoryName: string) {\r\n            const path = toPath(directoryName, currentDirectory, getCanonicalFileName);\r\n            let perFolderCache = directoryToModuleNameMap.get(path);\r\n            if (!perFolderCache) {\r\n                perFolderCache = createMap<ResolvedModuleWithFailedLookupLocations>();\r\n                directoryToModuleNameMap.set(path, perFolderCache);\r\n            }\r\n            return perFolderCache;\r\n        }\r\n\r\n        function getOrCreateCacheForModuleName(nonRelativeModuleName: string) {\r\n            if (isExternalModuleNameRelative(nonRelativeModuleName)) {\r\n                return undefined;\r\n            }\r\n            let perModuleNameCache = moduleNameToDirectoryMap.get(nonRelativeModuleName);\r\n            if (!perModuleNameCache) {\r\n                perModuleNameCache = createPerModuleNameCache();\r\n                moduleNameToDirectoryMap.set(nonRelativeModuleName, perModuleNameCache);\r\n            }\r\n            return perModuleNameCache;\r\n        }\r\n\r\n        function createPerModuleNameCache(): PerModuleNameCache {\r\n            const directoryPathMap = createMap<ResolvedModuleWithFailedLookupLocations>();\r\n\r\n            return { get, set };\r\n\r\n            function get(directory: string): ResolvedModuleWithFailedLookupLocations {\r\n                return directoryPathMap.get(toPath(directory, currentDirectory, getCanonicalFileName));\r\n            }\r\n\r\n            /**\r\n             * At first this function add entry directory -> module resolution result to the table.\r\n             * Then it computes the set of parent folders for 'directory' that should have the same module resolution result\r\n             * and for every parent folder in set it adds entry: parent -> module resolution. .\r\n             * Lets say we first directory name: /a/b/c/d/e and resolution result is: /a/b/bar.ts.\r\n             * Set of parent folders that should have the same result will be:\r\n             * [\r\n             *     /a/b/c/d, /a/b/c, /a/b\r\n             * ]\r\n             * this means that request for module resolution from file in any of these folder will be immediately found in cache.\r\n             */\r\n            function set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void {\r\n                const path = toPath(directory, currentDirectory, getCanonicalFileName);\r\n                // if entry is already in cache do nothing\r\n                if (directoryPathMap.has(path)) {\r\n                    return;\r\n                }\r\n                directoryPathMap.set(path, result);\r\n\r\n                const resolvedFileName = result.resolvedModule && result.resolvedModule.resolvedFileName;\r\n                // find common prefix between directory and resolved file name\r\n                // this common prefix should be the shorted path that has the same resolution\r\n                // directory: /a/b/c/d/e\r\n                // resolvedFileName: /a/b/foo.d.ts\r\n                const commonPrefix = getCommonPrefix(path, resolvedFileName);\r\n                let current = path;\r\n                while (true) {\r\n                    const parent = getDirectoryPath(current);\r\n                    if (parent === current || directoryPathMap.has(parent)) {\r\n                        break;\r\n                    }\r\n                    directoryPathMap.set(parent, result);\r\n                    current = parent;\r\n\r\n                    if (current === commonPrefix) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getCommonPrefix(directory: Path, resolution: string) {\r\n                if (resolution === undefined) {\r\n                    return undefined;\r\n                }\r\n                const resolutionDirectory = toPath(getDirectoryPath(resolution), currentDirectory, getCanonicalFileName);\r\n\r\n                // find first position where directory and resolution differs\r\n                let i = 0;\r\n                while (i < Math.min(directory.length, resolutionDirectory.length) && directory.charCodeAt(i) === resolutionDirectory.charCodeAt(i)) {\r\n                    i++;\r\n                }\r\n\r\n                // find last directory separator before position i\r\n                const sep = directory.lastIndexOf(directorySeparator, i);\r\n                if (sep < 0) {\r\n                    return undefined;\r\n                }\r\n\r\n                return directory.substr(0, sep);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Resolving_module_0_from_1, moduleName, containingFile);\r\n        }\r\n        const containingDirectory = getDirectoryPath(containingFile);\r\n        const perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);\r\n        let result = perFolderCache && perFolderCache.get(moduleName);\r\n\r\n        if (result) {\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Resolution_for_module_0_was_found_in_cache, moduleName);\r\n            }\r\n        }\r\n        else {\r\n            let moduleResolution = compilerOptions.moduleResolution;\r\n            if (moduleResolution === undefined) {\r\n                moduleResolution = getEmitModuleKind(compilerOptions) === ModuleKind.CommonJS ? ModuleResolutionKind.NodeJs : ModuleResolutionKind.Classic;\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Module_resolution_kind_is_not_specified_using_0, ModuleResolutionKind[moduleResolution]);\r\n                }\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Explicitly_specified_module_resolution_kind_Colon_0, ModuleResolutionKind[moduleResolution]);\r\n                }\r\n            }\r\n\r\n            switch (moduleResolution) {\r\n                case ModuleResolutionKind.NodeJs:\r\n                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache);\r\n                    break;\r\n                case ModuleResolutionKind.Classic:\r\n                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache);\r\n                    break;\r\n                default:\r\n                    Debug.fail(`Unexpected moduleResolution: ${moduleResolution}`);\r\n            }\r\n\r\n            if (perFolderCache) {\r\n                perFolderCache.set(moduleName, result);\r\n                // put result in per-module name cache\r\n                const perModuleNameCache = cache.getOrCreateCacheForModuleName(moduleName);\r\n                if (perModuleNameCache) {\r\n                    perModuleNameCache.set(containingDirectory, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (traceEnabled) {\r\n            if (result.resolvedModule) {\r\n                trace(host, Diagnostics.Module_name_0_was_successfully_resolved_to_1, moduleName, result.resolvedModule.resolvedFileName);\r\n            }\r\n            else {\r\n                trace(host, Diagnostics.Module_name_0_was_not_resolved, moduleName);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * Every module resolution kind can has its specific understanding how to load module from a specific path on disk\r\n     * I.e. for path '/a/b/c':\r\n     * - Node loader will first to try to check if '/a/b/c' points to a file with some supported extension and if this fails\r\n     * it will try to load module from directory: directory '/a/b/c' should exist and it should have either 'package.json' with\r\n     * 'typings' entry or file 'index' with some supported extension\r\n     * - Classic loader will only try to interpret '/a/b/c' as file.\r\n     */\r\n    type ResolutionKindSpecificLoader = (extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState) => Resolved | undefined;\r\n\r\n    /**\r\n     * Any module resolution kind can be augmented with optional settings: 'baseUrl', 'paths' and 'rootDirs' - they are used to\r\n     * mitigate differences between design time structure of the project and its runtime counterpart so the same import name\r\n     * can be resolved successfully by TypeScript compiler and runtime module loader.\r\n     * If these settings are set then loading procedure will try to use them to resolve module name and it can of failure it will\r\n     * fallback to standard resolution routine.\r\n     *\r\n     * - baseUrl - this setting controls how non-relative module names are resolved. If this setting is specified then non-relative\r\n     * names will be resolved relative to baseUrl: i.e. if baseUrl is '/a/b' then candidate location to resolve module name 'c/d' will\r\n     * be '/a/b/c/d'\r\n     * - paths - this setting can only be used when baseUrl is specified. allows to tune how non-relative module names\r\n     * will be resolved based on the content of the module name.\r\n     * Structure of 'paths' compiler options\r\n     * 'paths': {\r\n     *    pattern-1: [...substitutions],\r\n     *    pattern-2: [...substitutions],\r\n     *    ...\r\n     *    pattern-n: [...substitutions]\r\n     * }\r\n     * Pattern here is a string that can contain zero or one '*' character. During module resolution module name will be matched against\r\n     * all patterns in the list. Matching for patterns that don't contain '*' means that module name must be equal to pattern respecting the case.\r\n     * If pattern contains '*' then to match pattern \"<prefix>*<suffix>\" module name must start with the <prefix> and end with <suffix>.\r\n     * <MatchedStar> denotes part of the module name between <prefix> and <suffix>.\r\n     * If module name can be matches with multiple patterns then pattern with the longest prefix will be picked.\r\n     * After selecting pattern we'll use list of substitutions to get candidate locations of the module and the try to load module\r\n     * from the candidate location.\r\n     * Substitution is a string that can contain zero or one '*'. To get candidate location from substitution we'll pick every\r\n     * substitution in the list and replace '*' with <MatchedStar> string. If candidate location is not rooted it\r\n     * will be converted to absolute using baseUrl.\r\n     * For example:\r\n     * baseUrl: /a/b/c\r\n     * \"paths\": {\r\n     *     // match all module names\r\n     *     \"*\": [\r\n     *         \"*\",        // use matched name as is,\r\n     *                     // <matched name> will be looked as /a/b/c/<matched name>\r\n     *\r\n     *         \"folder1/*\" // substitution will convert matched name to 'folder1/<matched name>',\r\n     *                     // since it is not rooted then final candidate location will be /a/b/c/folder1/<matched name>\r\n     *     ],\r\n     *     // match module names that start with 'components/'\r\n     *     \"components/*\": [ \"/root/components/*\" ] // substitution will convert /components/folder1/<matched name> to '/root/components/folder1/<matched name>',\r\n     *                                              // it is rooted so it will be final candidate location\r\n     * }\r\n     *\r\n     * 'rootDirs' allows the project to be spreaded across multiple locations and resolve modules with relative names as if\r\n     * they were in the same location. For example lets say there are two files\r\n     * '/local/src/content/file1.ts'\r\n     * '/shared/components/contracts/src/content/protocols/file2.ts'\r\n     * After bundling content of '/shared/components/contracts/src' will be merged with '/local/src' so\r\n     * if file1 has the following import 'import {x} from \"./protocols/file2\"' it will be resolved successfully in runtime.\r\n     * 'rootDirs' provides the way to tell compiler that in order to get the whole project it should behave as if content of all\r\n     * root dirs were merged together.\r\n     * I.e. for the example above 'rootDirs' will have two entries: [ '/local/src', '/shared/components/contracts/src' ].\r\n     * Compiler will first convert './protocols/file2' into absolute path relative to the location of containing file:\r\n     * '/local/src/content/protocols/file2' and try to load it - failure.\r\n     * Then it will search 'rootDirs' looking for a longest matching prefix of this absolute path and if such prefix is found - absolute path will\r\n     * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining\r\n     * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.\r\n     */\r\n    function tryLoadModuleUsingOptionalResolutionSettings(extensions: Extensions, moduleName: string, containingDirectory: string, loader: ResolutionKindSpecificLoader,\r\n        failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n\r\n        if (!isExternalModuleNameRelative(moduleName)) {\r\n            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, failedLookupLocations, state);\r\n        }\r\n        else {\r\n            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, failedLookupLocations, state);\r\n        }\r\n    }\r\n\r\n    function tryLoadModuleUsingRootDirs(extensions: Extensions, moduleName: string, containingDirectory: string, loader: ResolutionKindSpecificLoader,\r\n        failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n\r\n        if (!state.compilerOptions.rootDirs) {\r\n            return undefined;\r\n        }\r\n\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0, moduleName);\r\n        }\r\n\r\n        const candidate = normalizePath(combinePaths(containingDirectory, moduleName));\r\n\r\n        let matchedRootDir: string;\r\n        let matchedNormalizedPrefix: string;\r\n        for (const rootDir of state.compilerOptions.rootDirs) {\r\n            // rootDirs are expected to be absolute\r\n            // in case of tsconfig.json this will happen automatically - compiler will expand relative names\r\n            // using location of tsconfig.json as base location\r\n            let normalizedRoot = normalizePath(rootDir);\r\n            if (!endsWith(normalizedRoot, directorySeparator)) {\r\n                normalizedRoot += directorySeparator;\r\n            }\r\n            const isLongestMatchingPrefix =\r\n                startsWith(candidate, normalizedRoot) &&\r\n                (matchedNormalizedPrefix === undefined || matchedNormalizedPrefix.length < normalizedRoot.length);\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Checking_if_0_is_the_longest_matching_prefix_for_1_2, normalizedRoot, candidate, isLongestMatchingPrefix);\r\n            }\r\n\r\n            if (isLongestMatchingPrefix) {\r\n                matchedNormalizedPrefix = normalizedRoot;\r\n                matchedRootDir = rootDir;\r\n            }\r\n        }\r\n        if (matchedNormalizedPrefix) {\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Longest_matching_prefix_for_0_is_1, candidate, matchedNormalizedPrefix);\r\n            }\r\n            const suffix = candidate.substr(matchedNormalizedPrefix.length);\r\n\r\n            // first - try to load from a initial location\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);\r\n            }\r\n            const resolvedFileName = loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(containingDirectory, state.host), state);\r\n            if (resolvedFileName) {\r\n                return resolvedFileName;\r\n            }\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Trying_other_entries_in_rootDirs);\r\n            }\r\n            // then try to resolve using remaining entries in rootDirs\r\n            for (const rootDir of state.compilerOptions.rootDirs) {\r\n                if (rootDir === matchedRootDir) {\r\n                    // skip the initially matched entry\r\n                    continue;\r\n                }\r\n                const candidate = combinePaths(normalizePath(rootDir), suffix);\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate);\r\n                }\r\n                const baseDirectory = getDirectoryPath(candidate);\r\n                const resolvedFileName = loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(baseDirectory, state.host), state);\r\n                if (resolvedFileName) {\r\n                    return resolvedFileName;\r\n                }\r\n            }\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Module_resolution_using_rootDirs_has_failed);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    function tryLoadModuleUsingBaseUrl(extensions: Extensions, moduleName: string, loader: ResolutionKindSpecificLoader, failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n        if (!state.compilerOptions.baseUrl) {\r\n            return undefined;\r\n        }\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, state.compilerOptions.baseUrl, moduleName);\r\n        }\r\n\r\n        // string is for exact match\r\n        let matchedPattern: Pattern | string | undefined = undefined;\r\n        if (state.compilerOptions.paths) {\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);\r\n            }\r\n            matchedPattern = matchPatternOrExact(getOwnKeys(state.compilerOptions.paths), moduleName);\r\n        }\r\n\r\n        if (matchedPattern) {\r\n            const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);\r\n            const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Module_name_0_matched_pattern_1, moduleName, matchedPatternText);\r\n            }\r\n            return forEach(state.compilerOptions.paths[matchedPatternText], subst => {\r\n                const path = matchedStar ? subst.replace(\"*\", matchedStar) : subst;\r\n                const candidate = normalizePath(combinePaths(state.compilerOptions.baseUrl, path));\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Trying_substitution_0_candidate_module_location_Colon_1, subst, path);\r\n                }\r\n                // A path mapping may have an extension, in contrast to an import, which should omit it.\r\n                const extension = tryGetExtensionFromPath(candidate);\r\n                if (extension !== undefined) {\r\n                    const path = tryFile(candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state);\r\n                    if (path !== undefined) {\r\n                        return noPackageId({ path, ext: extension });\r\n                    }\r\n                }\r\n\r\n                return loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(getDirectoryPath(candidate), state.host), state);\r\n            });\r\n        }\r\n        else {\r\n            const candidate = normalizePath(combinePaths(state.compilerOptions.baseUrl, moduleName));\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, state.compilerOptions.baseUrl, candidate);\r\n            }\r\n\r\n            return loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(getDirectoryPath(candidate), state.host), state);\r\n        }\r\n    }\r\n\r\n    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        return nodeModuleNameResolverWorker(moduleName, getDirectoryPath(containingFile), compilerOptions, host, cache, /*jsOnly*/ false);\r\n    }\r\n\r\n    /**\r\n     * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.\r\n     * No way to do this with `require()`: https://github.com/nodejs/node/issues/5963\r\n     * Throws an error if the module can't be resolved.\r\n     */\r\n    /* @internal */\r\n    export function resolveJavaScriptModule(moduleName: string, initialDir: string, host: ModuleResolutionHost): string {\r\n        const { resolvedModule, failedLookupLocations } =\r\n            nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, /*jsOnly*/ true);\r\n        if (!resolvedModule) {\r\n            throw new Error(`Could not resolve JS module '${moduleName}' starting at '${initialDir}'. Looked in: ${failedLookupLocations.join(\", \")}`);\r\n        }\r\n        return resolvedModule.resolvedFileName;\r\n    }\r\n\r\n    function nodeModuleNameResolverWorker(moduleName: string, containingDirectory: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined, jsOnly: boolean): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n\r\n        const failedLookupLocations: string[] = [];\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n\r\n        const result = jsOnly ? tryResolve(Extensions.JavaScript) : (tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript));\r\n        if (result && result.value) {\r\n            const { resolved, isExternalLibraryImport } = result.value;\r\n            return createResolvedModuleWithFailedLookupLocations(resolved, isExternalLibraryImport, failedLookupLocations);\r\n        }\r\n        return { resolvedModule: undefined, failedLookupLocations };\r\n\r\n        function tryResolve(extensions: Extensions): SearchResult<{ resolved: Resolved, isExternalLibraryImport: boolean }> {\r\n            const loader: ResolutionKindSpecificLoader = (extensions, candidate, failedLookupLocations, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n            const resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, failedLookupLocations, state);\r\n            if (resolved) {\r\n                return toSearchResult({ resolved, isExternalLibraryImport: false });\r\n            }\r\n\r\n            if (!isExternalModuleNameRelative(moduleName)) {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\r\n                }\r\n                const resolved = loadModuleFromNodeModules(extensions, moduleName, containingDirectory, failedLookupLocations, state, cache);\r\n                if (!resolved) return undefined;\r\n\r\n                let resolvedValue = resolved.value;\r\n                if (!compilerOptions.preserveSymlinks) {\r\n                    resolvedValue = resolvedValue && { ...resolved.value, path: realPath(resolved.value.path, host, traceEnabled), extension: resolved.value.extension };\r\n                }\r\n                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\r\n                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\r\n            }\r\n            else {\r\n                const { path: candidate, parts } = normalizePathAndParts(combinePaths(containingDirectory, moduleName));\r\n                const resolved = nodeLoadModuleByRelativeName(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);\r\n                // Treat explicit \"node_modules\" import as an external library import.\r\n                return resolved && toSearchResult({ resolved, isExternalLibraryImport: contains(parts, \"node_modules\") });\r\n            }\r\n        }\r\n    }\r\n\r\n    function realPath(path: string, host: ModuleResolutionHost, traceEnabled: boolean): string {\r\n        if (!host.realpath) {\r\n            return path;\r\n        }\r\n\r\n        const real = normalizePath(host.realpath(path));\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Resolving_real_path_for_0_result_1, path, real);\r\n        }\r\n        return real;\r\n    }\r\n\r\n    function nodeLoadModuleByRelativeName(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, considerPackageJson: boolean): Resolved | undefined {\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);\r\n        }\r\n        if (!pathEndsWithDirectorySeparator(candidate)) {\r\n            if (!onlyRecordFailures) {\r\n                const parentOfCandidate = getDirectoryPath(candidate);\r\n                if (!directoryProbablyExists(parentOfCandidate, state.host)) {\r\n                    if (state.traceEnabled) {\r\n                        trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, parentOfCandidate);\r\n                    }\r\n                    onlyRecordFailures = true;\r\n                }\r\n            }\r\n            const resolvedFromFile = loadModuleFromFile(extensions, candidate, failedLookupLocations, onlyRecordFailures, state);\r\n            if (resolvedFromFile) {\r\n                return noPackageId(resolvedFromFile);\r\n            }\r\n        }\r\n        if (!onlyRecordFailures) {\r\n            const candidateExists = directoryProbablyExists(candidate, state.host);\r\n            if (!candidateExists) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidate);\r\n                }\r\n                onlyRecordFailures = true;\r\n            }\r\n        }\r\n        return loadNodeModuleFromDirectory(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, considerPackageJson);\r\n    }\r\n\r\n    /* @internal */\r\n    export function directoryProbablyExists(directoryName: string, host: { directoryExists?: (directoryName: string) => boolean }): boolean {\r\n        // if host does not support 'directoryExists' assume that directory will exist\r\n        return !host.directoryExists || host.directoryExists(directoryName);\r\n    }\r\n\r\n    function loadModuleFromFileNoPackageId(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): Resolved {\r\n        return noPackageId(loadModuleFromFile(extensions, candidate, failedLookupLocations, onlyRecordFailures, state));\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary\r\n     * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.\r\n     */\r\n    function loadModuleFromFile(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        // First, try adding an extension. An import of \"foo\" could be matched by a file \"foo.ts\", or \"foo.js\" by \"foo.js.ts\"\r\n        const resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, failedLookupLocations, onlyRecordFailures, state);\r\n        if (resolvedByAddingExtension) {\r\n            return resolvedByAddingExtension;\r\n        }\r\n\r\n        // If that didn't work, try stripping a \".js\" or \".jsx\" extension and replacing it with a TypeScript one;\r\n        // e.g. \"./foo.js\" can be matched by \"./foo.ts\" or \"./foo.d.ts\"\r\n        if (hasJavaScriptFileExtension(candidate)) {\r\n            const extensionless = removeFileExtension(candidate);\r\n            if (state.traceEnabled) {\r\n                const extension = candidate.substring(extensionless.length);\r\n                trace(state.host, Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);\r\n            }\r\n            return tryAddingExtensions(extensionless, extensions, failedLookupLocations, onlyRecordFailures, state);\r\n        }\r\n    }\r\n\r\n    /** Try to return an existing file that adds one of the `extensions` to `candidate`. */\r\n    function tryAddingExtensions(candidate: string, extensions: Extensions, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        if (!onlyRecordFailures) {\r\n            // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing\r\n            const directory = getDirectoryPath(candidate);\r\n            if (directory) {\r\n                onlyRecordFailures = !directoryProbablyExists(directory, state.host);\r\n            }\r\n        }\r\n\r\n        switch (extensions) {\r\n            case Extensions.DtsOnly:\r\n                return tryExtension(Extension.Dts)||tryExtension(Extension.DCts);\r\n            case Extensions.TypeScript:\r\n                return tryExtension(Extension.Ts) ||tryExtension(Extension.CTs) || tryExtension(Extension.Tsx) ||tryExtension(Extension.CTsx) || tryExtension(Extension.Dts) || tryExtension(Extension.DCts);\r\n            case Extensions.JavaScript:\r\n                return tryExtension(Extension.Js) || tryExtension(Extension.Jsx);\r\n        }\r\n\r\n        function tryExtension(ext: Extension): PathAndExtension | undefined {\r\n            const path = tryFile(candidate + ext, failedLookupLocations, onlyRecordFailures, state);\r\n            return path && { path, ext };\r\n        }\r\n    }\r\n\r\n    /** Return the file if it exists. */\r\n    function tryFile(fileName: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): string | undefined {\r\n        if (!onlyRecordFailures) {\r\n            if (state.host.fileExists(fileName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.File_0_exist_use_it_as_a_name_resolution_result, fileName);\r\n                }\r\n                return fileName;\r\n            }\r\n            else {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.File_0_does_not_exist, fileName);\r\n                }\r\n            }\r\n        }\r\n        failedLookupLocations.push(fileName);\r\n        return undefined;\r\n    }\r\n\r\n    function loadNodeModuleFromDirectory(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, considerPackageJson = true) {\r\n        const { packageJsonContent, packageId } = considerPackageJson\r\n            ? getPackageJsonInfo(candidate, \"\", failedLookupLocations, onlyRecordFailures, state)\r\n            : { packageJsonContent: undefined, packageId: undefined };\r\n        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, packageJsonContent));\r\n    }\r\n\r\n    function loadNodeModuleFromDirectoryWorker(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, packageJsonContent: PackageJsonPathFields | undefined): PathAndExtension | undefined {\r\n        const fromPackageJson = packageJsonContent && loadModuleFromPackageJson(packageJsonContent, extensions, candidate, failedLookupLocations, state);\r\n        if (fromPackageJson) {\r\n            return fromPackageJson;\r\n        }\r\n        const directoryExists = !onlyRecordFailures && directoryProbablyExists(candidate, state.host);\r\n        return loadModuleFromFile(extensions, combinePaths(candidate, \"index\"), failedLookupLocations, !directoryExists, state);\r\n    }\r\n\r\n    function getPackageJsonInfo(\r\n        nodeModuleDirectory: string,\r\n        subModuleName: string,\r\n        failedLookupLocations: Push<string>,\r\n        onlyRecordFailures: boolean,\r\n        { host, traceEnabled }: ModuleResolutionState,\r\n    ): { found: boolean, packageJsonContent: PackageJsonPathFields | undefined, packageId: PackageId | undefined } {\r\n        const directoryExists = !onlyRecordFailures && directoryProbablyExists(nodeModuleDirectory, host);\r\n        const packageJsonPath = pathToPackageJson(nodeModuleDirectory);\r\n        if (directoryExists && host.fileExists(packageJsonPath)) {\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Found_package_json_at_0, packageJsonPath);\r\n            }\r\n            const packageJsonContent = readJson(packageJsonPath, host);\r\n            const packageId: PackageId = typeof packageJsonContent.name === \"string\" && typeof packageJsonContent.version === \"string\"\r\n                ? { name: packageJsonContent.name, subModuleName, version: packageJsonContent.version }\r\n                : undefined;\r\n            return { found: true, packageJsonContent, packageId };\r\n        }\r\n        else {\r\n            if (directoryExists && traceEnabled) {\r\n                trace(host, Diagnostics.File_0_does_not_exist, packageJsonPath);\r\n            }\r\n            // record package json as one of failed lookup locations - in the future if this file will appear it will invalidate resolution results\r\n            failedLookupLocations.push(packageJsonPath);\r\n            return { found: false, packageJsonContent: undefined, packageId: undefined };\r\n        }\r\n    }\r\n\r\n    function loadModuleFromPackageJson(jsonContent: PackageJsonPathFields, extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        const file = tryReadPackageJsonFields(extensions !== Extensions.JavaScript, jsonContent, candidate, state);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n\r\n        const onlyRecordFailures = !directoryProbablyExists(getDirectoryPath(file), state.host);\r\n        const fromFile = tryFile(file, failedLookupLocations, onlyRecordFailures, state);\r\n        if (fromFile) {\r\n            const resolved = fromFile && resolvedIfExtensionMatches(extensions, fromFile);\r\n            if (resolved) {\r\n                return resolved;\r\n            }\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.File_0_has_an_unsupported_extension_so_skipping_it, fromFile);\r\n            }\r\n        }\r\n\r\n        // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json \"types\"\r\n        const nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;\r\n        // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.\r\n        const result = nodeLoadModuleByRelativeName(nextExtensions, file, failedLookupLocations, onlyRecordFailures, state, /*considerPackageJson*/ false);\r\n        if (result) {\r\n            // It won't have a `packageId` set, because we disabled `considerPackageJson`.\r\n            Debug.assert(result.packageId === undefined);\r\n            return { path: result.path, ext: result.extension };\r\n        }\r\n    }\r\n\r\n    /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */\r\n    function resolvedIfExtensionMatches(extensions: Extensions, path: string): PathAndExtension | undefined {\r\n        const ext = tryGetExtensionFromPath(path);\r\n        return ext !== undefined && extensionIsOk(extensions, ext) ? { path, ext } : undefined;\r\n    }\r\n\r\n    /** True if `extension` is one of the supported `extensions`. */\r\n    function extensionIsOk(extensions: Extensions, extension: Extension): boolean {\r\n        switch (extensions) {\r\n            case Extensions.JavaScript:\r\n                return extension === Extension.Js || extension === Extension.Jsx;\r\n            case Extensions.TypeScript:\r\n                return extension === Extension.Ts ||extension === Extension.CTs || extension === Extension.Tsx|| extension === Extension.CTsx || extension === Extension.Dts|| extension === Extension.DCts;\r\n            case Extensions.DtsOnly:\r\n                return extension === Extension.Dts||extension === Extension.DCts;\r\n        }\r\n    }\r\n\r\n    function pathToPackageJson(directory: string): string {\r\n        return combinePaths(directory, \"package.json\");\r\n    }\r\n\r\n    function loadModuleFromNodeModulesFolder(extensions: Extensions, moduleName: string, nodeModulesFolder: string, nodeModulesFolderExists: boolean, failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n        const candidate = normalizePath(combinePaths(nodeModulesFolder, moduleName));\r\n        // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.\r\n        let packageJsonContent: PackageJsonPathFields | undefined;\r\n        let packageId: PackageId | undefined;\r\n        const packageInfo = getPackageJsonInfo(candidate, \"\", failedLookupLocations, /*onlyRecordFailures*/ !nodeModulesFolderExists, state);\r\n        if (packageInfo.found) {\r\n            ({ packageJsonContent, packageId } = packageInfo);\r\n        }\r\n        else {\r\n            const { packageName, rest } = getPackageName(moduleName);\r\n            if (rest !== \"\") { // If \"rest\" is empty, we just did this search above.\r\n                const packageRootPath = combinePaths(nodeModulesFolder, packageName);\r\n                // Don't use a \"types\" or \"main\" from here because we're not loading the root, but a subdirectory -- just here for the packageId.\r\n                packageId = getPackageJsonInfo(packageRootPath, rest, failedLookupLocations, !nodeModulesFolderExists, state).packageId;\r\n            }\r\n        }\r\n        const pathAndExtension = loadModuleFromFile(extensions, candidate, failedLookupLocations, !nodeModulesFolderExists, state) ||\r\n            loadNodeModuleFromDirectoryWorker(extensions, candidate, failedLookupLocations, !nodeModulesFolderExists, state, packageJsonContent);\r\n        return withPackageId(packageId, pathAndExtension);\r\n    }\r\n\r\n    /* @internal */\r\n    export function getPackageName(moduleName: string): { packageName: string, rest: string } {\r\n        let idx = moduleName.indexOf(directorySeparator);\r\n        if (moduleName[0] === \"@\") {\r\n            idx = moduleName.indexOf(directorySeparator, idx + 1);\r\n        }\r\n        return idx === -1 ? { packageName: moduleName, rest: \"\" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };\r\n    }\r\n\r\n    function loadModuleFromNodeModules(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, cache: NonRelativeModuleNameResolutionCache): SearchResult<Resolved> {\r\n        return loadModuleFromNodeModulesWorker(extensions, moduleName, directory, failedLookupLocations, state, /*typesOnly*/ false, cache);\r\n    }\r\n    function loadModuleFromNodeModulesAtTypes(moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState): SearchResult<Resolved> {\r\n        // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.\r\n        return loadModuleFromNodeModulesWorker(Extensions.DtsOnly, moduleName, directory, failedLookupLocations, state, /*typesOnly*/ true, /*cache*/ undefined);\r\n    }\r\n\r\n    function loadModuleFromNodeModulesWorker(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, typesOnly: boolean, cache: NonRelativeModuleNameResolutionCache): SearchResult<Resolved> {\r\n        const perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName);\r\n        return forEachAncestorDirectory(normalizeSlashes(directory), ancestorDirectory => {\r\n            if (getBaseFileName(ancestorDirectory) !== \"node_modules\") {\r\n                const resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state.traceEnabled, state.host);\r\n                if (resolutionFromCache) {\r\n                    return resolutionFromCache;\r\n                }\r\n                return toSearchResult(loadModuleFromNodeModulesOneLevel(extensions, moduleName, ancestorDirectory, failedLookupLocations, state, typesOnly));\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Load a module from a single node_modules directory, but not from any ancestors' node_modules directories. */\r\n    function loadModuleFromNodeModulesOneLevel(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, typesOnly = false): Resolved | undefined {\r\n        const nodeModulesFolder = combinePaths(directory, \"node_modules\");\r\n        const nodeModulesFolderExists = directoryProbablyExists(nodeModulesFolder, state.host);\r\n        if (!nodeModulesFolderExists && state.traceEnabled) {\r\n            trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);\r\n        }\r\n\r\n        const packageResult = typesOnly ? undefined : loadModuleFromNodeModulesFolder(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, failedLookupLocations, state);\r\n        if (packageResult) {\r\n            return packageResult;\r\n        }\r\n        if (extensions !== Extensions.JavaScript) {\r\n            const nodeModulesAtTypes = combinePaths(nodeModulesFolder, \"@types\");\r\n            const nodeModulesAtTypesCH = combinePaths(nodeModulesFolder, \"@typesch\");\r\n            let nodeModulesAtTypesExists = nodeModulesFolderExists;\r\n            if (nodeModulesFolderExists && !directoryProbablyExists(nodeModulesAtTypes, state.host) && !directoryProbablyExists(nodeModulesAtTypesCH, state.host)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesAtTypes);\r\n                }\r\n                nodeModulesAtTypesExists = false;\r\n            }\r\n            const 结果 = loadModuleFromNodeModulesFolder(Extensions.DtsOnly, mangleScopedPackage(moduleName, state), nodeModulesAtTypesCH, nodeModulesAtTypesExists, failedLookupLocations, state) || loadModuleFromNodeModulesFolder(Extensions.DtsOnly, mangleScopedPackage(moduleName, state), nodeModulesAtTypes, nodeModulesAtTypesExists, failedLookupLocations, state);\r\n\r\n            return 结果\r\n        }\r\n    }\r\n\r\n    /** Double underscores are used in DefinitelyTyped to delimit scoped packages. */\r\n    const mangledScopedPackageSeparator = \"__\";\r\n\r\n    /** For a scoped package, we must look in `@types/foo__bar` instead of `@types/@foo/bar`. */\r\n    function mangleScopedPackage(packageName: string, state: ModuleResolutionState): string {\r\n        const mangled = getMangledNameForScopedPackage(packageName);\r\n        if (state.traceEnabled && mangled !== packageName) {\r\n            trace(state.host, Diagnostics.Scoped_package_detected_looking_in_0, mangled);\r\n        }\r\n        return mangled;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getTypesPackageName(packageName: string, 使用中文库: boolean): string {\r\n        return 使用中文库 ? `@typesch/${getMangledNameForScopedPackage(packageName)}` : `@types/${getMangledNameForScopedPackage(packageName)}`;\r\n    }\r\n\r\n    function getMangledNameForScopedPackage(packageName: string): string {\r\n        if (startsWith(packageName, \"@\")) {\r\n            const replaceSlash = packageName.replace(ts.directorySeparator, mangledScopedPackageSeparator);\r\n            if (replaceSlash !== packageName) {\r\n                return replaceSlash.slice(1); // Take off the \"@\"\r\n            }\r\n        }\r\n        return packageName;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getPackageNameFromAtTypesDirectory(mangledName: string): string {\r\n        let withoutAtTypePrefix = removePrefix(mangledName, \"@types/\");\r\n        if (withoutAtTypePrefix !== mangledName) {\r\n            return stringContains(withoutAtTypePrefix, mangledScopedPackageSeparator) ?\r\n                \"@\" + withoutAtTypePrefix.replace(mangledScopedPackageSeparator, ts.directorySeparator) :\r\n                withoutAtTypePrefix;\r\n        }\r\n        withoutAtTypePrefix = removePrefix(mangledName, \"@typesch/\")\r\n        if (withoutAtTypePrefix !== mangledName) {\r\n            return stringContains(withoutAtTypePrefix, mangledScopedPackageSeparator) ?\r\n                \"@\" + withoutAtTypePrefix.replace(mangledScopedPackageSeparator, ts.directorySeparator) :\r\n                withoutAtTypePrefix;\r\n        }\r\n        return mangledName;\r\n    }\r\n\r\n    function tryFindNonRelativeModuleNameInCache(cache: PerModuleNameCache | undefined, moduleName: string, containingDirectory: string, traceEnabled: boolean, host: ModuleResolutionHost): SearchResult<Resolved> {\r\n        const result = cache && cache.get(containingDirectory);\r\n        if (result) {\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Resolution_for_module_0_was_found_in_cache, moduleName);\r\n            }\r\n            return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };\r\n        }\r\n    }\r\n\r\n    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n        const failedLookupLocations: string[] = [];\r\n        const containingDirectory = getDirectoryPath(containingFile);\r\n\r\n        const resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);\r\n        return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);\r\n\r\n        function tryResolve(extensions: Extensions): SearchResult<Resolved> {\r\n            const resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, failedLookupLocations, state);\r\n            if (resolvedUsingSettings) {\r\n                return { value: resolvedUsingSettings };\r\n            }\r\n            const perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName);\r\n\r\n            if (!isExternalModuleNameRelative(moduleName)) {\r\n                // Climb up parent directories looking for a module.\r\n                const resolved = forEachAncestorDirectory(containingDirectory, directory => {\r\n                    const resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, directory, traceEnabled, host);\r\n                    if (resolutionFromCache) {\r\n                        return resolutionFromCache;\r\n                    }\r\n                    const searchName = normalizePath(combinePaths(directory, moduleName));\r\n                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, failedLookupLocations, /*onlyRecordFailures*/ false, state));\r\n                });\r\n                if (resolved) {\r\n                    return resolved;\r\n                }\r\n                if (extensions === Extensions.TypeScript) {\r\n                    // If we didn't find the file normally, look it up in @types.\r\n                    return loadModuleFromNodeModulesAtTypes(moduleName, containingDirectory, failedLookupLocations, state);\r\n                }\r\n            }\r\n            else {\r\n                const candidate = normalizePath(combinePaths(containingDirectory, moduleName));\r\n                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * LSHost may load a module from a global cache of typings.\r\n     * This is the minumum code needed to expose that functionality; the rest is in LSHost.\r\n     */\r\n    /* @internal */\r\n    export function loadModuleFromGlobalCache(moduleName: string, projectName: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, globalCache: string): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);\r\n        }\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n        const failedLookupLocations: string[] = [];\r\n        const resolved = loadModuleFromNodeModulesOneLevel(Extensions.DtsOnly, moduleName, globalCache, failedLookupLocations, state);\r\n        return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);\r\n    }\r\n\r\n    /**\r\n     * Represents result of search. Normally when searching among several alternatives we treat value `undefined` as indicator\r\n     * that search fails and we should try another option.\r\n     * However this does not allow us to represent final result that should be used instead of further searching (i.e. a final result that was found in cache).\r\n     * SearchResult is used to deal with this issue, its values represents following outcomes:\r\n     * - undefined - not found, continue searching\r\n     * - { value: undefined } - not found - stop searching\r\n     * - { value: <some-value> } - found - stop searching\r\n     */\r\n    type SearchResult<T> = { value: T | undefined } | undefined;\r\n\r\n    /**\r\n     * Wraps value to SearchResult.\r\n     * @returns undefined if value is undefined or { value } otherwise\r\n     */\r\n    function toSearchResult<T>(value: T | undefined): SearchResult<T> {\r\n        return value !== undefined ? { value } : undefined;\r\n    }\r\n}\r\n","/// <reference path=\"../../compiler/core.ts\" />\r\n/// <reference path=\"../../compiler/moduleNameResolver.ts\" />\r\n/// <reference path=\"../../services/jsTyping.ts\"/>\r\n/// <reference path=\"../types.ts\"/>\r\n/// <reference path=\"../shared.ts\"/>\r\n\r\nnamespace ts.server.typingsInstaller {\r\n    interface NpmConfig {\r\n        devDependencies: MapLike<any>;\r\n    }\r\n\r\n    export interface Log {\r\n        isEnabled(): boolean;\r\n        writeLine(text: string): void;\r\n    }\r\n\r\n    const nullLog: Log = {\r\n        isEnabled: () => false,\r\n        writeLine: noop\r\n    };\r\n\r\n    function typingToFileName(cachePath: string, packageName: string, installTypingHost: InstallTypingHost, log: Log): string {\r\n        try {\r\n            const result = resolveModuleName(packageName, combinePaths(cachePath, \"index.d.ts\"), { moduleResolution: ModuleResolutionKind.NodeJs }, installTypingHost);\r\n            return result.resolvedModule && result.resolvedModule.resolvedFileName;\r\n        }\r\n        catch (e) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Failed to resolve ${packageName} in folder '${cachePath}': ${(<Error>e).message}`);\r\n            }\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n\r\n    export type RequestCompletedAction = (success: boolean) => void;\r\n    interface PendingRequest {\r\n        requestId: number;\r\n        packageNames: string[];\r\n        cwd: string;\r\n        onRequestCompleted: RequestCompletedAction;\r\n    }\r\n\r\n    export abstract class TypingsInstaller {\r\n        private readonly packageNameToTypingLocation: Map<string> = createMap<string>();\r\n        private readonly missingTypingsSet: Map<true> = createMap<true>();\r\n        private readonly knownCachesSet: Map<true> = createMap<true>();\r\n        private readonly projectWatchers: Map<FileWatcher[]> = createMap<FileWatcher[]>();\r\n        private safeList: JsTyping.SafeList | undefined;\r\n        readonly pendingRunRequests: PendingRequest[] = [];\r\n\r\n        private installRunCount = 1;\r\n        private inFlightRequestCount = 0;\r\n\r\n        abstract readonly typesRegistry: Map<void>;\r\n\r\n        constructor(\r\n            protected readonly installTypingHost: InstallTypingHost,\r\n            private readonly globalCachePath: string,\r\n            private readonly safeListPath: Path,\r\n            private readonly typesMapLocation: Path,\r\n            private readonly throttleLimit: number,\r\n            protected readonly log = nullLog) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Global cache location '${globalCachePath}', safe file path '${safeListPath}', types map path ${typesMapLocation}`);\r\n            }\r\n            this.processCacheLocation(this.globalCachePath);\r\n        }\r\n\r\n        closeProject(req: CloseProject) {\r\n            this.closeWatchers(req.projectName);\r\n        }\r\n\r\n        private closeWatchers(projectName: string): void {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Closing file watchers for project '${projectName}'`);\r\n            }\r\n            const watchers = this.projectWatchers.get(projectName);\r\n            if (!watchers) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`No watchers are registered for project '${projectName}'`);\r\n                }\r\n                return;\r\n            }\r\n            for (const w of watchers) {\r\n                w.close();\r\n            }\r\n\r\n            this.projectWatchers.delete(projectName);\r\n\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Closing file watchers for project '${projectName}' - done.`);\r\n            }\r\n        }\r\n\r\n        install(req: DiscoverTypings) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Got install request ${JSON.stringify(req)}`);\r\n            }\r\n\r\n            // load existing typing information from the cache\r\n            if (req.cachePath) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Request specifies cache path '${req.cachePath}', loading cached information...`);\r\n                }\r\n                this.processCacheLocation(req.cachePath);\r\n            }\r\n\r\n            if (this.safeList === undefined) {\r\n                this.initializeSafeList();\r\n            }\r\n            const discoverTypingsResult = JsTyping.discoverTypings(\r\n                this.installTypingHost,\r\n                this.log.isEnabled() ? (s => this.log.writeLine(s)) : undefined,\r\n                req.fileNames,\r\n                req.projectRootPath,\r\n                this.safeList,\r\n                this.packageNameToTypingLocation,\r\n                req.typeAcquisition,\r\n                req.unresolvedImports);\r\n\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Finished typings discovery: ${JSON.stringify(discoverTypingsResult)}`);\r\n            }\r\n\r\n            // respond with whatever cached typings we have now\r\n            this.sendResponse(this.createSetTypings(req, discoverTypingsResult.cachedTypingPaths));\r\n\r\n            // start watching files\r\n            this.watchFiles(req.projectName, discoverTypingsResult.filesToWatch);\r\n\r\n            // install typings\r\n            if (discoverTypingsResult.newTypingNames.length) {\r\n                this.installTypings(req, req.cachePath || this.globalCachePath, discoverTypingsResult.cachedTypingPaths, discoverTypingsResult.newTypingNames);\r\n            }\r\n            else {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`No new typings were requested as a result of typings discovery`);\r\n                }\r\n            }\r\n        }\r\n\r\n        private initializeSafeList() {\r\n            // Prefer the safe list from the types map if it exists\r\n            if (this.typesMapLocation) {\r\n                const safeListFromMap = JsTyping.loadTypesMap(this.installTypingHost, this.typesMapLocation);\r\n                if (safeListFromMap) {\r\n                    this.log.writeLine(`Loaded safelist from types map file '${this.typesMapLocation}'`);\r\n                    this.safeList = safeListFromMap;\r\n                    return;\r\n                }\r\n                this.log.writeLine(`Failed to load safelist from types map file '${this.typesMapLocation}'`);\r\n            }\r\n            this.safeList = JsTyping.loadSafeList(this.installTypingHost, this.safeListPath);\r\n        }\r\n\r\n        private processCacheLocation(cacheLocation: string) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Processing cache location '${cacheLocation}'`);\r\n            }\r\n            if (this.knownCachesSet.get(cacheLocation)) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Cache location was already processed...`);\r\n                }\r\n                return;\r\n            }\r\n            const packageJson = combinePaths(cacheLocation, \"package.json\");\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Trying to find '${packageJson}'...`);\r\n            }\r\n            if (this.installTypingHost.fileExists(packageJson)) {\r\n                const npmConfig = <NpmConfig>JSON.parse(this.installTypingHost.readFile(packageJson));\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Loaded content of '${packageJson}': ${JSON.stringify(npmConfig)}`);\r\n                }\r\n                if (npmConfig.devDependencies) {\r\n                    for (const key in npmConfig.devDependencies) {\r\n                        // key is @types/<package name>\r\n                        const packageName = getBaseFileName(key);\r\n                        if (!packageName) {\r\n                            continue;\r\n                        }\r\n                        const typingFile = typingToFileName(cacheLocation, packageName, this.installTypingHost, this.log);\r\n                        if (!typingFile) {\r\n                            this.missingTypingsSet.set(packageName, true);\r\n                            continue;\r\n                        }\r\n                        const existingTypingFile = this.packageNameToTypingLocation.get(packageName);\r\n                        if (existingTypingFile === typingFile) {\r\n                            continue;\r\n                        }\r\n                        if (existingTypingFile) {\r\n                            if (this.log.isEnabled()) {\r\n                                this.log.writeLine(`New typing for package ${packageName} from '${typingFile}' conflicts with existing typing file '${existingTypingFile}'`);\r\n                            }\r\n                        }\r\n                        if (this.log.isEnabled()) {\r\n                            this.log.writeLine(`Adding entry into typings cache: '${packageName}' => '${typingFile}'`);\r\n                        }\r\n                        this.packageNameToTypingLocation.set(packageName, typingFile);\r\n                    }\r\n                }\r\n            }\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Finished processing cache location '${cacheLocation}'`);\r\n            }\r\n            this.knownCachesSet.set(cacheLocation, true);\r\n        }\r\n\r\n        private filterTypings(typingsToInstall: string[]) {\r\n            if (typingsToInstall.length === 0) {\r\n                return typingsToInstall;\r\n            }\r\n            const result: string[] = [];\r\n            for (const typing of typingsToInstall) {\r\n                if (this.missingTypingsSet.get(typing) || this.packageNameToTypingLocation.get(typing)) {\r\n                    continue;\r\n                }\r\n                const validationResult = JsTyping.validatePackageName(typing);\r\n                if (validationResult === JsTyping.PackageNameValidationResult.Ok) {\r\n                    if (this.typesRegistry.has(typing)) {\r\n                        result.push(typing);\r\n                    }\r\n                    else {\r\n                        if (this.log.isEnabled()) {\r\n                            this.log.writeLine(`Entry for package '${typing}' does not exist in local types registry - skipping...`);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // add typing name to missing set so we won't process it again\r\n                    this.missingTypingsSet.set(typing, true);\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(JsTyping.renderPackageNameValidationFailure(validationResult, typing));\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        protected ensurePackageDirectoryExists(directory: string) {\r\n            const npmConfigPath = combinePaths(directory, \"package.json\");\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Npm config file: ${npmConfigPath}`);\r\n            }\r\n            if (!this.installTypingHost.fileExists(npmConfigPath)) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Npm config file: '${npmConfigPath}' is missing, creating new one...`);\r\n                }\r\n                this.ensureDirectoryExists(directory, this.installTypingHost);\r\n                this.installTypingHost.writeFile(npmConfigPath, \"{}\");\r\n            }\r\n        }\r\n\r\n        private installTypings(req: DiscoverTypings, cachePath: string, currentlyCachedTypings: string[], typingsToInstall: string[]) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Installing typings ${JSON.stringify(typingsToInstall)}`);\r\n            }\r\n            const filteredTypings = this.filterTypings(typingsToInstall);\r\n            if (filteredTypings.length === 0) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`All typings are known to be missing or invalid - no need to go any further`);\r\n                }\r\n                return;\r\n            }\r\n\r\n            this.ensurePackageDirectoryExists(cachePath);\r\n\r\n            const requestId = this.installRunCount;\r\n            this.installRunCount++;\r\n\r\n            // send progress event\r\n            this.sendResponse(<BeginInstallTypes>{\r\n                kind: EventBeginInstallTypes,\r\n                eventId: requestId,\r\n                typingsInstallerVersion: ts.version, // qualified explicitly to prevent occasional shadowing\r\n                projectName: req.projectName\r\n            });\r\n\r\n            const scopedTypings = filteredTypings.map(typingsName);\r\n            this.installTypingsAsync(requestId, scopedTypings, cachePath, ok => {\r\n                try {\r\n                    if (!ok) {\r\n                        if (this.log.isEnabled()) {\r\n                            this.log.writeLine(`install request failed, marking packages as missing to prevent repeated requests: ${JSON.stringify(filteredTypings)}`);\r\n                        }\r\n                        for (const typing of filteredTypings) {\r\n                            this.missingTypingsSet.set(typing, true);\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    // TODO: watch project directory\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(`Installed typings ${JSON.stringify(scopedTypings)}`);\r\n                    }\r\n                    const installedTypingFiles: string[] = [];\r\n                    for (const packageName of filteredTypings) {\r\n                        const typingFile = typingToFileName(cachePath, packageName, this.installTypingHost, this.log);\r\n                        if (!typingFile) {\r\n                            this.missingTypingsSet.set(packageName, true);\r\n                            continue;\r\n                        }\r\n                        if (!this.packageNameToTypingLocation.has(packageName)) {\r\n                            this.packageNameToTypingLocation.set(packageName, typingFile);\r\n                        }\r\n                        installedTypingFiles.push(typingFile);\r\n                    }\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(`Installed typing files ${JSON.stringify(installedTypingFiles)}`);\r\n                    }\r\n\r\n                    this.sendResponse(this.createSetTypings(req, currentlyCachedTypings.concat(installedTypingFiles)));\r\n                }\r\n                finally {\r\n                    const response: EndInstallTypes = {\r\n                        kind: EventEndInstallTypes,\r\n                        eventId: requestId,\r\n                        projectName: req.projectName,\r\n                        packagesToInstall: scopedTypings,\r\n                        installSuccess: ok,\r\n                        typingsInstallerVersion: ts.version // qualified explicitly to prevent occasional shadowing\r\n                    };\r\n                    this.sendResponse(response);\r\n                }\r\n            });\r\n        }\r\n\r\n        private ensureDirectoryExists(directory: string, host: InstallTypingHost): void {\r\n            const directoryName = getDirectoryPath(directory);\r\n            if (!host.directoryExists(directoryName)) {\r\n                this.ensureDirectoryExists(directoryName, host);\r\n            }\r\n            if (!host.directoryExists(directory)) {\r\n                host.createDirectory(directory);\r\n            }\r\n        }\r\n\r\n        private watchFiles(projectName: string, files: string[]) {\r\n            if (!files.length) {\r\n                return;\r\n            }\r\n            // shut down existing watchers\r\n            this.closeWatchers(projectName);\r\n\r\n            // handler should be invoked once for the entire set of files since it will trigger full rediscovery of typings\r\n            let isInvoked = false;\r\n            const watchers: FileWatcher[] = [];\r\n            for (const file of files) {\r\n                const w = this.installTypingHost.watchFile(file, f => {\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(`Got FS notification for ${f}, handler is already invoked '${isInvoked}'`);\r\n                    }\r\n                    if (!isInvoked) {\r\n                        this.sendResponse({ projectName, kind: server.ActionInvalidate });\r\n                        isInvoked = true;\r\n                    }\r\n                }, /*pollingInterval*/ 2000);\r\n                watchers.push(w);\r\n            }\r\n            this.projectWatchers.set(projectName, watchers);\r\n        }\r\n\r\n        private createSetTypings(request: DiscoverTypings, typings: string[]): SetTypings {\r\n            return {\r\n                projectName: request.projectName,\r\n                typeAcquisition: request.typeAcquisition,\r\n                compilerOptions: request.compilerOptions,\r\n                typings,\r\n                unresolvedImports: request.unresolvedImports,\r\n                kind: ActionSet\r\n            };\r\n        }\r\n\r\n        private installTypingsAsync(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void {\r\n            this.pendingRunRequests.unshift({ requestId, packageNames, cwd, onRequestCompleted });\r\n            this.executeWithThrottling();\r\n        }\r\n\r\n        private executeWithThrottling() {\r\n            while (this.inFlightRequestCount < this.throttleLimit && this.pendingRunRequests.length) {\r\n                this.inFlightRequestCount++;\r\n                const request = this.pendingRunRequests.pop();\r\n                this.installWorker(request.requestId, request.packageNames, request.cwd, ok => {\r\n                    this.inFlightRequestCount--;\r\n                    request.onRequestCompleted(ok);\r\n                    this.executeWithThrottling();\r\n                });\r\n            }\r\n        }\r\n\r\n        protected abstract installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void;\r\n        protected abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes): void;\r\n    }\r\n\r\n    /* @internal */\r\n    export function typingsName(packageName: string): string {\r\n        return `@types/${packageName}@ts${versionMajorMinor}`;\r\n    }\r\n}","/// <reference path=\"typingsInstaller.ts\"/>\r\n/// <reference types=\"node\" />\r\n\r\nnamespace ts.server.typingsInstaller {\r\n    const fs: {\r\n        appendFileSync(file: string, content: string): void\r\n    } = require(\"fs\");\r\n\r\n    const path: {\r\n        join(...parts: string[]): string;\r\n        dirname(path: string): string;\r\n        basename(path: string, extension?: string): string;\r\n    } = require(\"path\");\r\n\r\n    class FileLog implements Log {\r\n        private logEnabled = true;\r\n        constructor(private readonly logFile?: string) {\r\n        }\r\n\r\n        isEnabled = () => {\r\n            return this.logEnabled && this.logFile !== undefined;\r\n        }\r\n        writeLine = (text: string) => {\r\n            try {\r\n                fs.appendFileSync(this.logFile, text + sys.newLine);\r\n            }\r\n            catch (e) {\r\n                this.logEnabled = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Used if `--npmLocation` is not passed. */\r\n    function getDefaultNPMLocation(processName: string) {\r\n        if (path.basename(processName).indexOf(\"node\") === 0) {\r\n            return `\"${path.join(path.dirname(process.argv[0]), \"npm\")}\"`;\r\n        }\r\n        else {\r\n            return \"npm\";\r\n        }\r\n    }\r\n\r\n    interface TypesRegistryFile {\r\n        entries: MapLike<void>;\r\n    }\r\n\r\n    function loadTypesRegistryFile(typesRegistryFilePath: string, host: InstallTypingHost, log: Log): Map<void> {\r\n        if (!host.fileExists(typesRegistryFilePath)) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Types registry file '${typesRegistryFilePath}' does not exist`);\r\n            }\r\n            return createMap<void>();\r\n        }\r\n        try {\r\n            const content = <TypesRegistryFile>JSON.parse(host.readFile(typesRegistryFilePath));\r\n            return createMapFromTemplate(content.entries);\r\n        }\r\n        catch (e) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Error when loading types registry file '${typesRegistryFilePath}': ${(<Error>e).message}, ${(<Error>e).stack}`);\r\n            }\r\n            return createMap<void>();\r\n        }\r\n    }\r\n\r\n    const TypesRegistryPackageName = \"types-registry\";\r\n    function getTypesRegistryFileLocation(globalTypingsCacheLocation: string): string {\r\n        return combinePaths(normalizeSlashes(globalTypingsCacheLocation), `node_modules/${TypesRegistryPackageName}/index.json`);\r\n    }\r\n\r\n    interface ExecSyncOptions {\r\n        cwd: string;\r\n        encoding: \"utf-8\";\r\n    }\r\n    type ExecSync = (command: string, options: ExecSyncOptions) => string;\r\n\r\n    export class NodeTypingsInstaller extends TypingsInstaller {\r\n        private readonly nodeExecSync: ExecSync;\r\n        private readonly npmPath: string;\r\n        readonly typesRegistry: Map<void>;\r\n\r\n        private delayedInitializationError: InitializationFailedResponse | undefined;\r\n\r\n        constructor(globalTypingsCacheLocation: string, typingSafeListLocation: string, typesMapLocation: string, npmLocation: string | undefined, throttleLimit: number, log: Log) {\r\n            super(\r\n                sys,\r\n                globalTypingsCacheLocation,\r\n                typingSafeListLocation ? toPath(typingSafeListLocation, \"\", createGetCanonicalFileName(sys.useCaseSensitiveFileNames)) : toPath(\"typingSafeList.json\", __dirname, createGetCanonicalFileName(sys.useCaseSensitiveFileNames)),\r\n                typesMapLocation ? toPath(typesMapLocation, \"\", createGetCanonicalFileName(sys.useCaseSensitiveFileNames)) : toPath(\"typesMap.json\", __dirname, createGetCanonicalFileName(sys.useCaseSensitiveFileNames)),\r\n                throttleLimit,\r\n                log);\r\n            this.npmPath = npmLocation !== undefined ? npmLocation : getDefaultNPMLocation(process.argv[0]);\r\n\r\n            // If the NPM path contains spaces and isn't wrapped in quotes, do so.\r\n            if (stringContains(this.npmPath, \" \") && this.npmPath[0] !== `\"`) {\r\n                this.npmPath = `\"${this.npmPath}\"`;\r\n            }\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Process id: ${process.pid}`);\r\n                this.log.writeLine(`NPM location: ${this.npmPath} (explicit '${Arguments.NpmLocation}' ${npmLocation === undefined ? \"not \" : \"\"} provided)`);\r\n            }\r\n            ({ execSync: this.nodeExecSync } = require(\"child_process\"));\r\n\r\n            this.ensurePackageDirectoryExists(globalTypingsCacheLocation);\r\n\r\n            try {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Updating ${TypesRegistryPackageName} npm package...`);\r\n                }\r\n                this.execSyncAndLog(`${this.npmPath} install --ignore-scripts ${TypesRegistryPackageName}`, { cwd: globalTypingsCacheLocation });\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Updated ${TypesRegistryPackageName} npm package`);\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Error updating ${TypesRegistryPackageName} package: ${(<Error>e).message}`);\r\n                }\r\n                // store error info to report it later when it is known that server is already listening to events from typings installer\r\n                this.delayedInitializationError = {\r\n                    kind: \"event::initializationFailed\",\r\n                    message: (<Error>e).message\r\n                };\r\n            }\r\n\r\n            this.typesRegistry = loadTypesRegistryFile(getTypesRegistryFileLocation(globalTypingsCacheLocation), this.installTypingHost, this.log);\r\n        }\r\n\r\n        listen() {\r\n            process.on(\"message\", (req: TypingInstallerRequestUnion) => {\r\n                if (this.delayedInitializationError) {\r\n                    // report initializationFailed error\r\n                    this.sendResponse(this.delayedInitializationError);\r\n                    this.delayedInitializationError = undefined;\r\n                }\r\n                switch (req.kind) {\r\n                    case \"discover\":\r\n                        this.install(req);\r\n                        break;\r\n                    case \"closeProject\":\r\n                        this.closeProject(req);\r\n                        break;\r\n                    case \"typesRegistry\": {\r\n                        const typesRegistry: { [key: string]: void } = {};\r\n                        this.typesRegistry.forEach((value, key) => {\r\n                            typesRegistry[key] = value;\r\n                        });\r\n                        const response: TypesRegistryResponse = { kind: EventTypesRegistry, typesRegistry };\r\n                        this.sendResponse(response);\r\n                        break;\r\n                    }\r\n                    case \"installPackage\": {\r\n                        const { fileName, packageName, projectRootPath } = req;\r\n                        const cwd = getDirectoryOfPackageJson(fileName, this.installTypingHost) || projectRootPath;\r\n                        if (cwd) {\r\n                            this.installWorker(-1, [packageName], cwd, success => {\r\n                                const message = success ? `Package ${packageName} installed.` : `There was an error installing ${packageName}.`;\r\n                                const response: PackageInstalledResponse = { kind: EventPackageInstalled, success, message };\r\n                                this.sendResponse(response);\r\n                            });\r\n                        }\r\n                        else {\r\n                            const response: PackageInstalledResponse = { kind: EventPackageInstalled, success: false, message: \"Could not determine a project root path.\" };\r\n                            this.sendResponse(response);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Debug.assertNever(req);\r\n                }\r\n            });\r\n        }\r\n\r\n        protected sendResponse(response: TypingInstallerResponseUnion) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Sending response:\\n    ${JSON.stringify(response)}`);\r\n            }\r\n            process.send(response);\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Response has been sent.`);\r\n            }\r\n        }\r\n\r\n        protected installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`#${requestId} with arguments'${JSON.stringify(packageNames)}'.`);\r\n            }\r\n            const command = `${this.npmPath} install --ignore-scripts ${packageNames.join(\" \")} --save-dev --user-agent=\"typesInstaller/${version}\"`;\r\n            const start = Date.now();\r\n            const hasError = this.execSyncAndLog(command, { cwd });\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`npm install #${requestId} took: ${Date.now() - start} ms`);\r\n            }\r\n            onRequestCompleted(!hasError);\r\n        }\r\n\r\n        /** Returns 'true' in case of error. */\r\n        private execSyncAndLog(command: string, options: Pick<ExecSyncOptions, \"cwd\">): boolean {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Exec: ${command}`);\r\n            }\r\n            try {\r\n                const stdout = this.nodeExecSync(command, { ...options, encoding: \"utf-8\" });\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`    Succeeded. stdout:${indent(sys.newLine, stdout)}`);\r\n                }\r\n                return false;\r\n            }\r\n            catch (error) {\r\n                const { stdout, stderr } = error;\r\n                this.log.writeLine(`    Failed. stdout:${indent(sys.newLine, stdout)}${sys.newLine}    stderr:${indent(sys.newLine, stderr)}`);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDirectoryOfPackageJson(fileName: string, host: InstallTypingHost): string | undefined {\r\n        return forEachAncestorDirectory(getDirectoryPath(fileName), directory => {\r\n            if (host.fileExists(combinePaths(directory, \"package.json\"))) {\r\n                return directory;\r\n            }\r\n        });\r\n    }\r\n\r\n    const logFilePath = findArgument(server.Arguments.LogFile);\r\n    const globalTypingsCacheLocation = findArgument(server.Arguments.GlobalCacheLocation);\r\n    const typingSafeListLocation = findArgument(server.Arguments.TypingSafeListLocation);\r\n    const typesMapLocation = findArgument(server.Arguments.TypesMapLocation);\r\n    const npmLocation = findArgument(server.Arguments.NpmLocation);\r\n\r\n    const log = new FileLog(logFilePath);\r\n    if (log.isEnabled()) {\r\n        process.on(\"uncaughtException\", (e: Error) => {\r\n            log.writeLine(`Unhandled exception: ${e} at ${e.stack}`);\r\n        });\r\n    }\r\n    process.on(\"disconnect\", () => {\r\n        if (log.isEnabled()) {\r\n            log.writeLine(`Parent process has exited, shutting down...`);\r\n        }\r\n        process.exit(0);\r\n    });\r\n    const installer = new NodeTypingsInstaller(globalTypingsCacheLocation, typingSafeListLocation, typesMapLocation, npmLocation, /*throttleLimit*/5, log);\r\n    installer.listen();\r\n\r\n    function indent(newline: string, string: string): string {\r\n        return `${newline}    ` + string.replace(/\\r?\\n/, `${newline}    `);\r\n    }\r\n}\r\n"]}